import { 
  EvaluationData, 
  EvaluationDisplay, 
  MoveQuality,
  MoveQualityClass,
  RobustnessTag,
  EnhancedTablebaseData,
  EnhancedEvaluationDisplay
} from '@shared/types';

/**
 * Get move quality evaluation (how good was this specific move)
 * This compares the played move with the best available alternative
 * 
 * AI_NOTE: This is the ENGINE-based evaluation, not tablebase!
 * For endgame training, prefer getMoveQualityByTablebaseComparison() when available.
 * This function uses absolute values because a "good move" is good regardless of color.
 * 
 * QUIRK: isPlayerMove parameter is unused - legacy from earlier version.
 */
export const getMoveQualityDisplay = (
  evaluation: number, 
  mate?: number,
  isPlayerMove: boolean = true
): EvaluationDisplay => {
  // For move quality, we want to show how good the move was
  // regardless of who played it
  
  // Matt-Bewertungen sind immer excellent wenn man Matt setzt
  if (mate !== undefined) {
    if (mate > 0) {
      return { 
        text: `#${mate}`, 
        className: 'eval-excellent',
        color: 'var(--success-text)', 
        bgColor: 'var(--success-bg)' 
      };
    }
    if (mate < 0) {
      // Even when getting mated, if it's the best defense, show it neutrally
      return { 
        text: `#${Math.abs(mate)}`, 
        className: 'eval-neutral',
        color: 'var(--text-secondary)', 
        bgColor: 'var(--bg-accent)' 
      };
    }
  }
  
  // F√ºr Zugqualit√§t verwenden wir den absoluten Wert
  // Ein starker Zug ist stark, egal f√ºr welche Seite
  const absEval = Math.abs(evaluation);
  
  // Sehr starke Z√ºge (leading to winning positions)
  if (absEval >= 5) {
    return { 
      text: '‚≠ê', 
      className: 'eval-excellent',
      color: 'var(--success-text)', 
      bgColor: 'var(--success-bg)' 
    };
  }
  if (absEval >= 2) {
    return { 
      text: '‚ú®', 
      className: 'eval-excellent',
      color: 'var(--success-text)', 
      bgColor: 'var(--success-bg)' 
    };
  }
  if (absEval >= 0.5) {
    return { 
      text: 'üëå', 
      className: 'eval-good',
      color: 'var(--info-text)', 
      bgColor: 'var(--info-bg)' 
    };
  }
  if (absEval >= -0.5) {
    return { 
      text: '‚ö™', 
      className: 'eval-neutral',
      color: 'var(--text-secondary)', 
      bgColor: 'var(--bg-accent)' 
    };
  }
  
  // This shouldn't happen in move quality evaluation,
  // but keeping for safety
  return { 
    text: '‚ö™', 
    className: 'eval-neutral',
    color: 'var(--text-secondary)', 
    bgColor: 'var(--bg-accent)' 
  };
};

/**
 * NEW: Move quality based on tablebase WDL comparison
 * This is the REAL training value - detecting when players throw away wins!
 * 
 * @param wdlBefore - WDL value before the move (-2=loss, -1=blessed loss, 0=draw, 1=cursed win, 2=win)
 * @param wdlAfter - WDL value after the move 
 * @param playerSide - which side played the move ('w' or 'b')
 * 
 * AI_NOTE: CRITICAL PERSPECTIVE BUG FIXED (2025-01-11)
 * WDL values from tablebase API are ALWAYS from White's perspective!
 * Lines 107-108: We convert to player's perspective by negating for Black.
 * This bug caused Black's optimal defensive moves to show red triangles.
 * 
 * KNOWN ISSUE: Line 229 - When WDL stays exactly -2 to -2 for Black in losing position,
 * it's actually optimal defense (maintaining tablebase loss). We show shield (üõ°Ô∏è).
 * 
 * See: /shared/utils/chess/EVALUATION_LOGIC_LEARNINGS.md for full debugging story.
 */
export const getMoveQualityByTablebaseComparison = (
  wdlBefore: number,
  wdlAfter: number,
  playerSide: 'w' | 'b'
): EvaluationDisplay => {
  // CRITICAL: Convert WDL values to player's perspective
  // For Black, we need to flip the values since WDL is from White's perspective
  const wdlBeforeFromPlayerPerspective = playerSide === 'w' ? wdlBefore : -wdlBefore;
  const wdlAfterFromPlayerPerspective = playerSide === 'w' ? wdlAfter : -wdlAfter;
  
  
  // Convert WDL to simplified categories for clearer logic
  const getCategory = (wdl: number) => {
    if (wdl >= 1) return 'win';    // Both win and cursed-win are wins
    if (wdl <= -1) return 'loss';  // Both loss and blessed-loss are losses  
    return 'draw';
  };
  
  const categoryBefore = getCategory(wdlBeforeFromPlayerPerspective);
  const categoryAfter = getCategory(wdlAfterFromPlayerPerspective);
  
  // CATASTROPHIC: Threw away a winning position
  if (categoryBefore === 'win' && categoryAfter === 'draw') {
    return {
      text: 'üö®',
      className: 'eval-blunder',
      color: 'var(--error-text)',
      bgColor: 'var(--error-bg)'
    };
  }
  
  if (categoryBefore === 'win' && categoryAfter === 'loss') {
    return {
      text: 'üí•',
      className: 'eval-blunder', 
      color: 'var(--error-text)',
      bgColor: 'var(--error-bg)'
    };
  }
  
  // MAJOR MISTAKE: Threw away a draw
  if (categoryBefore === 'draw' && categoryAfter === 'loss') {
    return {
      text: '‚ùå',
      className: 'eval-mistake',
      color: '#fb923c',
      bgColor: '#c2410c'
    };
  }
  
  // EXCELLENT: Maintained or improved position
  if (categoryBefore === 'win' && categoryAfter === 'win') {
    // Check if we improved (higher WDL is better win from player's perspective)
    if (wdlAfterFromPlayerPerspective > wdlBeforeFromPlayerPerspective) {
      return {
        text: 'üåü',
        className: 'eval-excellent',
        color: 'var(--success-text)',
        bgColor: 'var(--success-bg)'
      };
    }
    return {
      text: '‚úÖ',
      className: 'eval-excellent', 
      color: 'var(--success-text)',
      bgColor: 'var(--success-bg)'
    };
  }
  
  // GOOD: Maintained draw or improved from losing
  if (categoryBefore === 'draw' && categoryAfter === 'draw') {
    return {
      text: '‚ûñ',
      className: 'eval-neutral',
      color: 'var(--text-secondary)',
      bgColor: 'var(--bg-accent)'
    };
  }
  
  if (categoryBefore === 'loss' && categoryAfter === 'draw') {
    return {
      text: 'üëç',
      className: 'eval-good',
      color: 'var(--info-text)', 
      bgColor: 'var(--info-bg)'
    };
  }
  
  if (categoryBefore === 'loss' && categoryAfter === 'win') {
    return {
      text: 'üéØ',
      className: 'eval-excellent',
      color: 'var(--success-text)',
      bgColor: 'var(--success-bg)'
    };
  }

  // EXCELLENT: Improved from draw to win
  if (categoryBefore === 'draw' && categoryAfter === 'win') {
    return {
      text: 'üéØ',
      className: 'eval-excellent',
      color: 'var(--success-text)',
      bgColor: 'var(--success-bg)'
    };
  }
  
  // DEFENSIVE: Best try in losing position
  if (categoryBefore === 'loss' && categoryAfter === 'loss') {
    // Check if we made the loss "better" (less negative WDL from player's perspective)
    if (wdlAfterFromPlayerPerspective > wdlBeforeFromPlayerPerspective) {
      return {
        text: 'üõ°Ô∏è',
        className: 'eval-neutral',
        color: 'var(--text-secondary)',
        bgColor: 'var(--bg-accent)'
      };
    }
    // Check if we made the loss worse (more negative WDL from player's perspective)
    if (wdlAfterFromPlayerPerspective < wdlBeforeFromPlayerPerspective) {
      return {
        text: 'üîª',
        className: 'eval-inaccurate',
        color: 'var(--warning-text)',
        bgColor: 'var(--warning-bg)'
      };
    }
    // When WDL stays exactly the same in a losing position (e.g., -2 to -2),
    // it means optimal defense - maintaining the best possible resistance
    return {
      text: 'üõ°Ô∏è',
      className: 'eval-neutral',
      color: 'var(--text-secondary)',
      bgColor: 'var(--bg-accent)'
    };
  }
  
  // Fallback (shouldn't happen)
  return {
    text: '‚ùì',
    className: 'eval-neutral',
    color: 'var(--text-secondary)',
    bgColor: 'var(--bg-accent)'
  };
};

/**
 * Legend for tablebase move quality symbols
 */
export const TABLEBASE_LEGEND = {
  'üö®': 'Sieg ‚Üí Remis weggeworfen',
  'üí•': 'Sieg ‚Üí Verlust weggeworfen', 
  '‚ùå': 'Remis ‚Üí Verlust weggeworfen',
  'üåü': 'Sieg verbessert',
  '‚úÖ': 'Sieg gehalten',
  'üéØ': 'Sieg aus verlorener Stellung',
  'üëç': 'Remis aus verlorener Stellung',
  '‚ûñ': 'Remis gehalten',
  'üõ°Ô∏è': 'Beste Verteidigung',
  'üîª': 'Schwache Verteidigung',
  '‚ùì': 'Unbekannt'
};

/**
 * Legend for engine evaluation symbols
 */
export const ENGINE_LEGEND = {
  '‚≠ê': 'Dominierend (5+ Bauern)',
  '‚ú®': 'Ausgezeichnet (2+ Bauern)',
  'üëå': 'Gut (0.5+ Bauern)',
  '‚ö™': 'Ausgeglichen/Solide',
  '‚ö†Ô∏è': 'Ungenau (-0.5 bis -2 Bauern)',
  'üî∂': 'Fehler (-2 bis -5 Bauern)',
  'üî¥': 'Katastrophal (-5+ Bauern)',
  '#': 'Matt in X Z√ºgen'
};

/**
 * Original position evaluation (who is better)
 */
export const getEvaluationDisplay = (evaluation: number, mate?: number): EvaluationDisplay => {
  // Matt-Bewertungen mit Zuganzahl
  if (mate !== undefined) {
    if (mate > 0) {
      return { 
        text: `#${mate}`, 
        className: 'eval-excellent',
        color: 'var(--success-text)', 
        bgColor: 'var(--success-bg)' 
      };
    }
    if (mate < 0) {
      return { 
        text: `#${Math.abs(mate)}`, 
        className: 'eval-blunder',
        color: 'var(--error-text)', 
        bgColor: 'var(--error-bg)' 
      };
    }
  }
  
  // Normale Bewertungen mit Symbolen
  if (evaluation >= 5) {
    return { 
      text: '‚≠ê', 
      className: 'eval-excellent',
      color: 'var(--success-text)', 
      bgColor: 'var(--success-bg)' 
    };
  }
  if (evaluation >= 2) {
    return { 
      text: '‚ú®', 
      className: 'eval-excellent',
      color: 'var(--success-text)', 
      bgColor: 'var(--success-bg)' 
    };
  }
  if (evaluation >= 0.5) {
    return { 
      text: 'üëå', 
      className: 'eval-good',
      color: 'var(--info-text)', 
      bgColor: 'var(--info-bg)' 
    };
  }
  if (evaluation >= -0.5) {
    return { 
      text: '‚ö™', 
      className: 'eval-neutral',
      color: 'var(--text-secondary)', 
      bgColor: 'var(--bg-accent)' 
    };
  }
  if (evaluation >= -2) {
    return { 
      text: '‚ö†Ô∏è', 
      className: 'eval-inaccurate',
      color: 'var(--warning-text)', 
      bgColor: 'var(--warning-bg)' 
    };
  }
  if (evaluation >= -5) {
    return { 
      text: 'üî∂', 
      className: 'eval-mistake',
      color: '#fb923c', 
      bgColor: '#c2410c' 
    };
  }
  
  return { 
    text: 'üî¥', 
    className: 'eval-blunder',
    color: 'var(--error-text)', 
    bgColor: 'var(--error-bg)' 
  };
};

export const formatEvaluation = (evalData?: EvaluationData): string => {
  if (!evalData) return '0.00';
  
  if (evalData.mateInMoves !== undefined) {
    return `#${Math.abs(evalData.mateInMoves)}`;
  }
  
  const eval_ = evalData.evaluation;
  if (Math.abs(eval_) < 0.1) return '0.0';
  return eval_ > 0 ? `+${eval_.toFixed(1)}` : eval_.toFixed(1);
};

export const getEvaluationColor = (evalData?: EvaluationData): string => {
  if (!evalData) return 'text-gray-600';
  
  if (evalData.mateInMoves !== undefined) {
    return evalData.mateInMoves > 0 ? 'text-green-700' : 'text-red-700';
  }
  
  const eval_ = evalData.evaluation;
  if (eval_ > 2) return 'text-green-700';
  if (eval_ > 0.5) return 'text-green-600';
  if (eval_ > -0.5) return 'text-gray-600';
  if (eval_ > -2) return 'text-orange-600';
  return 'text-red-600';
};

export const getEvaluationBarWidth = (evaluation?: number): number => {
  if (evaluation === undefined) return 50;
  // Convert evaluation to percentage (clamped between 0-100)
  return Math.max(0, Math.min(100, 50 + (evaluation * 10)));
};

// Helper function to access getCategory outside of getMoveQualityByTablebaseComparison
export const getCategory = (wdl: number): 'win' | 'draw' | 'loss' => {
  if (wdl >= 1) return 'win';    // Both win and cursed-win are wins
  if (wdl <= -1) return 'loss';  // Both loss and blessed-loss are losses  
  return 'draw';
};

/**
 * Enhanced Move Quality for Br√ºckenbau-Trainer
 * Classifies Win‚ÜíWin moves based on DTM difference
 */
export const classifyWinToWin = (dtmDiff: number): MoveQualityClass => {
  if (dtmDiff <= 1) return 'optimal';
  if (dtmDiff <= 5) return 'sicher';
  if (dtmDiff <= 15) return 'umweg';
  return 'riskant';
};

/**
 * Classify robustness based on number of winning moves
 */
export const classifyRobustness = (winningMovesCount: number): RobustnessTag => {
  if (winningMovesCount >= 3) return 'robust';
  if (winningMovesCount === 2) return 'pr√§zise';
  return 'haarig';
};

/**
 * Get educational tip based on move quality and robustness
 */
export const getEducationalTip = (
  qualityClass: MoveQualityClass, 
  robustness?: RobustnessTag
): string => {
  const tips: Record<MoveQualityClass, Record<RobustnessTag | 'default', string>> = {
    optimal: {
      robust: 'Perfekt! Viele gute Alternativen vorhanden.',
      pr√§zise: 'Sehr gut! Eine von wenigen optimalen L√∂sungen.',
      haarig: 'Exzellent! Der einzige optimale Zug gefunden.',
      default: 'K√ºrzester Weg zum Sieg.'
    },
    sicher: {
      robust: 'Solide Technik mit vielen Alternativen.',
      pr√§zise: 'Gute Wahl aus wenigen sicheren Optionen.',
      haarig: 'Wichtiger Zug - nur dieser h√§lt den Gewinn sicher.',
      default: 'Sichere Gewinntechnik angewendet.'
    },
    umweg: {
      robust: 'Funktioniert, aber es gibt effizientere Wege.',
      pr√§zise: 'Umst√§ndlich, aber einer der wenigen gewinnenden Z√ºge.',
      haarig: 'Kompliziert, aber der einzige Gewinnzug!',
      default: 'Gewinn bleibt, aber dauert l√§nger.'
    },
    riskant: {
      robust: 'Sehr kompliziert trotz vieler Alternativen.',
      pr√§zise: 'Riskant! Nur wenige Z√ºge halten noch den Gewinn.',
      haarig: 'Kritisch! Nur dieser Zug gewinnt noch.',
      default: 'Gewinn noch m√∂glich, aber sehr schwierig.'
    },
    fehler: {
      robust: 'Gewinn verspielt - zur√ºck zum Anfang!',
      pr√§zise: 'Gewinn verspielt - zur√ºck zum Anfang!',
      haarig: 'Gewinn verspielt - zur√ºck zum Anfang!',
      default: 'Gewinn verspielt - zur√ºck zum Anfang!'
    }
  };
  
  return tips[qualityClass][robustness || 'default'];
};

/**
 * Enhanced Move Quality Evaluation for Br√ºckenbau-Trainer
 * Provides detailed classification for Win‚ÜíWin moves based on DTM
 * 
 * AI_NOTE: NEW FEATURE (2025-01) - Not yet integrated in UI!
 * This is the planned enhancement for didactic endgame training.
 * DTM (Distance to Mate) differences classify move quality:
 * - ‚â§1: optimal (shortest path)
 * - ‚â§5: sicher (safe technique)
 * - ‚â§15: umweg (detour but works)
 * - >15: riskant (fragile win)
 * 
 * IMPLEMENTATION STATUS: Types defined, logic implemented, UI integration pending.
 * See: /docs/features/brueckenbau-trainer.md for full specification.
 */
export const getEnhancedMoveQuality = (
  wdlBefore: number,
  wdlAfter: number, 
  dtmBefore: number | undefined,
  dtmAfter: number | undefined,
  winningMovesCount: number,
  playerSide: 'w' | 'b'
): EnhancedEvaluationDisplay => {
  // 1. Get base WDL evaluation (existing logic)
  const baseEval = getMoveQualityByTablebaseComparison(wdlBefore, wdlAfter, playerSide);
  
  // 2. For Win‚ÜíWin: Refined classification
  if (getCategory(wdlBefore) === 'win' && getCategory(wdlAfter) === 'win' && 
      dtmBefore !== undefined && dtmAfter !== undefined) {
    const dtmDiff = dtmAfter - dtmBefore;
    const qualityClass = classifyWinToWin(dtmDiff);
    const robustness = classifyRobustness(winningMovesCount);
    const educationalTip = getEducationalTip(qualityClass, robustness);
    
    // Map quality class to display properties
    const qualityDisplayMap: Record<MoveQualityClass, Partial<EvaluationDisplay>> = {
      optimal: { text: 'üü¢', className: 'eval-optimal' },
      sicher: { text: '‚úÖ', className: 'eval-sicher' },
      umweg: { text: 'üü°', className: 'eval-umweg' },
      riskant: { text: '‚ö†Ô∏è', className: 'eval-riskant' },
      fehler: { text: 'üö®', className: 'eval-fehler' }
    };
    
    const display = qualityDisplayMap[qualityClass];
    
    return {
      ...baseEval,
      text: display.text || baseEval.text,
      className: display.className || baseEval.className,
      qualityClass,
      robustnessTag: robustness,
      dtmDifference: dtmDiff,
      educationalTip
    };
  }
  
  // 3. For non Win‚ÜíWin moves, map to enhanced format
  const qualityClassMap: Record<string, MoveQualityClass> = {
    'üö®': 'fehler',
    'üí•': 'fehler',
    '‚ùå': 'fehler',
    'üåü': 'optimal',
    '‚úÖ': 'sicher',
    'üéØ': 'optimal',
    'üëç': 'sicher',
    '‚ûñ': 'sicher',
    'üõ°Ô∏è': 'sicher',
    'üîª': 'umweg',
    '‚ùì': 'umweg'
  };
  
  return {
    ...baseEval,
    qualityClass: qualityClassMap[baseEval.text] || 'umweg',
    educationalTip: getEducationalTip(qualityClassMap[baseEval.text] || 'umweg')
  };
}; 