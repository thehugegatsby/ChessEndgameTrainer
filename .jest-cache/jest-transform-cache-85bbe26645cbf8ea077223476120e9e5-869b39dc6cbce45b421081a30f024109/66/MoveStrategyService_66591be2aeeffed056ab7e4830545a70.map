{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/MoveStrategyService.ts"],"sourcesContent":["import { tablebaseService } from \"./TablebaseService\";\nimport { getLogger } from \"./logging\";\n\nconst logger = getLogger().setContext(\"MoveStrategyService\");\n\n/**\n * Service for chess move selection strategies\n *\n * @class MoveStrategyService\n * @description\n * Provides different algorithms for selecting chess moves from tablebase data.\n * Supports multiple strategies:\n * - Longest resistance: Maximize DTM (Distance to Mate) in losing positions\n * - Best move: Objectively optimal move by WDL and DTZ\n * - Human-like: Introduces occasional suboptimal moves for realism\n *\n * @remarks\n * All methods query the tablebase service and apply different selection criteria.\n * The service is stateless - each method call is independent.\n * Used primarily by the training system for opponent move selection.\n */\nclass MoveStrategyService {\n  /**\n   * Select the move providing longest resistance (best defensive play)\n   *\n   * @param {string} fen - Current position in FEN notation\n   * @returns {Promise<string|null>} Best defensive move in UCI format, or null if unavailable\n   *\n   * @remarks\n   * Strategy varies by position evaluation:\n   * - **Winning positions**: Fastest win (lowest DTZ)\n   * - **Losing positions**: Longest resistance (highest DTM if available, else DTZ)\n   * - **Drawn positions**: Any move maintaining the draw\n   *\n   * DTM (Distance to Mate) is preferred over DTZ for losing positions because:\n   * - DTM shows actual moves until checkmate\n   * - DTZ only shows moves until 50-move rule reset\n   * - DTM provides more accurate resistance measurement\n   *\n   * @example\n   * const move = await moveStrategyService.getLongestResistanceMove(fen);\n   * if (move) {\n   *   console.log('Best defensive move:', move); // e.g., \"e7e8\"\n   * }\n   */\n  async getLongestResistanceMove(fen: string): Promise<string | null> {\n    try {\n      // Get ALL moves efficiently with single API call\n      const topMoves = await tablebaseService.getTopMoves(fen, 100);\n\n      if (\n        !topMoves.isAvailable ||\n        !topMoves.moves ||\n        topMoves.moves.length === 0\n      ) {\n        logger.warn(\"No tablebase moves available for position\", { fen });\n        return null;\n      }\n\n      const moves = topMoves.moves;\n      let selectedMove = moves[0];\n\n      // Determine the position evaluation from the first move\n      // wdl values: -2 (loss), 0 (draw), 2 (win) from side to move perspective\n      const positionWdl = moves[0].wdl;\n\n      if (positionWdl === 2) {\n        // Position is winning - find the fastest win (lowest DTZ)\n        let minDtz =\n          selectedMove.dtz !== null && selectedMove.dtz !== undefined\n            ? Math.abs(selectedMove.dtz)\n            : Infinity;\n        for (const move of moves) {\n          if (move.wdl === 2 && move.dtz !== undefined && move.dtz !== null) {\n            const absDtz = Math.abs(move.dtz);\n            if (absDtz < minDtz) {\n              minDtz = absDtz;\n              selectedMove = move;\n            }\n          }\n        }\n        logger.debug(\"Selected fastest winning move\", {\n          move: selectedMove.san,\n          dtz: selectedMove.dtz,\n        });\n      } else if (positionWdl === -2) {\n        // Position is losing - find the longest resistance (highest DTM, not DTZ!)\n        // DTM shows actual moves to mate, DTZ only shows moves to 50-move rule\n\n        // Check if we have DTM values directly in the moves\n        const movesWithDtm = moves.filter(\n          (m) => m.wdl === -2 && m.dtm !== null && m.dtm !== undefined,\n        );\n\n        if (movesWithDtm.length > 0) {\n          // We have DTM values - use them directly\n          let maxDtm = Math.abs(movesWithDtm[0].dtm!);\n          let maxDtz = Math.abs(movesWithDtm[0].dtz || 0);\n          selectedMove = movesWithDtm[0];\n\n          for (const move of movesWithDtm) {\n            const absDtm = Math.abs(move.dtm!);\n            const absDtz = Math.abs(move.dtz || 0);\n\n            // Primary criterion: maximize DTM (delay mate as long as possible)\n            if (absDtm > maxDtm) {\n              maxDtm = absDtm;\n              maxDtz = absDtz;\n              selectedMove = move;\n            }\n            // Secondary criterion: if DTM is equal, maximize DTZ\n            else if (absDtm === maxDtm && absDtz > maxDtz) {\n              maxDtz = absDtz;\n              selectedMove = move;\n            }\n          }\n        } else {\n          // No DTM values in moves - need to fetch DTM from resulting positions\n          logger.debug(\n            \"No DTM values in moves, fetching from resulting positions\",\n          );\n\n          // For now, fall back to DTZ-based selection\n          let maxDtz = Math.abs(selectedMove.dtz || 0);\n\n          for (const move of moves) {\n            if (\n              move.wdl === -2 &&\n              move.dtz !== null &&\n              move.dtz !== undefined\n            ) {\n              const absDtz = Math.abs(move.dtz);\n              if (absDtz > maxDtz) {\n                maxDtz = absDtz;\n                selectedMove = move;\n              }\n            }\n          }\n\n          // Note: DTM values are only available for positions with â‰¤5 pieces\n          // For 6-7 piece positions, we must use DTZ for resistance calculation\n        }\n\n        logger.debug(\"Selected longest resistance move\", {\n          move: selectedMove.san,\n          dtm: selectedMove.dtm,\n          dtz: selectedMove.dtz,\n        });\n      } else {\n        // Position is drawn - maintain the draw\n        const drawMove = moves.find((m) => m.wdl === 0);\n        if (drawMove) {\n          selectedMove = drawMove;\n        }\n        logger.debug(\"Selected draw maintaining move\", {\n          move: selectedMove.san,\n        });\n      }\n\n      return selectedMove.uci;\n    } catch (error) {\n      logger.error(\"Failed to get longest resistance move\", error as Error, {\n        fen,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Select the objectively best move according to tablebase\n   *\n   * @param {string} fen - Current position in FEN notation\n   * @returns {Promise<string|null>} Best move in UCI format, or null if unavailable\n   *\n   * @remarks\n   * Uses tablebase's pre-sorted move list which orders by:\n   * 1. WDL value (win > draw > loss)\n   * 2. DTZ for tiebreaking (lower is better for wins)\n   *\n   * This is the \"perfect play\" strategy - always choosing the objectively best move.\n   *\n   * @example\n   * const move = await moveStrategyService.getBestMove(fen);\n   * console.log('Tablebase says best is:', move); // e.g., \"a7a8q\"\n   */\n  async getBestMove(fen: string): Promise<string | null> {\n    try {\n      const topMoves = await tablebaseService.getTopMoves(fen, 1);\n\n      if (\n        !topMoves.isAvailable ||\n        !topMoves.moves ||\n        topMoves.moves.length === 0\n      ) {\n        logger.warn(\"No tablebase moves available for position\", { fen });\n        return null;\n      }\n\n      // The API already returns moves sorted by best first\n      return topMoves.moves[0].uci;\n    } catch (error) {\n      logger.error(\"Failed to get best move\", error as Error, { fen });\n      return null;\n    }\n  }\n\n  /**\n   * Select a move with human-like imperfection\n   *\n   * @param {string} fen - Current position in FEN notation\n   * @param {number} [strength=0.8] - Playing strength from 0 to 1\n   * @returns {Promise<string|null>} Selected move in UCI format, or null if unavailable\n   *\n   * @remarks\n   * Simulates human play by occasionally choosing suboptimal moves:\n   * - strength = 1.0: Always plays the best move (perfect play)\n   * - strength = 0.8: 80% chance of best move, 20% chance of top-3 move\n   * - strength = 0.5: 50% chance of best move, 50% chance of top-3 move\n   * - strength = 0.0: Random selection from top-3 moves\n   *\n   * Useful for creating more realistic training opponents that make\n   * occasional mistakes like human players.\n   *\n   * @example\n   * // Medium strength opponent\n   * const move = await moveStrategyService.getHumanLikeMove(fen, 0.7);\n   *\n   * // Very strong but not perfect\n   * const move = await moveStrategyService.getHumanLikeMove(fen, 0.95);\n   */\n  async getHumanLikeMove(\n    fen: string,\n    strength: number = 0.8,\n  ): Promise<string | null> {\n    try {\n      const topMoves = await tablebaseService.getTopMoves(fen, 5);\n\n      if (\n        !topMoves.isAvailable ||\n        !topMoves.moves ||\n        topMoves.moves.length === 0\n      ) {\n        return null;\n      }\n\n      // With perfect strength, always play the best move\n      if (strength >= 1) {\n        return topMoves.moves[0].uci;\n      }\n\n      // Otherwise, occasionally pick a suboptimal move\n      // Higher strength = higher chance of picking the best move\n      const random = Math.random();\n      if (random < strength) {\n        return topMoves.moves[0].uci;\n      }\n\n      // Pick a random move from the top moves\n      const moveIndex = Math.floor(\n        Math.random() * Math.min(3, topMoves.moves.length),\n      );\n      return topMoves.moves[moveIndex].uci;\n    } catch (error) {\n      logger.error(\"Failed to get human-like move\", error as Error, { fen });\n      return null;\n    }\n  }\n}\n\n/**\n * Singleton instance of MoveStrategyService\n *\n * @remarks\n * Provides move selection strategies for chess training:\n * - `getLongestResistanceMove()`: Best defensive play\n * - `getBestMove()`: Objectively optimal move\n * - `getHumanLikeMove()`: Realistic opponent with configurable strength\n *\n * @example\n * import { moveStrategyService } from '@shared/services/MoveStrategyService';\n *\n * // For training opponent moves\n * const defenseMove = await moveStrategyService.getLongestResistanceMove(fen);\n *\n * // For showing best play\n * const bestMove = await moveStrategyService.getBestMove(fen);\n */\nexport const moveStrategyService = new MoveStrategyService();\n"],"names":["moveStrategyService","logger","getLogger","setContext","MoveStrategyService","getLongestResistanceMove","fen","topMoves","tablebaseService","getTopMoves","isAvailable","moves","length","warn","selectedMove","positionWdl","wdl","minDtz","dtz","undefined","Math","abs","Infinity","move","absDtz","debug","san","movesWithDtm","filter","m","dtm","maxDtm","maxDtz","absDtm","drawMove","find","uci","error","getBestMove","getHumanLikeMove","strength","random","moveIndex","floor","min"],"mappings":"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"}