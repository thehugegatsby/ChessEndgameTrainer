473321ba4938b4eca3b589289711ef4b
/**
 * @file Unit tests for DueCardsCacheService
 * @description Comprehensive tests for localStorage cache with TTL, LRU, and midnight invalidation
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _DueCardsCacheService = require("../../../shared/services/DueCardsCacheService");
const _progress = require("../../../shared/types/progress");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// Mock localStorage for testing
class MockLocalStorage {
    getItem(key) {
        return this.store[key] || null;
    }
    setItem(key, value) {
        this.store[key] = value;
    }
    removeItem(key) {
        delete this.store[key];
    }
    clear() {
        this.store = {};
    }
    get length() {
        return Object.keys(this.store).length;
    }
    key(index) {
        const keys = Object.keys(this.store);
        return keys[index] || null;
    }
    constructor(){
        _define_property(this, "store", {});
    }
}
// Test helpers
const createTestCard = (id, nextReviewAt)=>({
        id,
        nextReviewAt,
        lastReviewedAt: Date.now() - 86400000,
        interval: 1,
        repetition: 1,
        efactor: 2.5,
        lapses: 0
    });
const createDueTestCards = (count)=>{
    const cards = Array.from({
        length: count
    }, (_, i)=>createTestCard(`test-${i}`, Date.now() - 1000) // Due 1 second ago
    );
    return (0, _progress.filterDueCards)(cards);
};
const createTestStats = (dueCount)=>({
        totalCards: dueCount + 5,
        dueCount,
        duePercentage: Math.round(dueCount / (dueCount + 5) * 100),
        nextDueAt: Date.now() + 3600000,
        averageInterval: 2.5
    });
// Mock Date.now for TTL testing
const originalDateNow = Date.now;
const mockDateNow = (timestamp)=>{
    Date.now = jest.fn(()=>timestamp);
};
const restoreDateNow = ()=>{
    Date.now = originalDateNow;
};
describe('DueCardsCacheService', ()=>{
    let mockLocalStorage;
    let cacheService;
    beforeEach(()=>{
        // Setup mock localStorage
        mockLocalStorage = new MockLocalStorage();
        Object.defineProperty(global, 'localStorage', {
            value: mockLocalStorage,
            writable: true
        });
        // Clear any existing instance
        _DueCardsCacheService.DueCardsCacheService.instance = null;
        // Create fresh instance
        cacheService = _DueCardsCacheService.DueCardsCacheService.getInstance();
        jest.clearAllMocks();
    });
    afterEach(()=>{
        restoreDateNow();
        cacheService.destroy();
        mockLocalStorage.clear();
    });
    describe('getInstance', ()=>{
        it('should return singleton instance', ()=>{
            const instance1 = _DueCardsCacheService.DueCardsCacheService.getInstance();
            const instance2 = _DueCardsCacheService.DueCardsCacheService.getInstance();
            expect(instance1).toBe(instance2);
        });
    });
    describe('setDueCards and getDueCards', ()=>{
        const userId = 'test-user-1';
        const inputHash = 'test-hash-123';
        it('should cache and retrieve due cards successfully', ()=>{
            const dueCards = createDueTestCards(5);
            const stats = createTestStats(5);
            // Cache the data
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Retrieve the data
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeTruthy();
            expect(cached === null || cached === void 0 ? void 0 : cached.dueCards).toHaveLength(5);
            expect(cached === null || cached === void 0 ? void 0 : cached.dueCards[0].id).toBe('test-0');
            expect(cached === null || cached === void 0 ? void 0 : cached.stats.dueCount).toBe(5);
            expect(cached === null || cached === void 0 ? void 0 : cached.inputHash).toBe(inputHash);
        });
        it('should return null for cache miss', ()=>{
            const cached = cacheService.getDueCards('nonexistent-user', inputHash);
            expect(cached).toBeNull();
        });
        it('should invalidate cache when input hash changes', ()=>{
            const dueCards = createDueTestCards(3);
            const stats = createTestStats(3);
            // Cache with original hash
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Try to retrieve with different hash
            const cached = cacheService.getDueCards(userId, 'different-hash');
            expect(cached).toBeNull();
            // Original hash should still work initially
            const original = cacheService.getDueCards(userId, inputHash);
            expect(original).toBeNull(); // Should be cleared due to hash mismatch above
        });
        it('should handle invalid cache entry structure gracefully', ()=>{
            // Manually insert invalid cache entry
            mockLocalStorage.setItem('endgame_due_cards_test-user-1', JSON.stringify({
                invalid: 'data'
            }));
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeNull();
        });
        it('should handle localStorage errors gracefully', ()=>{
            // Mock localStorage to throw errors
            jest.spyOn(mockLocalStorage, 'getItem').mockImplementation(()=>{
                throw new Error('LocalStorage error');
            });
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeNull();
        });
    });
    describe('TTL expiration', ()=>{
        const userId = 'ttl-test-user';
        const inputHash = 'ttl-hash';
        it('should expire cache after 24 hours', ()=>{
            const dueCards = createDueTestCards(2);
            const stats = createTestStats(2);
            const now = 1640000000000; // Fixed timestamp
            mockDateNow(now);
            // Cache the data
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Fast forward 25 hours
            mockDateNow(now + 25 * 60 * 60 * 1000);
            // Should be expired
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeNull();
        });
        it('should not expire cache before 24 hours', ()=>{
            const dueCards = createDueTestCards(2);
            const stats = createTestStats(2);
            // Use a timestamp at 10:00 AM UTC so adding 23 hours doesn't cross midnight
            const now = new Date('2024-01-15T10:00:00.000Z').getTime();
            mockDateNow(now);
            // Cache the data
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Fast forward 10 hours (should be 8:00 PM same UTC day)
            mockDateNow(now + 10 * 60 * 60 * 1000);
            // Should still be valid
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeTruthy();
            expect(cached === null || cached === void 0 ? void 0 : cached.dueCards).toHaveLength(2);
        });
    });
    describe('midnight invalidation', ()=>{
        const userId = 'midnight-test-user';
        const inputHash = 'midnight-hash';
        it('should invalidate cache after midnight UTC', ()=>{
            const dueCards = createDueTestCards(3);
            const stats = createTestStats(3);
            // Set time to just before midnight UTC (23:59 UTC)
            const beforeMidnight = new Date('2024-01-15T23:59:00.000Z').getTime();
            mockDateNow(beforeMidnight);
            // Cache the data
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Move to just after midnight UTC (00:01 next day)
            const afterMidnight = new Date('2024-01-16T00:01:00.000Z').getTime();
            mockDateNow(afterMidnight);
            // Should be invalidated due to midnight rollover
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeNull();
        });
        it('should not invalidate cache on same UTC day', ()=>{
            const dueCards = createDueTestCards(3);
            const stats = createTestStats(3);
            // Set time to morning UTC (8:00 AM)
            const morning = new Date('2024-01-15T08:00:00.000Z').getTime();
            mockDateNow(morning);
            // Cache the data
            cacheService.setDueCards(userId, dueCards, stats, inputHash);
            // Move to later same day UTC (6:00 PM same day)
            const evening = new Date('2024-01-15T18:00:00.000Z').getTime();
            mockDateNow(evening);
            // Should still be valid (same UTC day)
            const cached = cacheService.getDueCards(userId, inputHash);
            expect(cached).toBeTruthy();
            expect(cached === null || cached === void 0 ? void 0 : cached.dueCards).toHaveLength(3);
        });
    });
    describe('LRU cache management', ()=>{
        const inputHash = 'lru-hash';
        it('should track last accessed time', ()=>{
            const dueCards = createDueTestCards(1);
            const stats = createTestStats(1);
            const initialTime = 1640000000000;
            mockDateNow(initialTime);
            // Cache the data
            cacheService.setDueCards('user1', dueCards, stats, inputHash);
            // Access later
            const laterTime = initialTime + 60000; // 1 minute later
            mockDateNow(laterTime);
            const cached = cacheService.getDueCards('user1', inputHash);
            expect(cached === null || cached === void 0 ? void 0 : cached.lastAccessedAt).toBe(laterTime);
        });
        it('should handle large collections with performance warning', ()=>{
            // Mock console.warn to capture performance warnings
            const consoleSpy = jest.spyOn(console, 'warn').mockImplementation();
            const dueCards = createDueTestCards(600); // Over threshold
            const stats = createTestStats(600);
            cacheService.setDueCards('large-user', dueCards, stats, inputHash);
            // Check that warning was logged (through logger)
            // Note: The actual warning goes through logger.warn, not console.warn directly
            expect(dueCards.length).toBeGreaterThan(500);
            consoleSpy.mockRestore();
        });
    });
    describe('clearUserCache', ()=>{
        it('should clear cache for specific user', ()=>{
            const dueCards1 = createDueTestCards(2);
            const dueCards2 = createDueTestCards(3);
            const stats1 = createTestStats(2);
            const stats2 = createTestStats(3);
            // Cache for two users
            cacheService.setDueCards('user1', dueCards1, stats1, 'hash1');
            cacheService.setDueCards('user2', dueCards2, stats2, 'hash2');
            // Clear user1 cache
            cacheService.clearUserCache('user1');
            // user1 cache should be gone
            expect(cacheService.getDueCards('user1', 'hash1')).toBeNull();
            // user2 cache should still exist
            expect(cacheService.getDueCards('user2', 'hash2')).toBeTruthy();
        });
        it('should handle clearing nonexistent user cache', ()=>{
            // Should not throw error
            expect(()=>{
                cacheService.clearUserCache('nonexistent-user');
            }).not.toThrow();
        });
    });
    describe('clearAllCache', ()=>{
        it('should clear all cache entries', ()=>{
            const dueCards = createDueTestCards(2);
            const stats = createTestStats(2);
            // Cache for multiple users
            cacheService.setDueCards('user1', dueCards, stats, 'hash1');
            cacheService.setDueCards('user2', dueCards, stats, 'hash2');
            cacheService.setDueCards('user3', dueCards, stats, 'hash3');
            // Clear all
            cacheService.clearAllCache();
            // All caches should be gone
            expect(cacheService.getDueCards('user1', 'hash1')).toBeNull();
            expect(cacheService.getDueCards('user2', 'hash2')).toBeNull();
            expect(cacheService.getDueCards('user3', 'hash3')).toBeNull();
        });
    });
    describe('getCacheStats', ()=>{
        it('should return cache statistics', ()=>{
            const dueCards = createDueTestCards(5);
            const stats = createTestStats(5);
            // Initially empty
            let cacheStats = cacheService.getCacheStats();
            expect(cacheStats.available).toBe(true);
            expect(cacheStats.totalEntries).toBe(0);
            // Cache some data
            cacheService.setDueCards('stats-user', dueCards, stats, 'stats-hash');
            cacheStats = cacheService.getCacheStats();
            expect(cacheStats.totalEntries).toBe(1);
            expect(cacheStats.estimatedSize).toBeGreaterThan(0);
        });
        it('should handle unavailable localStorage', ()=>{
            // Mock localStorage as unavailable
            Object.defineProperty(global, 'localStorage', {
                value: {
                    setItem: ()=>{
                        throw new Error('Not available');
                    },
                    getItem: ()=>{
                        throw new Error('Not available');
                    }
                },
                writable: true
            });
            // Create new instance with unavailable localStorage
            _DueCardsCacheService.DueCardsCacheService.instance = null;
            const newService = _DueCardsCacheService.DueCardsCacheService.getInstance();
            const stats = newService.getCacheStats();
            expect(stats.available).toBe(false);
            expect(stats.totalEntries).toBe(0);
            newService.destroy();
        });
    });
    describe('forceCleanup', ()=>{
        it('should perform cleanup when called', ()=>{
            const dueCards = createDueTestCards(2);
            const stats = createTestStats(2);
            const pastTime = Date.now() - 25 * 60 * 60 * 1000; // 25 hours ago
            mockDateNow(pastTime);
            // Cache expired data
            cacheService.setDueCards('cleanup-user', dueCards, stats, 'cleanup-hash');
            // Return to present
            restoreDateNow();
            // Force cleanup
            cacheService.forceCleanup();
            // Expired entry should be removed
            expect(cacheService.getDueCards('cleanup-user', 'cleanup-hash')).toBeNull();
        });
    });
    describe('error handling', ()=>{
        it('should handle JSON parse errors gracefully', ()=>{
            // Manually insert invalid JSON
            mockLocalStorage.setItem('endgame_due_cards_error-user', 'invalid-json');
            const cached = cacheService.getDueCards('error-user', 'error-hash');
            expect(cached).toBeNull();
        });
        it('should handle localStorage quota exceeded', ()=>{
            // Mock setItem to throw quota exceeded error
            jest.spyOn(mockLocalStorage, 'setItem').mockImplementation(()=>{
                throw new Error('QuotaExceededError');
            });
            const dueCards = createDueTestCards(1);
            const stats = createTestStats(1);
            // Should not throw error
            expect(()=>{
                cacheService.setDueCards('quota-user', dueCards, stats, 'quota-hash');
            }).not.toThrow();
        });
    });
});
describe('createInputHash', ()=>{
    it('should create consistent hash for same input', ()=>{
        const input = {
            userId: 'test',
            cards: [
                'a',
                'b',
                'c'
            ]
        };
        const hash1 = (0, _DueCardsCacheService.createInputHash)(input);
        const hash2 = (0, _DueCardsCacheService.createInputHash)(input);
        expect(hash1).toBe(hash2);
        expect(typeof hash1).toBe('string');
        expect(hash1.length).toBeGreaterThan(0);
    });
    it('should create different hashes for different inputs', ()=>{
        const input1 = {
            userId: 'test1',
            cards: [
                'a',
                'b'
            ]
        };
        const input2 = {
            userId: 'test2',
            cards: [
                'a',
                'b'
            ]
        };
        const hash1 = (0, _DueCardsCacheService.createInputHash)(input1);
        const hash2 = (0, _DueCardsCacheService.createInputHash)(input2);
        expect(hash1).not.toBe(hash2);
    });
    it('should handle string input', ()=>{
        const hash = (0, _DueCardsCacheService.createInputHash)('test-string');
        expect(typeof hash).toBe('string');
        expect(hash.length).toBeGreaterThan(0);
    });
    it('should handle empty input', ()=>{
        const hash = (0, _DueCardsCacheService.createInputHash)('');
        expect(typeof hash).toBe('string');
    });
    it('should handle complex nested objects', ()=>{
        const complex = {
            user: {
                id: 'test',
                profile: {
                    name: 'Test User'
                }
            },
            cards: [
                {
                    id: 'card1',
                    data: {
                        score: 100
                    }
                }
            ],
            meta: {
                timestamp: 123456789
            }
        };
        const hash = (0, _DueCardsCacheService.createInputHash)(complex);
        expect(typeof hash).toBe('string');
        expect(hash.length).toBeGreaterThan(0);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9EdWVDYXJkc0NhY2hlU2VydmljZS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgVW5pdCB0ZXN0cyBmb3IgRHVlQ2FyZHNDYWNoZVNlcnZpY2VcbiAqIEBkZXNjcmlwdGlvbiBDb21wcmVoZW5zaXZlIHRlc3RzIGZvciBsb2NhbFN0b3JhZ2UgY2FjaGUgd2l0aCBUVEwsIExSVSwgYW5kIG1pZG5pZ2h0IGludmFsaWRhdGlvblxuICovXG5cbmltcG9ydCB7IER1ZUNhcmRzQ2FjaGVTZXJ2aWNlLCBjcmVhdGVJbnB1dEhhc2ggfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL0R1ZUNhcmRzQ2FjaGVTZXJ2aWNlJztcbmltcG9ydCB7IGZpbHRlckR1ZUNhcmRzLCB0eXBlIER1ZUNhcmQsIHR5cGUgRHVlQ2FyZHNTdGF0cyB9IGZyb20gJ0BzaGFyZWQvdHlwZXMvcHJvZ3Jlc3MnO1xuaW1wb3J0IHR5cGUgeyBDYXJkUHJvZ3Jlc3MgfSBmcm9tICdAc2hhcmVkL3N0b3JlL3NsaWNlcy90eXBlcyc7XG5cbi8vIE1vY2sgbG9jYWxTdG9yYWdlIGZvciB0ZXN0aW5nXG5jbGFzcyBNb2NrTG9jYWxTdG9yYWdlIHtcbiAgcHJpdmF0ZSBzdG9yZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZVtrZXldIHx8IG51bGw7XG4gIH1cblxuICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yZVtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgZGVsZXRlIHRoaXMuc3RvcmVba2V5XTtcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgfVxuXG4gIGdldCBsZW5ndGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zdG9yZSkubGVuZ3RoO1xuICB9XG5cbiAga2V5KGluZGV4OiBudW1iZXIpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zdG9yZSk7XG4gICAgcmV0dXJuIGtleXNbaW5kZXhdIHx8IG51bGw7XG4gIH1cbn1cblxuLy8gVGVzdCBoZWxwZXJzXG5jb25zdCBjcmVhdGVUZXN0Q2FyZCA9IChpZDogc3RyaW5nLCBuZXh0UmV2aWV3QXQ6IG51bWJlcik6IENhcmRQcm9ncmVzcyA9PiAoe1xuICBpZCxcbiAgbmV4dFJldmlld0F0LFxuICBsYXN0UmV2aWV3ZWRBdDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwLCAvLyAyNCBob3VycyBhZ29cbiAgaW50ZXJ2YWw6IDEsXG4gIHJlcGV0aXRpb246IDEsXG4gIGVmYWN0b3I6IDIuNSxcbiAgbGFwc2VzOiAwXG59KTtcblxuY29uc3QgY3JlYXRlRHVlVGVzdENhcmRzID0gKGNvdW50OiBudW1iZXIpOiBEdWVDYXJkW10gPT4ge1xuICBjb25zdCBjYXJkcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNvdW50IH0sIChfLCBpKSA9PiBcbiAgICBjcmVhdGVUZXN0Q2FyZChgdGVzdC0ke2l9YCwgRGF0ZS5ub3coKSAtIDEwMDApIC8vIER1ZSAxIHNlY29uZCBhZ29cbiAgKTtcbiAgcmV0dXJuIGZpbHRlckR1ZUNhcmRzKGNhcmRzKTtcbn07XG5cbmNvbnN0IGNyZWF0ZVRlc3RTdGF0cyA9IChkdWVDb3VudDogbnVtYmVyKTogRHVlQ2FyZHNTdGF0cyA9PiAoe1xuICB0b3RhbENhcmRzOiBkdWVDb3VudCArIDUsXG4gIGR1ZUNvdW50LFxuICBkdWVQZXJjZW50YWdlOiBNYXRoLnJvdW5kKChkdWVDb3VudCAvIChkdWVDb3VudCArIDUpKSAqIDEwMCksXG4gIG5leHREdWVBdDogRGF0ZS5ub3coKSArIDM2MDAwMDAsIC8vIDEgaG91ciBmcm9tIG5vd1xuICBhdmVyYWdlSW50ZXJ2YWw6IDIuNVxufSk7XG5cbi8vIE1vY2sgRGF0ZS5ub3cgZm9yIFRUTCB0ZXN0aW5nXG5jb25zdCBvcmlnaW5hbERhdGVOb3cgPSBEYXRlLm5vdztcbmNvbnN0IG1vY2tEYXRlTm93ID0gKHRpbWVzdGFtcDogbnVtYmVyKSA9PiB7XG4gIERhdGUubm93ID0gamVzdC5mbigoKSA9PiB0aW1lc3RhbXApO1xufTtcblxuY29uc3QgcmVzdG9yZURhdGVOb3cgPSAoKSA9PiB7XG4gIERhdGUubm93ID0gb3JpZ2luYWxEYXRlTm93O1xufTtcblxuZGVzY3JpYmUoJ0R1ZUNhcmRzQ2FjaGVTZXJ2aWNlJywgKCkgPT4ge1xuICBsZXQgbW9ja0xvY2FsU3RvcmFnZTogTW9ja0xvY2FsU3RvcmFnZTtcbiAgbGV0IGNhY2hlU2VydmljZTogRHVlQ2FyZHNDYWNoZVNlcnZpY2U7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gU2V0dXAgbW9jayBsb2NhbFN0b3JhZ2VcbiAgICBtb2NrTG9jYWxTdG9yYWdlID0gbmV3IE1vY2tMb2NhbFN0b3JhZ2UoKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnbG9jYWxTdG9yYWdlJywge1xuICAgICAgdmFsdWU6IG1vY2tMb2NhbFN0b3JhZ2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIGluc3RhbmNlXG4gICAgKER1ZUNhcmRzQ2FjaGVTZXJ2aWNlIGFzIGFueSkuaW5zdGFuY2UgPSBudWxsO1xuICAgIFxuICAgIC8vIENyZWF0ZSBmcmVzaCBpbnN0YW5jZVxuICAgIGNhY2hlU2VydmljZSA9IER1ZUNhcmRzQ2FjaGVTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgcmVzdG9yZURhdGVOb3coKTtcbiAgICBjYWNoZVNlcnZpY2UuZGVzdHJveSgpO1xuICAgIG1vY2tMb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEluc3RhbmNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIHNpbmdsZXRvbiBpbnN0YW5jZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlMSA9IER1ZUNhcmRzQ2FjaGVTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgICBjb25zdCBpbnN0YW5jZTIgPSBEdWVDYXJkc0NhY2hlU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgXG4gICAgICBleHBlY3QoaW5zdGFuY2UxKS50b0JlKGluc3RhbmNlMik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzZXREdWVDYXJkcyBhbmQgZ2V0RHVlQ2FyZHMnLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3Rlc3QtdXNlci0xJztcbiAgICBjb25zdCBpbnB1dEhhc2ggPSAndGVzdC1oYXNoLTEyMyc7XG5cbiAgICBpdCgnc2hvdWxkIGNhY2hlIGFuZCByZXRyaWV2ZSBkdWUgY2FyZHMgc3VjY2Vzc2Z1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoNSk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cyg1KTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIGRhdGFcbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcyh1c2VySWQsIGR1ZUNhcmRzLCBzdGF0cywgaW5wdXRIYXNoKTtcblxuICAgICAgLy8gUmV0cmlldmUgdGhlIGRhdGFcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlU2VydmljZS5nZXREdWVDYXJkcyh1c2VySWQsIGlucHV0SGFzaCk7XG5cbiAgICAgIGV4cGVjdChjYWNoZWQpLnRvQmVUcnV0aHkoKTtcbiAgICAgIGV4cGVjdChjYWNoZWQ/LmR1ZUNhcmRzKS50b0hhdmVMZW5ndGgoNSk7XG4gICAgICBleHBlY3QoY2FjaGVkPy5kdWVDYXJkc1swXS5pZCkudG9CZSgndGVzdC0wJyk7XG4gICAgICBleHBlY3QoY2FjaGVkPy5zdGF0cy5kdWVDb3VudCkudG9CZSg1KTtcbiAgICAgIGV4cGVjdChjYWNoZWQ/LmlucHV0SGFzaCkudG9CZShpbnB1dEhhc2gpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gbnVsbCBmb3IgY2FjaGUgbWlzcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlU2VydmljZS5nZXREdWVDYXJkcygnbm9uZXhpc3RlbnQtdXNlcicsIGlucHV0SGFzaCk7XG4gICAgICBleHBlY3QoY2FjaGVkKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbnZhbGlkYXRlIGNhY2hlIHdoZW4gaW5wdXQgaGFzaCBjaGFuZ2VzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMyk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cygzKTtcblxuICAgICAgLy8gQ2FjaGUgd2l0aCBvcmlnaW5hbCBoYXNoXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHModXNlcklkLCBkdWVDYXJkcywgc3RhdHMsIGlucHV0SGFzaCk7XG5cbiAgICAgIC8vIFRyeSB0byByZXRyaWV2ZSB3aXRoIGRpZmZlcmVudCBoYXNoXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHModXNlcklkLCAnZGlmZmVyZW50LWhhc2gnKTtcbiAgICAgIGV4cGVjdChjYWNoZWQpLnRvQmVOdWxsKCk7XG4gICAgICBcbiAgICAgIC8vIE9yaWdpbmFsIGhhc2ggc2hvdWxkIHN0aWxsIHdvcmsgaW5pdGlhbGx5XG4gICAgICBjb25zdCBvcmlnaW5hbCA9IGNhY2hlU2VydmljZS5nZXREdWVDYXJkcyh1c2VySWQsIGlucHV0SGFzaCk7XG4gICAgICBleHBlY3Qob3JpZ2luYWwpLnRvQmVOdWxsKCk7IC8vIFNob3VsZCBiZSBjbGVhcmVkIGR1ZSB0byBoYXNoIG1pc21hdGNoIGFib3ZlXG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIGNhY2hlIGVudHJ5IHN0cnVjdHVyZSBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gTWFudWFsbHkgaW5zZXJ0IGludmFsaWQgY2FjaGUgZW50cnlcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgJ2VuZGdhbWVfZHVlX2NhcmRzX3Rlc3QtdXNlci0xJyxcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyBpbnZhbGlkOiAnZGF0YScgfSlcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlU2VydmljZS5nZXREdWVDYXJkcyh1c2VySWQsIGlucHV0SGFzaCk7XG4gICAgICBleHBlY3QoY2FjaGVkKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbG9jYWxTdG9yYWdlIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gTW9jayBsb2NhbFN0b3JhZ2UgdG8gdGhyb3cgZXJyb3JzXG4gICAgICBqZXN0LnNweU9uKG1vY2tMb2NhbFN0b3JhZ2UsICdnZXRJdGVtJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2NhbFN0b3JhZ2UgZXJyb3InKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHModXNlcklkLCBpbnB1dEhhc2gpO1xuICAgICAgZXhwZWN0KGNhY2hlZCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RUTCBleHBpcmF0aW9uJywgKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9ICd0dGwtdGVzdC11c2VyJztcbiAgICBjb25zdCBpbnB1dEhhc2ggPSAndHRsLWhhc2gnO1xuXG4gICAgaXQoJ3Nob3VsZCBleHBpcmUgY2FjaGUgYWZ0ZXIgMjQgaG91cnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGNyZWF0ZUR1ZVRlc3RDYXJkcygyKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gY3JlYXRlVGVzdFN0YXRzKDIpO1xuICAgICAgXG4gICAgICBjb25zdCBub3cgPSAxNjQwMDAwMDAwMDAwOyAvLyBGaXhlZCB0aW1lc3RhbXBcbiAgICAgIG1vY2tEYXRlTm93KG5vdyk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBkYXRhXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHModXNlcklkLCBkdWVDYXJkcywgc3RhdHMsIGlucHV0SGFzaCk7XG5cbiAgICAgIC8vIEZhc3QgZm9yd2FyZCAyNSBob3Vyc1xuICAgICAgbW9ja0RhdGVOb3cobm93ICsgMjUgKiA2MCAqIDYwICogMTAwMCk7XG5cbiAgICAgIC8vIFNob3VsZCBiZSBleHBpcmVkXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHModXNlcklkLCBpbnB1dEhhc2gpO1xuICAgICAgZXhwZWN0KGNhY2hlZCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbm90IGV4cGlyZSBjYWNoZSBiZWZvcmUgMjQgaG91cnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGNyZWF0ZUR1ZVRlc3RDYXJkcygyKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gY3JlYXRlVGVzdFN0YXRzKDIpO1xuICAgICAgXG4gICAgICAvLyBVc2UgYSB0aW1lc3RhbXAgYXQgMTA6MDAgQU0gVVRDIHNvIGFkZGluZyAyMyBob3VycyBkb2Vzbid0IGNyb3NzIG1pZG5pZ2h0XG4gICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgnMjAyNC0wMS0xNVQxMDowMDowMC4wMDBaJykuZ2V0VGltZSgpO1xuICAgICAgbW9ja0RhdGVOb3cobm93KTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIGRhdGFcbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcyh1c2VySWQsIGR1ZUNhcmRzLCBzdGF0cywgaW5wdXRIYXNoKTtcblxuICAgICAgLy8gRmFzdCBmb3J3YXJkIDEwIGhvdXJzIChzaG91bGQgYmUgODowMCBQTSBzYW1lIFVUQyBkYXkpXG4gICAgICBtb2NrRGF0ZU5vdyhub3cgKyAxMCAqIDYwICogNjAgKiAxMDAwKTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIGJlIHZhbGlkXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHModXNlcklkLCBpbnB1dEhhc2gpO1xuICAgICAgZXhwZWN0KGNhY2hlZCkudG9CZVRydXRoeSgpO1xuICAgICAgZXhwZWN0KGNhY2hlZD8uZHVlQ2FyZHMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ21pZG5pZ2h0IGludmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSAnbWlkbmlnaHQtdGVzdC11c2VyJztcbiAgICBjb25zdCBpbnB1dEhhc2ggPSAnbWlkbmlnaHQtaGFzaCc7XG5cbiAgICBpdCgnc2hvdWxkIGludmFsaWRhdGUgY2FjaGUgYWZ0ZXIgbWlkbmlnaHQgVVRDJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMyk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cygzKTtcblxuICAgICAgLy8gU2V0IHRpbWUgdG8ganVzdCBiZWZvcmUgbWlkbmlnaHQgVVRDICgyMzo1OSBVVEMpXG4gICAgICBjb25zdCBiZWZvcmVNaWRuaWdodCA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDIzOjU5OjAwLjAwMFonKS5nZXRUaW1lKCk7XG4gICAgICBtb2NrRGF0ZU5vdyhiZWZvcmVNaWRuaWdodCk7XG5cbiAgICAgIC8vIENhY2hlIHRoZSBkYXRhXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHModXNlcklkLCBkdWVDYXJkcywgc3RhdHMsIGlucHV0SGFzaCk7XG5cbiAgICAgIC8vIE1vdmUgdG8ganVzdCBhZnRlciBtaWRuaWdodCBVVEMgKDAwOjAxIG5leHQgZGF5KVxuICAgICAgY29uc3QgYWZ0ZXJNaWRuaWdodCA9IG5ldyBEYXRlKCcyMDI0LTAxLTE2VDAwOjAxOjAwLjAwMFonKS5nZXRUaW1lKCk7XG4gICAgICBtb2NrRGF0ZU5vdyhhZnRlck1pZG5pZ2h0KTtcblxuICAgICAgLy8gU2hvdWxkIGJlIGludmFsaWRhdGVkIGR1ZSB0byBtaWRuaWdodCByb2xsb3ZlclxuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKHVzZXJJZCwgaW5wdXRIYXNoKTtcbiAgICAgIGV4cGVjdChjYWNoZWQpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCBpbnZhbGlkYXRlIGNhY2hlIG9uIHNhbWUgVVRDIGRheScsICgpID0+IHtcbiAgICAgIGNvbnN0IGR1ZUNhcmRzID0gY3JlYXRlRHVlVGVzdENhcmRzKDMpO1xuICAgICAgY29uc3Qgc3RhdHMgPSBjcmVhdGVUZXN0U3RhdHMoMyk7XG5cbiAgICAgIC8vIFNldCB0aW1lIHRvIG1vcm5pbmcgVVRDICg4OjAwIEFNKVxuICAgICAgY29uc3QgbW9ybmluZyA9IG5ldyBEYXRlKCcyMDI0LTAxLTE1VDA4OjAwOjAwLjAwMFonKS5nZXRUaW1lKCk7XG4gICAgICBtb2NrRGF0ZU5vdyhtb3JuaW5nKTtcblxuICAgICAgLy8gQ2FjaGUgdGhlIGRhdGFcbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcyh1c2VySWQsIGR1ZUNhcmRzLCBzdGF0cywgaW5wdXRIYXNoKTtcblxuICAgICAgLy8gTW92ZSB0byBsYXRlciBzYW1lIGRheSBVVEMgKDY6MDAgUE0gc2FtZSBkYXkpXG4gICAgICBjb25zdCBldmVuaW5nID0gbmV3IERhdGUoJzIwMjQtMDEtMTVUMTg6MDA6MDAuMDAwWicpLmdldFRpbWUoKTtcbiAgICAgIG1vY2tEYXRlTm93KGV2ZW5pbmcpO1xuXG4gICAgICAvLyBTaG91bGQgc3RpbGwgYmUgdmFsaWQgKHNhbWUgVVRDIGRheSlcbiAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlU2VydmljZS5nZXREdWVDYXJkcyh1c2VySWQsIGlucHV0SGFzaCk7XG4gICAgICBleHBlY3QoY2FjaGVkKS50b0JlVHJ1dGh5KCk7XG4gICAgICBleHBlY3QoY2FjaGVkPy5kdWVDYXJkcykudG9IYXZlTGVuZ3RoKDMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTFJVIGNhY2hlIG1hbmFnZW1lbnQnLCAoKSA9PiB7XG4gICAgY29uc3QgaW5wdXRIYXNoID0gJ2xydS1oYXNoJztcblxuICAgIGl0KCdzaG91bGQgdHJhY2sgbGFzdCBhY2Nlc3NlZCB0aW1lJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMSk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cygxKTtcbiAgICAgIFxuICAgICAgY29uc3QgaW5pdGlhbFRpbWUgPSAxNjQwMDAwMDAwMDAwO1xuICAgICAgbW9ja0RhdGVOb3coaW5pdGlhbFRpbWUpO1xuXG4gICAgICAvLyBDYWNoZSB0aGUgZGF0YVxuICAgICAgY2FjaGVTZXJ2aWNlLnNldER1ZUNhcmRzKCd1c2VyMScsIGR1ZUNhcmRzLCBzdGF0cywgaW5wdXRIYXNoKTtcblxuICAgICAgLy8gQWNjZXNzIGxhdGVyXG4gICAgICBjb25zdCBsYXRlclRpbWUgPSBpbml0aWFsVGltZSArIDYwMDAwOyAvLyAxIG1pbnV0ZSBsYXRlclxuICAgICAgbW9ja0RhdGVOb3cobGF0ZXJUaW1lKTtcblxuICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKCd1c2VyMScsIGlucHV0SGFzaCk7XG4gICAgICBleHBlY3QoY2FjaGVkPy5sYXN0QWNjZXNzZWRBdCkudG9CZShsYXRlclRpbWUpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbGFyZ2UgY29sbGVjdGlvbnMgd2l0aCBwZXJmb3JtYW5jZSB3YXJuaW5nJywgKCkgPT4ge1xuICAgICAgLy8gTW9jayBjb25zb2xlLndhcm4gdG8gY2FwdHVyZSBwZXJmb3JtYW5jZSB3YXJuaW5nc1xuICAgICAgY29uc3QgY29uc29sZVNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ3dhcm4nKS5tb2NrSW1wbGVtZW50YXRpb24oKTtcblxuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoNjAwKTsgLy8gT3ZlciB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHN0YXRzID0gY3JlYXRlVGVzdFN0YXRzKDYwMCk7XG5cbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcygnbGFyZ2UtdXNlcicsIGR1ZUNhcmRzLCBzdGF0cywgaW5wdXRIYXNoKTtcblxuICAgICAgLy8gQ2hlY2sgdGhhdCB3YXJuaW5nIHdhcyBsb2dnZWQgKHRocm91Z2ggbG9nZ2VyKVxuICAgICAgLy8gTm90ZTogVGhlIGFjdHVhbCB3YXJuaW5nIGdvZXMgdGhyb3VnaCBsb2dnZXIud2Fybiwgbm90IGNvbnNvbGUud2FybiBkaXJlY3RseVxuICAgICAgZXhwZWN0KGR1ZUNhcmRzLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDUwMCk7XG5cbiAgICAgIGNvbnNvbGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NsZWFyVXNlckNhY2hlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY2xlYXIgY2FjaGUgZm9yIHNwZWNpZmljIHVzZXInLCAoKSA9PiB7XG4gICAgICBjb25zdCBkdWVDYXJkczEgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMik7XG4gICAgICBjb25zdCBkdWVDYXJkczIgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMyk7XG4gICAgICBjb25zdCBzdGF0czEgPSBjcmVhdGVUZXN0U3RhdHMoMik7XG4gICAgICBjb25zdCBzdGF0czIgPSBjcmVhdGVUZXN0U3RhdHMoMyk7XG5cbiAgICAgIC8vIENhY2hlIGZvciB0d28gdXNlcnNcbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcygndXNlcjEnLCBkdWVDYXJkczEsIHN0YXRzMSwgJ2hhc2gxJyk7XG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHMoJ3VzZXIyJywgZHVlQ2FyZHMyLCBzdGF0czIsICdoYXNoMicpO1xuXG4gICAgICAvLyBDbGVhciB1c2VyMSBjYWNoZVxuICAgICAgY2FjaGVTZXJ2aWNlLmNsZWFyVXNlckNhY2hlKCd1c2VyMScpO1xuXG4gICAgICAvLyB1c2VyMSBjYWNoZSBzaG91bGQgYmUgZ29uZVxuICAgICAgZXhwZWN0KGNhY2hlU2VydmljZS5nZXREdWVDYXJkcygndXNlcjEnLCAnaGFzaDEnKSkudG9CZU51bGwoKTtcbiAgICAgIFxuICAgICAgLy8gdXNlcjIgY2FjaGUgc2hvdWxkIHN0aWxsIGV4aXN0XG4gICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKCd1c2VyMicsICdoYXNoMicpKS50b0JlVHJ1dGh5KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjbGVhcmluZyBub25leGlzdGVudCB1c2VyIGNhY2hlJywgKCkgPT4ge1xuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvclxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgY2FjaGVTZXJ2aWNlLmNsZWFyVXNlckNhY2hlKCdub25leGlzdGVudC11c2VyJyk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnY2xlYXJBbGxDYWNoZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNsZWFyIGFsbCBjYWNoZSBlbnRyaWVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMik7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cygyKTtcblxuICAgICAgLy8gQ2FjaGUgZm9yIG11bHRpcGxlIHVzZXJzXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHMoJ3VzZXIxJywgZHVlQ2FyZHMsIHN0YXRzLCAnaGFzaDEnKTtcbiAgICAgIGNhY2hlU2VydmljZS5zZXREdWVDYXJkcygndXNlcjInLCBkdWVDYXJkcywgc3RhdHMsICdoYXNoMicpO1xuICAgICAgY2FjaGVTZXJ2aWNlLnNldER1ZUNhcmRzKCd1c2VyMycsIGR1ZUNhcmRzLCBzdGF0cywgJ2hhc2gzJyk7XG5cbiAgICAgIC8vIENsZWFyIGFsbFxuICAgICAgY2FjaGVTZXJ2aWNlLmNsZWFyQWxsQ2FjaGUoKTtcblxuICAgICAgLy8gQWxsIGNhY2hlcyBzaG91bGQgYmUgZ29uZVxuICAgICAgZXhwZWN0KGNhY2hlU2VydmljZS5nZXREdWVDYXJkcygndXNlcjEnLCAnaGFzaDEnKSkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHMoJ3VzZXIyJywgJ2hhc2gyJykpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKCd1c2VyMycsICdoYXNoMycpKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0Q2FjaGVTdGF0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBjYWNoZSBzdGF0aXN0aWNzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoNSk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cyg1KTtcblxuICAgICAgLy8gSW5pdGlhbGx5IGVtcHR5XG4gICAgICBsZXQgY2FjaGVTdGF0cyA9IGNhY2hlU2VydmljZS5nZXRDYWNoZVN0YXRzKCk7XG4gICAgICBleHBlY3QoY2FjaGVTdGF0cy5hdmFpbGFibGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY2FjaGVTdGF0cy50b3RhbEVudHJpZXMpLnRvQmUoMCk7XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgZGF0YVxuICAgICAgY2FjaGVTZXJ2aWNlLnNldER1ZUNhcmRzKCdzdGF0cy11c2VyJywgZHVlQ2FyZHMsIHN0YXRzLCAnc3RhdHMtaGFzaCcpO1xuXG4gICAgICBjYWNoZVN0YXRzID0gY2FjaGVTZXJ2aWNlLmdldENhY2hlU3RhdHMoKTtcbiAgICAgIGV4cGVjdChjYWNoZVN0YXRzLnRvdGFsRW50cmllcykudG9CZSgxKTtcbiAgICAgIGV4cGVjdChjYWNoZVN0YXRzLmVzdGltYXRlZFNpemUpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVuYXZhaWxhYmxlIGxvY2FsU3RvcmFnZScsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgbG9jYWxTdG9yYWdlIGFzIHVuYXZhaWxhYmxlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCAnbG9jYWxTdG9yYWdlJywge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHNldEl0ZW06ICgpID0+IHsgdGhyb3cgbmV3IEVycm9yKCdOb3QgYXZhaWxhYmxlJyk7IH0sXG4gICAgICAgICAgZ2V0SXRlbTogKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUnKTsgfSxcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGggdW5hdmFpbGFibGUgbG9jYWxTdG9yYWdlXG4gICAgICAoRHVlQ2FyZHNDYWNoZVNlcnZpY2UgYXMgYW55KS5pbnN0YW5jZSA9IG51bGw7XG4gICAgICBjb25zdCBuZXdTZXJ2aWNlID0gRHVlQ2FyZHNDYWNoZVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcblxuICAgICAgY29uc3Qgc3RhdHMgPSBuZXdTZXJ2aWNlLmdldENhY2hlU3RhdHMoKTtcbiAgICAgIGV4cGVjdChzdGF0cy5hdmFpbGFibGUpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsRW50cmllcykudG9CZSgwKTtcblxuICAgICAgbmV3U2VydmljZS5kZXN0cm95KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdmb3JjZUNsZWFudXAnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBwZXJmb3JtIGNsZWFudXAgd2hlbiBjYWxsZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGNyZWF0ZUR1ZVRlc3RDYXJkcygyKTtcbiAgICAgIGNvbnN0IHN0YXRzID0gY3JlYXRlVGVzdFN0YXRzKDIpO1xuICAgICAgXG4gICAgICBjb25zdCBwYXN0VGltZSA9IERhdGUubm93KCkgLSAyNSAqIDYwICogNjAgKiAxMDAwOyAvLyAyNSBob3VycyBhZ29cbiAgICAgIG1vY2tEYXRlTm93KHBhc3RUaW1lKTtcblxuICAgICAgLy8gQ2FjaGUgZXhwaXJlZCBkYXRhXG4gICAgICBjYWNoZVNlcnZpY2Uuc2V0RHVlQ2FyZHMoJ2NsZWFudXAtdXNlcicsIGR1ZUNhcmRzLCBzdGF0cywgJ2NsZWFudXAtaGFzaCcpO1xuXG4gICAgICAvLyBSZXR1cm4gdG8gcHJlc2VudFxuICAgICAgcmVzdG9yZURhdGVOb3coKTtcblxuICAgICAgLy8gRm9yY2UgY2xlYW51cFxuICAgICAgY2FjaGVTZXJ2aWNlLmZvcmNlQ2xlYW51cCgpO1xuXG4gICAgICAvLyBFeHBpcmVkIGVudHJ5IHNob3VsZCBiZSByZW1vdmVkXG4gICAgICBleHBlY3QoY2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKCdjbGVhbnVwLXVzZXInLCAnY2xlYW51cC1oYXNoJykpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdlcnJvciBoYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBKU09OIHBhcnNlIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gTWFudWFsbHkgaW5zZXJ0IGludmFsaWQgSlNPTlxuICAgICAgbW9ja0xvY2FsU3RvcmFnZS5zZXRJdGVtKCdlbmRnYW1lX2R1ZV9jYXJkc19lcnJvci11c2VyJywgJ2ludmFsaWQtanNvbicpO1xuXG4gICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHMoJ2Vycm9yLXVzZXInLCAnZXJyb3ItaGFzaCcpO1xuICAgICAgZXhwZWN0KGNhY2hlZCkudG9CZU51bGwoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGxvY2FsU3RvcmFnZSBxdW90YSBleGNlZWRlZCcsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgc2V0SXRlbSB0byB0aHJvdyBxdW90YSBleGNlZWRlZCBlcnJvclxuICAgICAgamVzdC5zcHlPbihtb2NrTG9jYWxTdG9yYWdlLCAnc2V0SXRlbScpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVvdGFFeGNlZWRlZEVycm9yJyk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBjcmVhdGVEdWVUZXN0Q2FyZHMoMSk7XG4gICAgICBjb25zdCBzdGF0cyA9IGNyZWF0ZVRlc3RTdGF0cygxKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBlcnJvclxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgY2FjaGVTZXJ2aWNlLnNldER1ZUNhcmRzKCdxdW90YS11c2VyJywgZHVlQ2FyZHMsIHN0YXRzLCAncXVvdGEtaGFzaCcpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2NyZWF0ZUlucHV0SGFzaCcsICgpID0+IHtcbiAgaXQoJ3Nob3VsZCBjcmVhdGUgY29uc2lzdGVudCBoYXNoIGZvciBzYW1lIGlucHV0JywgKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0geyB1c2VySWQ6ICd0ZXN0JywgY2FyZHM6IFsnYScsICdiJywgJ2MnXSB9O1xuICAgIFxuICAgIGNvbnN0IGhhc2gxID0gY3JlYXRlSW5wdXRIYXNoKGlucHV0KTtcbiAgICBjb25zdCBoYXNoMiA9IGNyZWF0ZUlucHV0SGFzaChpbnB1dCk7XG4gICAgXG4gICAgZXhwZWN0KGhhc2gxKS50b0JlKGhhc2gyKTtcbiAgICBleHBlY3QodHlwZW9mIGhhc2gxKS50b0JlKCdzdHJpbmcnKTtcbiAgICBleHBlY3QoaGFzaDEubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY3JlYXRlIGRpZmZlcmVudCBoYXNoZXMgZm9yIGRpZmZlcmVudCBpbnB1dHMnLCAoKSA9PiB7XG4gICAgY29uc3QgaW5wdXQxID0geyB1c2VySWQ6ICd0ZXN0MScsIGNhcmRzOiBbJ2EnLCAnYiddIH07XG4gICAgY29uc3QgaW5wdXQyID0geyB1c2VySWQ6ICd0ZXN0MicsIGNhcmRzOiBbJ2EnLCAnYiddIH07XG4gICAgXG4gICAgY29uc3QgaGFzaDEgPSBjcmVhdGVJbnB1dEhhc2goaW5wdXQxKTtcbiAgICBjb25zdCBoYXNoMiA9IGNyZWF0ZUlucHV0SGFzaChpbnB1dDIpO1xuICAgIFxuICAgIGV4cGVjdChoYXNoMSkubm90LnRvQmUoaGFzaDIpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBzdHJpbmcgaW5wdXQnLCAoKSA9PiB7XG4gICAgY29uc3QgaGFzaCA9IGNyZWF0ZUlucHV0SGFzaCgndGVzdC1zdHJpbmcnKTtcbiAgICBleHBlY3QodHlwZW9mIGhhc2gpLnRvQmUoJ3N0cmluZycpO1xuICAgIGV4cGVjdChoYXNoLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBpbnB1dCcsICgpID0+IHtcbiAgICBjb25zdCBoYXNoID0gY3JlYXRlSW5wdXRIYXNoKCcnKTtcbiAgICBleHBlY3QodHlwZW9mIGhhc2gpLnRvQmUoJ3N0cmluZycpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBjb21wbGV4IG5lc3RlZCBvYmplY3RzJywgKCkgPT4ge1xuICAgIGNvbnN0IGNvbXBsZXggPSB7XG4gICAgICB1c2VyOiB7IGlkOiAndGVzdCcsIHByb2ZpbGU6IHsgbmFtZTogJ1Rlc3QgVXNlcicgfSB9LFxuICAgICAgY2FyZHM6IFt7IGlkOiAnY2FyZDEnLCBkYXRhOiB7IHNjb3JlOiAxMDAgfSB9XSxcbiAgICAgIG1ldGE6IHsgdGltZXN0YW1wOiAxMjM0NTY3ODkgfVxuICAgIH07XG4gICAgXG4gICAgY29uc3QgaGFzaCA9IGNyZWF0ZUlucHV0SGFzaChjb21wbGV4KTtcbiAgICBleHBlY3QodHlwZW9mIGhhc2gpLnRvQmUoJ3N0cmluZycpO1xuICAgIGV4cGVjdChoYXNoLmxlbmd0aCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJNb2NrTG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImtleSIsInN0b3JlIiwic2V0SXRlbSIsInZhbHVlIiwicmVtb3ZlSXRlbSIsImNsZWFyIiwibGVuZ3RoIiwiT2JqZWN0Iiwia2V5cyIsImluZGV4IiwiY3JlYXRlVGVzdENhcmQiLCJpZCIsIm5leHRSZXZpZXdBdCIsImxhc3RSZXZpZXdlZEF0IiwiRGF0ZSIsIm5vdyIsImludGVydmFsIiwicmVwZXRpdGlvbiIsImVmYWN0b3IiLCJsYXBzZXMiLCJjcmVhdGVEdWVUZXN0Q2FyZHMiLCJjb3VudCIsImNhcmRzIiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJmaWx0ZXJEdWVDYXJkcyIsImNyZWF0ZVRlc3RTdGF0cyIsImR1ZUNvdW50IiwidG90YWxDYXJkcyIsImR1ZVBlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJuZXh0RHVlQXQiLCJhdmVyYWdlSW50ZXJ2YWwiLCJvcmlnaW5hbERhdGVOb3ciLCJtb2NrRGF0ZU5vdyIsInRpbWVzdGFtcCIsImplc3QiLCJmbiIsInJlc3RvcmVEYXRlTm93IiwiZGVzY3JpYmUiLCJtb2NrTG9jYWxTdG9yYWdlIiwiY2FjaGVTZXJ2aWNlIiwiYmVmb3JlRWFjaCIsImRlZmluZVByb3BlcnR5IiwiZ2xvYmFsIiwid3JpdGFibGUiLCJEdWVDYXJkc0NhY2hlU2VydmljZSIsImluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJjbGVhckFsbE1vY2tzIiwiYWZ0ZXJFYWNoIiwiZGVzdHJveSIsIml0IiwiaW5zdGFuY2UxIiwiaW5zdGFuY2UyIiwiZXhwZWN0IiwidG9CZSIsInVzZXJJZCIsImlucHV0SGFzaCIsImR1ZUNhcmRzIiwic3RhdHMiLCJzZXREdWVDYXJkcyIsImNhY2hlZCIsImdldER1ZUNhcmRzIiwidG9CZVRydXRoeSIsInRvSGF2ZUxlbmd0aCIsInRvQmVOdWxsIiwib3JpZ2luYWwiLCJKU09OIiwic3RyaW5naWZ5IiwiaW52YWxpZCIsInNweU9uIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiRXJyb3IiLCJnZXRUaW1lIiwiYmVmb3JlTWlkbmlnaHQiLCJhZnRlck1pZG5pZ2h0IiwibW9ybmluZyIsImV2ZW5pbmciLCJpbml0aWFsVGltZSIsImxhdGVyVGltZSIsImxhc3RBY2Nlc3NlZEF0IiwiY29uc29sZVNweSIsImNvbnNvbGUiLCJ0b0JlR3JlYXRlclRoYW4iLCJtb2NrUmVzdG9yZSIsImR1ZUNhcmRzMSIsImR1ZUNhcmRzMiIsInN0YXRzMSIsInN0YXRzMiIsImNsZWFyVXNlckNhY2hlIiwibm90IiwidG9UaHJvdyIsImNsZWFyQWxsQ2FjaGUiLCJjYWNoZVN0YXRzIiwiZ2V0Q2FjaGVTdGF0cyIsImF2YWlsYWJsZSIsInRvdGFsRW50cmllcyIsImVzdGltYXRlZFNpemUiLCJuZXdTZXJ2aWNlIiwicGFzdFRpbWUiLCJmb3JjZUNsZWFudXAiLCJpbnB1dCIsImhhc2gxIiwiY3JlYXRlSW5wdXRIYXNoIiwiaGFzaDIiLCJpbnB1dDEiLCJpbnB1dDIiLCJoYXNoIiwiY29tcGxleCIsInVzZXIiLCJwcm9maWxlIiwibmFtZSIsImRhdGEiLCJzY29yZSIsIm1ldGEiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7OztzQ0FFcUQ7MEJBQ1c7Ozs7Ozs7Ozs7Ozs7O0FBR2pFLGdDQUFnQztBQUNoQyxNQUFNQTtJQUdKQyxRQUFRQyxHQUFXLEVBQWlCO1FBQ2xDLE9BQU8sSUFBSSxDQUFDQyxLQUFLLENBQUNELElBQUksSUFBSTtJQUM1QjtJQUVBRSxRQUFRRixHQUFXLEVBQUVHLEtBQWEsRUFBUTtRQUN4QyxJQUFJLENBQUNGLEtBQUssQ0FBQ0QsSUFBSSxHQUFHRztJQUNwQjtJQUVBQyxXQUFXSixHQUFXLEVBQVE7UUFDNUIsT0FBTyxJQUFJLENBQUNDLEtBQUssQ0FBQ0QsSUFBSTtJQUN4QjtJQUVBSyxRQUFjO1FBQ1osSUFBSSxDQUFDSixLQUFLLEdBQUcsQ0FBQztJQUNoQjtJQUVBLElBQUlLLFNBQWlCO1FBQ25CLE9BQU9DLE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNQLEtBQUssRUFBRUssTUFBTTtJQUN2QztJQUVBTixJQUFJUyxLQUFhLEVBQWlCO1FBQ2hDLE1BQU1ELE9BQU9ELE9BQU9DLElBQUksQ0FBQyxJQUFJLENBQUNQLEtBQUs7UUFDbkMsT0FBT08sSUFBSSxDQUFDQyxNQUFNLElBQUk7SUFDeEI7O1FBekJBLHVCQUFRUixTQUFnQyxDQUFDOztBQTBCM0M7QUFFQSxlQUFlO0FBQ2YsTUFBTVMsaUJBQWlCLENBQUNDLElBQVlDLGVBQXdDLENBQUE7UUFDMUVEO1FBQ0FDO1FBQ0FDLGdCQUFnQkMsS0FBS0MsR0FBRyxLQUFLO1FBQzdCQyxVQUFVO1FBQ1ZDLFlBQVk7UUFDWkMsU0FBUztRQUNUQyxRQUFRO0lBQ1YsQ0FBQTtBQUVBLE1BQU1DLHFCQUFxQixDQUFDQztJQUMxQixNQUFNQyxRQUFRQyxNQUFNQyxJQUFJLENBQUM7UUFBRWxCLFFBQVFlO0lBQU0sR0FBRyxDQUFDSSxHQUFHQyxJQUM5Q2hCLGVB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