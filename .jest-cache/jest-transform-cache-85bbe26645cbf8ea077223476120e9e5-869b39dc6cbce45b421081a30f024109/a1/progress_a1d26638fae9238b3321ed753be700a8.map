{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/types/progress.ts"],"sourcesContent":["/**\n * @file Progress-related branded types\n * @description Type-safe Due Card implementations with branded types\n * \n * This module provides branded types for Due Cards to ensure type safety\n * and prevent runtime errors when working with spaced repetition cards.\n * \n * @example\n * ```typescript\n * // Type-safe due card filtering\n * const cards: CardProgress[] = getUserCards();\n * const dueCards: DueCard[] = filterDueCards(cards);\n * \n * // Type guard usage\n * if (isDueCard(card)) {\n *   // TypeScript knows 'card' is DueCard here\n *   processCard(card);\n * }\n * ```\n */\n\nimport type { CardProgress } from '@shared/store/slices/types';\nimport { getLogger } from '@shared/services/logging/Logger';\n\nconst logger = getLogger().setContext('ProgressTypes');\n\n/**\n * Branded type for cards that are due for review\n * \n * This branded type ensures that only cards that have been validated\n * as due can be processed as DueCard instances.\n */\nexport type DueCard = CardProgress & { \n  readonly __isDue: true;\n  readonly __brand: 'DueCard';\n};\n\n/**\n * Type guard to check if a card is due for review\n * \n * @param card - CardProgress to check\n * @param now - Current timestamp (defaults to Date.now())\n * @returns True if card is due for review\n * \n * @example\n * ```typescript\n * if (isDueCard(card)) {\n *   // TypeScript narrows type to DueCard\n *   const dueCard: DueCard = card;\n * }\n * ```\n */\nexport function isDueCard(\n  card: CardProgress, \n  now: number = Date.now()\n): card is DueCard {\n  // Validate card structure\n  if (!card || typeof card.nextReviewAt !== 'number') {\n    logger.warn('Invalid card structure in isDueCard check', { card });\n    return false;\n  }\n  \n  // Check if card is due based on nextReviewAt timestamp\n  return card.nextReviewAt <= now;\n}\n\n/**\n * Safe factory function to create a DueCard\n * \n * @param card - CardProgress to convert\n * @param now - Current timestamp (defaults to Date.now())\n * @returns DueCard instance\n * @throws Error if card is not due\n * \n * @example\n * ```typescript\n * try {\n *   const dueCard = toDueCard(card);\n *   processCard(dueCard);\n * } catch (error) {\n *   // Card is not due for review\n * }\n * ```\n */\nexport function toDueCard(\n  card: CardProgress, \n  now: number = Date.now()\n): DueCard {\n  if (!isDueCard(card, now)) {\n    const nextReview = new Date(card.nextReviewAt).toISOString();\n    const currentTime = new Date(now).toISOString();\n    throw new Error(\n      `Card '${card.id}' is not due for review. ` +\n      `Next review: ${nextReview}, Current: ${currentTime}`\n    );\n  }\n  \n  // Create branded DueCard\n  return {\n    ...card,\n    __isDue: true,\n    __brand: 'DueCard' as const\n  } as DueCard;\n}\n\n/**\n * Batch processing function to filter due cards from a collection\n * \n * This function is optimized for performance when processing large\n * collections of cards (>500 cards).\n * \n * @param cards - Array of CardProgress objects\n * @param now - Current timestamp (defaults to Date.now())\n * @returns Array of DueCard objects\n * \n * @example\n * ```typescript\n * const allCards = Object.values(cardProgress);\n * const dueCards = filterDueCards(allCards);\n * console.log(`${dueCards.length} cards are due for review`);\n * ```\n */\nexport function filterDueCards(\n  cards: CardProgress[], \n  now: number = Date.now()\n): DueCard[] {\n  if (!Array.isArray(cards)) {\n    logger.warn('Invalid cards array in filterDueCards', { cards });\n    return [];\n  }\n  \n  const dueCards: DueCard[] = [];\n  \n  // Optimized loop for large collections\n  for (let i = 0; i < cards.length; i++) {\n    const card = cards[i];\n    \n    // Skip invalid cards\n    if (!card || typeof card.nextReviewAt !== 'number') {\n      continue;\n    }\n    \n    // Check if due and add to result\n    if (card.nextReviewAt <= now) {\n      dueCards.push({\n        ...card,\n        __isDue: true,\n        __brand: 'DueCard' as const\n      } as DueCard);\n    }\n  }\n  \n  logger.debug('Filtered due cards', { \n    totalCards: cards.length, \n    dueCards: dueCards.length,\n    percentage: Math.round((dueCards.length / cards.length) * 100) || 0\n  });\n  \n  return dueCards;\n}\n\n/**\n * Utility function to extract CardProgress from DueCard\n * \n * This function removes the branded type properties and returns\n * the underlying CardProgress object.\n * \n * @param dueCard - DueCard to convert\n * @returns CardProgress object\n */\nexport function fromDueCard(dueCard: DueCard): CardProgress {\n  const { __isDue, __brand, ...cardProgress } = dueCard;\n  return cardProgress;\n}\n\n/**\n * Type predicate to check if an array contains only DueCard objects\n * \n * @param cards - Array to check\n * @returns True if all items are DueCard objects\n */\nexport function areDueCards(cards: unknown[]): cards is DueCard[] {\n  return cards.every(card => \n    typeof card === 'object' && \n    card !== null && \n    '__isDue' in card && \n    '__brand' in card &&\n    (card as any).__brand === 'DueCard'\n  );\n}\n\n/**\n * Performance optimized due cards map creation\n * \n * Creates a map of positionId -> DueCard for O(1) lookups.\n * Useful for large card collections.\n * \n * @param dueCards - Array of DueCard objects\n * @returns Map of positionId to DueCard\n */\nexport function createDueCardsMap(dueCards: DueCard[]): Map<string, DueCard> {\n  const map = new Map<string, DueCard>();\n  \n  for (const card of dueCards) {\n    if (card.id) {\n      map.set(card.id, card);\n    }\n  }\n  \n  return map;\n}\n\n/**\n * Statistics interface for due cards analysis\n */\nexport interface DueCardsStats {\n  totalCards: number;\n  dueCount: number;\n  duePercentage: number;\n  nextDueAt: number | null;\n  averageInterval: number;\n}\n\n/**\n * Calculate statistics for due cards analysis\n * \n * @param allCards - All card progress objects\n * @param dueCards - Due cards subset\n * @param now - Current timestamp\n * @returns Statistics object\n */\nexport function calculateDueCardsStats(\n  allCards: CardProgress[],\n  dueCards: DueCard[],\n  now: number = Date.now()\n): DueCardsStats {\n  const totalCards = allCards.length;\n  const dueCount = dueCards.length;\n  const duePercentage = totalCards > 0 ? Math.round((dueCount / totalCards) * 100) : 0;\n  \n  // Find next due card\n  const futureDueCards = allCards\n    .filter(card => card.nextReviewAt > now)\n    .sort((a, b) => a.nextReviewAt - b.nextReviewAt);\n  \n  const nextDueAt = futureDueCards.length > 0 ? futureDueCards[0].nextReviewAt : null;\n  \n  // Calculate average interval for due cards\n  const totalInterval = dueCards.reduce((sum, card) => sum + card.interval, 0);\n  const averageInterval = dueCount > 0 ? Math.round(totalInterval / dueCount) : 0;\n  \n  return {\n    totalCards,\n    dueCount,\n    duePercentage,\n    nextDueAt,\n    averageInterval\n  };\n}"],"names":["areDueCards","calculateDueCardsStats","createDueCardsMap","filterDueCards","fromDueCard","isDueCard","toDueCard","logger","getLogger","setContext","card","now","Date","nextReviewAt","warn","nextReview","toISOString","currentTime","Error","id","__isDue","__brand","cards","Array","isArray","dueCards","i","length","push","debug","totalCards","percentage","Math","round","dueCard","cardProgress","every","map","Map","set","allCards","dueCount","duePercentage","futureDueCards","filter","sort","a","b","nextDueAt","totalInterval","reduce","sum","interval","averageInterval"],"mappings":"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"}