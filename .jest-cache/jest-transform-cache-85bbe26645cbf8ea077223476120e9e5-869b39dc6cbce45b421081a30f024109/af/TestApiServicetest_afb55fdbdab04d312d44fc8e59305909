ec12cfe9b56820d5186cf5f612aed720
/**
 * @file Tests for TestApiService - Clean Store-Based Architecture
 * @description Test coverage for E2E test API service with store interactions only
 */ // Mock the logging module BEFORE imports
"use strict";
jest.mock("../../../../shared/services/logging", ()=>({
        getLogger: jest.fn().mockReturnValue({
            setContext: jest.fn().mockReturnThis(),
            info: jest.fn(),
            error: jest.fn(),
            warn: jest.fn(),
            debug: jest.fn()
        })
    }));
// Mock chess.js
jest.mock("chess.js", ()=>{
    return {
        Chess: jest.fn().mockImplementation(function(fen) {
            return {
                fen: jest.fn(()=>fen || "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"),
                turn: jest.fn(()=>"w"),
                pgn: jest.fn(()=>"1. e4 e5"),
                isGameOver: jest.fn(()=>false),
                isCheck: jest.fn(()=>false),
                isCheckmate: jest.fn(()=>false),
                isDraw: jest.fn(()=>false),
                isStalemate: jest.fn(()=>false),
                isThreefoldRepetition: jest.fn(()=>false),
                isInsufficientMaterial: jest.fn(()=>false),
                move: jest.fn((_move)=>({
                        from: "e2",
                        to: "e4",
                        san: "e4"
                    }))
            };
        })
    };
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _TestApiService = require("../../../../shared/services/test/TestApiService");
const _logging = require("../../../../shared/services/logging");
describe("TestApiService - Store-Based Architecture", ()=>{
    let service;
    let mockStoreAccess;
    let consoleLogSpy;
    let consoleErrorSpy;
    let consoleWarnSpy;
    let mockLogger;
    beforeEach(()=>{
        // Get the mocked logger instance and clear all mocks
        mockLogger = (0, _logging.getLogger)();
        jest.clearAllMocks();
        // Reset singleton
        _TestApiService.TestApiService["instance"] = null;
        service = _TestApiService.TestApiService.getInstance();
        // Mock store access - the ONLY dependency
        mockStoreAccess = {
            getState: jest.fn(()=>({
                    game: {
                        currentFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
                    },
                    tablebase: {
                        analysisStatus: "idle"
                    },
                    training: {
                        currentFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                        moveHistory: [],
                        currentEvaluation: {
                            evaluation: 0.2
                        },
                        analysisStatus: "idle"
                    },
                    fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                    history: [],
                    evaluation: {
                        tablebaseEvaluation: {
                            value: 0.1
                        }
                    },
                    analysisStatus: "idle"
                })),
            subscribe: jest.fn(()=>jest.fn()),
            makeMove: jest.fn(),
            _internalApplyMove: jest.fn(),
            resetPosition: jest.fn(),
            setPosition: jest.fn(),
            goToMove: jest.fn(),
            setAnalysisStatus: jest.fn()
        };
        // Mock console methods
        consoleLogSpy = jest.spyOn(console, "log").mockImplementation();
        consoleErrorSpy = jest.spyOn(console, "error").mockImplementation();
        consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation();
    });
    afterEach(()=>{
        service.cleanup();
        jest.clearAllMocks();
        consoleLogSpy.mockRestore();
        consoleErrorSpy.mockRestore();
        consoleWarnSpy.mockRestore();
    });
    describe("Singleton Pattern", ()=>{
        it("should return the same instance", ()=>{
            const instance1 = _TestApiService.TestApiService.getInstance();
            const instance2 = _TestApiService.TestApiService.getInstance();
            expect(instance1).toBe(instance2);
        });
        it("should provide convenience getter", ()=>{
            const instance = (0, _TestApiService.getTestApi)();
            expect(instance).toBe(_TestApiService.TestApiService.getInstance());
        });
    });
    describe("Initialization", ()=>{
        it("should initialize with store access", ()=>{
            const eventHandler = jest.fn();
            service.on("test:initialized", eventHandler);
            service.initialize(mockStoreAccess);
            // Verify logger was called
            expect(mockLogger.info).toHaveBeenCalledWith("âœ… TestApiService: Successfully initialized with store actions");
            expect(eventHandler).toHaveBeenCalledWith(expect.objectContaining({
                config: {
                    deterministic: false
                }
            }));
            expect(service.isInitialized).toBe(true);
        });
        it("should initialize with custom config", ()=>{
            const customConfig = {
                deterministic: true
            };
            service.initialize(mockStoreAccess, customConfig);
            // Can't access private property directly, but we can verify it was set
            expect(service.isInitialized).toBe(true);
        });
        it("should fail initialization if required actions are missing", ()=>{
            const invalidStoreAccess = {
                getState: jest.fn(),
                subscribe: jest.fn()
            };
            service.initialize(invalidStoreAccess);
            // Verify logger error was called
            expect(mockLogger.error).toHaveBeenCalledWith("Required store actions not available");
            expect(service.isInitialized).toBe(false);
        });
    });
    describe("makeMove", ()=>{
        beforeEach(()=>{
            service.initialize(mockStoreAccess);
        });
        it("should make move with dash notation", async ()=>{
            const eventHandler = jest.fn();
            service.on("test:move", eventHandler);
            const result = await service.makeMove("e2-e4");
            expect(mockStoreAccess._internalApplyMove).toHaveBeenCalledWith(expect.objectContaining({
                from: "e2",
                to: "e4"
            }));
            expect(result.success).toBe(true);
            expect(result.resultingFen).toBeDefined();
            expect(eventHandler).toHaveBeenCalled();
        });
        it("should make move with SAN notation", async ()=>{
            const result = await service.makeMove("e4");
            expect(mockStoreAccess._internalApplyMove).toHaveBeenCalledWith("e4");
            expect(result.success).toBe(true);
        });
        it("should handle errors gracefully", async ()=>{
            mockStoreAccess._internalApplyMove.mockImplementation(()=>{
                throw new Error("Invalid move");
            });
            const result = await service.makeMove("invalid");
            expect(result.success).toBe(false);
            expect(result.error).toBe("Invalid move");
        });
    });
    describe("getGameState", ()=>{
        beforeEach(()=>{
            service.initialize(mockStoreAccess);
        });
        it("should return current game state", ()=>{
            const state = service.getGameState();
            expect(state).toEqual(expect.objectContaining({
                fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                pgn: "1. e4 e5",
                turn: "w",
                moveCount: 0,
                isGameOver: false,
                isCheck: false,
                isCheckmate: false,
                isDraw: false
            }));
        });
    });
    describe("resetGame", ()=>{
        beforeEach(()=>{
            service.initialize(mockStoreAccess);
        });
        it("should reset game position", async ()=>{
            const eventHandler = jest.fn();
            service.on("test:reset", eventHandler);
            await service.resetGame();
            expect(mockStoreAccess.resetPosition).toHaveBeenCalled();
            expect(eventHandler).toHaveBeenCalledWith({});
        });
    });
    describe("triggerTablebaseAnalysis", ()=>{
        beforeEach(()=>{
            service.initialize(mockStoreAccess);
        });
        it("should trigger tablebase analysis", async ()=>{
            const eventHandler = jest.fn();
            service.on("test:tablebaseAnalysisComplete", eventHandler);
            const result = await service.triggerTablebaseAnalysis(2000);
            expect(mockStoreAccess.getState).toHaveBeenCalled();
            expect(result).toBe(true);
            expect(eventHandler).toHaveBeenCalledWith({
                fen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
            });
        });
        it("should handle timeout", async ()=>{
            // Mock tablebase status as always loading
            mockStoreAccess.getState.mockReturnValue({
                tablebase: {
                    analysisStatus: "loading"
                },
                game: {
                    currentFen: "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"
                }
            });
            const result = await service.triggerTablebaseAnalysis(100);
            expect(result).toBe(false);
            expect(mockLogger.warn).toHaveBeenCalledWith("Tablebase analysis timeout after", {
                timeoutMs: 100
            });
        });
        it("should handle errors", async ()=>{
            mockStoreAccess.getState.mockImplementation(()=>{
                throw new Error("Store error");
            });
            const result = await service.triggerTablebaseAnalysis(1000);
            expect(result).toBe(false);
            expect(mockLogger.error).toHaveBeenCalled();
        });
    });
    describe("cleanup", ()=>{
        it("should clean up all state", ()=>{
            service.initialize(mockStoreAccess);
            const unsubscribe = jest.fn();
            mockStoreAccess.subscribe.mockReturnValue(unsubscribe);
            service.cleanup();
            expect(service.isInitialized).toBe(false);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy90ZXN0L1Rlc3RBcGlTZXJ2aWNlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBUZXN0cyBmb3IgVGVzdEFwaVNlcnZpY2UgLSBDbGVhbiBTdG9yZS1CYXNlZCBBcmNoaXRlY3R1cmVcbiAqIEBkZXNjcmlwdGlvbiBUZXN0IGNvdmVyYWdlIGZvciBFMkUgdGVzdCBBUEkgc2VydmljZSB3aXRoIHN0b3JlIGludGVyYWN0aW9ucyBvbmx5XG4gKi9cblxuLy8gTW9jayB0aGUgbG9nZ2luZyBtb2R1bGUgQkVGT1JFIGltcG9ydHNcbmplc3QubW9jayhcIi4uLy4uLy4uLy4uL3NoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nXCIsICgpID0+ICh7XG4gIGdldExvZ2dlcjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgc2V0Q29udGV4dDogamVzdC5mbigpLm1vY2tSZXR1cm5UaGlzKCksXG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGRlYnVnOiBqZXN0LmZuKCksXG4gIH0pLFxufSkpO1xuXG4vLyBNb2NrIGNoZXNzLmpzXG5qZXN0Lm1vY2soXCJjaGVzcy5qc1wiLCAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgQ2hlc3M6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oZnVuY3Rpb24gKGZlbj86IHN0cmluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmVuOiBqZXN0LmZuKFxuICAgICAgICAgICgpID0+XG4gICAgICAgICAgICBmZW4gfHwgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiLFxuICAgICAgICApLFxuICAgICAgICB0dXJuOiBqZXN0LmZuKCgpID0+IFwid1wiKSxcbiAgICAgICAgcGduOiBqZXN0LmZuKCgpID0+IFwiMS4gZTQgZTVcIiksXG4gICAgICAgIGlzR2FtZU92ZXI6IGplc3QuZm4oKCkgPT4gZmFsc2UpLFxuICAgICAgICBpc0NoZWNrOiBqZXN0LmZuKCgpID0+IGZhbHNlKSxcbiAgICAgICAgaXNDaGVja21hdGU6IGplc3QuZm4oKCkgPT4gZmFsc2UpLFxuICAgICAgICBpc0RyYXc6IGplc3QuZm4oKCkgPT4gZmFsc2UpLFxuICAgICAgICBpc1N0YWxlbWF0ZTogamVzdC5mbigoKSA9PiBmYWxzZSksXG4gICAgICAgIGlzVGhyZWVmb2xkUmVwZXRpdGlvbjogamVzdC5mbigoKSA9PiBmYWxzZSksXG4gICAgICAgIGlzSW5zdWZmaWNpZW50TWF0ZXJpYWw6IGplc3QuZm4oKCkgPT4gZmFsc2UpLFxuICAgICAgICBtb3ZlOiBqZXN0LmZuKChfbW92ZSkgPT4gKHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiB9KSksXG4gICAgICB9O1xuICAgIH0pLFxuICB9O1xufSk7XG5cbmltcG9ydCB7XG4gIFRlc3RBcGlTZXJ2aWNlLFxuICBUZXN0VGFibGViYXNlQ29uZmlnLFxuICBnZXRUZXN0QXBpLFxufSBmcm9tIFwiLi4vLi4vLi4vLi4vc2hhcmVkL3NlcnZpY2VzL3Rlc3QvVGVzdEFwaVNlcnZpY2VcIjtcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCIuLi8uLi8uLi8uLi9zaGFyZWQvc2VydmljZXMvbG9nZ2luZ1wiO1xuXG5kZXNjcmliZShcIlRlc3RBcGlTZXJ2aWNlIC0gU3RvcmUtQmFzZWQgQXJjaGl0ZWN0dXJlXCIsICgpID0+IHtcbiAgbGV0IHNlcnZpY2U6IFRlc3RBcGlTZXJ2aWNlO1xuICBsZXQgbW9ja1N0b3JlQWNjZXNzOiBhbnk7XG4gIGxldCBjb25zb2xlTG9nU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICBsZXQgY29uc29sZUVycm9yU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICBsZXQgY29uc29sZVdhcm5TcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gIGxldCBtb2NrTG9nZ2VyOiBhbnk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gR2V0IHRoZSBtb2NrZWQgbG9nZ2VyIGluc3RhbmNlIGFuZCBjbGVhciBhbGwgbW9ja3NcbiAgICBtb2NrTG9nZ2VyID0gZ2V0TG9nZ2VyKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG5cbiAgICAvLyBSZXNldCBzaW5nbGV0b25cbiAgICBUZXN0QXBpU2VydmljZVtcImluc3RhbmNlXCJdID0gbnVsbDtcbiAgICBzZXJ2aWNlID0gVGVzdEFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcblxuICAgIC8vIE1vY2sgc3RvcmUgYWNjZXNzIC0gdGhlIE9OTFkgZGVwZW5kZW5jeVxuICAgIG1vY2tTdG9yZUFjY2VzcyA9IHtcbiAgICAgIGdldFN0YXRlOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICAgIGdhbWU6IHtcbiAgICAgICAgICBjdXJyZW50RmVuOlxuICAgICAgICAgICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiLFxuICAgICAgICB9LFxuICAgICAgICB0YWJsZWJhc2U6IHtcbiAgICAgICAgICBhbmFseXNpc1N0YXR1czogXCJpZGxlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYWluaW5nOiB7XG4gICAgICAgICAgY3VycmVudEZlbjpcbiAgICAgICAgICAgIFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIixcbiAgICAgICAgICBtb3ZlSGlzdG9yeTogW10sXG4gICAgICAgICAgY3VycmVudEV2YWx1YXRpb246IHsgZXZhbHVhdGlvbjogMC4yIH0sXG4gICAgICAgICAgYW5hbHlzaXNTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgICB9LFxuICAgICAgICBmZW46IFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIixcbiAgICAgICAgaGlzdG9yeTogW10sXG4gICAgICAgIGV2YWx1YXRpb246IHsgdGFibGViYXNlRXZhbHVhdGlvbjogeyB2YWx1ZTogMC4xIH0gfSxcbiAgICAgICAgYW5hbHlzaXNTdGF0dXM6IFwiaWRsZVwiLFxuICAgICAgfSkpLFxuICAgICAgc3Vic2NyaWJlOiBqZXN0LmZuKCgpID0+IGplc3QuZm4oKSksXG4gICAgICBtYWtlTW92ZTogamVzdC5mbigpLFxuICAgICAgX2ludGVybmFsQXBwbHlNb3ZlOiBqZXN0LmZuKCksXG4gICAgICByZXNldFBvc2l0aW9uOiBqZXN0LmZuKCksXG4gICAgICBzZXRQb3NpdGlvbjogamVzdC5mbigpLFxuICAgICAgZ29Ub01vdmU6IGplc3QuZm4oKSxcbiAgICAgIHNldEFuYWx5c2lzU3RhdHVzOiBqZXN0LmZuKCksXG4gICAgfTtcblxuICAgIC8vIE1vY2sgY29uc29sZSBtZXRob2RzXG4gICAgY29uc29sZUxvZ1NweSA9IGplc3Quc3B5T24oY29uc29sZSwgXCJsb2dcIikubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gICAgY29uc29sZUVycm9yU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCBcImVycm9yXCIpLm1vY2tJbXBsZW1lbnRhdGlvbigpO1xuICAgIGNvbnNvbGVXYXJuU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCBcIndhcm5cIikubW9ja0ltcGxlbWVudGF0aW9uKCk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgc2VydmljZS5jbGVhbnVwKCk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgY29uc29sZUxvZ1NweS5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVFcnJvclNweS5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVXYXJuU3B5Lm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU2luZ2xldG9uIFBhdHRlcm5cIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHJldHVybiB0aGUgc2FtZSBpbnN0YW5jZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZTEgPSBUZXN0QXBpU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgY29uc3QgaW5zdGFuY2UyID0gVGVzdEFwaVNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICAgIGV4cGVjdChpbnN0YW5jZTEpLnRvQmUoaW5zdGFuY2UyKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHByb3ZpZGUgY29udmVuaWVuY2UgZ2V0dGVyXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZ2V0VGVzdEFwaSgpO1xuICAgICAgZXhwZWN0KGluc3RhbmNlKS50b0JlKFRlc3RBcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkluaXRpYWxpemF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBpbml0aWFsaXplIHdpdGggc3RvcmUgYWNjZXNzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIHNlcnZpY2Uub24oXCJ0ZXN0OmluaXRpYWxpemVkXCIsIGV2ZW50SGFuZGxlcik7XG5cbiAgICAgIHNlcnZpY2UuaW5pdGlhbGl6ZShtb2NrU3RvcmVBY2Nlc3MpO1xuXG4gICAgICAvLyBWZXJpZnkgbG9nZ2VyIHdhcyBjYWxsZWRcbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIuKchSBUZXN0QXBpU2VydmljZTogU3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkIHdpdGggc3RvcmUgYWN0aW9uc1wiLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChldmVudEhhbmRsZXIpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgY29uZmlnOiB7IGRldGVybWluaXN0aWM6IGZhbHNlIH0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmlzSW5pdGlhbGl6ZWQpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBpbml0aWFsaXplIHdpdGggY3VzdG9tIGNvbmZpZ1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjdXN0b21Db25maWc6IFRlc3RUYWJsZWJhc2VDb25maWcgPSB7XG4gICAgICAgIGRldGVybWluaXN0aWM6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBzZXJ2aWNlLmluaXRpYWxpemUobW9ja1N0b3JlQWNjZXNzLCBjdXN0b21Db25maWcpO1xuXG4gICAgICAvLyBDYW4ndCBhY2Nlc3MgcHJpdmF0ZSBwcm9wZXJ0eSBkaXJlY3RseSwgYnV0IHdlIGNhbiB2ZXJpZnkgaXQgd2FzIHNldFxuICAgICAgZXhwZWN0KHNlcnZpY2UuaXNJbml0aWFsaXplZCkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGZhaWwgaW5pdGlhbGl6YXRpb24gaWYgcmVxdWlyZWQgYWN0aW9ucyBhcmUgbWlzc2luZ1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbnZhbGlkU3RvcmVBY2Nlc3MgPSB7XG4gICAgICAgIGdldFN0YXRlOiBqZXN0LmZuKCksXG4gICAgICAgIHN1YnNjcmliZTogamVzdC5mbigpLFxuICAgICAgICAvLyBNaXNzaW5nIHJlcXVpcmVkIGFjdGlvbnM6IG1ha2VNb3ZlLCByZXNldFBvc2l0aW9uXG4gICAgICB9O1xuXG4gICAgICBzZXJ2aWNlLmluaXRpYWxpemUoaW52YWxpZFN0b3JlQWNjZXNzIGFzIGFueSk7XG5cbiAgICAgIC8vIFZlcmlmeSBsb2dnZXIgZXJyb3Igd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlJlcXVpcmVkIHN0b3JlIGFjdGlvbnMgbm90IGF2YWlsYWJsZVwiLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzZXJ2aWNlLmlzSW5pdGlhbGl6ZWQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIm1ha2VNb3ZlXCIsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHNlcnZpY2UuaW5pdGlhbGl6ZShtb2NrU3RvcmVBY2Nlc3MpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbWFrZSBtb3ZlIHdpdGggZGFzaCBub3RhdGlvblwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudEhhbmRsZXIgPSBqZXN0LmZuKCk7XG4gICAgICBzZXJ2aWNlLm9uKFwidGVzdDptb3ZlXCIsIGV2ZW50SGFuZGxlcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UubWFrZU1vdmUoXCJlMi1lNFwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tTdG9yZUFjY2Vzcy5faW50ZXJuYWxBcHBseU1vdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZnJvbTogXCJlMlwiLFxuICAgICAgICAgIHRvOiBcImU0XCIsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucmVzdWx0aW5nRmVuKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbWFrZSBtb3ZlIHdpdGggU0FOIG5vdGF0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UubWFrZU1vdmUoXCJlNFwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tTdG9yZUFjY2Vzcy5faW50ZXJuYWxBcHBseU1vdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFwiZTRcIik7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgZXJyb3JzIGdyYWNlZnVsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N0b3JlQWNjZXNzLl9pbnRlcm5hbEFwcGx5TW92ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG1vdmVcIik7XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS5tYWtlTW92ZShcImludmFsaWRcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yKS50b0JlKFwiSW52YWxpZCBtb3ZlXCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcImdldEdhbWVTdGF0ZVwiLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBzZXJ2aWNlLmluaXRpYWxpemUobW9ja1N0b3JlQWNjZXNzKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJldHVybiBjdXJyZW50IGdhbWUgc3RhdGVcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGUgPSBzZXJ2aWNlLmdldEdhbWVTdGF0ZSgpO1xuXG4gICAgICBleHBlY3Qoc3RhdGUpLnRvRXF1YWwoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBmZW46IFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIixcbiAgICAgICAgICBwZ246IFwiMS4gZTQgZTVcIixcbiAgICAgICAgICB0dXJuOiBcIndcIixcbiAgICAgICAgICBtb3ZlQ291bnQ6IDAsXG4gICAgICAgICAgaXNHYW1lT3ZlcjogZmFsc2UsXG4gICAgICAgICAgaXNDaGVjazogZmFsc2UsXG4gICAgICAgICAgaXNDaGVja21hdGU6IGZhbHNlLFxuICAgICAgICAgIGlzRHJhdzogZmFsc2UsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJyZXNldEdhbWVcIiwgKCkgPT4ge1xuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgc2VydmljZS5pbml0aWFsaXplKG1vY2tTdG9yZUFjY2Vzcyk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXNldCBnYW1lIHBvc2l0aW9uXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIHNlcnZpY2Uub24oXCJ0ZXN0OnJlc2V0XCIsIGV2ZW50SGFuZGxlcik7XG5cbiAgICAgIGF3YWl0IHNlcnZpY2UucmVzZXRHYW1lKCk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3RvcmVBY2Nlc3MucmVzZXRQb3NpdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGV2ZW50SGFuZGxlcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoe30pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcInRyaWdnZXJUYWJsZWJhc2VBbmFseXNpc1wiLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBzZXJ2aWNlLmluaXRpYWxpemUobW9ja1N0b3JlQWNjZXNzKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHRyaWdnZXIgdGFibGViYXNlIGFuYWx5c2lzXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IGplc3QuZm4oKTtcbiAgICAgIHNlcnZpY2Uub24oXCJ0ZXN0OnRhYmxlYmFzZUFuYWx5c2lzQ29tcGxldGVcIiwgZXZlbnRIYW5kbGVyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VydmljZS50cmlnZ2VyVGFibGViYXNlQW5hbHlzaXMoMjAwMCk7XG5cbiAgICAgIGV4cGVjdChtb2NrU3RvcmVBY2Nlc3MuZ2V0U3RhdGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoZXZlbnRIYW5kbGVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGZlbjogXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgdGltZW91dFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBNb2NrIHRhYmxlYmFzZSBzdGF0dXMgYXMgYWx3YXlzIGxvYWRpbmdcbiAgICAgIG1vY2tTdG9yZUFjY2Vzcy5nZXRTdGF0ZS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICB0YWJsZWJhc2U6IHsgYW5hbHlzaXNTdGF0dXM6IFwibG9hZGluZ1wiIH0sXG4gICAgICAgIGdhbWU6IHtcbiAgICAgICAgICBjdXJyZW50RmVuOlxuICAgICAgICAgICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudHJpZ2dlclRhYmxlYmFzZUFuYWx5c2lzKDEwMCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG1vY2tMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiVGFibGViYXNlIGFuYWx5c2lzIHRpbWVvdXQgYWZ0ZXJcIixcbiAgICAgICAgeyB0aW1lb3V0TXM6IDEwMCB9LFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBlcnJvcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja1N0b3JlQWNjZXNzLmdldFN0YXRlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0b3JlIGVycm9yXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlcnZpY2UudHJpZ2dlclRhYmxlYmFzZUFuYWx5c2lzKDEwMDApO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChtb2NrTG9nZ2VyLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiY2xlYW51cFwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgY2xlYW4gdXAgYWxsIHN0YXRlXCIsICgpID0+IHtcbiAgICAgIHNlcnZpY2UuaW5pdGlhbGl6ZShtb2NrU3RvcmVBY2Nlc3MpO1xuICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBqZXN0LmZuKCk7XG4gICAgICBtb2NrU3RvcmVBY2Nlc3Muc3Vic2NyaWJlLm1vY2tSZXR1cm5WYWx1ZSh1bnN1YnNjcmliZSk7XG5cbiAgICAgIHNlcnZpY2UuY2xlYW51cCgpO1xuXG4gICAgICBleHBlY3Qoc2VydmljZS5pc0luaXRpYWxpemVkKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldExvZ2dlciIsImZuIiwibW9ja1JldHVyblZhbHVlIiwic2V0Q29udGV4dCIsIm1vY2tSZXR1cm5UaGlzIiwiaW5mbyIsImVycm9yIiwid2FybiIsImRlYnVnIiwiQ2hlc3MiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJmZW4iLCJ0dXJuIiwicGduIiwiaXNHYW1lT3ZlciIsImlzQ2hlY2siLCJpc0NoZWNrbWF0ZSIsImlzRHJhdyIsImlzU3RhbGVtYXRlIiwiaXNUaHJlZWZvbGRSZXBldGl0aW9uIiwiaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCIsIm1vdmUiLCJfbW92ZSIsImZyb20iLCJ0byIsInNhbiIsImRlc2NyaWJlIiwic2VydmljZSIsIm1vY2tTdG9yZUFjY2VzcyIsImNvbnNvbGVMb2dTcHkiLCJjb25zb2xlRXJyb3JTcHkiLCJjb25zb2xlV2FyblNweSIsIm1vY2tMb2dnZXIiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIlRlc3RBcGlTZXJ2aWNlIiwiZ2V0SW5zdGFuY2UiLCJnZXRTdGF0ZSIsImdhbWUiLCJjdXJyZW50RmVuIiwidGFibGViYXNlIiwiYW5hbHlzaXNTdGF0dXMiLCJ0cmFpbmluZyIsIm1vdmVIaXN0b3J5IiwiY3VycmVudEV2YWx1YXRpb24iLCJldmFsdWF0aW9uIiwiaGlzdG9yeSIsInRhYmxlYmFzZUV2YWx1YXRpb24iLCJ2YWx1ZSIsInN1YnNjcmliZSIsIm1ha2VNb3ZlIiwiX2ludGVybmFsQXBwbHlNb3ZlIiwicmVzZXRQb3NpdGlvbiIsInNldFBvc2l0aW9uIiwiZ29Ub01vdmUiLCJzZXRBbmFseXNpc1N0YXR1cyIsInNweU9uIiwiY29uc29sZSIsImFmdGVyRWFjaCIsImNsZWFudXAiLCJtb2NrUmVzdG9yZSIsIml0IiwiaW5zdGFuY2UxIiwiaW5zdGFuY2UyIiwiZXhwZWN0IiwidG9CZSIsImluc3RhbmNlIiwiZ2V0VGVzdEFwaSIsImV2ZW50SGFuZGxlciIsIm9uIiwiaW5pdGlhbGl6ZSIsInRvSGF2ZUJlZW5DYWxsZWRXaXRoIiwib2JqZWN0Q29udGFpbmluZyIsImNvbmZpZyIsImRldGVybWluaXN0aWMiLCJpc0luaXRpYWxpemVkIiwiY3VzdG9tQ29uZmlnIiwiaW52YWxpZFN0b3JlQWNjZXNzIiwicmVzdWx0Iiwic3VjY2VzcyIsInJlc3VsdGluZ0ZlbiIsInRvQmVEZWZpbmVkIiwidG9IYXZlQmVlbkNhbGxlZCIsIkVycm9yIiwic3RhdGUiLCJnZXRHYW1lU3RhdGUiLCJ0b0VxdWFsIiwibW92ZUNvdW50IiwicmVzZXRHYW1lIiwidHJpZ2dlclRhYmxlYmFzZUFuYWx5c2lzIiwidGltZW91dE1zIiwidW5zdWJzY3JpYmUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQyxHQUVELHlDQUF5Qzs7QUFDekNBLEtBQUtDLElBQUksQ0FBQyx1Q0FBdUMsSUFBTyxDQUFBO1FBQ3REQyxXQUFXRixLQUFLRyxFQUFFLEdBQUdDLGVBQWUsQ0FBQztZQUNuQ0MsWUFBWUwsS0FBS0csRUFBRSxHQUFHRyxjQUFjO1lBQ3BDQyxNQUFNUCxLQUFLRyxFQUFFO1lBQ2JLLE9BQU9SLEtBQUtHLEVBQUU7WUFDZE0sTUFBTVQsS0FBS0csRUFBRTtZQUNiTyxPQUFPVixLQUFLRyxFQUFFO1FBQ2hCO0lBQ0YsQ0FBQTtBQUVBLGdCQUFnQjtBQUNoQkgsS0FBS0MsSUFBSSxDQUFDLFlBQVk7SUFDcEIsT0FBTztRQUNMVSxPQUFPWCxLQUFLRyxFQUFFLEdBQUdTLGtCQUFrQixDQUFDLFNBQVVDLEdBQVk7WUFDeEQsT0FBTztnQkFDTEEsS0FBS2IsS0FBS0csRUFBRSxDQUNWLElBQ0VVLE9BQU87Z0JBRVhDLE1BQU1kLEtBQUtHLEVBQUUsQ0FBQyxJQUFNO2dCQUNwQlksS0FBS2YsS0FBS0csRUFBRSxDQUFDLElBQU07Z0JBQ25CYSxZQUFZaEIsS0FBS0csRUFBRSxDQUFDLElBQU07Z0JBQzFCYyxTQUFTakIsS0FBS0csRUFBRSxDQUFDLElBQU07Z0JBQ3ZCZSxhQUFhbEIsS0FBS0csRUFBRSxDQUFDLElBQU07Z0JBQzNCZ0IsUUFBUW5CLEtBQUtHLEVBQUUsQ0FBQyxJQUFNO2dCQUN0QmlCLGFBQWFwQixLQUFLRyxFQUFFLENBQUMsSUFBTTtnQkFDM0JrQix1QkFBdUJyQixLQUFLRyxFQUFFLENBQUMsSUFBTTtnQkFDckNtQix3QkFBd0J0QixLQUFLRyxFQUFFLENBQUMsSUFBTTtnQkFDdENvQixNQUFNdkIsS0FBS0csRUFBRSxDQUFDLENBQUNxQixRQUFXLENBQUE7d0JBQUVDLE1BQU07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