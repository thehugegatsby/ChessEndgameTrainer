ae7f8fee082d988c126f918a22640e97
/**
 * Centralized Error Handling Service
 *
 * Provides consistent error handling, logging, and user-friendly messages
 * across the application.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ErrorService () {
        return ErrorService;
    },
    get ErrorType () {
        return ErrorType;
    }
});
const _logging = require("./logging");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ErrorType = /*#__PURE__*/ function(ErrorType) {
    ErrorType["TABLEBASE"] = "TABLEBASE";
    ErrorType["UI_COMPONENT"] = "UI_COMPONENT";
    ErrorType["NETWORK"] = "NETWORK";
    ErrorType["STORAGE"] = "STORAGE";
    ErrorType["VALIDATION"] = "VALIDATION";
    return ErrorType;
}({});
class ErrorService {
    /**
   * Gets the singleton instance of ErrorService.
   *
   * Creates a new instance on first call and returns the same
   * instance on subsequent calls. This ensures consistent error
   * handling and a single error log across the application.
   *
   * @returns {ErrorService} The singleton ErrorService instance
   * @example
   * const errorService = ErrorService.getInstance();
   * const stats = errorService.getErrorStats();
   */ static getInstance() {
        if (!ErrorService.instance) {
            ErrorService.instance = new ErrorService();
        }
        return ErrorService.instance;
    }
    /**
   * Handles errors from tablebase operations.
   *
   * Processes errors that occur when interacting with the Lichess
   * tablebase API. Logs the error with context and returns a
   * user-friendly German message.
   *
   * Side effects:
   * - Logs the error via Logger service with ERROR level
   * - Adds the error to internal error log
   *
   * @static
   * @param {Error} error - The error object from tablebase operations
   * @param {ErrorContext} [context={}] - Additional context for debugging
   * @param {string} [context.component] - Component where error occurred
   * @param {string} [context.action] - Action that triggered the error
   * @param {Record<string, any>} [context.additionalData] - Extra debug data
   * @returns {string} User-friendly German error message
   *
   * @example
   * try {
   *   await tablebaseService.getEvaluation(fen);
   * } catch (error) {
   *   const message = ErrorService.handleTablebaseError(error, {
   *     component: "TrainingBoard",
   *     action: "evaluate-position",
   *     additionalData: { fen, pieceCount: 7 }
   *   });
   *   showToast(message, "error");
   * }
   *
   * @remarks
   * Common tablebase errors include:
   * - Network timeout: "Request timeout after retries"
   * - Invalid FEN: "Invalid FEN: <details>"
   * - Rate limiting: "API error: 429"
   * - Too many pieces: Position has >7 pieces
   */ static handleTablebaseError(error, context = {}) {
        const service = ErrorService.getInstance();
        const enhancedContext = {
            ...context,
            type: "TABLEBASE",
            timestamp: new Date()
        };
        service.logger.error("Tablebase Error", error, enhancedContext);
        service.logError(error, enhancedContext);
        return service.getUserFriendlyMessage("TABLEBASE", error);
    }
    /**
   * Handles errors from UI components.
   *
   * Processes errors that occur in React components, including render
   * errors, state update issues, and prop validation failures. Logs the
   * error with component context and returns a user-friendly German message.
   *
   * Side effects:
   * - Logs the error via Logger service with ERROR level
   * - Adds the error to internal error log with component name
   *
   * @static
   * @param {Error} error - The error object from React component
   * @param {string} componentName - Name of the component that errored
   * @param {ErrorContext} [context={}] - Additional debugging context
   * @param {string} [context.action] - User action that triggered the error
   * @param {Record<string, any>} [context.additionalData] - Extra debug data (e.g., ErrorInfo from React)
   * @returns {string} User-friendly German error message
   *
   * @example
   * // In React Error Boundary
   * componentDidCatch(error: Error, errorInfo: ErrorInfo) {
   *   const message = ErrorService.handleUIError(error, "ChessBoard", {
   *     additionalData: errorInfo
   *   });
   *   this.setState({ errorMessage: message });
   * }
   *
   * @example
   * // In event handler
   * try {
   *   handleSquareClick(square);
   * } catch (error) {
   *   const message = ErrorService.handleUIError(error, "TrainingBoard", {
   *     action: "square-click",
   *     additionalData: { square, position: currentPosition }
   *   });
   *   showToast(message, "error");
   * }
   *
   * @remarks
   * Common UI errors include:
   * - State update on unmounted component
   * - Invalid props passed to component
   * - Chess.js move validation failures
   * - Render errors from missing data
   * - Event handler exceptions
   */ static handleUIError(error, componentName, context = {}) {
        const service = ErrorService.getInstance();
        const enhancedContext = {
            ...context,
            component: componentName,
            type: "UI_COMPONENT",
            timestamp: new Date()
        };
        service.logger.error(`UI Error in ${componentName}`, error, enhancedContext);
        service.logError(error, enhancedContext);
        return service.getUserFriendlyMessage("UI_COMPONENT", error);
    }
    /**
   * Handles network and API communication errors.
   *
   * Processes errors that occur during network requests, including
   * timeouts, connection failures, and API response errors. Logs the
   * error with request context and returns a user-friendly German message.
   *
   * Side effects:
   * - Logs the error via Logger service with ERROR level
   * - Adds the error to internal error log with network context
   *
   * @static
   * @param {Error} error - Network or API error object
   * @param {ErrorContext} [context={}] - Additional context for debugging
   * @param {string} [context.component] - Component making the request
   * @param {string} [context.action] - Action that triggered the request
   * @param {Record<string, any>} [context.additionalData] - Extra debug data (URL, method, headers)
   * @returns {string} User-friendly German error message
   *
   * @example
   * // In async fetch call
   * try {
   *   const response = await fetch(url);
   *   return await response.json();
   * } catch (error) {
   *   const message = ErrorService.handleNetworkError(error, {
   *     action: "fetch-tablebase",
   *     additionalData: { url, method: "GET" }
   *   });
   *   return { error: message };
   * }
   *
   * @example
   * // With AbortController for timeout
   * const controller = new AbortController();
   * const timeout = setTimeout(() => controller.abort(), 5000);
   *
   * try {
   *   const response = await fetch(url, { signal: controller.signal });
   *   return await response.json();
   * } catch (error) {
   *   const message = ErrorService.handleNetworkError(error, {
   *     component: "TablebaseService",
   *     action: "evaluate-position",
   *     additionalData: {
   *       url,
   *       timeout: 5000,
   *       aborted: error.name === 'AbortError'
   *     }
   *   });
   *   throw new Error(message);
   * } finally {
   *   clearTimeout(timeout);
   * }
   *
   * @remarks
   * Common network errors include:
   * - AbortError: Request timeout or manual abort
   * - TypeError: Network failure (no connection)
   * - HTTP 429: Rate limit exceeded
   * - HTTP 503: Service temporarily unavailable
   * - HTTP 500: Server error
   * - CORS errors: Cross-origin request blocked
   */ static handleNetworkError(error, context = {}) {
        const service = ErrorService.getInstance();
        const enhancedContext = {
            ...context,
            type: "NETWORK",
            timestamp: new Date()
        };
        service.logger.error("Network Error", error, enhancedContext);
        service.logError(error, enhancedContext);
        return service.getUserFriendlyMessage("NETWORK", error);
    }
    /**
   * Logs an error to the internal error log.
   *
   * Maintains a rolling log of the last 50 errors for debugging
   * and monitoring purposes. Older errors are automatically removed
   * when the limit is exceeded.
   *
   * @private
   * @param {Error} error - The error object to log
   * @param {ErrorContext} context - Additional context information
   */ logError(error, context) {
        this.errorLog.push({
            error,
            context,
            timestamp: new Date()
        });
        // Keep only last 50 errors in memory
        if (this.errorLog.length > 50) {
            this.errorLog.shift();
        }
    }
    /**
   * Gets a user-friendly German error message based on error type.
   *
   * Returns localized messages suitable for display to end users.
   * Technical error details are logged separately and not exposed
   * to users for security and usability reasons.
   *
   * @private
   * @param {ErrorType} type - The category of error
   * @param {Error} _error - The error object (unused, for future extension)
   * @returns {string} A German error message suitable for user display
   */ getUserFriendlyMessage(type, _error) {
        switch(type){
            case "TABLEBASE":
                return "Die Tablebase-Datenbank konnte nicht geladen werden. Bitte aktualisieren Sie die Seite.";
            case "UI_COMPONENT":
                return "Ein Problem mit der Benutzeroberfläche ist aufgetreten. Bitte versuchen Sie es erneut.";
            case "NETWORK":
                return "Netzwerkfehler. Bitte prüfen Sie Ihre Internetverbindung.";
            case "STORAGE":
                return "Fehler beim Speichern der Daten. Bitte versuchen Sie es erneut.";
            case "VALIDATION":
                return "Ungültige Eingabe. Bitte überprüfen Sie Ihre Eingaben.";
            default:
                return "Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es erneut.";
        }
    }
    /**
   * Gets statistics about logged errors.
   *
   * Provides a summary of all errors in the internal log, grouped
   * by type and including recent error details. Useful for debugging
   * and monitoring application health.
   *
   * @returns {Object} Error statistics including:
   *   - totalErrors: Total number of errors in log
   *   - errorsByType: Count of errors grouped by ErrorType
   *   - recentErrors: Array of last 5 errors with details
   * @example
   * import { getLogger } from '@shared/services/logging/Logger';
   * const logger = getLogger();
   * const stats = errorService.getErrorStats();
   * logger.info(`Total errors: ${stats.totalErrors}`);
   * logger.info(`UI errors: ${stats.errorsByType.UI_COMPONENT || 0}`);
   */ getErrorStats() {
        const stats = this.errorLog.reduce((acc, log)=>{
            const type = log.context.type || "UNKNOWN";
            acc[type] = (acc[type] || 0) + 1;
            return acc;
        }, {});
        return {
            totalErrors: this.errorLog.length,
            errorsByType: stats,
            recentErrors: this.errorLog.slice(-5).map((log)=>({
                    type: log.context.type,
                    component: log.context.component,
                    timestamp: log.timestamp,
                    message: log.error.message
                }))
        };
    }
    /**
   * Clears all errors from the internal log.
   *
   * Resets the error tracking to a clean state. Primarily used
   * for testing, but can also be used to reset error tracking
   * after exporting or processing error data.
   *
   * @returns {void}
   * @example
   * // Export errors then clear
   * const stats = errorService.getErrorStats();
   * await sendErrorReport(stats);
   * errorService.clearErrorLog();
   */ clearErrorLog() {
        this.errorLog = [];
    }
    constructor(){
        _define_property(this, "errorLog", []);
        _define_property(this, "logger", (0, _logging.getLogger)().setContext("ErrorService"));
    }
}
_define_property(ErrorService, "instance", void 0);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3NlcnZpY2VzL0Vycm9yU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENlbnRyYWxpemVkIEVycm9yIEhhbmRsaW5nIFNlcnZpY2VcbiAqXG4gKiBQcm92aWRlcyBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nLCBsb2dnaW5nLCBhbmQgdXNlci1mcmllbmRseSBtZXNzYWdlc1xuICogYWNyb3NzIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuXG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiLi9sb2dnaW5nXCI7XG5cbi8qKlxuICogRXJyb3IgdHlwZXMgZm9yIGNhdGVnb3JpemluZyBkaWZmZXJlbnQgZXJyb3Igc2NlbmFyaW9zXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQHJlbWFya3MgVXNlZCB0byBwcm92aWRlIGNvbnRleHQtc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXMgaW4gR2VybWFuXG4gKi9cbmV4cG9ydCBlbnVtIEVycm9yVHlwZSB7XG4gIFRBQkxFQkFTRSA9IFwiVEFCTEVCQVNFXCIsXG4gIFVJX0NPTVBPTkVOVCA9IFwiVUlfQ09NUE9ORU5UXCIsXG4gIE5FVFdPUksgPSBcIk5FVFdPUktcIixcbiAgU1RPUkFHRSA9IFwiU1RPUkFHRVwiLFxuICBWQUxJREFUSU9OID0gXCJWQUxJREFUSU9OXCIsXG59XG5cbi8qKlxuICogQ29udGV4dCBpbmZvcm1hdGlvbiBmb3IgZXJyb3IgdHJhY2tpbmcgYW5kIGRlYnVnZ2luZ1xuICogQGludGVyZmFjZSBFcnJvckNvbnRleHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbY29tcG9uZW50XSAtIENvbXBvbmVudCB3aGVyZSBlcnJvciBvY2N1cnJlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthY3Rpb25dIC0gVXNlciBhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhlIGVycm9yXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VzZXJdIC0gVXNlciBpZGVudGlmaWVyIGZvciBlcnJvciB0cmFja2luZ1xuICogQHByb3BlcnR5IHtEYXRlfSBbdGltZXN0YW1wXSAtIFdoZW4gdGhlIGVycm9yIG9jY3VycmVkXG4gKiBAcHJvcGVydHkge0Vycm9yVHlwZX0gW3R5cGVdIC0gQ2F0ZWdvcml6ZWQgZXJyb3IgdHlwZVxuICogQHByb3BlcnR5IHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbYWRkaXRpb25hbERhdGFdIC0gRXh0cmEgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JDb250ZXh0IHtcbiAgY29tcG9uZW50Pzogc3RyaW5nO1xuICBhY3Rpb24/OiBzdHJpbmc7XG4gIHVzZXI/OiBzdHJpbmc7XG4gIHRpbWVzdGFtcD86IERhdGU7XG4gIHR5cGU/OiBFcnJvclR5cGU7XG4gIGFkZGl0aW9uYWxEYXRhPzogUmVjb3JkPHN0cmluZywgYW55Pjtcbn1cblxuLyoqXG4gKiBDZW50cmFsaXplZCBFcnJvciBIYW5kbGluZyBTZXJ2aWNlXG4gKlxuICogUHJvdmlkZXMgYSBzaW5nbGUgcG9pbnQgb2YgZXJyb3IgbWFuYWdlbWVudCBhY3Jvc3MgdGhlIGFwcGxpY2F0aW9uLlxuICogSGFuZGxlcyBkaWZmZXJlbnQgZXJyb3IgdHlwZXMsIGxvZ3MgdGhlbSBpbnRlcm5hbGx5LCBhbmQgcmV0dXJuc1xuICogdXNlci1mcmllbmRseSBHZXJtYW4gZXJyb3IgbWVzc2FnZXMuXG4gKlxuICogQHNpbmdsZXRvblxuICogQGV4YW1wbGVcbiAqIC8vIEdldCB0aGUgc2luZ2xldG9uIGluc3RhbmNlXG4gKiBjb25zdCBlcnJvclNlcnZpY2UgPSBFcnJvclNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSGFuZGxlIGEgdGFibGViYXNlIGVycm9yXG4gKiB0cnkge1xuICogICBhd2FpdCB0YWJsZWJhc2VTZXJ2aWNlLmdldEV2YWx1YXRpb24oZmVuKTtcbiAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gKiAgIGNvbnN0IHVzZXJNZXNzYWdlID0gRXJyb3JTZXJ2aWNlLmhhbmRsZVRhYmxlYmFzZUVycm9yKGVycm9yLCB7XG4gKiAgICAgY29tcG9uZW50OiAnVHJhaW5pbmdCb2FyZCcsXG4gKiAgICAgYWN0aW9uOiAnZXZhbHVhdGUtcG9zaXRpb24nXG4gKiAgIH0pO1xuICogICBzaG93VG9hc3QodXNlck1lc3NhZ2UsICdlcnJvcicpO1xuICogfVxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IEVycm9yU2VydmljZTtcbiAgcHJpdmF0ZSBlcnJvckxvZzogQXJyYXk8e1xuICAgIGVycm9yOiBFcnJvcjtcbiAgICBjb250ZXh0OiBFcnJvckNvbnRleHQ7XG4gICAgdGltZXN0YW1wOiBEYXRlO1xuICB9PiA9IFtdO1xuICBwcml2YXRlIGxvZ2dlciA9IGdldExvZ2dlcigpLnNldENvbnRleHQoXCJFcnJvclNlcnZpY2VcIik7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBFcnJvclNlcnZpY2UuXG4gICAqXG4gICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb24gZmlyc3QgY2FsbCBhbmQgcmV0dXJucyB0aGUgc2FtZVxuICAgKiBpbnN0YW5jZSBvbiBzdWJzZXF1ZW50IGNhbGxzLiBUaGlzIGVuc3VyZXMgY29uc2lzdGVudCBlcnJvclxuICAgKiBoYW5kbGluZyBhbmQgYSBzaW5nbGUgZXJyb3IgbG9nIGFjcm9zcyB0aGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtFcnJvclNlcnZpY2V9IFRoZSBzaW5nbGV0b24gRXJyb3JTZXJ2aWNlIGluc3RhbmNlXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IGVycm9yU2VydmljZSA9IEVycm9yU2VydmljZS5nZXRJbnN0YW5jZSgpO1xuICAgKiBjb25zdCBzdGF0cyA9IGVycm9yU2VydmljZS5nZXRFcnJvclN0YXRzKCk7XG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogRXJyb3JTZXJ2aWNlIHtcbiAgICBpZiAoIUVycm9yU2VydmljZS5pbnN0YW5jZSkge1xuICAgICAgRXJyb3JTZXJ2aWNlLmluc3RhbmNlID0gbmV3IEVycm9yU2VydmljZSgpO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JTZXJ2aWNlLmluc3RhbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXJyb3JzIGZyb20gdGFibGViYXNlIG9wZXJhdGlvbnMuXG4gICAqXG4gICAqIFByb2Nlc3NlcyBlcnJvcnMgdGhhdCBvY2N1ciB3aGVuIGludGVyYWN0aW5nIHdpdGggdGhlIExpY2hlc3NcbiAgICogdGFibGViYXNlIEFQSS4gTG9ncyB0aGUgZXJyb3Igd2l0aCBjb250ZXh0IGFuZCByZXR1cm5zIGFcbiAgICogdXNlci1mcmllbmRseSBHZXJtYW4gbWVzc2FnZS5cbiAgICpcbiAgICogU2lkZSBlZmZlY3RzOlxuICAgKiAtIExvZ3MgdGhlIGVycm9yIHZpYSBMb2dnZXIgc2VydmljZSB3aXRoIEVSUk9SIGxldmVsXG4gICAqIC0gQWRkcyB0aGUgZXJyb3IgdG8gaW50ZXJuYWwgZXJyb3IgbG9nXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IGZyb20gdGFibGViYXNlIG9wZXJhdGlvbnNcbiAgICogQHBhcmFtIHtFcnJvckNvbnRleHR9IFtjb250ZXh0PXt9XSAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5jb21wb25lbnRdIC0gQ29tcG9uZW50IHdoZXJlIGVycm9yIG9jY3VycmVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29udGV4dC5hY3Rpb25dIC0gQWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtjb250ZXh0LmFkZGl0aW9uYWxEYXRhXSAtIEV4dHJhIGRlYnVnIGRhdGFcbiAgICogQHJldHVybnMge3N0cmluZ30gVXNlci1mcmllbmRseSBHZXJtYW4gZXJyb3IgbWVzc2FnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiB0cnkge1xuICAgKiAgIGF3YWl0IHRhYmxlYmFzZVNlcnZpY2UuZ2V0RXZhbHVhdGlvbihmZW4pO1xuICAgKiB9IGNhdGNoIChlcnJvcikge1xuICAgKiAgIGNvbnN0IG1lc3NhZ2UgPSBFcnJvclNlcnZpY2UuaGFuZGxlVGFibGViYXNlRXJyb3IoZXJyb3IsIHtcbiAgICogICAgIGNvbXBvbmVudDogXCJUcmFpbmluZ0JvYXJkXCIsXG4gICAqICAgICBhY3Rpb246IFwiZXZhbHVhdGUtcG9zaXRpb25cIixcbiAgICogICAgIGFkZGl0aW9uYWxEYXRhOiB7IGZlbiwgcGllY2VDb3VudDogNyB9XG4gICAqICAgfSk7XG4gICAqICAgc2hvd1RvYXN0KG1lc3NhZ2UsIFwiZXJyb3JcIik7XG4gICAqIH1cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ29tbW9uIHRhYmxlYmFzZSBlcnJvcnMgaW5jbHVkZTpcbiAgICogLSBOZXR3b3JrIHRpbWVvdXQ6IFwiUmVxdWVzdCB0aW1lb3V0IGFmdGVyIHJldHJpZXNcIlxuICAgKiAtIEludmFsaWQgRkVOOiBcIkludmFsaWQgRkVOOiA8ZGV0YWlscz5cIlxuICAgKiAtIFJhdGUgbGltaXRpbmc6IFwiQVBJIGVycm9yOiA0MjlcIlxuICAgKiAtIFRvbyBtYW55IHBpZWNlczogUG9zaXRpb24gaGFzID43IHBpZWNlc1xuICAgKi9cbiAgc3RhdGljIGhhbmRsZVRhYmxlYmFzZUVycm9yKGVycm9yOiBFcnJvciwgY29udGV4dDogRXJyb3JDb250ZXh0ID0ge30pIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gRXJyb3JTZXJ2aWNlLmdldEluc3RhbmNlKCk7XG4gICAgY29uc3QgZW5oYW5jZWRDb250ZXh0ID0ge1xuICAgICAgLi4uY29udGV4dCxcbiAgICAgIHR5cGU6IEVycm9yVHlwZS5UQUJMRUJBU0UsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIHNlcnZpY2UubG9nZ2VyLmVycm9yKFwiVGFibGViYXNlIEVycm9yXCIsIGVycm9yLCBlbmhhbmNlZENvbnRleHQpO1xuXG4gICAgc2VydmljZS5sb2dFcnJvcihlcnJvciwgZW5oYW5jZWRDb250ZXh0KTtcbiAgICByZXR1cm4gc2VydmljZS5nZXRVc2VyRnJpZW5kbHlNZXNzYWdlKEVycm9yVHlwZS5UQUJMRUJBU0UsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGVycm9ycyBmcm9tIFVJIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIFByb2Nlc3NlcyBlcnJvcnMgdGhhdCBvY2N1ciBpbiBSZWFjdCBjb21wb25lbnRzLCBpbmNsdWRpbmcgcmVuZGVyXG4gICAqIGVycm9ycywgc3RhdGUgdXBkYXRlIGlzc3VlcywgYW5kIHByb3AgdmFsaWRhdGlvbiBmYWlsdXJlcy4gTG9ncyB0aGVcbiAgICogZXJyb3Igd2l0aCBjb21wb25lbnQgY29udGV4dCBhbmQgcmV0dXJucyBhIHVzZXItZnJpZW5kbHkgR2VybWFuIG1lc3NhZ2UuXG4gICAqXG4gICAqIFNpZGUgZWZmZWN0czpcbiAgICogLSBMb2dzIHRoZSBlcnJvciB2aWEgTG9nZ2VyIHNlcnZpY2Ugd2l0aCBFUlJPUiBsZXZlbFxuICAgKiAtIEFkZHMgdGhlIGVycm9yIHRvIGludGVybmFsIGVycm9yIGxvZyB3aXRoIGNvbXBvbmVudCBuYW1lXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3Igb2JqZWN0IGZyb20gUmVhY3QgY29tcG9uZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIC0gTmFtZSBvZiB0aGUgY29tcG9uZW50IHRoYXQgZXJyb3JlZFxuICAgKiBAcGFyYW0ge0Vycm9yQ29udGV4dH0gW2NvbnRleHQ9e31dIC0gQWRkaXRpb25hbCBkZWJ1Z2dpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuYWN0aW9uXSAtIFVzZXIgYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIGFueT59IFtjb250ZXh0LmFkZGl0aW9uYWxEYXRhXSAtIEV4dHJhIGRlYnVnIGRhdGEgKGUuZy4sIEVycm9ySW5mbyBmcm9tIFJlYWN0KVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBVc2VyLWZyaWVuZGx5IEdlcm1hbiBlcnJvciBtZXNzYWdlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEluIFJlYWN0IEVycm9yIEJvdW5kYXJ5XG4gICAqIGNvbXBvbmVudERpZENhdGNoKGVycm9yOiBFcnJvciwgZXJyb3JJbmZvOiBFcnJvckluZm8pIHtcbiAgICogICBjb25zdCBtZXNzYWdlID0gRXJyb3JTZXJ2aWNlLmhhbmRsZVVJRXJyb3IoZXJyb3IsIFwiQ2hlc3NCb2FyZFwiLCB7XG4gICAqICAgICBhZGRpdGlvbmFsRGF0YTogZXJyb3JJbmZvXG4gICAqICAgfSk7XG4gICAqICAgdGhpcy5zZXRTdGF0ZSh7IGVycm9yTWVzc2FnZTogbWVzc2FnZSB9KTtcbiAgICogfVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBJbiBldmVudCBoYW5kbGVyXG4gICAqIHRyeSB7XG4gICAqICAgaGFuZGxlU3F1YXJlQ2xpY2soc3F1YXJlKTtcbiAgICogfSBjYXRjaCAoZXJyb3IpIHtcbiAgICogICBjb25zdCBtZXNzYWdlID0gRXJyb3JTZXJ2aWNlLmhhbmRsZVVJRXJyb3IoZXJyb3IsIFwiVHJhaW5pbmdCb2FyZFwiLCB7XG4gICAqICAgICBhY3Rpb246IFwic3F1YXJlLWNsaWNrXCIsXG4gICAqICAgICBhZGRpdGlvbmFsRGF0YTogeyBzcXVhcmUsIHBvc2l0aW9uOiBjdXJyZW50UG9zaXRpb24gfVxuICAgKiAgIH0pO1xuICAgKiAgIHNob3dUb2FzdChtZXNzYWdlLCBcImVycm9yXCIpO1xuICAgKiB9XG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENvbW1vbiBVSSBlcnJvcnMgaW5jbHVkZTpcbiAgICogLSBTdGF0ZSB1cGRhdGUgb24gdW5tb3VudGVkIGNvbXBvbmVudFxuICAgKiAtIEludmFsaWQgcHJvcHMgcGFzc2VkIHRvIGNvbXBvbmVudFxuICAgKiAtIENoZXNzLmpzIG1vdmUgdmFsaWRhdGlvbiBmYWlsdXJlc1xuICAgKiAtIFJlbmRlciBlcnJvcnMgZnJvbSBtaXNzaW5nIGRhdGFcbiAgICogLSBFdmVudCBoYW5kbGVyIGV4Y2VwdGlvbnNcbiAgICovXG4gIHN0YXRpYyBoYW5kbGVVSUVycm9yKFxuICAgIGVycm9yOiBFcnJvcixcbiAgICBjb21wb25lbnROYW1lOiBzdHJpbmcsXG4gICAgY29udGV4dDogRXJyb3JDb250ZXh0ID0ge30sXG4gICkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBFcnJvclNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICBjb25zdCBlbmhhbmNlZENvbnRleHQgPSB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgY29tcG9uZW50OiBjb21wb25lbnROYW1lLFxuICAgICAgdHlwZTogRXJyb3JUeXBlLlVJX0NPTVBPTkVOVCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICB9O1xuXG4gICAgc2VydmljZS5sb2dnZXIuZXJyb3IoXG4gICAgICBgVUkgRXJyb3IgaW4gJHtjb21wb25lbnROYW1lfWAsXG4gICAgICBlcnJvcixcbiAgICAgIGVuaGFuY2VkQ29udGV4dCxcbiAgICApO1xuXG4gICAgc2VydmljZS5sb2dFcnJvcihlcnJvciwgZW5oYW5jZWRDb250ZXh0KTtcbiAgICByZXR1cm4gc2VydmljZS5nZXRVc2VyRnJpZW5kbHlNZXNzYWdlKEVycm9yVHlwZS5VSV9DT01QT05FTlQsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIG5ldHdvcmsgYW5kIEFQSSBjb21tdW5pY2F0aW9uIGVycm9ycy5cbiAgICpcbiAgICogUHJvY2Vzc2VzIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBuZXR3b3JrIHJlcXVlc3RzLCBpbmNsdWRpbmdcbiAgICogdGltZW91dHMsIGNvbm5lY3Rpb24gZmFpbHVyZXMsIGFuZCBBUEkgcmVzcG9uc2UgZXJyb3JzLiBMb2dzIHRoZVxuICAgKiBlcnJvciB3aXRoIHJlcXVlc3QgY29udGV4dCBhbmQgcmV0dXJucyBhIHVzZXItZnJpZW5kbHkgR2VybWFuIG1lc3NhZ2UuXG4gICAqXG4gICAqIFNpZGUgZWZmZWN0czpcbiAgICogLSBMb2dzIHRoZSBlcnJvciB2aWEgTG9nZ2VyIHNlcnZpY2Ugd2l0aCBFUlJPUiBsZXZlbFxuICAgKiAtIEFkZHMgdGhlIGVycm9yIHRvIGludGVybmFsIGVycm9yIGxvZyB3aXRoIG5ldHdvcmsgY29udGV4dFxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIC0gTmV0d29yayBvciBBUEkgZXJyb3Igb2JqZWN0XG4gICAqIEBwYXJhbSB7RXJyb3JDb250ZXh0fSBbY29udGV4dD17fV0gLSBBZGRpdGlvbmFsIGNvbnRleHQgZm9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbnRleHQuY29tcG9uZW50XSAtIENvbXBvbmVudCBtYWtpbmcgdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0LmFjdGlvbl0gLSBBY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhlIHJlcXVlc3RcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBbY29udGV4dC5hZGRpdGlvbmFsRGF0YV0gLSBFeHRyYSBkZWJ1ZyBkYXRhIChVUkwsIG1ldGhvZCwgaGVhZGVycylcbiAgICogQHJldHVybnMge3N0cmluZ30gVXNlci1mcmllbmRseSBHZXJtYW4gZXJyb3IgbWVzc2FnZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBJbiBhc3luYyBmZXRjaCBjYWxsXG4gICAqIHRyeSB7XG4gICAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgKiAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAqIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAqICAgY29uc3QgbWVzc2FnZSA9IEVycm9yU2VydmljZS5oYW5kbGVOZXR3b3JrRXJyb3IoZXJyb3IsIHtcbiAgICogICAgIGFjdGlvbjogXCJmZXRjaC10YWJsZWJhc2VcIixcbiAgICogICAgIGFkZGl0aW9uYWxEYXRhOiB7IHVybCwgbWV0aG9kOiBcIkdFVFwiIH1cbiAgICogICB9KTtcbiAgICogICByZXR1cm4geyBlcnJvcjogbWVzc2FnZSB9O1xuICAgKiB9XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFdpdGggQWJvcnRDb250cm9sbGVyIGZvciB0aW1lb3V0XG4gICAqIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAqIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgNTAwMCk7XG4gICAqXG4gICAqIHRyeSB7XG4gICAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9KTtcbiAgICogICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgKiB9IGNhdGNoIChlcnJvcikge1xuICAgKiAgIGNvbnN0IG1lc3NhZ2UgPSBFcnJvclNlcnZpY2UuaGFuZGxlTmV0d29ya0Vycm9yKGVycm9yLCB7XG4gICAqICAgICBjb21wb25lbnQ6IFwiVGFibGViYXNlU2VydmljZVwiLFxuICAgKiAgICAgYWN0aW9uOiBcImV2YWx1YXRlLXBvc2l0aW9uXCIsXG4gICAqICAgICBhZGRpdGlvbmFsRGF0YToge1xuICAgKiAgICAgICB1cmwsXG4gICAqICAgICAgIHRpbWVvdXQ6IDUwMDAsXG4gICAqICAgICAgIGFib3J0ZWQ6IGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJ1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKiAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICogfSBmaW5hbGx5IHtcbiAgICogICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAqIH1cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ29tbW9uIG5ldHdvcmsgZXJyb3JzIGluY2x1ZGU6XG4gICAqIC0gQWJvcnRFcnJvcjogUmVxdWVzdCB0aW1lb3V0IG9yIG1hbnVhbCBhYm9ydFxuICAgKiAtIFR5cGVFcnJvcjogTmV0d29yayBmYWlsdXJlIChubyBjb25uZWN0aW9uKVxuICAgKiAtIEhUVFAgNDI5OiBSYXRlIGxpbWl0IGV4Y2VlZGVkXG4gICAqIC0gSFRUUCA1MDM6IFNlcnZpY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGVcbiAgICogLSBIVFRQIDUwMDogU2VydmVyIGVycm9yXG4gICAqIC0gQ09SUyBlcnJvcnM6IENyb3NzLW9yaWdpbiByZXF1ZXN0IGJsb2NrZWRcbiAgICovXG4gIHN0YXRpYyBoYW5kbGVOZXR3b3JrRXJyb3IoZXJyb3I6IEVycm9yLCBjb250ZXh0OiBFcnJvckNvbnRleHQgPSB7fSkge1xuICAgIGNvbnN0IHNlcnZpY2UgPSBFcnJvclNlcnZpY2UuZ2V0SW5zdGFuY2UoKTtcbiAgICBjb25zdCBlbmhhbmNlZENvbnRleHQgPSB7XG4gICAgICAuLi5jb250ZXh0LFxuICAgICAgdHlwZTogRXJyb3JUeXBlLk5FVFdPUkssXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgfTtcblxuICAgIHNlcnZpY2UubG9nZ2VyLmVycm9yKFwiTmV0d29yayBFcnJvclwiLCBlcnJvciwgZW5oYW5jZWRDb250ZXh0KTtcblxuICAgIHNlcnZpY2UubG9nRXJyb3IoZXJyb3IsIGVuaGFuY2VkQ29udGV4dCk7XG4gICAgcmV0dXJuIHNlcnZpY2UuZ2V0VXNlckZyaWVuZGx5TWVzc2FnZShFcnJvclR5cGUuTkVUV09SSywgZXJyb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYW4gZXJyb3IgdG8gdGhlIGludGVybmFsIGVycm9yIGxvZy5cbiAgICpcbiAgICogTWFpbnRhaW5zIGEgcm9sbGluZyBsb2cgb2YgdGhlIGxhc3QgNTAgZXJyb3JzIGZvciBkZWJ1Z2dpbmdcbiAgICogYW5kIG1vbml0b3JpbmcgcHVycG9zZXMuIE9sZGVyIGVycm9ycyBhcmUgYXV0b21hdGljYWxseSByZW1vdmVkXG4gICAqIHdoZW4gdGhlIGxpbWl0IGlzIGV4Y2VlZGVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBlcnJvciBvYmplY3QgdG8gbG9nXG4gICAqIEBwYXJhbSB7RXJyb3JDb250ZXh0fSBjb250ZXh0IC0gQWRkaXRpb25hbCBjb250ZXh0IGluZm9ybWF0aW9uXG4gICAqL1xuICBwcml2YXRlIGxvZ0Vycm9yKGVycm9yOiBFcnJvciwgY29udGV4dDogRXJyb3JDb250ZXh0KSB7XG4gICAgdGhpcy5lcnJvckxvZy5wdXNoKHtcbiAgICAgIGVycm9yLFxuICAgICAgY29udGV4dCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICB9KTtcblxuICAgIC8vIEtlZXAgb25seSBsYXN0IDUwIGVycm9ycyBpbiBtZW1vcnlcbiAgICBpZiAodGhpcy5lcnJvckxvZy5sZW5ndGggPiA1MCkge1xuICAgICAgdGhpcy5lcnJvckxvZy5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgdXNlci1mcmllbmRseSBHZXJtYW4gZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiBlcnJvciB0eXBlLlxuICAgKlxuICAgKiBSZXR1cm5zIGxvY2FsaXplZCBtZXNzYWdlcyBzdWl0YWJsZSBmb3IgZGlzcGxheSB0byBlbmQgdXNlcnMuXG4gICAqIFRlY2huaWNhbCBlcnJvciBkZXRhaWxzIGFyZSBsb2dnZWQgc2VwYXJhdGVseSBhbmQgbm90IGV4cG9zZWRcbiAgICogdG8gdXNlcnMgZm9yIHNlY3VyaXR5IGFuZCB1c2FiaWxpdHkgcmVhc29ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtFcnJvclR5cGV9IHR5cGUgLSBUaGUgY2F0ZWdvcnkgb2YgZXJyb3JcbiAgICogQHBhcmFtIHtFcnJvcn0gX2Vycm9yIC0gVGhlIGVycm9yIG9iamVjdCAodW51c2VkLCBmb3IgZnV0dXJlIGV4dGVuc2lvbilcbiAgICogQHJldHVybnMge3N0cmluZ30gQSBHZXJtYW4gZXJyb3IgbWVzc2FnZSBzdWl0YWJsZSBmb3IgdXNlciBkaXNwbGF5XG4gICAqL1xuICBwcml2YXRlIGdldFVzZXJGcmllbmRseU1lc3NhZ2UodHlwZTogRXJyb3JUeXBlLCBfZXJyb3I6IEVycm9yKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgRXJyb3JUeXBlLlRBQkxFQkFTRTpcbiAgICAgICAgcmV0dXJuIFwiRGllIFRhYmxlYmFzZS1EYXRlbmJhbmsga29ubnRlIG5pY2h0IGdlbGFkZW4gd2VyZGVuLiBCaXR0ZSBha3R1YWxpc2llcmVuIFNpZSBkaWUgU2VpdGUuXCI7XG5cbiAgICAgIGNhc2UgRXJyb3JUeXBlLlVJX0NPTVBPTkVOVDpcbiAgICAgICAgcmV0dXJuIFwiRWluIFByb2JsZW0gbWl0IGRlciBCZW51dHplcm9iZXJmbMOkY2hlIGlzdCBhdWZnZXRyZXRlbi4gQml0dGUgdmVyc3VjaGVuIFNpZSBlcyBlcm5ldXQuXCI7XG5cbiAgICAgIGNhc2UgRXJyb3JUeXBlLk5FVFdPUks6XG4gICAgICAgIHJldHVybiBcIk5ldHp3ZXJrZmVobGVyLiBCaXR0ZSBwcsO8ZmVuIFNpZSBJaHJlIEludGVybmV0dmVyYmluZHVuZy5cIjtcblxuICAgICAgY2FzZSBFcnJvclR5cGUuU1RPUkFHRTpcbiAgICAgICAgcmV0dXJuIFwiRmVobGVyIGJlaW0gU3BlaWNoZXJuIGRlciBEYXRlbi4gQml0dGUgdmVyc3VjaGVuIFNpZSBlcyBlcm5ldXQuXCI7XG5cbiAgICAgIGNhc2UgRXJyb3JUeXBlLlZBTElEQVRJT046XG4gICAgICAgIHJldHVybiBcIlVuZ8O8bHRpZ2UgRWluZ2FiZS4gQml0dGUgw7xiZXJwcsO8ZmVuIFNpZSBJaHJlIEVpbmdhYmVuLlwiO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJFaW4gdW5lcndhcnRldGVyIEZlaGxlciBpc3QgYXVmZ2V0cmV0ZW4uIEJpdHRlIHZlcnN1Y2hlbiBTaWUgZXMgZXJuZXV0LlwiO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHN0YXRpc3RpY3MgYWJvdXQgbG9nZ2VkIGVycm9ycy5cbiAgICpcbiAgICogUHJvdmlkZXMgYSBzdW1tYXJ5IG9mIGFsbCBlcnJvcnMgaW4gdGhlIGludGVybmFsIGxvZywgZ3JvdXBlZFxuICAgKiBieSB0eXBlIGFuZCBpbmNsdWRpbmcgcmVjZW50IGVycm9yIGRldGFpbHMuIFVzZWZ1bCBmb3IgZGVidWdnaW5nXG4gICAqIGFuZCBtb25pdG9yaW5nIGFwcGxpY2F0aW9uIGhlYWx0aC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRXJyb3Igc3RhdGlzdGljcyBpbmNsdWRpbmc6XG4gICAqICAgLSB0b3RhbEVycm9yczogVG90YWwgbnVtYmVyIG9mIGVycm9ycyBpbiBsb2dcbiAgICogICAtIGVycm9yc0J5VHlwZTogQ291bnQgb2YgZXJyb3JzIGdyb3VwZWQgYnkgRXJyb3JUeXBlXG4gICAqICAgLSByZWNlbnRFcnJvcnM6IEFycmF5IG9mIGxhc3QgNSBlcnJvcnMgd2l0aCBkZXRhaWxzXG4gICAqIEBleGFtcGxlXG4gICAqIGltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2luZy9Mb2dnZXInO1xuICAgKiBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKTtcbiAgICogY29uc3Qgc3RhdHMgPSBlcnJvclNlcnZpY2UuZ2V0RXJyb3JTdGF0cygpO1xuICAgKiBsb2dnZXIuaW5mbyhgVG90YWwgZXJyb3JzOiAke3N0YXRzLnRvdGFsRXJyb3JzfWApO1xuICAgKiBsb2dnZXIuaW5mbyhgVUkgZXJyb3JzOiAke3N0YXRzLmVycm9yc0J5VHlwZS5VSV9DT01QT05FTlQgfHwgMH1gKTtcbiAgICovXG4gIGdldEVycm9yU3RhdHMoKSB7XG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLmVycm9yTG9nLnJlZHVjZShcbiAgICAgIChhY2MsIGxvZykgPT4ge1xuICAgICAgICBjb25zdCB0eXBlID0gbG9nLmNvbnRleHQudHlwZSB8fCBcIlVOS05PV05cIjtcbiAgICAgICAgYWNjW3R5cGVdID0gKGFjY1t0eXBlXSB8fCAwKSArIDE7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvdGFsRXJyb3JzOiB0aGlzLmVycm9yTG9nLmxlbmd0aCxcbiAgICAgIGVycm9yc0J5VHlwZTogc3RhdHMsXG4gICAgICByZWNlbnRFcnJvcnM6IHRoaXMuZXJyb3JMb2cuc2xpY2UoLTUpLm1hcCgobG9nKSA9PiAoe1xuICAgICAgICB0eXBlOiBsb2cuY29udGV4dC50eXBlLFxuICAgICAgICBjb21wb25lbnQ6IGxvZy5jb250ZXh0LmNvbXBvbmVudCxcbiAgICAgICAgdGltZXN0YW1wOiBsb2cudGltZXN0YW1wLFxuICAgICAgICBtZXNzYWdlOiBsb2cuZXJyb3IubWVzc2FnZSxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgZXJyb3JzIGZyb20gdGhlIGludGVybmFsIGxvZy5cbiAgICpcbiAgICogUmVzZXRzIHRoZSBlcnJvciB0cmFja2luZyB0byBhIGNsZWFuIHN0YXRlLiBQcmltYXJpbHkgdXNlZFxuICAgKiBmb3IgdGVzdGluZywgYnV0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVzZXQgZXJyb3IgdHJhY2tpbmdcbiAgICogYWZ0ZXIgZXhwb3J0aW5nIG9yIHByb2Nlc3NpbmcgZXJyb3IgZGF0YS5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEV4cG9ydCBlcnJvcnMgdGhlbiBjbGVhclxuICAgKiBjb25zdCBzdGF0cyA9IGVycm9yU2VydmljZS5nZXRFcnJvclN0YXRzKCk7XG4gICAqIGF3YWl0IHNlbmRFcnJvclJlcG9ydChzdGF0cyk7XG4gICAqIGVycm9yU2VydmljZS5jbGVhckVycm9yTG9nKCk7XG4gICAqL1xuICBjbGVhckVycm9yTG9nKCkge1xuICAgIHRoaXMuZXJyb3JMb2cgPSBbXTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkVycm9yU2VydmljZSIsIkVycm9yVHlwZSIsImdldEluc3RhbmNlIiwiaW5zdGFuY2UiLCJoYW5kbGVUYWJsZWJhc2VFcnJvciIsImVycm9yIiwiY29udGV4dCIsInNlcnZpY2UiLCJlbmhhbmNlZENvbnRleHQiLCJ0eXBlIiwidGltZXN0YW1wIiwiRGF0ZSIsImxvZ2dlciIsImxvZ0Vycm9yIiwiZ2V0VXNlckZyaWVuZGx5TWVzc2FnZSIsImhhbmRsZVVJRXJyb3IiLCJjb21wb25lbnROYW1lIiwiY29tcG9uZW50IiwiaGFuZGxlTmV0d29ya0Vycm9yIiwiZXJyb3JMb2ciLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJfZXJyb3IiLCJnZXRFcnJvclN0YXRzIiwic3RhdHMiLCJyZWR1Y2UiLCJhY2MiLCJsb2ciLCJ0b3RhbEVycm9ycyIsImVycm9yc0J5VHlwZSIsInJlY2VudEVycm9ycyIsInNsaWNlIiwibWFwIiwibWVzc2FnZSIsImNsZWFyRXJyb3JMb2ciLCJnZXRMb2dnZXIiLCJzZXRDb250ZXh0Il0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Q0FLQzs7Ozs7Ozs7Ozs7UUE0RFlBO2VBQUFBOztRQW5EREM7ZUFBQUE7Ozt5QkFQYzs7Ozs7Ozs7Ozs7Ozs7QUFPbkIsSUFBQSxBQUFL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