1f999fd919e39d66b2a8689494232917
/**
 * @fileoverview Unit tests for Chess.js integration and chess logic wrappers
 * @description Tests move validation, game rules, position analysis, and chess state management
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _globals = require("@jest/globals");
const _chess = require("chess.js");
const _TestFixtures = require("../../../shared/testing/TestFixtures");
(0, _globals.describe)("Chess.js Integration and Game Logic", ()=>{
    let game;
    (0, _globals.beforeEach)(()=>{
        game = new _chess.Chess();
    });
    (0, _globals.describe)("Position Loading and FEN Handling", ()=>{
        (0, _globals.test)("should_load_starting_position_correctly", ()=>{
            game.load(_TestFixtures.TEST_FENS.STARTING_POSITION);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.STARTING_POSITION);
            (0, _globals.expect)(game.turn()).toBe("w");
        });
        (0, _globals.test)("should_load_endgame_positions_correctly", ()=>{
            game.load(_TestFixtures.TEST_FENS.KQK_TABLEBASE_WIN);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.KQK_TABLEBASE_WIN);
            game.load(_TestFixtures.TEST_FENS.ROOK_ENDGAME);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.ROOK_ENDGAME);
            game.load(_TestFixtures.TEST_FENS.WHITE_ADVANTAGE);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.WHITE_ADVANTAGE);
        });
        (0, _globals.test)("should_reject_invalid_fen_strings", ()=>{
            (0, _globals.expect)(()=>game.load(_TestFixtures.TEST_FENS.INVALID_FEN)).toThrow();
            (0, _globals.expect)(()=>game.load(_TestFixtures.TEST_FENS.MALFORMED_FEN)).toThrow();
            (0, _globals.expect)(()=>game.load("")).toThrow();
        });
        (0, _globals.test)("should_preserve_original_position_on_invalid_load", ()=>{
            const originalFen = game.fen();
            try {
                game.load("invalid fen");
            } catch (e) {
            // Expected to throw
            }
            (0, _globals.expect)(game.fen()).toBe(originalFen); // Should be unchanged
        });
        (0, _globals.test)("should_handle_complex_fen_features", ()=>{
            // En passant - correct format
            const enPassantFen = "rnbqkbnr/ppp1pppp/8/3pP3/8/8/PPPP1PPP/RNBQKBNR w KQkq d6 0 3";
            game.load(enPassantFen);
            (0, _globals.expect)(game.fen()).toBe(enPassantFen);
            // Castling rights
            const castlingFen = "r3k2r/pppppppp/8/8/8/8/PPPPPPPP/R3K2R w KQkq - 0 1";
            game.load(castlingFen);
            (0, _globals.expect)(game.fen()).toBe(castlingFen);
            // High move counters
            const highCounterFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 99 150";
            game.load(highCounterFen);
            (0, _globals.expect)(game.fen()).toBe(highCounterFen);
        });
    });
    (0, _globals.describe)("Move Validation and Execution", ()=>{
        (0, _globals.describe)("Legal Moves", ()=>{
            (0, _globals.test)("should_allow_legal_pawn_moves", ()=>{
                const move = game.move(_TestFixtures.TEST_MOVES.E2E4);
                (0, _globals.expect)(move).not.toBeNull();
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.from).toBe("e2");
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.to).toBe("e4");
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.piece).toBe("p");
            });
            (0, _globals.test)("should_allow_legal_knight_moves", ()=>{
                const move = game.move(_TestFixtures.TEST_MOVES.NG1F3);
                (0, _globals.expect)(move).not.toBeNull();
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.from).toBe("g1");
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.to).toBe("f3");
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.piece).toBe("n");
            });
            (0, _globals.test)("should_allow_piece_captures", ()=>{
                // Set up a capture scenario where white can capture black pawn
                game.load("rnbqkbnr/pppp1ppp/8/4p3/3P4/8/PPP1PPPP/RNBQKBNR w KQkq e6 0 2");
                const move = game.move({
                    from: "d4",
                    to: "e5"
                });
                (0, _globals.expect)(move).not.toBeNull();
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.captured).toBe("p");
            });
            (0, _globals.test)("should_handle_en_passant_captures", ()=>{
                // Set up en passant scenario
                game.load(_TestFixtures.TEST_FENS.EN_PASSANT_POSITION);
                const move = game.move({
                    from: "e5",
                    to: "d6"
                });
                (0, _globals.expect)(move).not.toBeNull();
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.flags).toContain("e"); // En passant flag
                (0, _globals.expect)(move === null || move === void 0 ? void 0 : move.captured).toBe("p");
            });
            (0, _globals.test)("should_handle_castling_moves", ()=>{
                // Set up castling scenario
                game.load(_TestFixtures.TEST_FENS.CASTLING_AVAILABLE);
                // Kingside castling
                const kingsideCastle = game.move({
                    from: "e1",
                    to: "g1"
                });
                (0, _globals.expect)(kingsideCastle).not.toBeNull();
                (0, _globals.expect)(kingsideCastle === null || kingsideCastle === void 0 ? void 0 : kingsideCastle.flags).toContain("k"); // Kingside castle flag
                // Reset and try queenside
                game.load(_TestFixtures.TEST_FENS.CASTLING_AVAILABLE);
                const queensideCastle = game.move({
                    from: "e1",
                    to: "c1"
                });
                (0, _globals.expect)(queensideCastle).not.toBeNull();
                (0, _globals.expect)(queensideCastle === null || queensideCastle === void 0 ? void 0 : queensideCastle.flags).toContain("q"); // Queenside castle flag
            });
            (0, _globals.test)("should_handle_pawn_promotion", ()=>{
                // Set up promotion scenario
                game.load(_TestFixtures.TEST_FENS.PAWN_PROMOTION_WHITE);
                const promotion = game.move(_TestFixtures.TEST_MOVES.PROMOTION_QUEEN);
                (0, _globals.expect)(promotion).not.toBeNull();
                (0, _globals.expect)(promotion === null || promotion === void 0 ? void 0 : promotion.flags).toContain("p"); // Promotion flag
                (0, _globals.expect)(promotion === null || promotion === void 0 ? void 0 : promotion.promotion).toBe("q");
            });
        });
        (0, _globals.describe)("Illegal Moves", ()=>{
            (0, _globals.test)("should_reject_illegal_pawn_moves", ()=>{
                (0, _globals.expect)(()=>game.move(_TestFixtures.TEST_MOVES.ILLEGAL_MOVE)).toThrow();
            });
            (0, _globals.test)("should_reject_moves_to_invalid_squares", ()=>{
                (0, _globals.expect)(()=>game.move(_TestFixtures.TEST_MOVES.INVALID_SQUARE)).toThrow();
            });
            (0, _globals.test)("should_reject_moves_that_leave_king_in_check", ()=>{
                // Set up endgame position where king cannot move, only pawn can move
                game.load(_TestFixtures.TEST_FENS.EXPOSED_KING_POSITION);
                // Try to move the h2 pawn, king stays safe (this should work)
                const move = game.move({
                    from: "h2",
                    to: "h3"
                });
                (0, _globals.expect)(move).not.toBeNull();
            });
            (0, _globals.test)("should_reject_castling_through_check", ()=>{
                // Test chess.js castling validation - this validates the integration works
                // Use a position where castling is available
                game.load(_TestFixtures.TEST_FENS.CASTLING_AVAILABLE);
                // Test that chess.js properly validates castling moves
                const legalMoves = game.moves({
                    verbose: true
                });
                const castlingMoves = legalMoves.filter((move)=>move.flags.includes("k") || move.flags.includes("q"));
                // Should have castling moves in this position
                (0, _globals.expect)(castlingMoves.length).toBeGreaterThan(0);
            });
            (0, _globals.test)("should_reject_castling_when_king_in_check", ()=>{
                // Set up position where king is in check
                game.load(_TestFixtures.TEST_FENS.KING_IN_CHECK);
                // Cannot castle when king is in check from queen on e2
                (0, _globals.expect)(()=>game.move({
                        from: "e1",
                        to: "g1"
                    })).toThrow();
                (0, _globals.expect)(()=>game.move({
                        from: "e1",
                        to: "c1"
                    })).toThrow();
            });
            (0, _globals.test)("should_reject_moves_when_no_castling_rights", ()=>{
                // Set up position without castling rights
                game.load(_TestFixtures.TEST_FENS.CASTLING_NO_RIGHTS);
                // Castling without rights - chess.js throws
                (0, _globals.expect)(()=>game.move({
                        from: "e1",
                        to: "g1"
                    })).toThrow();
            });
        });
    });
    (0, _globals.describe)("Game State Detection", ()=>{
        (0, _globals.describe)("Check Detection", ()=>{
            (0, _globals.test)("should_detect_check_correctly", ()=>{
                // Set up a position with king in check
                game.load("rnbqkbnr/pppp1ppp/8/4p3/6P1/5P2/PPPPP2P/RNBQKBNR b KQkq - 0 2");
                game.move({
                    from: "d8",
                    to: "h4"
                }); // Queen checks king
                (0, _globals.expect)(game.inCheck()).toBe(true);
            });
            (0, _globals.test)("should_not_detect_check_when_king_safe", ()=>{
                (0, _globals.expect)(game.inCheck()).toBe(false);
                game.move("e4");
                (0, _globals.expect)(game.inCheck()).toBe(false);
            });
        });
        (0, _globals.describe)("Checkmate Detection", ()=>{
            (0, _globals.test)("should_detect_checkmate_correctly", ()=>{
                // Scholar's mate
                game.move("e4");
                game.move("e5");
                game.move("Bc4");
                game.move("Nc6");
                game.move("Qh5");
                game.move("Nf6");
                game.move("Qxf7#");
                (0, _globals.expect)(game.isCheckmate()).toBe(true);
                (0, _globals.expect)(game.isGameOver()).toBe(true);
            });
            (0, _globals.test)("should_not_detect_checkmate_in_normal_positions", ()=>{
                (0, _globals.expect)(game.isCheckmate()).toBe(false);
                game.move("e4");
                (0, _globals.expect)(game.isCheckmate()).toBe(false);
            });
        });
        (0, _globals.describe)("Stalemate Detection", ()=>{
            (0, _globals.test)("should_detect_stalemate_correctly", ()=>{
                // Set up a real stalemate position: Black king trapped by white king and pawn
                game.load(_TestFixtures.TEST_FENS.STALEMATE_POSITION);
                (0, _globals.expect)(game.isStalemate()).toBe(true);
                (0, _globals.expect)(game.isGameOver()).toBe(true);
            });
            (0, _globals.test)("should_not_detect_stalemate_with_legal_moves", ()=>{
                (0, _globals.expect)(game.isStalemate()).toBe(false);
            });
        });
        (0, _globals.describe)("Draw Conditions", ()=>{
            (0, _globals.test)("should_detect_insufficient_material_draw", ()=>{
                // King vs King
                game.load(_TestFixtures.TEST_FENS.INSUFFICIENT_MATERIAL);
                (0, _globals.expect)(game.isInsufficientMaterial()).toBe(true);
                (0, _globals.expect)(game.isDraw()).toBe(true);
            });
            (0, _globals.test)("should_detect_threefold_repetition", ()=>{
                // Repeat the same position three times
                game.move("Nf3");
                game.move("Nf6");
                game.move("Ng1");
                game.move("Ng8");
                game.move("Nf3");
                game.move("Nf6");
                game.move("Ng1");
                game.move("Ng8");
                (0, _globals.expect)(game.isThreefoldRepetition()).toBe(true);
                (0, _globals.expect)(game.isDraw()).toBe(true);
            });
            (0, _globals.test)("should_handle_fifty_move_rule", ()=>{
                // This is harder to test directly, but we can check the method exists
                (0, _globals.expect)(typeof game.isDraw).toBe("function");
            });
        });
    });
    (0, _globals.describe)("Move Generation and Analysis", ()=>{
        (0, _globals.test)("should_generate_legal_moves_from_starting_position", ()=>{
            const moves = game.moves();
            (0, _globals.expect)(moves).toHaveLength(20); // 16 pawn moves + 4 knight moves
            (0, _globals.expect)(moves).toContain("e4");
            (0, _globals.expect)(moves).toContain("Nf3");
        });
        (0, _globals.test)("should_generate_detailed_move_objects", ()=>{
            const moves = game.moves({
                verbose: true
            });
            (0, _globals.expect)(moves).toHaveLength(20);
            (0, _globals.expect)(moves[0]).toHaveProperty("from");
            (0, _globals.expect)(moves[0]).toHaveProperty("to");
            (0, _globals.expect)(moves[0]).toHaveProperty("piece");
        });
        (0, _globals.test)("should_generate_moves_for_specific_square", ()=>{
            const e2Moves = game.moves({
                square: "e2"
            });
            (0, _globals.expect)(e2Moves).toHaveLength(2); // e3 and e4
            (0, _globals.expect)(e2Moves).toContain("e3");
            (0, _globals.expect)(e2Moves).toContain("e4");
        });
        (0, _globals.test)("should_handle_no_legal_moves_in_checkmate", ()=>{
            // Use Scholar's mate sequence to create checkmate
            game.move("e4");
            game.move("e5");
            game.move("Bc4");
            game.move("Nc6");
            game.move("Qh5");
            game.move("Nf6");
            game.move("Qxf7#"); // Checkmate
            const moves = game.moves();
            (0, _globals.expect)(moves).toHaveLength(0);
            (0, _globals.expect)(game.isCheckmate()).toBe(true);
        });
    });
    (0, _globals.describe)("Position Analysis", ()=>{
        (0, _globals.test)("should_analyze_piece_positions_correctly", ()=>{
            var _board__, _board__1, _board__2;
            const board = game.board();
            (0, _globals.expect)(board).toHaveLength(8); // 8 ranks
            (0, _globals.expect)(board[0]).toHaveLength(8); // 8 files
            // Check specific pieces in starting position
            (0, _globals.expect)((_board__ = board[0][0]) === null || _board__ === void 0 ? void 0 : _board__.type).toBe("r"); // a8 rook
            (0, _globals.expect)((_board__1 = board[0][4]) === null || _board__1 === void 0 ? void 0 : _board__1.type).toBe("k"); // e8 king
            (0, _globals.expect)((_board__2 = board[7][4]) === null || _board__2 === void 0 ? void 0 : _board__2.type).toBe("k"); // e1 king
        });
        (0, _globals.test)("should_track_piece_counts_correctly", ()=>{
            // Count pieces in starting position
            const board = game.board();
            let whitePieces = 0;
            let blackPieces = 0;
            for (const rank of board){
                for (const square of rank){
                    if (square) {
                        if (square.color === "w") whitePieces++;
                        else blackPieces++;
                    }
                }
            }
            (0, _globals.expect)(whitePieces).toBe(16);
            (0, _globals.expect)(blackPieces).toBe(16);
        });
        (0, _globals.test)("should_handle_piece_movement_correctly", ()=>{
            var _board__, _board__1;
            game.move("e4");
            const board = game.board();
            (0, _globals.expect)(board[6][4]).toBeNull(); // e2 should be empty
            (0, _globals.expect)((_board__ = board[4][4]) === null || _board__ === void 0 ? void 0 : _board__.type).toBe("p"); // e4 should have pawn
            (0, _globals.expect)((_board__1 = board[4][4]) === null || _board__1 === void 0 ? void 0 : _board__1.color).toBe("w");
        });
    });
    (0, _globals.describe)("History and Undo Functionality", ()=>{
        (0, _globals.test)("should_track_move_history_correctly", ()=>{
            game.move("e4");
            game.move("e5");
            game.move("Nf3");
            const history = game.history();
            (0, _globals.expect)(history).toEqual([
                "e4",
                "e5",
                "Nf3"
            ]);
        });
        (0, _globals.test)("should_track_detailed_move_history", ()=>{
            game.move("e4");
            game.move("e5");
            const detailedHistory = game.history({
                verbose: true
            });
            (0, _globals.expect)(detailedHistory).toHaveLength(2);
            (0, _globals.expect)(detailedHistory[0].from).toBe("e2");
            (0, _globals.expect)(detailedHistory[0].to).toBe("e4");
            (0, _globals.expect)(detailedHistory[1].from).toBe("e7");
            (0, _globals.expect)(detailedHistory[1].to).toBe("e5");
        });
        (0, _globals.test)("should_support_undo_functionality", ()=>{
            const originalFen = game.fen();
            game.move("e4");
            (0, _globals.expect)(game.fen()).not.toBe(originalFen);
            const undoneMove = game.undo();
            (0, _globals.expect)(undoneMove).not.toBeNull();
            (0, _globals.expect)(game.fen()).toBe(originalFen);
        });
        (0, _globals.test)("should_handle_multiple_undos", ()=>{
            const originalFen = game.fen();
            game.move("e4");
            game.move("e5");
            game.move("Nf3");
            game.undo();
            game.undo();
            game.undo();
            (0, _globals.expect)(game.fen()).toBe(originalFen);
        });
        (0, _globals.test)("should_return_null_when_no_moves_to_undo", ()=>{
            const undoResult = game.undo();
            (0, _globals.expect)(undoResult).toBeNull();
        });
    });
    (0, _globals.describe)("Edge Cases and Error Handling", ()=>{
        (0, _globals.test)("should_handle_invalid_move_formats", ()=>{
            // chess.js throws for invalid move formats
            (0, _globals.expect)(()=>game.move("invalid")).toThrow();
            (0, _globals.expect)(()=>game.move({
                    from: "z9",
                    to: "a1"
                })).toThrow();
            // null moves - chess.js handles them as null moves
            // They return a special null move object
            const nullMove = game.move(null);
            (0, _globals.expect)(nullMove).toBeTruthy();
            (0, _globals.expect)(nullMove === null || nullMove === void 0 ? void 0 : nullMove.san).toBe("--"); // null move notation
            // undefined throws an error
            (0, _globals.expect)(()=>game.move(undefined)).toThrow();
        });
        (0, _globals.test)("should_maintain_consistency_after_invalid_operations", ()=>{
            const originalFen = game.fen();
            // Try various invalid operations (they throw but don't change state)
            try {
                game.move("invalid");
            } catch (e) {
            /* expected */ }
            try {
                game.load("invalid fen");
            } catch (e) {
            /* expected - now throws */ }
            try {
                game.move({
                    from: "z9",
                    to: "a1"
                });
            } catch (e) {
            /* expected */ }
            // Game state should be unchanged
            (0, _globals.expect)(game.fen()).toBe(originalFen);
            (0, _globals.expect)(game.turn()).toBe("w");
        });
        (0, _globals.test)("should_handle_complex_endgame_positions", ()=>{
            // Load various endgame positions and verify they work
            game.load(_TestFixtures.TEST_FENS.BLACK_ADVANTAGE);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.BLACK_ADVANTAGE);
            game.load(_TestFixtures.TEST_FENS.EQUAL_POSITION);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.EQUAL_POSITION);
            game.load(_TestFixtures.TEST_FENS.KPK_WINNING);
            (0, _globals.expect)(game.fen()).toBe(_TestFixtures.TEST_FENS.KPK_WINNING);
            // Each should still allow move generation
            game.load(_TestFixtures.TEST_FENS.EQUAL_POSITION);
            const moves = game.moves();
            (0, _globals.expect)(moves.length).toBeGreaterThan(0);
        });
    });
    (0, _globals.describe)("Performance and Memory", ()=>{
        (0, _globals.test)("should_handle_rapid_move_sequences_efficiently", ()=>{
            const startTime = Date.now();
            // Make many moves rapidly
            for(let i = 0; i < 100; i++){
                game.move("Nf3");
                game.move("Nf6");
                game.undo();
                game.undo();
            }
            const endTime = Date.now();
            (0, _globals.expect)(endTime - startTime).toBeLessThan(1000); // Should be fast
        });
        (0, _globals.test)("should_not_leak_memory_with_repeated_operations", ()=>{
            // This is hard to test directly, but we can ensure operations complete
            for(let i = 0; i < 50; i++){
                const newGame = new _chess.Chess();
                newGame.move("e4");
                newGame.move("e5");
                const history = newGame.history();
                (0, _globals.expect)(history).toHaveLength(2);
            }
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9jaGVzcy9jaGVzc0ludGVncmF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IFVuaXQgdGVzdHMgZm9yIENoZXNzLmpzIGludGVncmF0aW9uIGFuZCBjaGVzcyBsb2dpYyB3cmFwcGVyc1xuICogQGRlc2NyaXB0aW9uIFRlc3RzIG1vdmUgdmFsaWRhdGlvbiwgZ2FtZSBydWxlcywgcG9zaXRpb24gYW5hbHlzaXMsIGFuZCBjaGVzcyBzdGF0ZSBtYW5hZ2VtZW50XG4gKi9cblxuaW1wb3J0IHsgZGVzY3JpYmUsIHRlc3QsIGV4cGVjdCwgYmVmb3JlRWFjaCB9IGZyb20gXCJAamVzdC9nbG9iYWxzXCI7XG5pbXBvcnQgeyBDaGVzcyB9IGZyb20gXCJjaGVzcy5qc1wiO1xuaW1wb3J0IHsgVEVTVF9GRU5TLCBURVNUX01PVkVTIH0gZnJvbSBcIi4uLy4uLy4uL3NoYXJlZC90ZXN0aW5nL1Rlc3RGaXh0dXJlc1wiO1xuXG5kZXNjcmliZShcIkNoZXNzLmpzIEludGVncmF0aW9uIGFuZCBHYW1lIExvZ2ljXCIsICgpID0+IHtcbiAgbGV0IGdhbWU6IENoZXNzO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGdhbWUgPSBuZXcgQ2hlc3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQb3NpdGlvbiBMb2FkaW5nIGFuZCBGRU4gSGFuZGxpbmdcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGRfbG9hZF9zdGFydGluZ19wb3NpdGlvbl9jb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5TVEFSVElOR19QT1NJVElPTik7XG5cbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKFRFU1RfRkVOUy5TVEFSVElOR19QT1NJVElPTik7XG4gICAgICBleHBlY3QoZ2FtZS50dXJuKCkpLnRvQmUoXCJ3XCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZF9sb2FkX2VuZGdhbWVfcG9zaXRpb25zX2NvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLktRS19UQUJMRUJBU0VfV0lOKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKFRFU1RfRkVOUy5LUUtfVEFCTEVCQVNFX1dJTik7XG5cbiAgICAgIGdhbWUubG9hZChURVNUX0ZFTlMuUk9PS19FTkRHQU1FKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKFRFU1RfRkVOUy5ST09LX0VOREdBTUUpO1xuXG4gICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLldISVRFX0FEVkFOVEFHRSk7XG4gICAgICBleHBlY3QoZ2FtZS5mZW4oKSkudG9CZShURVNUX0ZFTlMuV0hJVEVfQURWQU5UQUdFKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfcmVqZWN0X2ludmFsaWRfZmVuX3N0cmluZ3NcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KCgpID0+IGdhbWUubG9hZChURVNUX0ZFTlMuSU5WQUxJRF9GRU4pKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gZ2FtZS5sb2FkKFRFU1RfRkVOUy5NQUxGT1JNRURfRkVOKSkudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KCgpID0+IGdhbWUubG9hZChcIlwiKSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZF9wcmVzZXJ2ZV9vcmlnaW5hbF9wb3NpdGlvbl9vbl9pbnZhbGlkX2xvYWRcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGZW4gPSBnYW1lLmZlbigpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBnYW1lLmxvYWQoXCJpbnZhbGlkIGZlblwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgdG8gdGhyb3dcbiAgICAgIH1cblxuICAgICAgZXhwZWN0KGdhbWUuZmVuKCkpLnRvQmUob3JpZ2luYWxGZW4pOyAvLyBTaG91bGQgYmUgdW5jaGFuZ2VkXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX2hhbmRsZV9jb21wbGV4X2Zlbl9mZWF0dXJlc1wiLCAoKSA9PiB7XG4gICAgICAvLyBFbiBwYXNzYW50IC0gY29ycmVjdCBmb3JtYXRcbiAgICAgIGNvbnN0IGVuUGFzc2FudEZlbiA9XG4gICAgICAgIFwicm5icWtibnIvcHBwMXBwcHAvOC8zcFAzLzgvOC9QUFBQMVBQUC9STkJRS0JOUiB3IEtRa3EgZDYgMCAzXCI7XG4gICAgICBnYW1lLmxvYWQoZW5QYXNzYW50RmVuKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKGVuUGFzc2FudEZlbik7XG5cbiAgICAgIC8vIENhc3RsaW5nIHJpZ2h0c1xuICAgICAgY29uc3QgY2FzdGxpbmdGZW4gPSBcInIzazJyL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUjNLMlIgdyBLUWtxIC0gMCAxXCI7XG4gICAgICBnYW1lLmxvYWQoY2FzdGxpbmdGZW4pO1xuICAgICAgZXhwZWN0KGdhbWUuZmVuKCkpLnRvQmUoY2FzdGxpbmdGZW4pO1xuXG4gICAgICAvLyBIaWdoIG1vdmUgY291bnRlcnNcbiAgICAgIGNvbnN0IGhpZ2hDb3VudGVyRmVuID1cbiAgICAgICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDk5IDE1MFwiO1xuICAgICAgZ2FtZS5sb2FkKGhpZ2hDb3VudGVyRmVuKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKGhpZ2hDb3VudGVyRmVuKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJNb3ZlIFZhbGlkYXRpb24gYW5kIEV4ZWN1dGlvblwiLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoXCJMZWdhbCBNb3Zlc1wiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwic2hvdWxkX2FsbG93X2xlZ2FsX3Bhd25fbW92ZXNcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBtb3ZlID0gZ2FtZS5tb3ZlKFRFU1RfTU9WRVMuRTJFNCk7XG5cbiAgICAgICAgZXhwZWN0KG1vdmUpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QobW92ZT8uZnJvbSkudG9CZShcImUyXCIpO1xuICAgICAgICBleHBlY3QobW92ZT8udG8pLnRvQmUoXCJlNFwiKTtcbiAgICAgICAgZXhwZWN0KG1vdmU/LnBpZWNlKS50b0JlKFwicFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX2FsbG93X2xlZ2FsX2tuaWdodF9tb3Zlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vdmUgPSBnYW1lLm1vdmUoVEVTVF9NT1ZFUy5ORzFGMyk7XG5cbiAgICAgICAgZXhwZWN0KG1vdmUpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QobW92ZT8uZnJvbSkudG9CZShcImcxXCIpO1xuICAgICAgICBleHBlY3QobW92ZT8udG8pLnRvQmUoXCJmM1wiKTtcbiAgICAgICAgZXhwZWN0KG1vdmU/LnBpZWNlKS50b0JlKFwiblwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX2FsbG93X3BpZWNlX2NhcHR1cmVzXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIGEgY2FwdHVyZSBzY2VuYXJpbyB3aGVyZSB3aGl0ZSBjYW4gY2FwdHVyZSBibGFjayBwYXduXG4gICAgICAgIGdhbWUubG9hZChcbiAgICAgICAgICBcInJuYnFrYm5yL3BwcHAxcHBwLzgvNHAzLzNQNC84L1BQUDFQUFBQL1JOQlFLQk5SIHcgS1FrcSBlNiAwIDJcIixcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtb3ZlID0gZ2FtZS5tb3ZlKHsgZnJvbTogXCJkNFwiLCB0bzogXCJlNVwiIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb3ZlKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgZXhwZWN0KG1vdmU/LmNhcHR1cmVkKS50b0JlKFwicFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX2hhbmRsZV9lbl9wYXNzYW50X2NhcHR1cmVzXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIGVuIHBhc3NhbnQgc2NlbmFyaW9cbiAgICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5FTl9QQVNTQU5UX1BPU0lUSU9OKTtcblxuICAgICAgICBjb25zdCBtb3ZlID0gZ2FtZS5tb3ZlKHsgZnJvbTogXCJlNVwiLCB0bzogXCJkNlwiIH0pO1xuXG4gICAgICAgIGV4cGVjdChtb3ZlKS5ub3QudG9CZU51bGwoKTtcbiAgICAgICAgZXhwZWN0KG1vdmU/LmZsYWdzKS50b0NvbnRhaW4oXCJlXCIpOyAvLyBFbiBwYXNzYW50IGZsYWdcbiAgICAgICAgZXhwZWN0KG1vdmU/LmNhcHR1cmVkKS50b0JlKFwicFwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX2hhbmRsZV9jYXN0bGluZ19tb3Zlc1wiLCAoKSA9PiB7XG4gICAgICAgIC8vIFNldCB1cCBjYXN0bGluZyBzY2VuYXJpb1xuICAgICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLkNBU1RMSU5HX0FWQUlMQUJMRSk7XG5cbiAgICAgICAgLy8gS2luZ3NpZGUgY2FzdGxpbmdcbiAgICAgICAgY29uc3Qga2luZ3NpZGVDYXN0bGUgPSBnYW1lLm1vdmUoeyBmcm9tOiBcImUxXCIsIHRvOiBcImcxXCIgfSk7XG4gICAgICAgIGV4cGVjdChraW5nc2lkZUNhc3RsZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChraW5nc2lkZUNhc3RsZT8uZmxhZ3MpLnRvQ29udGFpbihcImtcIik7IC8vIEtpbmdzaWRlIGNhc3RsZSBmbGFnXG5cbiAgICAgICAgLy8gUmVzZXQgYW5kIHRyeSBxdWVlbnNpZGVcbiAgICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5DQVNUTElOR19BVkFJTEFCTEUpO1xuICAgICAgICBjb25zdCBxdWVlbnNpZGVDYXN0bGUgPSBnYW1lLm1vdmUoeyBmcm9tOiBcImUxXCIsIHRvOiBcImMxXCIgfSk7XG4gICAgICAgIGV4cGVjdChxdWVlbnNpZGVDYXN0bGUpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICBleHBlY3QocXVlZW5zaWRlQ2FzdGxlPy5mbGFncykudG9Db250YWluKFwicVwiKTsgLy8gUXVlZW5zaWRlIGNhc3RsZSBmbGFnXG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9oYW5kbGVfcGF3bl9wcm9tb3Rpb25cIiwgKCkgPT4ge1xuICAgICAgICAvLyBTZXQgdXAgcHJvbW90aW9uIHNjZW5hcmlvXG4gICAgICAgIGdhbWUubG9hZChURVNUX0ZFTlMuUEFXTl9QUk9NT1RJT05fV0hJVEUpO1xuXG4gICAgICAgIGNvbnN0IHByb21vdGlvbiA9IGdhbWUubW92ZShURVNUX01PVkVTLlBST01PVElPTl9RVUVFTik7XG5cbiAgICAgICAgZXhwZWN0KHByb21vdGlvbikubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChwcm9tb3Rpb24/LmZsYWdzKS50b0NvbnRhaW4oXCJwXCIpOyAvLyBQcm9tb3Rpb24gZmxhZ1xuICAgICAgICBleHBlY3QocHJvbW90aW9uPy5wcm9tb3Rpb24pLnRvQmUoXCJxXCIpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIklsbGVnYWwgTW92ZXNcIiwgKCkgPT4ge1xuICAgICAgdGVzdChcInNob3VsZF9yZWplY3RfaWxsZWdhbF9wYXduX21vdmVzXCIsICgpID0+IHtcbiAgICAgICAgZXhwZWN0KCgpID0+IGdhbWUubW92ZShURVNUX01PVkVTLklMTEVHQUxfTU9WRSkpLnRvVGhyb3coKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX3JlamVjdF9tb3Zlc190b19pbnZhbGlkX3NxdWFyZXNcIiwgKCkgPT4ge1xuICAgICAgICBleHBlY3QoKCkgPT4gZ2FtZS5tb3ZlKFRFU1RfTU9WRVMuSU5WQUxJRF9TUVVBUkUpKS50b1Rocm93KCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9yZWplY3RfbW92ZXNfdGhhdF9sZWF2ZV9raW5nX2luX2NoZWNrXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIGVuZGdhbWUgcG9zaXRpb24gd2hlcmUga2luZyBjYW5ub3QgbW92ZSwgb25seSBwYXduIGNhbiBtb3ZlXG4gICAgICAgIGdhbWUubG9hZChURVNUX0ZFTlMuRVhQT1NFRF9LSU5HX1BPU0lUSU9OKTtcblxuICAgICAgICAvLyBUcnkgdG8gbW92ZSB0aGUgaDIgcGF3biwga2luZyBzdGF5cyBzYWZlICh0aGlzIHNob3VsZCB3b3JrKVxuICAgICAgICBjb25zdCBtb3ZlID0gZ2FtZS5tb3ZlKHsgZnJvbTogXCJoMlwiLCB0bzogXCJoM1wiIH0pO1xuICAgICAgICBleHBlY3QobW92ZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9yZWplY3RfY2FzdGxpbmdfdGhyb3VnaF9jaGVja1wiLCAoKSA9PiB7XG4gICAgICAgIC8vIFRlc3QgY2hlc3MuanMgY2FzdGxpbmcgdmFsaWRhdGlvbiAtIHRoaXMgdmFsaWRhdGVzIHRoZSBpbnRlZ3JhdGlvbiB3b3Jrc1xuICAgICAgICAvLyBVc2UgYSBwb3NpdGlvbiB3aGVyZSBjYXN0bGluZyBpcyBhdmFpbGFibGVcbiAgICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5DQVNUTElOR19BVkFJTEFCTEUpO1xuXG4gICAgICAgIC8vIFRlc3QgdGhhdCBjaGVzcy5qcyBwcm9wZXJseSB2YWxpZGF0ZXMgY2FzdGxpbmcgbW92ZXNcbiAgICAgICAgY29uc3QgbGVnYWxNb3ZlcyA9IGdhbWUubW92ZXMoeyB2ZXJib3NlOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBjYXN0bGluZ01vdmVzID0gbGVnYWxNb3Zlcy5maWx0ZXIoXG4gICAgICAgICAgKG1vdmUpID0+IG1vdmUuZmxhZ3MuaW5jbHVkZXMoXCJrXCIpIHx8IG1vdmUuZmxhZ3MuaW5jbHVkZXMoXCJxXCIpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNob3VsZCBoYXZlIGNhc3RsaW5nIG1vdmVzIGluIHRoaXMgcG9zaXRpb25cbiAgICAgICAgZXhwZWN0KGNhc3RsaW5nTW92ZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9yZWplY3RfY2FzdGxpbmdfd2hlbl9raW5nX2luX2NoZWNrXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIHBvc2l0aW9uIHdoZXJlIGtpbmcgaXMgaW4gY2hlY2tcbiAgICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5LSU5HX0lOX0NIRUNLKTtcblxuICAgICAgICAvLyBDYW5ub3QgY2FzdGxlIHdoZW4ga2luZyBpcyBpbiBjaGVjayBmcm9tIHF1ZWVuIG9uIGUyXG4gICAgICAgIGV4cGVjdCgoKSA9PiBnYW1lLm1vdmUoeyBmcm9tOiBcImUxXCIsIHRvOiBcImcxXCIgfSkpLnRvVGhyb3coKTtcbiAgICAgICAgZXhwZWN0KCgpID0+IGdhbWUubW92ZSh7IGZyb206IFwiZTFcIiwgdG86IFwiYzFcIiB9KSkudG9UaHJvdygpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJzaG91bGRfcmVqZWN0X21vdmVzX3doZW5fbm9fY2FzdGxpbmdfcmlnaHRzXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIHBvc2l0aW9uIHdpdGhvdXQgY2FzdGxpbmcgcmlnaHRzXG4gICAgICAgIGdhbWUubG9hZChURVNUX0ZFTlMuQ0FTVExJTkdfTk9fUklHSFRTKTtcblxuICAgICAgICAvLyBDYXN0bGluZyB3aXRob3V0IHJpZ2h0cyAtIGNoZXNzLmpzIHRocm93c1xuICAgICAgICBleHBlY3QoKCkgPT4gZ2FtZS5tb3ZlKHsgZnJvbTogXCJlMVwiLCB0bzogXCJnMVwiIH0pKS50b1Rocm93KCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJHYW1lIFN0YXRlIERldGVjdGlvblwiLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoXCJDaGVjayBEZXRlY3Rpb25cIiwgKCkgPT4ge1xuICAgICAgdGVzdChcInNob3VsZF9kZXRlY3RfY2hlY2tfY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgICAgLy8gU2V0IHVwIGEgcG9zaXRpb24gd2l0aCBraW5nIGluIGNoZWNrXG4gICAgICAgIGdhbWUubG9hZChcbiAgICAgICAgICBcInJuYnFrYm5yL3BwcHAxcHBwLzgvNHAzLzZQMS81UDIvUFBQUFAyUC9STkJRS0JOUiBiIEtRa3EgLSAwIDJcIixcbiAgICAgICAgKTtcbiAgICAgICAgZ2FtZS5tb3ZlKHsgZnJvbTogXCJkOFwiLCB0bzogXCJoNFwiIH0pOyAvLyBRdWVlbiBjaGVja3Mga2luZ1xuXG4gICAgICAgIGV4cGVjdChnYW1lLmluQ2hlY2soKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX25vdF9kZXRlY3RfY2hlY2tfd2hlbl9raW5nX3NhZmVcIiwgKCkgPT4ge1xuICAgICAgICBleHBlY3QoZ2FtZS5pbkNoZWNrKCkpLnRvQmUoZmFsc2UpO1xuXG4gICAgICAgIGdhbWUubW92ZShcImU0XCIpO1xuICAgICAgICBleHBlY3QoZ2FtZS5pbkNoZWNrKCkpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIkNoZWNrbWF0ZSBEZXRlY3Rpb25cIiwgKCkgPT4ge1xuICAgICAgdGVzdChcInNob3VsZF9kZXRlY3RfY2hlY2ttYXRlX2NvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICAgIC8vIFNjaG9sYXIncyBtYXRlXG4gICAgICAgIGdhbWUubW92ZShcImU0XCIpO1xuICAgICAgICBnYW1lLm1vdmUoXCJlNVwiKTtcbiAgICAgICAgZ2FtZS5tb3ZlKFwiQmM0XCIpO1xuICAgICAgICBnYW1lLm1vdmUoXCJOYzZcIik7XG4gICAgICAgIGdhbWUubW92ZShcIlFoNVwiKTtcbiAgICAgICAgZ2FtZS5tb3ZlKFwiTmY2XCIpO1xuICAgICAgICBnYW1lLm1vdmUoXCJReGY3I1wiKTtcblxuICAgICAgICBleHBlY3QoZ2FtZS5pc0NoZWNrbWF0ZSgpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoZ2FtZS5pc0dhbWVPdmVyKCkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9ub3RfZGV0ZWN0X2NoZWNrbWF0ZV9pbl9ub3JtYWxfcG9zaXRpb25zXCIsICgpID0+IHtcbiAgICAgICAgZXhwZWN0KGdhbWUuaXNDaGVja21hdGUoKSkudG9CZShmYWxzZSk7XG5cbiAgICAgICAgZ2FtZS5tb3ZlKFwiZTRcIik7XG4gICAgICAgIGV4cGVjdChnYW1lLmlzQ2hlY2ttYXRlKCkpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIlN0YWxlbWF0ZSBEZXRlY3Rpb25cIiwgKCkgPT4ge1xuICAgICAgdGVzdChcInNob3VsZF9kZXRlY3Rfc3RhbGVtYXRlX2NvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICAgIC8vIFNldCB1cCBhIHJlYWwgc3RhbGVtYXRlIHBvc2l0aW9uOiBCbGFjayBraW5nIHRyYXBwZWQgYnkgd2hpdGUga2luZyBhbmQgcGF3blxuICAgICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLlNUQUxFTUFURV9QT1NJVElPTik7XG5cbiAgICAgICAgZXhwZWN0KGdhbWUuaXNTdGFsZW1hdGUoKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGdhbWUuaXNHYW1lT3ZlcigpKS50b0JlKHRydWUpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJzaG91bGRfbm90X2RldGVjdF9zdGFsZW1hdGVfd2l0aF9sZWdhbF9tb3Zlc1wiLCAoKSA9PiB7XG4gICAgICAgIGV4cGVjdChnYW1lLmlzU3RhbGVtYXRlKCkpLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZShcIkRyYXcgQ29uZGl0aW9uc1wiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwic2hvdWxkX2RldGVjdF9pbnN1ZmZpY2llbnRfbWF0ZXJpYWxfZHJhd1wiLCAoKSA9PiB7XG4gICAgICAgIC8vIEtpbmcgdnMgS2luZ1xuICAgICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLklOU1VGRklDSUVOVF9NQVRFUklBTCk7XG5cbiAgICAgICAgZXhwZWN0KGdhbWUuaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoZ2FtZS5pc0RyYXcoKSkudG9CZSh0cnVlKTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0KFwic2hvdWxkX2RldGVjdF90aHJlZWZvbGRfcmVwZXRpdGlvblwiLCAoKSA9PiB7XG4gICAgICAgIC8vIFJlcGVhdCB0aGUgc2FtZSBwb3NpdGlvbiB0aHJlZSB0aW1lc1xuICAgICAgICBnYW1lLm1vdmUoXCJOZjNcIik7XG4gICAgICAgIGdhbWUubW92ZShcIk5mNlwiKTtcbiAgICAgICAgZ2FtZS5tb3ZlKFwiTmcxXCIpO1xuICAgICAgICBnYW1lLm1vdmUoXCJOZzhcIik7XG4gICAgICAgIGdhbWUubW92ZShcIk5mM1wiKTtcbiAgICAgICAgZ2FtZS5tb3ZlKFwiTmY2XCIpO1xuICAgICAgICBnYW1lLm1vdmUoXCJOZzFcIik7XG4gICAgICAgIGdhbWUubW92ZShcIk5nOFwiKTtcblxuICAgICAgICBleHBlY3QoZ2FtZS5pc1RocmVlZm9sZFJlcGV0aXRpb24oKSkudG9CZSh0cnVlKTtcbiAgICAgICAgZXhwZWN0KGdhbWUuaXNEcmF3KCkpLnRvQmUodHJ1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZF9oYW5kbGVfZmlmdHlfbW92ZV9ydWxlXCIsICgpID0+IHtcbiAgICAgICAgLy8gVGhpcyBpcyBoYXJkZXIgdG8gdGVzdCBkaXJlY3RseSwgYnV0IHdlIGNhbiBjaGVjayB0aGUgbWV0aG9kIGV4aXN0c1xuICAgICAgICBleHBlY3QodHlwZW9mIGdhbWUuaXNEcmF3KS50b0JlKFwiZnVuY3Rpb25cIik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJNb3ZlIEdlbmVyYXRpb24gYW5kIEFuYWx5c2lzXCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkX2dlbmVyYXRlX2xlZ2FsX21vdmVzX2Zyb21fc3RhcnRpbmdfcG9zaXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW92ZXMgPSBnYW1lLm1vdmVzKCk7XG5cbiAgICAgIGV4cGVjdChtb3ZlcykudG9IYXZlTGVuZ3RoKDIwKTsgLy8gMTYgcGF3biBtb3ZlcyArIDQga25pZ2h0IG1vdmVzXG4gICAgICBleHBlY3QobW92ZXMpLnRvQ29udGFpbihcImU0XCIpO1xuICAgICAgZXhwZWN0KG1vdmVzKS50b0NvbnRhaW4oXCJOZjNcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX2dlbmVyYXRlX2RldGFpbGVkX21vdmVfb2JqZWN0c1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb3ZlcyA9IGdhbWUubW92ZXMoeyB2ZXJib3NlOiB0cnVlIH0pO1xuXG4gICAgICBleHBlY3QobW92ZXMpLnRvSGF2ZUxlbmd0aCgyMCk7XG4gICAgICBleHBlY3QobW92ZXNbMF0pLnRvSGF2ZVByb3BlcnR5KFwiZnJvbVwiKTtcbiAgICAgIGV4cGVjdChtb3Zlc1swXSkudG9IYXZlUHJvcGVydHkoXCJ0b1wiKTtcbiAgICAgIGV4cGVjdChtb3Zlc1swXSkudG9IYXZlUHJvcGVydHkoXCJwaWVjZVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfZ2VuZXJhdGVfbW92ZXNfZm9yX3NwZWNpZmljX3NxdWFyZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBlMk1vdmVzID0gZ2FtZS5tb3Zlcyh7IHNxdWFyZTogXCJlMlwiIH0pO1xuXG4gICAgICBleHBlY3QoZTJNb3ZlcykudG9IYXZlTGVuZ3RoKDIpOyAvLyBlMyBhbmQgZTRcbiAgICAgIGV4cGVjdChlMk1vdmVzKS50b0NvbnRhaW4oXCJlM1wiKTtcbiAgICAgIGV4cGVjdChlMk1vdmVzKS50b0NvbnRhaW4oXCJlNFwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfaGFuZGxlX25vX2xlZ2FsX21vdmVzX2luX2NoZWNrbWF0ZVwiLCAoKSA9PiB7XG4gICAgICAvLyBVc2UgU2Nob2xhcidzIG1hdGUgc2VxdWVuY2UgdG8gY3JlYXRlIGNoZWNrbWF0ZVxuICAgICAgZ2FtZS5tb3ZlKFwiZTRcIik7XG4gICAgICBnYW1lLm1vdmUoXCJlNVwiKTtcbiAgICAgIGdhbWUubW92ZShcIkJjNFwiKTtcbiAgICAgIGdhbWUubW92ZShcIk5jNlwiKTtcbiAgICAgIGdhbWUubW92ZShcIlFoNVwiKTtcbiAgICAgIGdhbWUubW92ZShcIk5mNlwiKTtcbiAgICAgIGdhbWUubW92ZShcIlF4ZjcjXCIpOyAvLyBDaGVja21hdGVcblxuICAgICAgY29uc3QgbW92ZXMgPSBnYW1lLm1vdmVzKCk7XG4gICAgICBleHBlY3QobW92ZXMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgIGV4cGVjdChnYW1lLmlzQ2hlY2ttYXRlKCkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUG9zaXRpb24gQW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGRfYW5hbHl6ZV9waWVjZV9wb3NpdGlvbnNfY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGJvYXJkID0gZ2FtZS5ib2FyZCgpO1xuXG4gICAgICBleHBlY3QoYm9hcmQpLnRvSGF2ZUxlbmd0aCg4KTsgLy8gOCByYW5rc1xuICAgICAgZXhwZWN0KGJvYXJkWzBdKS50b0hhdmVMZW5ndGgoOCk7IC8vIDggZmlsZXNcblxuICAgICAgLy8gQ2hlY2sgc3BlY2lmaWMgcGllY2VzIGluIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICBleHBlY3QoYm9hcmRbMF1bMF0/LnR5cGUpLnRvQmUoXCJyXCIpOyAvLyBhOCByb29rXG4gICAgICBleHBlY3QoYm9hcmRbMF1bNF0/LnR5cGUpLnRvQmUoXCJrXCIpOyAvLyBlOCBraW5nXG4gICAgICBleHBlY3QoYm9hcmRbN11bNF0/LnR5cGUpLnRvQmUoXCJrXCIpOyAvLyBlMSBraW5nXG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX3RyYWNrX3BpZWNlX2NvdW50c19jb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgLy8gQ291bnQgcGllY2VzIGluIHN0YXJ0aW5nIHBvc2l0aW9uXG4gICAgICBjb25zdCBib2FyZCA9IGdhbWUuYm9hcmQoKTtcbiAgICAgIGxldCB3aGl0ZVBpZWNlcyA9IDA7XG4gICAgICBsZXQgYmxhY2tQaWVjZXMgPSAwO1xuXG4gICAgICBmb3IgKGNvbnN0IHJhbmsgb2YgYm9hcmQpIHtcbiAgICAgICAgZm9yIChjb25zdCBzcXVhcmUgb2YgcmFuaykge1xuICAgICAgICAgIGlmIChzcXVhcmUpIHtcbiAgICAgICAgICAgIGlmIChzcXVhcmUuY29sb3IgPT09IFwid1wiKSB3aGl0ZVBpZWNlcysrO1xuICAgICAgICAgICAgZWxzZSBibGFja1BpZWNlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBleHBlY3Qod2hpdGVQaWVjZXMpLnRvQmUoMTYpO1xuICAgICAgZXhwZWN0KGJsYWNrUGllY2VzKS50b0JlKDE2KTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfaGFuZGxlX3BpZWNlX21vdmVtZW50X2NvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBnYW1lLm1vdmUoXCJlNFwiKTtcblxuICAgICAgY29uc3QgYm9hcmQgPSBnYW1lLmJvYXJkKCk7XG4gICAgICBleHBlY3QoYm9hcmRbNl1bNF0pLnRvQmVOdWxsKCk7IC8vIGUyIHNob3VsZCBiZSBlbXB0eVxuICAgICAgZXhwZWN0KGJvYXJkWzRdWzRdPy50eXBlKS50b0JlKFwicFwiKTsgLy8gZTQgc2hvdWxkIGhhdmUgcGF3blxuICAgICAgZXhwZWN0KGJvYXJkWzRdWzRdPy5jb2xvcikudG9CZShcIndcIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSGlzdG9yeSBhbmQgVW5kbyBGdW5jdGlvbmFsaXR5XCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkX3RyYWNrX21vdmVfaGlzdG9yeV9jb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgZ2FtZS5tb3ZlKFwiZTRcIik7XG4gICAgICBnYW1lLm1vdmUoXCJlNVwiKTtcbiAgICAgIGdhbWUubW92ZShcIk5mM1wiKTtcblxuICAgICAgY29uc3QgaGlzdG9yeSA9IGdhbWUuaGlzdG9yeSgpO1xuICAgICAgZXhwZWN0KGhpc3RvcnkpLnRvRXF1YWwoW1wiZTRcIiwgXCJlNVwiLCBcIk5mM1wiXSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX3RyYWNrX2RldGFpbGVkX21vdmVfaGlzdG9yeVwiLCAoKSA9PiB7XG4gICAgICBnYW1lLm1vdmUoXCJlNFwiKTtcbiAgICAgIGdhbWUubW92ZShcImU1XCIpO1xuXG4gICAgICBjb25zdCBkZXRhaWxlZEhpc3RvcnkgPSBnYW1lLmhpc3RvcnkoeyB2ZXJib3NlOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KGRldGFpbGVkSGlzdG9yeSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KGRldGFpbGVkSGlzdG9yeVswXS5mcm9tKS50b0JlKFwiZTJcIik7XG4gICAgICBleHBlY3QoZGV0YWlsZWRIaXN0b3J5WzBdLnRvKS50b0JlKFwiZTRcIik7XG4gICAgICBleHBlY3QoZGV0YWlsZWRIaXN0b3J5WzFdLmZyb20pLnRvQmUoXCJlN1wiKTtcbiAgICAgIGV4cGVjdChkZXRhaWxlZEhpc3RvcnlbMV0udG8pLnRvQmUoXCJlNVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfc3VwcG9ydF91bmRvX2Z1bmN0aW9uYWxpdHlcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGZW4gPSBnYW1lLmZlbigpO1xuXG4gICAgICBnYW1lLm1vdmUoXCJlNFwiKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS5ub3QudG9CZShvcmlnaW5hbEZlbik7XG5cbiAgICAgIGNvbnN0IHVuZG9uZU1vdmUgPSBnYW1lLnVuZG8oKTtcbiAgICAgIGV4cGVjdCh1bmRvbmVNb3ZlKS5ub3QudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKG9yaWdpbmFsRmVuKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfaGFuZGxlX211bHRpcGxlX3VuZG9zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdpbmFsRmVuID0gZ2FtZS5mZW4oKTtcblxuICAgICAgZ2FtZS5tb3ZlKFwiZTRcIik7XG4gICAgICBnYW1lLm1vdmUoXCJlNVwiKTtcbiAgICAgIGdhbWUubW92ZShcIk5mM1wiKTtcblxuICAgICAgZ2FtZS51bmRvKCk7XG4gICAgICBnYW1lLnVuZG8oKTtcbiAgICAgIGdhbWUudW5kbygpO1xuXG4gICAgICBleHBlY3QoZ2FtZS5mZW4oKSkudG9CZShvcmlnaW5hbEZlbik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX3JldHVybl9udWxsX3doZW5fbm9fbW92ZXNfdG9fdW5kb1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB1bmRvUmVzdWx0ID0gZ2FtZS51bmRvKCk7XG4gICAgICBleHBlY3QodW5kb1Jlc3VsdCkudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFZGdlIENhc2VzIGFuZCBFcnJvciBIYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZF9oYW5kbGVfaW52YWxpZF9tb3ZlX2Zvcm1hdHNcIiwgKCkgPT4ge1xuICAgICAgLy8gY2hlc3MuanMgdGhyb3dzIGZvciBpbnZhbGlkIG1vdmUgZm9ybWF0c1xuICAgICAgZXhwZWN0KCgpID0+IGdhbWUubW92ZShcImludmFsaWRcIikpLnRvVGhyb3coKTtcbiAgICAgIGV4cGVjdCgoKSA9PiBnYW1lLm1vdmUoeyBmcm9tOiBcIno5XCIsIHRvOiBcImExXCIgfSkpLnRvVGhyb3coKTtcblxuICAgICAgLy8gbnVsbCBtb3ZlcyAtIGNoZXNzLmpzIGhhbmRsZXMgdGhlbSBhcyBudWxsIG1vdmVzXG4gICAgICAvLyBUaGV5IHJldHVybiBhIHNwZWNpYWwgbnVsbCBtb3ZlIG9iamVjdFxuICAgICAgY29uc3QgbnVsbE1vdmUgPSBnYW1lLm1vdmUobnVsbCBhcyBhbnkpO1xuICAgICAgZXhwZWN0KG51bGxNb3ZlKS50b0JlVHJ1dGh5KCk7XG4gICAgICBleHBlY3QobnVsbE1vdmU/LnNhbikudG9CZShcIi0tXCIpOyAvLyBudWxsIG1vdmUgbm90YXRpb25cblxuICAgICAgLy8gdW5kZWZpbmVkIHRocm93cyBhbiBlcnJvclxuICAgICAgZXhwZWN0KCgpID0+IGdhbWUubW92ZSh1bmRlZmluZWQgYXMgYW55KSkudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZF9tYWludGFpbl9jb25zaXN0ZW5jeV9hZnRlcl9pbnZhbGlkX29wZXJhdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luYWxGZW4gPSBnYW1lLmZlbigpO1xuXG4gICAgICAvLyBUcnkgdmFyaW91cyBpbnZhbGlkIG9wZXJhdGlvbnMgKHRoZXkgdGhyb3cgYnV0IGRvbid0IGNoYW5nZSBzdGF0ZSlcbiAgICAgIHRyeSB7XG4gICAgICAgIGdhbWUubW92ZShcImludmFsaWRcIik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGV4cGVjdGVkICovXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBnYW1lLmxvYWQoXCJpbnZhbGlkIGZlblwiKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogZXhwZWN0ZWQgLSBub3cgdGhyb3dzICovXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBnYW1lLm1vdmUoeyBmcm9tOiBcIno5XCIsIHRvOiBcImExXCIgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGV4cGVjdGVkICovXG4gICAgICB9XG5cbiAgICAgIC8vIEdhbWUgc3RhdGUgc2hvdWxkIGJlIHVuY2hhbmdlZFxuICAgICAgZXhwZWN0KGdhbWUuZmVuKCkpLnRvQmUob3JpZ2luYWxGZW4pO1xuICAgICAgZXhwZWN0KGdhbWUudHVybigpKS50b0JlKFwid1wiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGRfaGFuZGxlX2NvbXBsZXhfZW5kZ2FtZV9wb3NpdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgLy8gTG9hZCB2YXJpb3VzIGVuZGdhbWUgcG9zaXRpb25zIGFuZCB2ZXJpZnkgdGhleSB3b3JrXG4gICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLkJMQUNLX0FEVkFOVEFHRSk7XG4gICAgICBleHBlY3QoZ2FtZS5mZW4oKSkudG9CZShURVNUX0ZFTlMuQkxBQ0tfQURWQU5UQUdFKTtcblxuICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5FUVVBTF9QT1NJVElPTik7XG4gICAgICBleHBlY3QoZ2FtZS5mZW4oKSkudG9CZShURVNUX0ZFTlMuRVFVQUxfUE9TSVRJT04pO1xuXG4gICAgICBnYW1lLmxvYWQoVEVTVF9GRU5TLktQS19XSU5OSU5HKTtcbiAgICAgIGV4cGVjdChnYW1lLmZlbigpKS50b0JlKFRFU1RfRkVOUy5LUEtfV0lOTklORyk7XG5cbiAgICAgIC8vIEVhY2ggc2hvdWxkIHN0aWxsIGFsbG93IG1vdmUgZ2VuZXJhdGlvblxuICAgICAgZ2FtZS5sb2FkKFRFU1RfRkVOUy5FUVVBTF9QT1NJVElPTik7XG4gICAgICBjb25zdCBtb3ZlcyA9IGdhbWUubW92ZXMoKTtcbiAgICAgIGV4cGVjdChtb3Zlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQZXJmb3JtYW5jZSBhbmQgTWVtb3J5XCIsICgpID0+IHtcbiAgICB0ZXN0KFwic2hvdWxkX2hhbmRsZV9yYXBpZF9tb3ZlX3NlcXVlbmNlc19lZmZpY2llbnRseVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBNYWtlIG1hbnkgbW92ZXMgcmFwaWRseVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDA7IGkrKykge1xuICAgICAgICBnYW1lLm1vdmUoXCJOZjNcIik7XG4gICAgICAgIGdhbWUubW92ZShcIk5mNlwiKTtcbiAgICAgICAgZ2FtZS51bmRvKCk7XG4gICAgICAgIGdhbWUudW5kbygpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlbmRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGV4cGVjdChlbmRUaW1lIC0gc3RhcnRUaW1lKS50b0JlTGVzc1RoYW4oMTAwMCk7IC8vIFNob3VsZCBiZSBmYXN0XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkX25vdF9sZWFrX21lbW9yeV93aXRoX3JlcGVhdGVkX29wZXJhdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgLy8gVGhpcyBpcyBoYXJkIHRvIHRlc3QgZGlyZWN0bHksIGJ1dCB3ZSBjYW4gZW5zdXJlIG9wZXJhdGlvbnMgY29tcGxldGVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTA7IGkrKykge1xuICAgICAgICBjb25zdCBuZXdHYW1lID0gbmV3IENoZXNzKCk7XG4gICAgICAgIG5ld0dhbWUubW92ZShcImU0XCIpO1xuICAgICAgICBuZXdHYW1lLm1vdmUoXCJlNVwiKTtcbiAgICAgICAgY29uc3QgaGlzdG9yeSA9IG5ld0dhbWUuaGlzdG9yeSgpO1xuICAgICAgICBleHBlY3QoaGlzdG9yeSkudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImRlc2NyaWJlIiwiZ2FtZSIsImJlZm9yZUVhY2giLCJDaGVzcyIsInRlc3QiLCJsb2FkIiwiVEVTVF9GRU5TIiwiU1RBUlRJTkdfUE9TSVRJT04iLCJleHBlY3QiLCJmZW4iLCJ0b0JlIiwidHVybiIsIktRS19UQUJMRUJBU0VfV0lOIiwiUk9PS19FTkRHQU1FIiwiV0hJVEVfQURWQU5UQUdFIiwiSU5WQUxJRF9GRU4iLCJ0b1Rocm93IiwiTUFMRk9STUVEX0ZFTiIsIm9yaWdpbmFsRmVuIiwiZSIsImVuUGFzc2FudEZlbiIsImNhc3RsaW5nRmVuIiwiaGlnaENvdW50ZXJGZW4iLCJtb3ZlIiwiVEVTVF9NT1ZFUyIsIkUyRTQiLCJub3QiLCJ0b0JlTnVsbCIsImZyb20iLCJ0byIsInBpZWNlIiwiTkcxRjMiLCJjYXB0dXJlZCIsIkVOX1BBU1NBTlRfUE9TSVRJT04iLCJmbGFncyIsInRvQ29udGFpbiIsIkNBU1RMSU5HX0FWQUlMQUJMRSIsImtpbmdzaWRlQ2FzdGxlIiwicXVlZW5zaWRlQ2FzdGxlIiwiUEFXTl9QUk9NT1RJT05fV0hJVEUiLCJwcm9tb3Rpb24iLCJQUk9NT1RJT05fUVVFRU4iLCJJTExFR0FMX01PVkUiLCJJTlZBTElEX1NRVUFSRSIsIkVYUE9TRURfS0lOR19QT1NJVElPTiIsImxlZ2FsTW92ZXMiLCJtb3ZlcyIsInZlcmJvc2UiLCJjYXN0bGluZ01vdmVzIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJsZW5ndGgiLCJ0b0JlR3JlYXRlclRoYW4iLCJLSU5HX0lOX0NIRUNLIiwiQ0FTVExJTkdfTk9fUklHSFRTIiwiaW5DaGVjayIsImlzQ2hlY2ttYXRlIiwiaXNHYW1lT3ZlciIsIlNUQUxFTUFURV9QT1NJVElPTiIsImlzU3RhbGVtYXRlIiwiSU5TVUZGSUNJRU5UX01BVEVSSUFMIiwiaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCIsImlzRHJhdyIsImlzVGhyZWVmb2xkUmVwZXRpdGlvbiIsInRvSGF2ZUxlbmd0aCIsInRvSGF2ZVByb3BlcnR5IiwiZTJNb3ZlcyIsInNxdWFyZSIsImJvYXJkIiwidHlwZSIsIndoaXRlUGllY2VzIiwiYmxhY2tQaWVjZXMiLCJyYW5rIiwiY29sb3IiLCJoaXN0b3J5IiwidG9FcXVhbCIsImRldGFpbGVkSGlzdG9yeSIsInVuZG9uZU1vdmUiLCJ1bmRvIiwidW5kb1Jlc3VsdCIsIm51bGxNb3ZlIiwidG9CZVRydXRoeSIsInNhbiIsInVuZGVmaW5lZCIsIkJMQUNLX0FEVkFOVEFHRSIsIkVRVUFMX1BPU0lUSU9OIiwiS1BLX1dJTk5JTkciLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwiaSIsImVuZFRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJuZXdHYW1lIl0sIm1hcHBpbmdzIjoiQUFBQTs7O0NBR0M7Ozs7eUJBRWtEO3VCQUM3Qjs4QkFDZ0I7QUFFdENBLElBQUFBLGlCQUFRLEVBQUMsdUNBQXVDO0lBQzlDLElBQUlDO0lBRUpDLElBQUFBLG1CQUFVLEVBQUM7UUFDVEQsT0FBTyxJQUFJRSxZQUFLO0lBQ2xCO0lBRUFILElBQUFBLGlCQUFRLEVBQUMscUNBQXFDO1FBQzVDSSxJQUFBQSxhQUFJLEVBQUMsMkNBQTJDO1lBQzlDSCxLQUFLSSxJQUFJLENBQUNDLHVCQUFTLENBQUNDLGlCQUFpQjtZQUVyQ0MsSUFBQUEsZUFBTSxFQUFDUCxLQUFLUSxHQUFHLElBQUlDLElBQUksQ0FBQ0osdUJBQVMsQ0FBQ0MsaUJBQWlCO1lBQ25EQyxJQUFBQSxlQUFNLEVBQUNQLEtBQUtVLElBQUksSUFBSUQsSUFBSSxDQUFDO1FBQzNCO1FBRUFOLElBQUFBLGFBQUksRUFBQywyQ0FBMkM7WUFDOUNILEtBQUtJLElBQUksQ0FBQ0MsdUJBQVMsQ0FBQ00saUJBQWlCO1lBQ3JDSixJQUFBQSxlQUFNLEVBQUNQLEtBQUtRLEdBQUcsSUFBSUMsSUFBSSxDQUFDSix1QkFBUyxDQUFDTSxpQkFBaUI7WUFFbkRYLEtBQUtJLElBQUksQ0FBQ0MsdUJBQVMsQ0FBQ08sWUFBWTtZQUNoQ0wsSUFBQUEsZUFBTSxFQUFDUCxLQUFLUSxHQUFHLElBQUlDLElBQUksQ0FBQ0osdUJBQVMsQ0FBQ08sWUFBWTtZQUU5Q1osS0FBS0ksSUFBSSxDQUFDQyx1QkFBUyxDQUFDUSxlQUFlO1lBQ25DTixJQUFBQSxlQUFNLEVBQUNQLEtBQUtRLEdBQUcs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