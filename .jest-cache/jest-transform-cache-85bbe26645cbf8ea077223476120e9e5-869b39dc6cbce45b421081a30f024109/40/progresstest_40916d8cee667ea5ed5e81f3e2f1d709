b4699b9ae7450c2a34ec90240411f9a3
/**
 * @file Unit tests for progress branded types
 * @description Comprehensive tests for DueCard branded types and utilities
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _progress = require("../../../shared/types/progress");
// Test helpers
const createTestCard = (id, nextReviewAt)=>({
        id,
        nextReviewAt,
        lastReviewedAt: Date.now() - 86400000,
        interval: 1,
        repetition: 1,
        efactor: 2.5,
        lapses: 0
    });
const createDueTestCard = (id)=>createTestCard(id, Date.now() - 1000);
const createFutureTestCard = (id)=>createTestCard(id, Date.now() + 86400000);
describe('Progress Branded Types', ()=>{
    const now = Date.now();
    describe('isDueCard', ()=>{
        it('should return true for cards that are due', ()=>{
            const dueCard = createDueTestCard('test-1');
            expect((0, _progress.isDueCard)(dueCard, now)).toBe(true);
        });
        it('should return false for cards that are not due', ()=>{
            const futureCard = createFutureTestCard('test-1');
            expect((0, _progress.isDueCard)(futureCard, now)).toBe(false);
        });
        it('should return true for cards due exactly now', ()=>{
            const exactCard = createTestCard('test-1', now);
            expect((0, _progress.isDueCard)(exactCard, now)).toBe(true);
        });
        it('should handle invalid card structures gracefully', ()=>{
            const invalidCard = {
                id: 'test'
            };
            expect((0, _progress.isDueCard)(invalidCard, now)).toBe(false);
        });
        it('should handle null/undefined cards', ()=>{
            expect((0, _progress.isDueCard)(null, now)).toBe(false);
            expect((0, _progress.isDueCard)(undefined, now)).toBe(false);
        });
        it('should use current time when now parameter is not provided', ()=>{
            const dueCard = createTestCard('test-1', Date.now() - 1000);
            expect((0, _progress.isDueCard)(dueCard)).toBe(true);
        });
    });
    describe('toDueCard', ()=>{
        it('should successfully convert a due card', ()=>{
            const card = createDueTestCard('test-1');
            const dueCard = (0, _progress.toDueCard)(card, now);
            expect(dueCard).toMatchObject(card);
            expect(dueCard.__isDue).toBe(true);
            expect(dueCard.__brand).toBe('DueCard');
        });
        it('should throw error for non-due cards', ()=>{
            const futureCard = createFutureTestCard('test-1');
            expect(()=>(0, _progress.toDueCard)(futureCard, now)).toThrow();
            expect(()=>(0, _progress.toDueCard)(futureCard, now)).toThrow(/not due for review/);
        });
        it('should include detailed error information', ()=>{
            const futureCard = createFutureTestCard('test-1');
            try {
                (0, _progress.toDueCard)(futureCard, now);
            } catch (error) {
                expect(error.message).toContain('test-1');
                expect(error.message).toContain('Next review:');
                expect(error.message).toContain('Current:');
            }
        });
        it('should use current time when now parameter is not provided', ()=>{
            const dueCard = createTestCard('test-1', Date.now() - 1000);
            const result = (0, _progress.toDueCard)(dueCard);
            expect(result.__isDue).toBe(true);
            expect(result.__brand).toBe('DueCard');
        });
    });
    describe('filterDueCards', ()=>{
        it('should filter due cards from mixed collection', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                createFutureTestCard('future-1'),
                createDueTestCard('due-2'),
                createFutureTestCard('future-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            expect(dueCards).toHaveLength(2);
            expect(dueCards[0].id).toBe('due-1');
            expect(dueCards[1].id).toBe('due-2');
            expect(dueCards[0].__isDue).toBe(true);
            expect(dueCards[0].__brand).toBe('DueCard');
        });
        it('should return empty array for no due cards', ()=>{
            const cards = [
                createFutureTestCard('future-1'),
                createFutureTestCard('future-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            expect(dueCards).toHaveLength(0);
        });
        it('should handle empty array input', ()=>{
            const dueCards = (0, _progress.filterDueCards)([], now);
            expect(dueCards).toHaveLength(0);
        });
        it('should handle invalid array input gracefully', ()=>{
            const dueCards = (0, _progress.filterDueCards)(null, now);
            expect(dueCards).toHaveLength(0);
        });
        it('should skip invalid cards in the collection', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                {
                    id: 'invalid'
                },
                createDueTestCard('due-2'),
                null
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            expect(dueCards).toHaveLength(2);
            expect(dueCards[0].id).toBe('due-1');
            expect(dueCards[1].id).toBe('due-2');
        });
        it('should handle large collections efficiently', ()=>{
            // Create large collection
            const largeCollection = Array.from({
                length: 1000
            }, (_, i)=>i % 2 === 0 ? createDueTestCard(`due-${i}`) : createFutureTestCard(`future-${i}`));
            const start = performance.now();
            const dueCards = (0, _progress.filterDueCards)(largeCollection, now);
            const duration = performance.now() - start;
            expect(dueCards).toHaveLength(500); // Half should be due
            expect(duration).toBeLessThan(50); // Should be fast (<50ms)
        });
        it('should use current time when now parameter is not provided', ()=>{
            const cards = [
                createTestCard('test-1', Date.now() - 1000)
            ];
            const dueCards = (0, _progress.filterDueCards)(cards);
            expect(dueCards).toHaveLength(1);
        });
    });
    describe('fromDueCard', ()=>{
        it('should extract CardProgress from DueCard', ()=>{
            const originalCard = createDueTestCard('test-1');
            const dueCard = (0, _progress.toDueCard)(originalCard, now);
            const extracted = (0, _progress.fromDueCard)(dueCard);
            expect(extracted).toMatchObject(originalCard);
            expect(extracted).not.toHaveProperty('__isDue');
            expect(extracted).not.toHaveProperty('__brand');
        });
    });
    describe('areDueCards', ()=>{
        it('should return true for array of DueCard objects', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            expect((0, _progress.areDueCards)(dueCards)).toBe(true);
        });
        it('should return false for mixed array', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            const mixed = [
                ...dueCards,
                createFutureTestCard('future-1')
            ];
            expect((0, _progress.areDueCards)(mixed)).toBe(false);
        });
        it('should return true for empty array', ()=>{
            expect((0, _progress.areDueCards)([])).toBe(true);
        });
        it('should return false for invalid objects', ()=>{
            const invalid = [
                {
                    id: 'test'
                },
                null,
                undefined
            ];
            expect((0, _progress.areDueCards)(invalid)).toBe(false);
        });
    });
    describe('createDueCardsMap', ()=>{
        it('should create map with positionId keys', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            const map = (0, _progress.createDueCardsMap)(dueCards);
            expect(map.size).toBe(2);
            expect(map.has('due-1')).toBe(true);
            expect(map.has('due-2')).toBe(true);
            expect(map.get('due-1')).toMatchObject(dueCards[0]);
        });
        it('should handle empty array', ()=>{
            const map = (0, _progress.createDueCardsMap)([]);
            expect(map.size).toBe(0);
        });
        it('should skip cards without id', ()=>{
            const cards = [
                createDueTestCard('due-1')
            ];
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            // Remove id from one card
            delete dueCards[0].id;
            const map = (0, _progress.createDueCardsMap)(dueCards);
            expect(map.size).toBe(0);
        });
    });
    describe('calculateDueCardsStats', ()=>{
        it('should calculate correct statistics', ()=>{
            const allCards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2'),
                createFutureTestCard('future-1'),
                createFutureTestCard('future-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(allCards, now);
            const stats = (0, _progress.calculateDueCardsStats)(allCards, dueCards, now);
            expect(stats.totalCards).toBe(4);
            expect(stats.dueCount).toBe(2);
            expect(stats.duePercentage).toBe(50);
            expect(stats.nextDueAt).toBeTruthy();
            expect(typeof stats.averageInterval).toBe('number');
        });
        it('should handle empty collections', ()=>{
            const stats = (0, _progress.calculateDueCardsStats)([], [], now);
            expect(stats.totalCards).toBe(0);
            expect(stats.dueCount).toBe(0);
            expect(stats.duePercentage).toBe(0);
            expect(stats.nextDueAt).toBeNull();
            expect(stats.averageInterval).toBe(0);
        });
        it('should handle no future due cards', ()=>{
            const allCards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2')
            ];
            const dueCards = (0, _progress.filterDueCards)(allCards, now);
            const stats = (0, _progress.calculateDueCardsStats)(allCards, dueCards, now);
            expect(stats.nextDueAt).toBeNull();
        });
        it('should calculate average interval correctly', ()=>{
            const cards = [
                createDueTestCard('due-1'),
                createDueTestCard('due-2')
            ];
            // Set specific intervals
            cards[0].interval = 2;
            cards[1].interval = 4;
            const dueCards = (0, _progress.filterDueCards)(cards, now);
            const stats = (0, _progress.calculateDueCardsStats)(cards, dueCards, now);
            expect(stats.averageInterval).toBe(3); // (2 + 4) / 2
        });
        it('should find next due card correctly', ()=>{
            const nextDueTime = now + 3600000; // 1 hour from now
            const allCards = [
                createDueTestCard('due-1'),
                createTestCard('next-due', nextDueTime),
                createTestCard('later-due', now + 7200000) // 2 hours from now
            ];
            const dueCards = (0, _progress.filterDueCards)(allCards, now);
            const stats = (0, _progress.calculateDueCardsStats)(allCards, dueCards, now);
            expect(stats.nextDueAt).toBe(nextDueTime);
        });
    });
    describe('TypeScript type checking', ()=>{
        it('should enforce DueCard branded type at compile time', ()=>{
            const card = createDueTestCard('test-1');
            const dueCard = (0, _progress.toDueCard)(card, now);
            // These should compile without errors
            const branded = dueCard;
            expect(branded.__isDue).toBe(true);
            expect(branded.__brand).toBe('DueCard');
        // This should be caught by TypeScript (though not at runtime)
        // const invalid: DueCard = card; // Would fail TypeScript compilation
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC90eXBlcy9wcm9ncmVzcy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgVW5pdCB0ZXN0cyBmb3IgcHJvZ3Jlc3MgYnJhbmRlZCB0eXBlc1xuICogQGRlc2NyaXB0aW9uIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIER1ZUNhcmQgYnJhbmRlZCB0eXBlcyBhbmQgdXRpbGl0aWVzXG4gKi9cblxuaW1wb3J0IHtcbiAgRHVlQ2FyZCxcbiAgaXNEdWVDYXJkLFxuICB0b0R1ZUNhcmQsXG4gIGZpbHRlckR1ZUNhcmRzLFxuICBmcm9tRHVlQ2FyZCxcbiAgYXJlRHVlQ2FyZHMsXG4gIGNyZWF0ZUR1ZUNhcmRzTWFwLFxuICBjYWxjdWxhdGVEdWVDYXJkc1N0YXRzXG59IGZyb20gJ0BzaGFyZWQvdHlwZXMvcHJvZ3Jlc3MnO1xuaW1wb3J0IHR5cGUgeyBDYXJkUHJvZ3Jlc3MgfSBmcm9tICdAc2hhcmVkL3N0b3JlL3NsaWNlcy90eXBlcyc7XG5cbi8vIFRlc3QgaGVscGVyc1xuY29uc3QgY3JlYXRlVGVzdENhcmQgPSAoaWQ6IHN0cmluZywgbmV4dFJldmlld0F0OiBudW1iZXIpOiBDYXJkUHJvZ3Jlc3MgPT4gKHtcbiAgaWQsXG4gIG5leHRSZXZpZXdBdCxcbiAgbGFzdFJldmlld2VkQXQ6IERhdGUubm93KCkgLSA4NjQwMDAwMCwgLy8gMjQgaG91cnMgYWdvXG4gIGludGVydmFsOiAxLFxuICByZXBldGl0aW9uOiAxLFxuICBlZmFjdG9yOiAyLjUsXG4gIGxhcHNlczogMFxufSk7XG5cbmNvbnN0IGNyZWF0ZUR1ZVRlc3RDYXJkID0gKGlkOiBzdHJpbmcpOiBDYXJkUHJvZ3Jlc3MgPT4gY3JlYXRlVGVzdENhcmQoaWQsIERhdGUubm93KCkgLSAxMDAwKTtcbmNvbnN0IGNyZWF0ZUZ1dHVyZVRlc3RDYXJkID0gKGlkOiBzdHJpbmcpOiBDYXJkUHJvZ3Jlc3MgPT4gY3JlYXRlVGVzdENhcmQoaWQsIERhdGUubm93KCkgKyA4NjQwMDAwMCk7XG5cbmRlc2NyaWJlKCdQcm9ncmVzcyBCcmFuZGVkIFR5cGVzJywgKCkgPT4ge1xuICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICBcbiAgZGVzY3JpYmUoJ2lzRHVlQ2FyZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIGZvciBjYXJkcyB0aGF0IGFyZSBkdWUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBkdWVDYXJkID0gY3JlYXRlRHVlVGVzdENhcmQoJ3Rlc3QtMScpO1xuICAgICAgZXhwZWN0KGlzRHVlQ2FyZChkdWVDYXJkLCBub3cpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBjYXJkcyB0aGF0IGFyZSBub3QgZHVlJywgKCkgPT4ge1xuICAgICAgY29uc3QgZnV0dXJlQ2FyZCA9IGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKCd0ZXN0LTEnKTtcbiAgICAgIGV4cGVjdChpc0R1ZUNhcmQoZnV0dXJlQ2FyZCwgbm93KSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSBmb3IgY2FyZHMgZHVlIGV4YWN0bHkgbm93JywgKCkgPT4ge1xuICAgICAgY29uc3QgZXhhY3RDYXJkID0gY3JlYXRlVGVzdENhcmQoJ3Rlc3QtMScsIG5vdyk7XG4gICAgICBleHBlY3QoaXNEdWVDYXJkKGV4YWN0Q2FyZCwgbm93KSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIGNhcmQgc3RydWN0dXJlcyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZENhcmQgPSB7IGlkOiAndGVzdCcgfSBhcyBDYXJkUHJvZ3Jlc3M7XG4gICAgICBleHBlY3QoaXNEdWVDYXJkKGludmFsaWRDYXJkLCBub3cpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBudWxsL3VuZGVmaW5lZCBjYXJkcycsICgpID0+IHtcbiAgICAgIGV4cGVjdChpc0R1ZUNhcmQobnVsbCBhcyBhbnksIG5vdykpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KGlzRHVlQ2FyZCh1bmRlZmluZWQgYXMgYW55LCBub3cpKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHVzZSBjdXJyZW50IHRpbWUgd2hlbiBub3cgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGR1ZUNhcmQgPSBjcmVhdGVUZXN0Q2FyZCgndGVzdC0xJywgRGF0ZS5ub3coKSAtIDEwMDApO1xuICAgICAgZXhwZWN0KGlzRHVlQ2FyZChkdWVDYXJkKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgndG9EdWVDYXJkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGNvbnZlcnQgYSBkdWUgY2FyZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhcmQgPSBjcmVhdGVEdWVUZXN0Q2FyZCgndGVzdC0xJyk7XG4gICAgICBjb25zdCBkdWVDYXJkID0gdG9EdWVDYXJkKGNhcmQsIG5vdyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdWVDYXJkKS50b01hdGNoT2JqZWN0KGNhcmQpO1xuICAgICAgZXhwZWN0KGR1ZUNhcmQuX19pc0R1ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkLl9fYnJhbmQpLnRvQmUoJ0R1ZUNhcmQnKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHRocm93IGVycm9yIGZvciBub24tZHVlIGNhcmRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZnV0dXJlQ2FyZCA9IGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKCd0ZXN0LTEnKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KCgpID0+IHRvRHVlQ2FyZChmdXR1cmVDYXJkLCBub3cpKS50b1Rocm93KCk7XG4gICAgICBleHBlY3QoKCkgPT4gdG9EdWVDYXJkKGZ1dHVyZUNhcmQsIG5vdykpLnRvVGhyb3coL25vdCBkdWUgZm9yIHJldmlldy8pO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaW5jbHVkZSBkZXRhaWxlZCBlcnJvciBpbmZvcm1hdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGZ1dHVyZUNhcmQgPSBjcmVhdGVGdXR1cmVUZXN0Q2FyZCgndGVzdC0xJyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIHRvRHVlQ2FyZChmdXR1cmVDYXJkLCBub3cpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXhwZWN0KChlcnJvciBhcyBFcnJvcikubWVzc2FnZSkudG9Db250YWluKCd0ZXN0LTEnKTtcbiAgICAgICAgZXhwZWN0KChlcnJvciBhcyBFcnJvcikubWVzc2FnZSkudG9Db250YWluKCdOZXh0IHJldmlldzonKTtcbiAgICAgICAgZXhwZWN0KChlcnJvciBhcyBFcnJvcikubWVzc2FnZSkudG9Db250YWluKCdDdXJyZW50OicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgdXNlIGN1cnJlbnQgdGltZSB3aGVuIG5vdyBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkJywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZCA9IGNyZWF0ZVRlc3RDYXJkKCd0ZXN0LTEnLCBEYXRlLm5vdygpIC0gMTAwMCk7XG4gICAgICBjb25zdCByZXN1bHQgPSB0b0R1ZUNhcmQoZHVlQ2FyZCk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQuX19pc0R1ZSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuX19icmFuZCkudG9CZSgnRHVlQ2FyZCcpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdmaWx0ZXJEdWVDYXJkcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGZpbHRlciBkdWUgY2FyZHMgZnJvbSBtaXhlZCBjb2xsZWN0aW9uJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIGNyZWF0ZUR1ZVRlc3RDYXJkKCdkdWUtMScpLFxuICAgICAgICBjcmVhdGVGdXR1cmVUZXN0Q2FyZCgnZnV0dXJlLTEnKSxcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0yJyksXG4gICAgICAgIGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKCdmdXR1cmUtMicpXG4gICAgICBdO1xuICAgICAgXG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGZpbHRlckR1ZUNhcmRzKGNhcmRzLCBub3cpO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVlQ2FyZHMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkc1swXS5pZCkudG9CZSgnZHVlLTEnKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkc1sxXS5pZCkudG9CZSgnZHVlLTInKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkc1swXS5fX2lzRHVlKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGR1ZUNhcmRzWzBdLl9fYnJhbmQpLnRvQmUoJ0R1ZUNhcmQnKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHJldHVybiBlbXB0eSBhcnJheSBmb3Igbm8gZHVlIGNhcmRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKCdmdXR1cmUtMScpLFxuICAgICAgICBjcmVhdGVGdXR1cmVUZXN0Q2FyZCgnZnV0dXJlLTInKVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhjYXJkcywgbm93KTtcbiAgICAgIGV4cGVjdChkdWVDYXJkcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGFycmF5IGlucHV0JywgKCkgPT4ge1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhbXSwgbm93KTtcbiAgICAgIGV4cGVjdChkdWVDYXJkcykudG9IYXZlTGVuZ3RoKDApO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgYXJyYXkgaW5wdXQgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGR1ZUNhcmRzID0gZmlsdGVyRHVlQ2FyZHMobnVsbCBhcyBhbnksIG5vdyk7XG4gICAgICBleHBlY3QoZHVlQ2FyZHMpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHNraXAgaW52YWxpZCBjYXJkcyBpbiB0aGUgY29sbGVjdGlvbicsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhcmRzID0gW1xuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTEnKSxcbiAgICAgICAgeyBpZDogJ2ludmFsaWQnIH0gYXMgQ2FyZFByb2dyZXNzLCAvLyBNaXNzaW5nIG5leHRSZXZpZXdBdFxuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTInKSxcbiAgICAgICAgbnVsbCBhcyBhbnlcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGNvbnN0IGR1ZUNhcmRzID0gZmlsdGVyRHVlQ2FyZHMoY2FyZHMsIG5vdyk7XG4gICAgICBleHBlY3QoZHVlQ2FyZHMpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkc1swXS5pZCkudG9CZSgnZHVlLTEnKTtcbiAgICAgIGV4cGVjdChkdWVDYXJkc1sxXS5pZCkudG9CZSgnZHVlLTInKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBjb2xsZWN0aW9ucyBlZmZpY2llbnRseScsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBsYXJnZSBjb2xsZWN0aW9uXG4gICAgICBjb25zdCBsYXJnZUNvbGxlY3Rpb24gPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgaSAlIDIgPT09IDAgPyBjcmVhdGVEdWVUZXN0Q2FyZChgZHVlLSR7aX1gKSA6IGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKGBmdXR1cmUtJHtpfWApXG4gICAgICApO1xuICAgICAgXG4gICAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhsYXJnZUNvbGxlY3Rpb24sIG5vdyk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICBcbiAgICAgIGV4cGVjdChkdWVDYXJkcykudG9IYXZlTGVuZ3RoKDUwMCk7IC8vIEhhbGYgc2hvdWxkIGJlIGR1ZVxuICAgICAgZXhwZWN0KGR1cmF0aW9uKS50b0JlTGVzc1RoYW4oNTApOyAvLyBTaG91bGQgYmUgZmFzdCAoPDUwbXMpXG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCB1c2UgY3VycmVudCB0aW1lIHdoZW4gbm93IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYXJkcyA9IFtjcmVhdGVUZXN0Q2FyZCgndGVzdC0xJywgRGF0ZS5ub3coKSAtIDEwMDApXTtcbiAgICAgIGNvbnN0IGR1ZUNhcmRzID0gZmlsdGVyRHVlQ2FyZHMoY2FyZHMpO1xuICAgICAgXG4gICAgICBleHBlY3QoZHVlQ2FyZHMpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnZnJvbUR1ZUNhcmQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBleHRyYWN0IENhcmRQcm9ncmVzcyBmcm9tIER1ZUNhcmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBvcmlnaW5hbENhcmQgPSBjcmVhdGVEdWVUZXN0Q2FyZCgndGVzdC0xJyk7XG4gICAgICBjb25zdCBkdWVDYXJkID0gdG9EdWVDYXJkKG9yaWdpbmFsQ2FyZCwgbm93KTtcbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IGZyb21EdWVDYXJkKGR1ZUNhcmQpO1xuICAgICAgXG4gICAgICBleHBlY3QoZXh0cmFjdGVkKS50b01hdGNoT2JqZWN0KG9yaWdpbmFsQ2FyZCk7XG4gICAgICBleHBlY3QoZXh0cmFjdGVkKS5ub3QudG9IYXZlUHJvcGVydHkoJ19faXNEdWUnKTtcbiAgICAgIGV4cGVjdChleHRyYWN0ZWQpLm5vdC50b0hhdmVQcm9wZXJ0eSgnX19icmFuZCcpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdhcmVEdWVDYXJkcycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIGZvciBhcnJheSBvZiBEdWVDYXJkIG9iamVjdHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYXJkcyA9IFtcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0xJyksXG4gICAgICAgIGNyZWF0ZUR1ZVRlc3RDYXJkKCdkdWUtMicpXG4gICAgICBdO1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhjYXJkcywgbm93KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KGFyZUR1ZUNhcmRzKGR1ZUNhcmRzKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgbWl4ZWQgYXJyYXknLCAoKSA9PiB7XG4gICAgICBjb25zdCBjYXJkcyA9IFtcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0xJyksXG4gICAgICAgIGNyZWF0ZUR1ZVRlc3RDYXJkKCdkdWUtMicpXG4gICAgICBdO1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhjYXJkcywgbm93KTtcbiAgICAgIGNvbnN0IG1peGVkID0gWy4uLmR1ZUNhcmRzLCBjcmVhdGVGdXR1cmVUZXN0Q2FyZCgnZnV0dXJlLTEnKV07XG4gICAgICBcbiAgICAgIGV4cGVjdChhcmVEdWVDYXJkcyhtaXhlZCkpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRydWUgZm9yIGVtcHR5IGFycmF5JywgKCkgPT4ge1xuICAgICAgZXhwZWN0KGFyZUR1ZUNhcmRzKFtdKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgaW52YWxpZCBvYmplY3RzJywgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZCA9IFt7IGlkOiAndGVzdCcgfSwgbnVsbCwgdW5kZWZpbmVkXTtcbiAgICAgIGV4cGVjdChhcmVEdWVDYXJkcyhpbnZhbGlkKSkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuICBcbiAgZGVzY3JpYmUoJ2NyZWF0ZUR1ZUNhcmRzTWFwJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgY3JlYXRlIG1hcCB3aXRoIHBvc2l0aW9uSWQga2V5cycsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhcmRzID0gW1xuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTEnKSxcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0yJylcbiAgICAgIF07XG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGZpbHRlckR1ZUNhcmRzKGNhcmRzLCBub3cpO1xuICAgICAgY29uc3QgbWFwID0gY3JlYXRlRHVlQ2FyZHNNYXAoZHVlQ2FyZHMpO1xuICAgICAgXG4gICAgICBleHBlY3QobWFwLnNpemUpLnRvQmUoMik7XG4gICAgICBleHBlY3QobWFwLmhhcygnZHVlLTEnKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtYXAuaGFzKCdkdWUtMicpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1hcC5nZXQoJ2R1ZS0xJykpLnRvTWF0Y2hPYmplY3QoZHVlQ2FyZHNbMF0pO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGVtcHR5IGFycmF5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbWFwID0gY3JlYXRlRHVlQ2FyZHNNYXAoW10pO1xuICAgICAgZXhwZWN0KG1hcC5zaXplKS50b0JlKDApO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgc2tpcCBjYXJkcyB3aXRob3V0IGlkJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FyZHMgPSBbY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0xJyldO1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhjYXJkcywgbm93KTtcbiAgICAgIC8vIFJlbW92ZSBpZCBmcm9tIG9uZSBjYXJkXG4gICAgICBkZWxldGUgKGR1ZUNhcmRzWzBdIGFzIGFueSkuaWQ7XG4gICAgICBcbiAgICAgIGNvbnN0IG1hcCA9IGNyZWF0ZUR1ZUNhcmRzTWFwKGR1ZUNhcmRzKTtcbiAgICAgIGV4cGVjdChtYXAuc2l6ZSkudG9CZSgwKTtcbiAgICB9KTtcbiAgfSk7XG4gIFxuICBkZXNjcmliZSgnY2FsY3VsYXRlRHVlQ2FyZHNTdGF0cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBjb3JyZWN0IHN0YXRpc3RpY3MnLCAoKSA9PiB7XG4gICAgICBjb25zdCBhbGxDYXJkcyA9IFtcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0xJyksXG4gICAgICAgIGNyZWF0ZUR1ZVRlc3RDYXJkKCdkdWUtMicpLCBcbiAgICAgICAgY3JlYXRlRnV0dXJlVGVzdENhcmQoJ2Z1dHVyZS0xJyksXG4gICAgICAgIGNyZWF0ZUZ1dHVyZVRlc3RDYXJkKCdmdXR1cmUtMicpXG4gICAgICBdO1xuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhhbGxDYXJkcywgbm93KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RhdHMgPSBjYWxjdWxhdGVEdWVDYXJkc1N0YXRzKGFsbENhcmRzLCBkdWVDYXJkcywgbm93KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHN0YXRzLnRvdGFsQ2FyZHMpLnRvQmUoNCk7XG4gICAgICBleHBlY3Qoc3RhdHMuZHVlQ291bnQpLnRvQmUoMik7XG4gICAgICBleHBlY3Qoc3RhdHMuZHVlUGVyY2VudGFnZSkudG9CZSg1MCk7XG4gICAgICBleHBlY3Qoc3RhdHMubmV4dER1ZUF0KS50b0JlVHJ1dGh5KCk7XG4gICAgICBleHBlY3QodHlwZW9mIHN0YXRzLmF2ZXJhZ2VJbnRlcnZhbCkudG9CZSgnbnVtYmVyJyk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgY29sbGVjdGlvbnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdGF0cyA9IGNhbGN1bGF0ZUR1ZUNhcmRzU3RhdHMoW10sIFtdLCBub3cpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3RhdHMudG90YWxDYXJkcykudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5kdWVDb3VudCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChzdGF0cy5kdWVQZXJjZW50YWdlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHN0YXRzLm5leHREdWVBdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChzdGF0cy5hdmVyYWdlSW50ZXJ2YWwpLnRvQmUoMCk7XG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbm8gZnV0dXJlIGR1ZSBjYXJkcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGFsbENhcmRzID0gW1xuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTEnKSxcbiAgICAgICAgY3JlYXRlRHVlVGVzdENhcmQoJ2R1ZS0yJylcbiAgICAgIF07XG4gICAgICBjb25zdCBkdWVDYXJkcyA9IGZpbHRlckR1ZUNhcmRzKGFsbENhcmRzLCBub3cpO1xuICAgICAgXG4gICAgICBjb25zdCBzdGF0cyA9IGNhbGN1bGF0ZUR1ZUNhcmRzU3RhdHMoYWxsQ2FyZHMsIGR1ZUNhcmRzLCBub3cpO1xuICAgICAgXG4gICAgICBleHBlY3Qoc3RhdHMubmV4dER1ZUF0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICAgIFxuICAgIGl0KCdzaG91bGQgY2FsY3VsYXRlIGF2ZXJhZ2UgaW50ZXJ2YWwgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIGNyZWF0ZUR1ZVRlc3RDYXJkKCdkdWUtMScpLFxuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTInKVxuICAgICAgXTtcbiAgICAgIC8vIFNldCBzcGVjaWZpYyBpbnRlcnZhbHNcbiAgICAgIGNhcmRzWzBdLmludGVydmFsID0gMjtcbiAgICAgIGNhcmRzWzFdLmludGVydmFsID0gNDtcbiAgICAgIFxuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBmaWx0ZXJEdWVDYXJkcyhjYXJkcywgbm93KTtcbiAgICAgIGNvbnN0IHN0YXRzID0gY2FsY3VsYXRlRHVlQ2FyZHNTdGF0cyhjYXJkcywgZHVlQ2FyZHMsIG5vdyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzdGF0cy5hdmVyYWdlSW50ZXJ2YWwpLnRvQmUoMyk7IC8vICgyICsgNCkgLyAyXG4gICAgfSk7XG4gICAgXG4gICAgaXQoJ3Nob3VsZCBmaW5kIG5leHQgZHVlIGNhcmQgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbmV4dER1ZVRpbWUgPSBub3cgKyAzNjAwMDAwOyAvLyAxIGhvdXIgZnJvbSBub3dcbiAgICAgIGNvbnN0IGFsbENhcmRzID0gW1xuICAgICAgICBjcmVhdGVEdWVUZXN0Q2FyZCgnZHVlLTEnKSxcbiAgICAgICAgY3JlYXRlVGVzdENhcmQoJ25leHQtZHVlJywgbmV4dER1ZVRpbWUpLFxuICAgICAgICBjcmVhdGVUZXN0Q2FyZCgnbGF0ZXItZHVlJywgbm93ICsgNzIwMDAwMCkgLy8gMiBob3VycyBmcm9tIG5vd1xuICAgICAgXTtcbiAgICAgIGNvbnN0IGR1ZUNhcmRzID0gZmlsdGVyRHVlQ2FyZHMoYWxsQ2FyZHMsIG5vdyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHN0YXRzID0gY2FsY3VsYXRlRHVlQ2FyZHNTdGF0cyhhbGxDYXJkcywgZHVlQ2FyZHMsIG5vdyk7XG4gICAgICBcbiAgICAgIGV4cGVjdChzdGF0cy5uZXh0RHVlQXQpLnRvQmUobmV4dER1ZVRpbWUpO1xuICAgIH0pO1xuICB9KTtcbiAgXG4gIGRlc2NyaWJlKCdUeXBlU2NyaXB0IHR5cGUgY2hlY2tpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBlbmZvcmNlIER1ZUNhcmQgYnJhbmRlZCB0eXBlIGF0IGNvbXBpbGUgdGltZScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhcmQgPSBjcmVhdGVEdWVUZXN0Q2FyZCgndGVzdC0xJyk7XG4gICAgICBjb25zdCBkdWVDYXJkID0gdG9EdWVDYXJkKGNhcmQsIG5vdyk7XG4gICAgICBcbiAgICAgIC8vIFRoZXNlIHNob3VsZCBjb21waWxlIHdpdGhvdXQgZXJyb3JzXG4gICAgICBjb25zdCBicmFuZGVkOiBEdWVDYXJkID0gZHVlQ2FyZDtcbiAgICAgIGV4cGVjdChicmFuZGVkLl9faXNEdWUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoYnJhbmRlZC5fX2JyYW5kKS50b0JlKCdEdWVDYXJkJyk7XG4gICAgICBcbiAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGNhdWdodCBieSBUeXBlU2NyaXB0ICh0aG91Z2ggbm90IGF0IHJ1bnRpbWUpXG4gICAgICAvLyBjb25zdCBpbnZhbGlkOiBEdWVDYXJkID0gY2FyZDsgLy8gV291bGQgZmFpbCBUeXBlU2NyaXB0IGNvbXBpbGF0aW9uXG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImNyZWF0ZVRlc3RDYXJkIiwiaWQiLCJuZXh0UmV2aWV3QXQiLCJsYXN0UmV2aWV3ZWRBdCIsIkRhdGUiLCJub3ciLCJpbnRlcnZhbCIsInJlcGV0aXRpb24iLCJlZmFjdG9yIiwibGFwc2VzIiwiY3JlYXRlRHVlVGVzdENhcmQiLCJjcmVhdGVGdXR1cmVUZXN0Q2FyZCIsImRlc2NyaWJlIiwiaXQiLCJkdWVDYXJkIiwiZXhwZWN0IiwiaXNEdWVDYXJkIiwidG9CZSIsImZ1dHVyZUNhcmQiLCJleGFjdENhcmQiLCJpbnZhbGlkQ2FyZCIsInVuZGVmaW5lZCIsImNhcmQiLCJ0b0R1ZUNhcmQiLCJ0b01hdGNoT2JqZWN0IiwiX19pc0R1ZSIsIl9fYnJhbmQiLCJ0b1Rocm93IiwiZXJyb3IiLCJtZXNzYWdlIiwidG9Db250YWluIiwicmVzdWx0IiwiY2FyZHMiLCJkdWVDYXJkcyIsImZpbHRlckR1ZUNhcmRzIiwidG9IYXZlTGVuZ3RoIiwibGFyZ2VDb2xsZWN0aW9uIiwiQXJyYXkiLCJmcm9tIiwibGVuZ3RoIiwiXyIsImkiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwiZHVyYXRpb24iLCJ0b0JlTGVzc1RoYW4iLCJvcmlnaW5hbENhcmQiLCJleHRyYWN0ZWQiLCJmcm9tRHVlQ2FyZCIsIm5vdCIsInRvSGF2ZVByb3BlcnR5IiwiYXJlRHVlQ2FyZHMiLCJtaXhlZCIsImludmFsaWQiLCJtYXAiLCJjcmVhdGVEdWVDYXJkc01hcCIsInNpemUiLCJoYXMiLCJnZXQiLCJhbGxDYXJkcyIsInN0YXRzIiwiY2FsY3VsYXRlRHVlQ2FyZHNTdGF0cyIsInRvdGFsQ2FyZHMiLCJkdWVDb3VudCIsImR1ZVBlcmNlbnRhZ2UiLCJuZXh0RHVlQXQiLCJ0b0JlVHJ1dGh5IiwiYXZlcmFnZUludGVydmFsIiwidG9CZU51bGwiLCJuZXh0RHVlVGltZSIsImJyYW5kZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7OzswQkFXTTtBQUdQLGVBQWU7QUFDZixNQUFNQSxpQkFBaUIsQ0FBQ0MsSUFBWUMsZUFBd0MsQ0FBQTtRQUMxRUQ7UUFDQUM7UUFDQUMsZ0JBQWdCQyxLQUFLQyxHQUFHLEtBQUs7UUFDN0JDLFVBQVU7UUFDVkMsWUFBWTtRQUNaQyxTQUFTO1FBQ1RDLFFBQVE7SUFDVixDQUFBO0FBRUEsTUFBTUMsb0JBQW9CLENBQUNULEtBQTZCRCxlQUFlQyxJQUFJRyxLQUFLQyxHQUFHLEtBQUs7QUFDeEYsTUFBTU0sdUJBQXVCLENB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