{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/test/TestApiService.ts"],"sourcesContent":["/**\n * @file Test API Service - Clean interface for E2E tests\n * @version 1.0.0\n * @description Provides a dedicated service for test interactions,\n * separating test infrastructure from UI components.\n *\n * ARCHITECTURE PRINCIPLES:\n * - Single Responsibility: Only handles test interactions\n * - Clean Interface: Well-defined API for E2E tests\n * - No UI Coupling: Independent of component implementation\n * - Deterministic: Provides predictable test behavior\n */\n\nimport { Chess } from \"chess.js\";\nimport { TESTING } from \"@shared/constants\";\nimport { getLogger } from \"@shared/services/logging\";\n\nconst logger = getLogger().setContext(\"TestApiService\");\n\n/**\n * Test API Response types\n */\nexport interface TestMoveResponse {\n  success: boolean;\n  error?: string;\n  resultingFen?: string;\n  moveCount?: number;\n}\n\n/**\n * Game state information for test scenarios\n *\n * @interface TestGameState\n *\n * @property {string} fen - Current board position in FEN notation\n * @property {'w' | 'b'} turn - Current player to move (white or black)\n * @property {number} moveCount - Total number of moves made in the game\n * @property {string} pgn - Game in Portable Game Notation format\n * @property {boolean} isGameOver - Whether the game has ended\n * @property {string} [gameOverReason] - Reason for game termination if applicable\n * @property {string[]} history - List of moves in SAN notation\n * @property {number} [evaluation] - Current position evaluation if available\n * @property {boolean} isCheck - Whether the current player is in check\n * @property {boolean} isCheckmate - Whether the current player is checkmated\n * @property {boolean} isDraw - Whether the game is drawn\n * @property {object} [lastMove] - Details of the most recent move\n */\nexport interface TestGameState {\n  fen: string;\n  turn: \"w\" | \"b\";\n  moveCount: number;\n  pgn: string;\n  isGameOver: boolean;\n  gameOverReason?: string;\n  history: string[];\n  evaluation?: number;\n  isCheck: boolean;\n  isCheckmate: boolean;\n  isDraw: boolean;\n  lastMove?: {\n    from: string;\n    to: string;\n    san: string;\n  };\n}\n\n/**\n * Configuration options for test tablebase behavior\n *\n * @interface TestTablebaseConfig\n *\n * @property {boolean} [deterministic] - Whether tablebase should provide predictable responses\n * @property {number} [seed] - Random seed for deterministic behavior\n * @property {Map<string, string>} [fixedResponses] - Pre-defined responses for specific FEN positions\n * @property {number} [depth] - Analysis depth limit for tablebase calculations\n * @property {number} [timeLimit] - Time limit in milliseconds for tablebase responses\n */\nexport interface TestTablebaseConfig {\n  deterministic?: boolean;\n  seed?: number;\n  fixedResponses?: Map<string, string>;\n  depth?: number;\n  timeLimit?: number;\n}\n\n/**\n * Test API Service\n *\n * @class TestApiService\n * @description\n * Provides clean interface for E2E tests to interact with the chess game.\n * Implements singleton pattern for consistent test state management across\n * test scenarios while maintaining separation from UI components.\n *\n * @remarks\n * Key responsibilities:\n * - Game state management for test scenarios\n * - Move execution with bypass for test validation\n * - Tablebase configuration for deterministic behavior\n * - Event emission for test coordination\n * - Store integration without tight coupling\n * - Error handling with proper test feedback\n *\n * Architecture features:\n * - Singleton pattern for consistent state\n * - Store access through dependency injection\n * - Event-driven communication with tests\n * - Deterministic tablebase response handling\n * - Clean separation from UI layer\n *\n * @example\n * ```typescript\n * // Initialize test API with store access\n * const testApi = TestApiService.getInstance();\n * testApi.initialize(storeAccess, { deterministic: true });\n *\n * // Make moves and verify game state\n * await testApi.makeMove('e2-e4');\n * const state = testApi.getGameState();\n * expect(state.fen).toContain('e4');\n *\n * // Configure deterministic tablebase\n * testApi.configureTablebase({\n *   deterministic: true,\n *   fixedResponses: new Map([['fen1', 'Nf3']])\n * });\n * ```\n */\nexport class TestApiService {\n  private static instance: TestApiService | null = null;\n  private tablebaseConfig: TestTablebaseConfig = {\n    deterministic: false,\n  };\n  private eventEmitter: EventTarget = new EventTarget();\n  private _isInitialized: boolean = false;\n  // Tablebase control is now handled via TestBridge, not directly\n  private storeAccess: {\n    getState: () => any;\n    subscribe: (listener: (state: any, prevState: any) => void) => () => void;\n    // Individual action functions extracted from store state\n    makeMove: (move: any) => void;\n    _internalApplyMove: (move: any) => void;\n    resetPosition: () => void;\n    setPosition: (position: any) => void;\n    goToMove: (moveIndex: number) => void;\n    setAnalysisStatus: (status: string) => void;\n  } | null = null;\n\n  private constructor() {}\n\n  /**\n   * Get singleton instance of TestApiService\n   *\n   * @static\n   * @description\n   * Returns the singleton instance of TestApiService, creating it if\n   * it doesn't exist. Ensures consistent test state across all test\n   * scenarios and prevents multiple instances from interfering.\n   *\n   * @returns {TestApiService} The singleton TestApiService instance\n   *\n   * @example\n   * ```typescript\n   * const testApi = TestApiService.getInstance();\n   * await testApi.initialize(storeAccess);\n   * ```\n   */\n  public static getInstance(): TestApiService {\n    if (!TestApiService.instance) {\n      TestApiService.instance = new TestApiService();\n    }\n    return TestApiService.instance;\n  }\n\n  /**\n   * Initialize test API for a test session\n   * @param storeAccess\n   * @param storeAccess.getState\n   * @param storeAccess.subscribe\n   * @param storeAccess.makeMove\n   * @param storeAccess._internalApplyMove\n   * @param storeAccess.resetPosition\n   * @param storeAccess.setPosition\n   * @param storeAccess.goToMove\n   * @param storeAccess.setAnalysisStatus\n   * @param config\n   */\n  public initialize(\n    storeAccess: {\n      getState: () => any;\n      subscribe: (listener: (state: any, prevState: any) => void) => () => void;\n      // Individual action functions extracted from store state\n      makeMove: (move: any) => void;\n      _internalApplyMove: (move: any) => void;\n      resetPosition: () => void;\n      setPosition: (position: any) => void;\n      goToMove: (moveIndex: number) => void;\n      setAnalysisStatus: (status: string) => void;\n    },\n    config?: TestTablebaseConfig,\n  ): void {\n    // Validate required actions\n    if (!storeAccess.makeMove || !storeAccess.resetPosition) {\n      logger.error(\"Required store actions not available\");\n      this._isInitialized = false;\n      return;\n    }\n\n    this.storeAccess = storeAccess;\n    this._isInitialized = true;\n\n    if (config) {\n      this.tablebaseConfig = { ...this.tablebaseConfig, ...config };\n    }\n\n    logger.info(\n      \"âœ… TestApiService: Successfully initialized with store actions\",\n    );\n\n    // Emit initialization event\n    this.emit(\"test:initialized\", { config: this.tablebaseConfig });\n  }\n\n  /**\n   * Clean up test API after test session\n   *\n   * @description\n   * Resets the TestApiService to its initial state, clearing all\n   * configuration and store access. Should be called after each\n   * test to prevent state leakage between test scenarios.\n   *\n   * @remarks\n   * Cleanup operations:\n   * - Reset tablebase configuration to defaults\n   * - Clear store access references\n   * - Emit cleanup event for test coordination\n   * - Destroy singleton instance\n   *\n   * @example\n   * ```typescript\n   * // In test teardown\n   * testApi.cleanup();\n   * // Fresh instance will be created on next getInstance() call\n   * ```\n   */\n  public cleanup(): void {\n    this.tablebaseConfig = { deterministic: false };\n    this._isInitialized = false;\n    this.storeAccess = null;\n    this.emit(\"test:cleanup\", {});\n    TestApiService.instance = null;\n  }\n\n  /**\n   * Check if service is initialized and ready for use\n   *\n   * @description\n   * Returns whether the TestApiService has been properly initialized\n   * with store access and is ready to handle test operations.\n   *\n   * @returns {boolean} True if service is initialized and ready\n   *\n   * @example\n   * ```typescript\n   * if (!testApi.isInitialized) {\n   *   await testApi.initialize(storeAccess);\n   * }\n   * ```\n   */\n  public get isInitialized(): boolean {\n    return this._isInitialized;\n  }\n\n  /**\n   * Make a chess move through full validation pipeline (like real user interaction)\n   * @param move - Move in format 'from-to' (e.g., 'e2-e4') or SAN notation\n   * @returns Promise resolving to move execution result with validation\n   */\n  public async makeValidatedMove(move: string): Promise<TestMoveResponse> {\n    if (!this.storeAccess) {\n      throw new Error(\"TestApiService not initialized with store access\");\n    }\n\n    try {\n      // Parse move format\n      let moveObj: { from: string; to: string; promotion?: string } | string;\n\n      if (move.includes(\"-\")) {\n        // Format: 'e2-e4'\n        const [from, to] = move.split(\"-\");\n        moveObj = { from, to };\n      } else {\n        // SAN notation\n        moveObj = move;\n      }\n\n      // Import handlePlayerMove directly (it's not part of store, it's an orchestrator)\n      const { handlePlayerMove } = await import(\n        \"@shared/store/orchestrators/handlePlayerMove\"\n      );\n\n      // Create a store API object that handlePlayerMove expects (like in rootStore.ts:186)\n      const storeApi = {\n        getState: this.storeAccess.getState,\n        setState: (updater: any) => {\n          // We need the actual setState from store access - this is the key fix\n          // The storeAccess should provide the actual Zustand setState method\n          if (this.storeAccess && \"setState\" in this.storeAccess) {\n            // If storeAccess provides setState directly\n            (this.storeAccess as any).setState(updater);\n          } else {\n            // Fallback - log warning but don't fail\n            logger.warn(\n              \"TestApiService: setState not available in storeAccess - state updates may not work\",\n            );\n          }\n        },\n      };\n\n      // Execute move through the FULL validation pipeline\n      const result = await handlePlayerMove(storeApi, moveObj);\n\n      // Get final state after move processing\n      const finalState = this.storeAccess.getState();\n\n      this.emit(\"test:validated_move\", {\n        move,\n        success: result,\n        fen: finalState.game?.currentFen || finalState.currentFen || \"unknown\",\n        moveCount: finalState.game?.moveHistory?.length || 0,\n      });\n\n      return {\n        success: result,\n        resultingFen:\n          finalState.game?.currentFen || finalState.currentFen || \"unknown\",\n        moveCount: finalState.game?.moveHistory?.length || 0,\n        error: result ? undefined : \"Move rejected by validation pipeline\",\n      };\n    } catch (error) {\n      logger.error(\"TestApiService.makeValidatedMove error:\", error);\n      return {\n        success: false,\n        error: `Error: ${error instanceof Error ? error.message : String(error)}`,\n      };\n    }\n  }\n\n  /**\n   * Make a chess move (bypasses validation for fast test setup)\n   * @param move - Move in format 'from-to' (e.g., 'e2-e4') or SAN notation\n   * @deprecated Use makeValidatedMove for behavior testing, this is for setup only\n   */\n  public async makeMove(move: string): Promise<TestMoveResponse> {\n    if (!this.storeAccess) {\n      throw new Error(\"TestApiService not initialized with store access\");\n    }\n\n    try {\n      // Parse move format\n      let moveObj: { from: string; to: string; promotion?: string } | string;\n\n      if (move.includes(\"-\")) {\n        // Format: 'e2-e4'\n        const [from, to] = move.split(\"-\");\n        moveObj = { from, to };\n      } else {\n        // SAN notation\n        moveObj = move;\n      }\n\n      // Execute move through store actions (bypass validation for tests)\n      this.storeAccess._internalApplyMove(moveObj);\n      const success = true; // makeMove is synchronous in Zustand\n\n      if (success) {\n        const newState = this.storeAccess.getState();\n\n        // Check if deterministic mode is enabled and if we should mock tablebase response\n        if (\n          this.tablebaseConfig.deterministic &&\n          this.tablebaseConfig.fixedResponses\n        ) {\n          // After player move, check if tablebase should respond with a fixed move\n          await this.handleDeterministicTablebaseMove(newState.fen);\n        }\n\n        this.emit(\"test:move\", {\n          move,\n          fen: newState.training?.currentFen || newState.fen,\n          moveCount:\n            newState.training?.moveHistory?.length ||\n            newState.history?.length ||\n            0,\n        });\n\n        // Get updated state after potential tablebase move\n        const finalState = this.storeAccess.getState();\n\n        return {\n          success: true,\n          resultingFen:\n            finalState.game?.currentFen || finalState.currentFen || \"unknown\",\n          moveCount: finalState.game?.moveHistory?.length || 0,\n        };\n      } else {\n        return {\n          success: false,\n          error: \"Invalid move\",\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n\n  /**\n   * Get current game state for test verification\n   *\n   * @description\n   * Returns comprehensive game state information for test assertions\n   * and verification. Constructs a detailed game state object from\n   * the current store state with all relevant chess game information.\n   *\n   * @returns {TestGameState} Current game state with position, moves, and status\n   *\n   * @throws {Error} If service is not initialized with store access\n   *\n   * @example\n   * ```typescript\n   * const state = testApi.getGameState();\n   * expect(state.fen).toBe('expected-fen');\n   * expect(state.turn).toBe('w');\n   * expect(state.moveCount).toBe(2);\n   * expect(state.isCheck).toBe(false);\n   * ```\n   */\n  public getGameState(): TestGameState {\n    if (!this.storeAccess) {\n      throw new Error(\"TestApiService not initialized with store access\");\n    }\n\n    const state = this.storeAccess.getState();\n    const currentFen =\n      state.training?.currentFen ||\n      state.fen ||\n      \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\";\n    const game = new Chess(currentFen);\n\n    // Get last move if available\n    const history = state.training?.moveHistory || state.history || [];\n    let lastMove;\n    if (history.length > 0) {\n      const lastHistoryItem = history[history.length - 1];\n      lastMove = {\n        from: lastHistoryItem.from || \"\",\n        to: lastHistoryItem.to || \"\",\n        san: lastHistoryItem.san,\n      };\n    }\n\n    return {\n      fen: currentFen,\n      turn: game.turn(),\n      moveCount: history.length,\n      pgn: game.pgn(),\n      isGameOver: game.isGameOver(),\n      gameOverReason: this.getGameOverReason(game),\n      history: history.map((h: any) => h.san),\n      evaluation:\n        state.training?.currentEvaluation?.evaluation ||\n        state.evaluation?.engineEvaluation?.value,\n      isCheck: game.isCheck(),\n      isCheckmate: game.isCheckmate(),\n      isDraw: game.isDraw(),\n      lastMove,\n    };\n  }\n\n  /**\n   * Reset game to initial position\n   *\n   * @description\n   * Resets the chess game to its initial starting position, clearing\n   * all move history and returning to the standard opening setup.\n   * Useful for test scenarios that need a clean game state.\n   *\n   * @returns {Promise<void>} Promise that resolves when reset is complete\n   *\n   * @throws {Error} If service is not initialized with store access\n   *\n   * @example\n   * ```typescript\n   * // Reset before starting a new test scenario\n   * await testApi.resetGame();\n   * const state = testApi.getGameState();\n   * expect(state.fen).toBe('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1');\n   * ```\n   */\n  public async resetGame(): Promise<void> {\n    if (!this.storeAccess) {\n      throw new Error(\"TestApiService not initialized with store access\");\n    }\n\n    this.storeAccess.resetPosition();\n    this.emit(\"test:reset\", {});\n  }\n\n  /**\n   * Configure tablebase for deterministic behavior\n   * @param config\n   */\n  public configureTablebase(config: TestTablebaseConfig): void {\n    this.tablebaseConfig = { ...this.tablebaseConfig, ...config };\n    this.emit(\"test:tablebaseConfigured\", { config: this.tablebaseConfig });\n\n    // Note: TestBridge system already handles configuration propagation\n    // to the actual tablebase instance for deterministic test behavior\n  }\n\n  /**\n   * Trigger tablebase analysis for current position\n   * @param timeoutMs - Maximum time to wait (for mock tablebase this is instant)\n   *\n   * Note: In the new architecture, tablebase analysis happens automatically\n   * through the store when moves are made. This method now just waits\n   * for the tablebase status to become ready.\n   */\n  public async triggerTablebaseAnalysis(\n    timeoutMs: number = TESTING.DEFAULT_TIMEOUT,\n  ): Promise<boolean> {\n    if (!this.storeAccess) {\n      throw new Error(\"TestApiService not initialized\");\n    }\n\n    try {\n      const startTime = Date.now();\n\n      // Wait for tablebase to be ready\n      while (Date.now() - startTime < timeoutMs) {\n        const state = this.storeAccess.getState();\n        const analysisStatus = state.tablebase?.analysisStatus || \"idle\";\n\n        if (analysisStatus === \"idle\" || analysisStatus === \"success\") {\n          // Tablebase is working or has finished\n          this.emit(\"test:tablebaseAnalysisComplete\", {\n            fen: state.game?.currentFen || state.currentFen,\n          });\n          return true;\n        }\n\n        // Wait a bit before checking again\n        await new Promise((resolve) =>\n          setTimeout(resolve, TESTING.POLL_INTERVAL),\n        );\n      }\n\n      // Timeout reached\n      logger.warn(\"Tablebase analysis timeout after\", { timeoutMs });\n      return false;\n    } catch (error) {\n      logger.error(\"Tablebase analysis check failed\", error);\n      this.emit(\"test:tablebaseError\", {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Subscribe to test events\n   * @param event\n   * @param handler\n   */\n  public on(event: string, handler: (detail: any) => void): void {\n    this.eventEmitter.addEventListener(event, (e: any) => handler(e.detail));\n  }\n\n  /**\n   * Unsubscribe from test events\n   * @param event\n   * @param handler\n   */\n  public off(event: string, handler: (detail: any) => void): void {\n    this.eventEmitter.removeEventListener(event, (e: any) => handler(e.detail));\n  }\n\n  /**\n   * Emit test event\n   * @param event\n   * @param detail\n   */\n  private emit(event: string, detail: any): void {\n    this.eventEmitter.dispatchEvent(new CustomEvent(event, { detail }));\n  }\n\n  /**\n   * Handle deterministic tablebase move in mock mode\n   * @param currentFen\n   */\n  private async handleDeterministicTablebaseMove(\n    currentFen: string,\n  ): Promise<void> {\n    if (!this.storeAccess || !this.tablebaseConfig.fixedResponses) {\n      return;\n    }\n\n    // Check if we have a fixed response for this position\n    const tablebaseMove = this.tablebaseConfig.fixedResponses.get(currentFen);\n\n    if (tablebaseMove) {\n      // Wait a bit to simulate tablebase thinking time (optional)\n      if (\n        this.tablebaseConfig.timeLimit &&\n        this.tablebaseConfig.timeLimit > 0\n      ) {\n        await new Promise((resolve) =>\n          setTimeout(resolve, this.tablebaseConfig.timeLimit),\n        );\n      }\n\n      // Make the deterministic tablebase move\n      try {\n        // Use direct makeMove for test bypass\n        if (this.storeAccess.makeMove) {\n          this.storeAccess.makeMove(tablebaseMove);\n        }\n        this.emit(\"test:tablebaseMove\", {\n          move: tablebaseMove,\n          fen: currentFen,\n          deterministic: true,\n        });\n      } catch (error) {\n        logger.warn(\"Deterministic tablebase move failed\", {\n          tablebaseMove,\n          position: currentFen,\n          error,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get game over reason\n   * @param game\n   */\n  private getGameOverReason(game: Chess): string | undefined {\n    if (!game.isGameOver()) return undefined;\n\n    if (game.isCheckmate()) return \"checkmate\";\n    if (game.isDraw()) {\n      if (game.isStalemate()) return \"stalemate\";\n      if (game.isThreefoldRepetition()) return \"threefold repetition\";\n      if (game.isInsufficientMaterial()) return \"insufficient material\";\n      return \"draw\";\n    }\n\n    return \"game over\";\n  }\n}\n\n/**\n * Convenience function to get TestApiService singleton instance\n *\n * @description\n * Provides a convenient way to access the TestApiService singleton\n * instance without having to call the full static method name.\n *\n * @returns {TestApiService} The singleton TestApiService instance\n *\n * @example\n * ```typescript\n * const testApi = getTestApi();\n * await testApi.initialize(storeAccess);\n * ```\n */\nexport const getTestApi = () => TestApiService.getInstance();\n"],"names":["TestApiService","getTestApi","logger","getLogger","setContext","getInstance","instance","initialize","storeAccess","config","makeMove","resetPosition","error","_isInitialized","tablebaseConfig","info","emit","cleanup","deterministic","isInitialized","makeValidatedMove","move","Error","finalState","moveObj","includes","from","to","split","handlePlayerMove","storeApi","getState","setState","updater","warn","result","success","fen","game","currentFen","moveCount","moveHistory","length","resultingFen","undefined","message","String","_internalApplyMove","newState","fixedResponses","handleDeterministicTablebaseMove","training","history","getGameState","state","Chess","lastMove","lastHistoryItem","san","turn","pgn","isGameOver","gameOverReason","getGameOverReason","map","h","evaluation","currentEvaluation","engineEvaluation","value","isCheck","isCheckmate","isDraw","resetGame","configureTablebase","triggerTablebaseAnalysis","timeoutMs","TESTING","DEFAULT_TIMEOUT","startTime","Date","now","analysisStatus","tablebase","Promise","resolve","setTimeout","POLL_INTERVAL","on","event","handler","eventEmitter","addEventListener","e","detail","off","removeEventListener","dispatchEvent","CustomEvent","tablebaseMove","get","timeLimit","position","isStalemate","isThreefoldRepetition","isInsufficientMaterial","EventTarget"],"mappings":"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"}