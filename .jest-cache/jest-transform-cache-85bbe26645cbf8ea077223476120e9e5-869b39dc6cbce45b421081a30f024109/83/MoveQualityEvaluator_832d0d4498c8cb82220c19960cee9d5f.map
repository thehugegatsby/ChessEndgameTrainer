{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/orchestrators/handlePlayerMove/MoveQualityEvaluator.ts"],"sourcesContent":["/**\n * @file Move quality evaluation module\n * @module store/orchestrators/handlePlayerMove/MoveQualityEvaluator\n *\n * @description\n * Evaluates chess move quality using tablebase analysis.\n * Compares player moves against optimal tablebase recommendations to determine\n * if moves are suboptimal and warrant user feedback through error dialogs.\n *\n * @remarks\n * Key features:\n * - Parallel tablebase API calls for performance\n * - WDL (Win/Draw/Loss) perspective conversion for accurate evaluation\n * - Best move comparison against top 3 tablebase recommendations\n * - Outcome change detection (Win->Draw/Loss, Draw->Loss)\n * - Comprehensive logging for debugging move evaluation logic\n *\n * @example\n * ```typescript\n * const evaluator = new MoveQualityEvaluator();\n * const result = await evaluator.evaluateMoveQuality(\n *   \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\",\n *   \"rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1\",\n *   { from: \"e2\", to: \"e4\", san: \"e4\", color: \"w\" }\n * );\n * if (result.shouldShowErrorDialog) {\n *   // Show error dialog to user\n * }\n * ```\n */\n\nimport type { ValidatedMove } from \"@shared/types/chess\";\nimport {\n  tablebaseService,\n  type TablebaseEvaluation,\n  type TablebaseMovesResult,\n} from \"@shared/services/TablebaseService\";\nimport { getLogger } from \"@shared/services/logging\";\n\n/**\n * Result of move quality evaluation containing recommendation data\n * @interface MoveQualityResult\n */\nexport interface MoveQualityResult {\n  /** Whether to display an error dialog to the user */\n  shouldShowErrorDialog: boolean;\n  /** WDL value before the move (from white's perspective) */\n  wdlBefore?: number;\n  /** WDL value after the move (from white's perspective) */\n  wdlAfter?: number;\n  /** Best recommended move in algebraic notation */\n  bestMove?: string;\n  /** Whether the played move was among the optimal moves */\n  wasOptimal: boolean;\n  /** Whether the move significantly changed the game outcome */\n  outcomeChanged: boolean;\n}\n\n/** Number of top moves to fetch from tablebase for comparison */\nconst TOP_MOVES_LIMIT = 3;\n\n/**\n * Evaluates chess move quality using advanced tablebase analysis\n * @class MoveQualityEvaluator\n *\n * @description\n * Provides comprehensive move quality assessment including:\n * - Tablebase evaluation comparison (before/after positions)\n * - WDL perspective conversion for accurate player-centric evaluation\n * - Best move detection using top tablebase recommendations\n * - Outcome change analysis (Win/Draw/Loss transitions)\n * - Performance-optimized parallel API calls\n * - Detailed logging for debugging evaluation decisions\n *\n * @remarks\n * The evaluator uses sophisticated logic to determine when to show error dialogs:\n * 1. Move must NOT be among the top 3 tablebase recommendations\n * 2. Move must cause a significant outcome change (Win->Draw/Loss or Draw->Loss)\n *\n * WDL (Win/Draw/Loss) values are handled carefully:\n * - Tablebase returns values from white's perspective\n * - Values are converted to moving player's perspective\n * - After a move, evaluation is from opponent's perspective\n *\n * @example\n * ```typescript\n * const evaluator = new MoveQualityEvaluator();\n *\n * // Evaluate a potentially suboptimal move\n * const result = await evaluator.evaluateMoveQuality(\n *   fenBefore,\n *   fenAfter,\n *   playedMove\n * );\n *\n * if (result.shouldShowErrorDialog) {\n *   console.log(`Suboptimal move! Best was: ${result.bestMove}`);\n *   console.log(`WDL change: ${result.wdlBefore} -> ${result.wdlAfter}`);\n * }\n * ```\n */\nexport class MoveQualityEvaluator {\n  /**\n   * Evaluates the quality of a played move against tablebase recommendations\n   *\n   * @param fenBefore - FEN position before the move\n   * @param fenAfter - FEN position after the move\n   * @param validatedMove - The move that was played\n   * @param trainingBaseline - Optional evaluation baseline for training context\n   * @returns Quality evaluation result\n   */\n  async evaluateMoveQuality(\n    fenBefore: string,\n    fenAfter: string,\n    validatedMove: ValidatedMove,\n    trainingBaseline?: { wdl: number; fen: string } | null,\n  ): Promise<MoveQualityResult> {\n    try {\n      // Get evaluations before and after the move in parallel for better performance\n      const [evalBefore, evalAfter] = await Promise.all([\n        this.getEvaluation(fenBefore),\n        this.getEvaluation(fenAfter),\n      ]);\n\n      // Check if both evaluations are available\n      if (!this.areEvaluationsValid(evalBefore, evalAfter)) {\n        getLogger().debug(\n          \"[MoveQuality] Skipping evaluation - insufficient data:\",\n          {\n            evalBeforeAvailable: evalBefore?.isAvailable,\n            evalAfterAvailable: evalAfter?.isAvailable,\n            hasBeforeResult: evalBefore && \"result\" in evalBefore,\n            hasAfterResult: evalAfter && \"result\" in evalAfter,\n          },\n        );\n\n        return {\n          shouldShowErrorDialog: false,\n          wasOptimal: false, // Conservative - if we can't evaluate, don't assume optimal\n          outcomeChanged: false,\n        };\n      }\n\n      const wdlBefore = evalBefore.result!.wdl;\n      const wdlAfter = evalAfter.result!.wdl;\n\n      getLogger().debug(\"[MoveQuality] Evaluating move quality:\", {\n        moveColor: validatedMove.color,\n        moveSan: validatedMove.san,\n        wdlBefore,\n        wdlAfter,\n        fenBefore: fenBefore.split(\" \")[0], // Just board position\n        fenAfter: fenAfter.split(\" \")[0],\n      });\n\n      // Convert WDL values to player perspective\n      const { wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective } =\n        this.convertToPlayerPerspective(wdlBefore, wdlAfter);\n\n      // Determine effective baseline for comparison\n      const effectiveWdlBefore = this.determineEffectiveBaseline(\n        trainingBaseline,\n        wdlBeforeFromPlayerPerspective\n      );\n\n      getLogger().debug(\"[MoveQuality] WDL evaluation context:\", {\n        wdlBeforeFromPlayerPerspective,\n        wdlAfterFromPlayerPerspective,\n        trainingBaselineWdl: trainingBaseline?.wdl,\n        effectiveWdlBefore,\n        usingBaseline: !!trainingBaseline,\n      });\n\n      // Get best moves for comparison\n      const topMoves = await tablebaseService\n        .getTopMoves(fenBefore, TOP_MOVES_LIMIT)\n        .catch(() => ({ isAvailable: false, moves: [] }));\n\n      // Check if the played move was one of the best moves\n      const playedMoveWasBest = this.wasMoveBest(topMoves, validatedMove.san);\n\n      this.logBestMovesComparison(\n        topMoves,\n        validatedMove.san,\n        playedMoveWasBest,\n      );\n\n      // Determine if outcome changed significantly - use baseline if available\n      const outcomeChanged = this.didOutcomeChange(\n        effectiveWdlBefore,\n        wdlAfterFromPlayerPerspective,\n      );\n\n      this.logDecisionValues(\n        outcomeChanged,\n        playedMoveWasBest,\n        effectiveWdlBefore,\n        wdlAfterFromPlayerPerspective,\n      );\n\n      const shouldShowErrorDialog = this.shouldShowErrorDialog(\n        playedMoveWasBest,\n        outcomeChanged\n      );\n      const bestMove = this.getBestMove(topMoves);\n\n      getLogger().info(\"[MoveQuality] Decision to show error dialog:\", {\n        shouldShowErrorDialog,\n        playedMoveWasBest,\n        outcomeChanged,\n        effectiveWdlBefore,\n        wdlAfterFromPlayerPerspective,\n        usingBaseline: !!trainingBaseline,\n        validatedMove: validatedMove.san,\n        bestMove,\n      });\n\n      if (shouldShowErrorDialog) {\n        getLogger().info(\n          \"[MoveQuality] Move quality issue detected - suggesting error dialog\",\n        );\n      }\n\n      return {\n        shouldShowErrorDialog,\n        wdlBefore,\n        wdlAfter,\n        bestMove,\n        wasOptimal: playedMoveWasBest,\n        outcomeChanged,\n      };\n    } catch (error) {\n      getLogger().error(\"Move quality evaluation failed:\", error);\n      return {\n        shouldShowErrorDialog: false,\n        wasOptimal: false, // Conservative - don't assume optimal on evaluation failure\n        outcomeChanged: false,\n      };\n    }\n  }\n\n  /**\n   * Gets tablebase evaluation for a position with error handling\n   */\n  private async getEvaluation(fen: string): Promise<TablebaseEvaluation> {\n    return await tablebaseService\n      .getEvaluation(fen)\n      .catch(() => ({ isAvailable: false }));\n  }\n\n  /**\n   * Validates that both evaluations are available and have results\n   */\n  private areEvaluationsValid(\n    evalBefore: TablebaseEvaluation,\n    evalAfter: TablebaseEvaluation,\n  ): boolean {\n    return this.hasValidResult(evalBefore) && this.hasValidResult(evalAfter);\n  }\n\n  /**\n   * Checks if a single evaluation has a valid result\n   */\n  private hasValidResult(evaluation: TablebaseEvaluation): boolean {\n    return (\n      evaluation.isAvailable &&\n      \"result\" in evaluation &&\n      !!evaluation.result\n    );\n  }\n\n  /**\n   * Converts WDL values from the Lichess Tablebase API to a consistent perspective\n   * for the player who just moved.\n   *\n   * @remarks\n   * The Lichess Tablebase API returns WDL from the perspective of the side whose turn it is\n   * (the side-to-move perspective). This is standard behavior for chess tablebases and engines.\n   *\n   * - `wdlBefore`: The WDL score before the move was made. This is from the perspective\n   *   of the player making the move (they were the side-to-move).\n   * - `wdlAfter`: The WDL score after the move was made. The turn has now passed to the\n   *   opponent, so this score is from the opponent's perspective.\n   *\n   * Therefore, to maintain the original player's perspective for comparison:\n   * - `wdlBefore` needs no conversion (already from player's perspective)\n   * - `wdlAfter` must be negated (convert from opponent's to player's perspective)\n   *\n   * @param wdlBefore The WDL score for the position before the move\n   * @param wdlAfter The WDL score for the position after the move\n   * @returns An object with both WDL values from the original player's perspective\n   *\n   * @example\n   * // Black plays a losing move (Kd7 instead of drawing Ke7)\n   * // wdlBefore = 0 (draw from Black's perspective as side-to-move)\n   * // wdlAfter = 1000 (win from White's perspective as side-to-move)\n   * // Returns: { wdlBeforeFromPlayerPerspective: 0, wdlAfterFromPlayerPerspective: -1000 }\n   * // This correctly shows Black went from draw (0) to loss (-1000)\n   */\n  private convertToPlayerPerspective(wdlBefore: number, wdlAfter: number) {\n    // wdlBefore is already from the moving player's perspective (side-to-move)\n    const wdlBeforeFromPlayerPerspective = wdlBefore;\n\n    // wdlAfter is from opponent's perspective (they are now side-to-move)\n    // We need to negate it to get the moving player's perspective\n    const wdlAfterFromPlayerPerspective = -wdlAfter;\n\n    return { wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective };\n  }\n\n  /**\n   * Checks if the played move was among the best moves\n   */\n  private wasMoveBest(\n    topMoves: TablebaseMovesResult,\n    playedMoveSan: string,\n  ): boolean {\n    if (!this.hasAvailableMoves(topMoves)) {\n      return false;\n    }\n    return topMoves.moves!.some((m) => m.san === playedMoveSan);\n  }\n\n  /**\n   * Checks if tablebase moves are available\n   */\n  private hasAvailableMoves(topMoves: TablebaseMovesResult): boolean {\n    return topMoves.isAvailable && !!topMoves.moves && topMoves.moves.length > 0;\n  }\n\n  /**\n   * Determines if the move outcome changed significantly\n   */\n  private didOutcomeChange(\n    wdlBeforeFromPlayerPerspective: number,\n    wdlAfterFromPlayerPerspective: number,\n  ): boolean {\n    const winTurnedIntoDrawOrLoss = this.isWinToDrawOrLoss(\n      wdlBeforeFromPlayerPerspective,\n      wdlAfterFromPlayerPerspective\n    );\n    const drawTurnedIntoLoss = this.isDrawToLoss(\n      wdlBeforeFromPlayerPerspective,\n      wdlAfterFromPlayerPerspective\n    );\n    \n    return winTurnedIntoDrawOrLoss || drawTurnedIntoLoss;\n  }\n\n  /**\n   * Checks if a winning position turned into a draw or loss\n   */\n  private isWinToDrawOrLoss(wdlBefore: number, wdlAfter: number): boolean {\n    return wdlBefore > 0 && wdlAfter <= 0;\n  }\n\n  /**\n   * Checks if a drawn position turned into a loss\n   */\n  private isDrawToLoss(wdlBefore: number, wdlAfter: number): boolean {\n    return wdlBefore === 0 && wdlAfter < 0;\n  }\n\n  /**\n   * Gets the best move from top moves result\n   */\n  private getBestMove(topMoves: TablebaseMovesResult): string | undefined {\n    return topMoves.isAvailable && topMoves.moves && topMoves.moves.length > 0\n      ? topMoves.moves[0].san\n      : undefined;\n  }\n\n  /**\n   * Logs best moves comparison for debugging\n   */\n  private logBestMovesComparison(\n    topMoves: TablebaseMovesResult,\n    playedMoveSan: string,\n    playedMoveWasBest: boolean,\n  ): void {\n    getLogger().info(\"[MoveQuality] Best moves check:\");\n    getLogger().info(\"  topMovesAvailable:\", topMoves.isAvailable);\n    getLogger().info(\n      \"  bestMoves:\",\n      JSON.stringify(topMoves.moves?.map((m) => m.san)),\n    );\n    getLogger().info(\"  playedMove:\", playedMoveSan);\n    getLogger().info(\"  playedMoveWasBest:\", playedMoveWasBest);\n\n    // Debug each move comparison\n    if (topMoves.moves) {\n      getLogger().debug(\"  Comparing each move:\");\n      topMoves.moves.forEach((m, i) => {\n        getLogger().debug(\n          `    Move ${i}: \"${m.san}\" === \"${playedMoveSan}\" ? ${m.san === playedMoveSan}`,\n        );\n      });\n    }\n  }\n\n  /**\n   * Determines the effective baseline for comparison\n   */\n  private determineEffectiveBaseline(\n    trainingBaseline: { wdl: number; fen: string } | null | undefined,\n    wdlBeforeFromPlayerPerspective: number\n  ): number {\n    return trainingBaseline?.wdl ?? wdlBeforeFromPlayerPerspective;\n  }\n\n  /**\n   * Determines if error dialog should be shown based on move quality\n   */\n  private shouldShowErrorDialog(\n    playedMoveWasBest: boolean,\n    outcomeChanged: boolean\n  ): boolean {\n    return !playedMoveWasBest && outcomeChanged;\n  }\n\n  /**\n   * Logs decision values for debugging\n   */\n  private logDecisionValues(\n    outcomeChanged: boolean,\n    playedMoveWasBest: boolean,\n    effectiveWdlBefore: number,\n    wdlAfterFromPlayerPerspective: number,\n  ): void {\n    getLogger().debug(\"[MoveQuality] DECISION VALUES:\");\n    getLogger().debug(\"  outcomeChanged:\", outcomeChanged);\n    getLogger().debug(\"  playedMoveWasBest:\", playedMoveWasBest);\n    getLogger().debug(\n      \"  effectiveWdlBefore:\",\n      effectiveWdlBefore,\n    );\n    getLogger().debug(\n      \"  wdlAfterFromPlayerPerspective:\",\n      wdlAfterFromPlayerPerspective,\n    );\n    getLogger().debug(\"  showDialog:\", !playedMoveWasBest && outcomeChanged);\n  }\n}\n"],"names":["MoveQualityEvaluator","TOP_MOVES_LIMIT","evaluateMoveQuality","fenBefore","fenAfter","validatedMove","trainingBaseline","evalBefore","evalAfter","Promise","all","getEvaluation","areEvaluationsValid","getLogger","debug","evalBeforeAvailable","isAvailable","evalAfterAvailable","hasBeforeResult","hasAfterResult","shouldShowErrorDialog","wasOptimal","outcomeChanged","wdlBefore","result","wdl","wdlAfter","moveColor","color","moveSan","san","split","wdlBeforeFromPlayerPerspective","wdlAfterFromPlayerPerspective","convertToPlayerPerspective","effectiveWdlBefore","determineEffectiveBaseline","trainingBaselineWdl","usingBaseline","topMoves","tablebaseService","getTopMoves","catch","moves","playedMoveWasBest","wasMoveBest","logBestMovesComparison","didOutcomeChange","logDecisionValues","bestMove","getBestMove","info","error","fen","hasValidResult","evaluation","playedMoveSan","hasAvailableMoves","some","m","length","winTurnedIntoDrawOrLoss","isWinToDrawOrLoss","drawTurnedIntoLoss","isDrawToLoss","undefined","JSON","stringify","map","forEach","i"],"mappings":"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"}