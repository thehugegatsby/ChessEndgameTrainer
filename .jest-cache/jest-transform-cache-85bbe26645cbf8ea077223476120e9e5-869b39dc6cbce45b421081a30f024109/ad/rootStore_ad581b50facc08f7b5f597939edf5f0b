0333947ab6910caeb755de827b6f763c
/**
 * @file Root store assembly for refactored Zustand architecture
 * @module store/rootStore
 * @description Combines all domain-specific slices into a unified store with middleware
 * integration. Uses a clean, maintainable architecture with domain-driven slices.
 *
 * @example
 * ```typescript
 * // Using the refactored store
 * import { useStore } from '@/store/rootStore';
 *
 * function MyComponent() {
 *   const restartRequired = useStore(state => state.restartRequired);
 *   const clearRestart = useStore(state => state.clearRestartRequired);
 *   const makeMove = useStore(state => state.handlePlayerMove);
 *
 *   return (
 *     <div>
 *       {restartRequired && <div>App restart required</div>}
 *       <button onClick={() => makeMove({ from: 'e2', to: 'e4' })}>
 *         Make Move
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get /**
 * Hook for accessing the complete store state and actions
 *
 * @remarks
 * This is the main hook for accessing the store. It provides access to:
 * - All slice state and actions (Game, Training, Tablebase, Progress, UI, Settings, User)
 * - Orchestrator actions for complex operations
 * - Global reset and hydration methods
 *
 * For performance-sensitive components, consider using specific selectors
 * to avoid unnecessary re-renders when unrelated state changes.
 *
 * @example
 * ```typescript
 * // Full store access
 * const store = useStore();
 *
 * // Selective access (better performance)
 * const restartRequired = useStore(state => state.restartRequired);
 * const clearRestart = useStore(state => state.clearRestartRequired);
 *
 * // Training state access (replaces useTrainingState hook)
 * const currentPosition = useStore(state => state.currentPosition);
 * const isPlayerTurn = useStore(state => state.isPlayerTurn);
 * const setPlayerTurn = useStore(state => state.setPlayerTurn);
 *
 * // Game state access
 * const currentFen = useStore(state => state.currentFen);
 * const makeMove = useStore(state => state.makeMove);
 *
 * // Multiple selections with useShallow for complex objects
 * import { useShallow } from 'zustand/react/shallow';
 * const { currentPosition, isPlayerTurn, hintsUsed } = useStore(
 *   useShallow(state => ({
 *     currentPosition: state.currentPosition,
 *     isPlayerTurn: state.isPlayerTurn,
 *     hintsUsed: state.hintsUsed
 *   }))
 * );
 * ```
 */ default () {
        return _default;
    },
    get store () {
        return store;
    },
    get useStore () {
        return useStore;
    }
});
const _zustand = require("zustand");
const _middleware = require("zustand/middleware");
const _immer = require("zustand/middleware/immer");
const _gameSlice = require("./slices/gameSlice");
const _tablebaseSlice = require("./slices/tablebaseSlice");
const _trainingSlice = require("./slices/trainingSlice");
const _progressSlice = require("./slices/progressSlice");
const _uiSlice = require("./slices/uiSlice");
const _ChessService = require("../services/ChessService");
const _Logger = require("../services/logging/Logger");
const _loadTrainingContext = require("./orchestrators/loadTrainingContext");
const _index = require("./orchestrators/handlePlayerMove/index");
// Initial state creation removed - slices are initialized directly in store
/**
 * Safe storage adapter that gracefully handles localStorage errors
 * This prevents warnings in E2E tests and other restricted environments
 * while maintaining functionality in normal browser environments
 */ const safeStorage = {
    getItem: (name)=>{
        try {
            if (typeof window === "undefined") return null;
            return localStorage.getItem(name);
        } catch  {
            // Silently fail in restricted environments (E2E tests, etc.)
            return null;
        }
    },
    setItem: (name, value)=>{
        try {
            if (typeof window === "undefined") return;
            localStorage.setItem(name, value);
        } catch  {
        // Silently fail in restricted environments
        // This prevents warnings in E2E tests where localStorage exists but throws
        }
    },
    removeItem: (name)=>{
        try {
            if (typeof window === "undefined") return;
            localStorage.removeItem(name);
        } catch  {
        // Silently fail in restricted environments
        }
    }
};
const useStore = (0, _zustand.create)()((0, _middleware.devtools)((0, _middleware.persist)((0, _immer.immer)((set, get, store)=>{
    // Create slices using Slice-in-Slice pattern (clean separation of state and actions)
    const gameSlice = (0, _gameSlice.createGameSlice)(set, get, store);
    const progressSlice = (0, _progressSlice.createProgressSlice)(set, get, store);
    const uiSlice = (0, _uiSlice.createUISlice)(set, get, store);
    return {
        // Clean Slice-in-Slice pattern: state and actions preserved at slice level
        game: gameSlice,
        training: {
            ...(0, _trainingSlice.createTrainingState)(),
            ...(0, _trainingSlice.createTrainingActions)(set, get)
        },
        tablebase: {
            ...(0, _tablebaseSlice.createTablebaseState)(),
            ...(0, _tablebaseSlice.createTablebaseActions)(set)
        },
        progress: progressSlice,
        ui: uiSlice,
        // Orchestrator actions - coordinate across multiple slices
        /**
           * Makes a user move with full validation and tablebase integration
           *
           * @param {ChessJsMove | {from: string; to: string; promotion?: string} | string} move - The move to make
           * @returns {Promise<boolean>} Whether the move was successful
           *
           * @remarks
           * This orchestrator coordinates across multiple slices:
           * - Validates move through Game slice
           * - Updates Training slice with move result
           * - Requests tablebase analysis via Tablebase slice
           * - Updates Progress slice with attempt data
           * - Shows UI feedback for errors
           *
           * @example
           * ```typescript
           * const handlePlayerMove = useStore(state => state.handlePlayerMove);
           *
           * const handleMove = async (from: string, to: string) => {
           *   const success = await handlePlayerMove({ from, to });
           *   if (success) {
           *     logger.info('Move completed successfully');
           *   }
           * };
           * ```
           */ handlePlayerMove: async (move)=>{
            const logger = (0, _Logger.getLogger)().setContext("RootStore");
            logger.debug("handlePlayerMove called", {
                move
            });
            const storeApi = {
                getState: get,
                setState: set
            };
            logger.debug("Calling handlePlayerMoveOrchestrator");
            // Add timeout for E2E tests to prevent hanging
            let result;
            if (process.env.NEXT_PUBLIC_IS_E2E_TEST === "true") {
                result = await Promise.race([
                    (0, _index.handlePlayerMove)(storeApi, move),
                    new Promise((_, reject)=>setTimeout(()=>reject(new Error("E2E orchestrator timeout")), 5000))
                ]);
            } else {
                result = await (0, _index.handlePlayerMove)(storeApi, move);
            }
            logger.debug("handlePlayerMoveOrchestrator result", {
                result
            });
            return result;
        },
        // Note: handleOpponentTurn and requestPositionEvaluation removed
        // Their functionality is now in chessService and handlePlayerMove orchestrator
        /**
           * Loads training context for a position
           *
           * @param {EndgamePosition} position - The endgame position to load
           * @returns {Promise<void>} Completes when context is loaded
           *
           * @remarks
           * This orchestrator sets up the complete training context:
           * - Loads position into Game slice
           * - Initializes Training slice state
           * - Resets UI and Progress tracking
           * - Prepares for user interaction
           *
           * @example
           * ```typescript
           * const loadContext = useStore(state => state.loadTrainingContext);
           *
           * const startTraining = async (position: EndgamePosition) => {
           *   await loadContext(position);
           *   logger.info('Training context loaded');
           * };
           * ```
           */ loadTrainingContext: async (position)=>{
            const storeApi = {
                getState: get,
                setState: set
            };
            return await (0, _loadTrainingContext.loadTrainingContext)(storeApi, position);
        },
        /**
           * Resets entire store to initial state
           *
           * @remarks
           * Uses pre-computed initial state for efficient and reliable reset.
           * With Slice-in-Slice pattern, actions are preserved automatically.
           */ reset: ()=>{
            set((state)=>{
                // Reset slices to their initial states (actions preserved automatically)
                // Game slice - merge initial state
                Object.assign(state.game, _gameSlice.initialGameState);
                // Training slice - merge only state properties (actions preserved)
                Object.assign(state.training, {
                    ..._trainingSlice.initialTrainingState,
                    // Preserve action functions that are mixed in
                    setPosition: state.training.setPosition,
                    setNavigationPositions: state.training.setNavigationPositions,
                    setNavigationLoading: state.training.setNavigationLoading,
                    setNavigationError: state.training.setNavigationError,
                    setChapterProgress: state.training.setChapterProgress,
                    setPlayerTurn: state.training.setPlayerTurn,
                    clearOpponentThinking: state.training.clearOpponentThinking,
                    completeTraining: state.training.completeTraining,
                    incrementHint: state.training.incrementHint,
                    incrementMistake: state.training.incrementMistake,
                    setMoveErrorDialog: state.training.setMoveErrorDialog,
                    setMoveSuccessDialog: state.training.setMoveSuccessDialog,
                    addTrainingMove: state.training.addTrainingMove,
                    resetTraining: state.training.resetTraining,
                    resetPosition: state.training.resetPosition
                });
                // Tablebase slice - merge only state properties (actions preserved)
                Object.assign(state.tablebase, {
                    ..._tablebaseSlice.initialTablebaseState,
                    // Preserve action functions
                    setTablebaseMove: state.tablebase.setTablebaseMove,
                    setAnalysisStatus: state.tablebase.setAnalysisStatus,
                    addEvaluation: state.tablebase.addEvaluation,
                    setEvaluations: state.tablebase.setEvaluations,
                    setCurrentEvaluation: state.tablebase.setCurrentEvaluation,
                    clearTablebaseState: state.tablebase.clearTablebaseState
                });
                // Progress slice - merge initial state
                Object.assign(state.progress, _progressSlice.initialProgressState);
                // UI slice - merge initial state  
                Object.assign(state.ui, _uiSlice.initialUIState);
            });
        },
        /**
           * Hydrates store with partial state data
           *
           * @param {Partial<RootState>} state - Partial state to merge into current state
           *
           * @remarks
           * This action is useful for:
           * - Loading state from external sources (localStorage, API)
           * - Server-side rendering hydration
           * - State synchronization between tabs
           * - Partial state restoration from backups
           *
           * The method performs a shallow merge of the provided state
           * with the current state, preserving any fields not specified.
           *
           * @example
           * ```typescript
           * const hydrate = useStore(state => state.hydrate);
           *
           * // Restore user data from API
           * const restoreUserData = async () => {
           *   const userData = await api.getUserData();
           *   hydrate({
           *     id: userData.id,
           *     username: userData.username,
           *     preferences: userData.preferences
           *   });
           * };
           *
           * // Sync settings from another tab
           * const syncSettings = (settingsData) => {
           *   hydrate({
           *     theme: settingsData.theme,
           *     language: settingsData.language
           *   });
           * };
           * ```
           */ hydrate: (state)=>{
            set((currentState)=>({
                    ...currentState,
                    ...state
                }));
        }
    };
}), {
    name: "endgame-trainer-store",
    version: 1,
    storage: (0, _middleware.createJSONStorage)(()=>safeStorage),
    // Only persist training position for session continuity
    partialize: (state)=>({
            // Training position - persist for session continuity
            training: {
                currentPosition: state.training.currentPosition
            }
        }),
    // Merge strategy to prevent overwriting the entire slice
    merge: (persistedState, currentState)=>{
        // Deep merge to preserve slice structure and functions
        const merged = {
            ...currentState
        };
        if (persistedState && typeof persistedState === "object") {
            var _persisted_training;
            const persisted = persistedState;
            // Only merge the specific persisted properties, not the entire slice
            if ((_persisted_training = persisted.training) === null || _persisted_training === void 0 ? void 0 : _persisted_training.currentPosition) {
                merged.training = {
                    ...currentState.training,
                    currentPosition: persisted.training.currentPosition
                };
            }
        }
        return merged;
    }
}), {
    name: "EndgameTrainer Store",
    enabled: process.env.NODE_ENV === "development"
}));
/**
 * Subscribe to ChessService events for automatic state synchronization
 * This ensures the store stays in sync with the ChessService singleton
 */ const unsubscribeChessService = _ChessService.chessService.subscribe((event)=>{
    switch(event.type){
        case "stateUpdate":
            // Use batched payload for atomic state update
            // This ensures consistency and reduces getter calls
            useStore.setState((draft)=>{
                draft.game.currentFen = event.payload.fen;
                draft.game.currentPgn = event.payload.pgn;
                draft.game.moveHistory = event.payload.moveHistory;
                draft.game.currentMoveIndex = event.payload.currentMoveIndex;
                draft.game.isGameFinished = event.payload.isGameOver;
                draft.game.gameResult = event.payload.gameResult;
            });
            break;
        case "error":
            // Handle errors from ChessService
            useStore.setState((draft)=>{
                draft.ui.toasts.push({
                    id: crypto.randomUUID(),
                    message: event.payload.message,
                    type: "error",
                    duration: 5000
                });
            });
            break;
    }
});
// Store cleanup function for hot-module reload or testing
if (typeof window !== "undefined") {
    window.__cleanupChessService = unsubscribeChessService;
}
const _default = useStore;
const store = useStore;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL3Jvb3RTdG9yZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFJvb3Qgc3RvcmUgYXNzZW1ibHkgZm9yIHJlZmFjdG9yZWQgWnVzdGFuZCBhcmNoaXRlY3R1cmVcbiAqIEBtb2R1bGUgc3RvcmUvcm9vdFN0b3JlXG4gKiBAZGVzY3JpcHRpb24gQ29tYmluZXMgYWxsIGRvbWFpbi1zcGVjaWZpYyBzbGljZXMgaW50byBhIHVuaWZpZWQgc3RvcmUgd2l0aCBtaWRkbGV3YXJlXG4gKiBpbnRlZ3JhdGlvbi4gVXNlcyBhIGNsZWFuLCBtYWludGFpbmFibGUgYXJjaGl0ZWN0dXJlIHdpdGggZG9tYWluLWRyaXZlbiBzbGljZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFVzaW5nIHRoZSByZWZhY3RvcmVkIHN0b3JlXG4gKiBpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ0Avc3RvcmUvcm9vdFN0b3JlJztcbiAqXG4gKiBmdW5jdGlvbiBNeUNvbXBvbmVudCgpIHtcbiAqICAgY29uc3QgcmVzdGFydFJlcXVpcmVkID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUucmVzdGFydFJlcXVpcmVkKTtcbiAqICAgY29uc3QgY2xlYXJSZXN0YXJ0ID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuY2xlYXJSZXN0YXJ0UmVxdWlyZWQpO1xuICogICBjb25zdCBtYWtlTW92ZSA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmhhbmRsZVBsYXllck1vdmUpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAge3Jlc3RhcnRSZXF1aXJlZCAmJiA8ZGl2PkFwcCByZXN0YXJ0IHJlcXVpcmVkPC9kaXY+fVxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBtYWtlTW92ZSh7IGZyb206ICdlMicsIHRvOiAnZTQnIH0pfT5cbiAqICAgICAgICAgTWFrZSBNb3ZlXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5cbmltcG9ydCB7IGNyZWF0ZSB9IGZyb20gXCJ6dXN0YW5kXCI7XG5pbXBvcnQgeyBkZXZ0b29scywgcGVyc2lzdCwgY3JlYXRlSlNPTlN0b3JhZ2UsIFN0YXRlU3RvcmFnZSB9IGZyb20gXCJ6dXN0YW5kL21pZGRsZXdhcmVcIjtcbmltcG9ydCB7IGltbWVyIH0gZnJvbSBcInp1c3RhbmQvbWlkZGxld2FyZS9pbW1lclwiO1xuXG4vLyBJbXBvcnQgYWxsIHNsaWNlIGNyZWF0b3JzIGFuZCBpbml0aWFsIHN0YXRlc1xuaW1wb3J0IHsgY3JlYXRlR2FtZVNsaWNlLCBpbml0aWFsR2FtZVN0YXRlIH0gZnJvbSBcIi4vc2xpY2VzL2dhbWVTbGljZVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGFibGViYXNlU3RhdGUsXG4gIGNyZWF0ZVRhYmxlYmFzZUFjdGlvbnMsXG4gIGluaXRpYWxUYWJsZWJhc2VTdGF0ZSxcbn0gZnJvbSBcIi4vc2xpY2VzL3RhYmxlYmFzZVNsaWNlXCI7XG5pbXBvcnQge1xuICBjcmVhdGVUcmFpbmluZ1N0YXRlLFxuICBjcmVhdGVUcmFpbmluZ0FjdGlvbnMsXG4gIGluaXRpYWxUcmFpbmluZ1N0YXRlLFxufSBmcm9tIFwiLi9zbGljZXMvdHJhaW5pbmdTbGljZVwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlUHJvZ3Jlc3NTbGljZSxcbiAgaW5pdGlhbFByb2dyZXNzU3RhdGUsXG59IGZyb20gXCIuL3NsaWNlcy9wcm9ncmVzc1NsaWNlXCI7XG5pbXBvcnQgeyBjcmVhdGVVSVNsaWNlLCBpbml0aWFsVUlTdGF0ZSB9IGZyb20gXCIuL3NsaWNlcy91aVNsaWNlXCI7XG5cbi8vIEltcG9ydCBDaGVzc1NlcnZpY2UgZm9yIGV2ZW50IHN1YnNjcmlwdGlvblxuaW1wb3J0IHtcbiAgY2hlc3NTZXJ2aWNlLFxuICB0eXBlIENoZXNzU2VydmljZUV2ZW50LFxufSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2VcIjtcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyXCI7XG5cbi8vIEltcG9ydCBvcmNoZXN0cmF0b3JzXG5pbXBvcnQgeyBsb2FkVHJhaW5pbmdDb250ZXh0IGFzIGxvYWRUcmFpbmluZ0NvbnRleHRPcmNoZXN0cmF0b3IgfSBmcm9tIFwiLi9vcmNoZXN0cmF0b3JzL2xvYWRUcmFpbmluZ0NvbnRleHRcIjtcbmltcG9ydCB7IGhhbmRsZVBsYXllck1vdmUgYXMgaGFuZGxlUGxheWVyTW92ZU9yY2hlc3RyYXRvciB9IGZyb20gXCIuL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZS9pbmRleFwiO1xuXG4vLyBJbXBvcnQgdHlwZXNcbmltcG9ydCB0eXBlIHsgUm9vdFN0YXRlIH0gZnJvbSBcIi4vc2xpY2VzL3R5cGVzXCI7XG5pbXBvcnQgdHlwZSB7IE1vdmUgYXMgQ2hlc3NKc01vdmUgfSBmcm9tIFwiY2hlc3MuanNcIjtcbmltcG9ydCB0eXBlIHsgRW5kZ2FtZVBvc2l0aW9uIH0gZnJvbSBcIkBzaGFyZWQvdHlwZXMvZW5kZ2FtZVwiO1xuXG4vLyBJbml0aWFsIHN0YXRlIGNyZWF0aW9uIHJlbW92ZWQgLSBzbGljZXMgYXJlIGluaXRpYWxpemVkIGRpcmVjdGx5IGluIHN0b3JlXG5cbi8qKlxuICogU2FmZSBzdG9yYWdlIGFkYXB0ZXIgdGhhdCBncmFjZWZ1bGx5IGhhbmRsZXMgbG9jYWxTdG9yYWdlIGVycm9yc1xuICogVGhpcyBwcmV2ZW50cyB3YXJuaW5ncyBpbiBFMkUgdGVzdHMgYW5kIG90aGVyIHJlc3RyaWN0ZWQgZW52aXJvbm1lbnRzXG4gKiB3aGlsZSBtYWludGFpbmluZyBmdW5jdGlvbmFsaXR5IGluIG5vcm1hbCBicm93c2VyIGVudmlyb25tZW50c1xuICovXG5jb25zdCBzYWZlU3RvcmFnZTogU3RhdGVTdG9yYWdlID0ge1xuICBnZXRJdGVtOiAobmFtZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIGluIHJlc3RyaWN0ZWQgZW52aXJvbm1lbnRzIChFMkUgdGVzdHMsIGV0Yy4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIHNldEl0ZW06IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0obmFtZSwgdmFsdWUpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBpbiByZXN0cmljdGVkIGVudmlyb25tZW50c1xuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB3YXJuaW5ncyBpbiBFMkUgdGVzdHMgd2hlcmUgbG9jYWxTdG9yYWdlIGV4aXN0cyBidXQgdGhyb3dzXG4gICAgfVxuICB9LFxuICByZW1vdmVJdGVtOiAobmFtZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuO1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBTaWxlbnRseSBmYWlsIGluIHJlc3RyaWN0ZWQgZW52aXJvbm1lbnRzXG4gICAgfVxuICB9LFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSByb290IHN0b3JlIHdpdGggYWxsIHNsaWNlcyBhbmQgb3JjaGVzdHJhdG9ycyBpbnRlZ3JhdGVkXG4gKlxuICogQHJldHVybnMge09iamVjdH0gWnVzdGFuZCBzdG9yZSB3aXRoIGFsbCBzbGljZXMgYW5kIG1pZGRsZXdhcmVcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBzdG9yZSBjb21iaW5lczpcbiAqIC0gQWxsIDQgZG9tYWluLXNwZWNpZmljIHNsaWNlcyAoR2FtZSwgVGFibGViYXNlLCBUcmFpbmluZywgVUkpXG4gKiAtIENyb3NzLXNsaWNlIG9yY2hlc3RyYXRvcnMgZm9yIGNvbXBsZXggYXN5bmMgb3BlcmF0aW9uc1xuICogLSBNaWRkbGV3YXJlIGludGVncmF0aW9uIChEZXZUb29scywgUGVyc2lzdCwgSW1tZXIpXG4gKiAtIEdsb2JhbCByZXNldCBhbmQgaHlkcmF0aW9uIGFjdGlvbnMgKHVzaW5nIGVmZmljaWVudCBpbml0aWFsU3RhdGUgcGF0dGVybilcbiAqXG4gKiBUaGUgc3RvcmUgdXNlcyBtaWRkbGV3YXJlIGNvbmZpZ3VyYXRpb24gZm9yIGVuaGFuY2VkIGZ1bmN0aW9uYWxpdHk6XG4gKiAtIERldlRvb2xzOiBGb3IgZGVidWdnaW5nIGFuZCB0aW1lLXRyYXZlbCBkZWJ1Z2dpbmdcbiAqIC0gUGVyc2lzdDogRm9yIGxvY2FsU3RvcmFnZSBwZXJzaXN0ZW5jZSBvZiB1c2VyIGRhdGFcbiAqIC0gSW1tZXI6IEZvciBpbW11dGFibGUgc3RhdGUgdXBkYXRlcyB3aXRoIG11dGFibGUgc3ludGF4XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIEFjY2VzcyBzbGljZSBzdGF0ZVxuICogY29uc3QgcmVzdGFydFJlcXVpcmVkID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUucmVzdGFydFJlcXVpcmVkKTtcbiAqIGNvbnN0IGN1cnJlbnRHYW1lID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuZ2FtZSk7XG4gKlxuICogLy8gQWNjZXNzIHNsaWNlIGFjdGlvbnNcbiAqIGNvbnN0IGNsZWFyUmVzdGFydCA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmNsZWFyUmVzdGFydFJlcXVpcmVkKTtcbiAqIGNvbnN0IG1ha2VNb3ZlID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuYWRkTW92ZSk7XG4gKlxuICogLy8gQWNjZXNzIG9yY2hlc3RyYXRvciBhY3Rpb25zXG4gKiBjb25zdCBoYW5kbGVQbGF5ZXJNb3ZlID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuaGFuZGxlUGxheWVyTW92ZSk7XG4gKiBjb25zdCByZXF1ZXN0RXZhbHVhdGlvbiA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLnJlcXVlc3RQb3NpdGlvbkV2YWx1YXRpb24pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VTdG9yZSA9IGNyZWF0ZTxSb290U3RhdGU+KCkoXG4gIGRldnRvb2xzKFxuICAgIHBlcnNpc3QoXG4gICAgICBpbW1lcigoc2V0LCBnZXQsIHN0b3JlKSA9PiB7XG4gICAgICAgIC8vIENyZWF0ZSBzbGljZXMgdXNpbmcgU2xpY2UtaW4tU2xpY2UgcGF0dGVybiAoY2xlYW4gc2VwYXJhdGlvbiBvZiBzdGF0ZSBhbmQgYWN0aW9ucylcbiAgICAgICAgY29uc3QgZ2FtZVNsaWNlID0gY3JlYXRlR2FtZVNsaWNlKHNldCwgZ2V0LCBzdG9yZSk7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzU2xpY2UgPSBjcmVhdGVQcm9ncmVzc1NsaWNlKHNldCwgZ2V0LCBzdG9yZSk7XG4gICAgICAgIGNvbnN0IHVpU2xpY2UgPSBjcmVhdGVVSVNsaWNlKHNldCwgZ2V0LCBzdG9yZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAvLyBDbGVhbiBTbGljZS1pbi1TbGljZSBwYXR0ZXJuOiBzdGF0ZSBhbmQgYWN0aW9ucyBwcmVzZXJ2ZWQgYXQgc2xpY2UgbGV2ZWxcbiAgICAgICAgICBnYW1lOiBnYW1lU2xpY2UsXG4gICAgICAgICAgdHJhaW5pbmc6IHtcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRyYWluaW5nU3RhdGUoKSxcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRyYWluaW5nQWN0aW9ucyhzZXQsIGdldCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0YWJsZWJhc2U6IHtcbiAgICAgICAgICAgIC4uLmNyZWF0ZVRhYmxlYmFzZVN0YXRlKCksXG4gICAgICAgICAgICAuLi5jcmVhdGVUYWJsZWJhc2VBY3Rpb25zKHNldCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcm9ncmVzczogcHJvZ3Jlc3NTbGljZSxcbiAgICAgICAgICB1aTogdWlTbGljZSxcblxuICAgICAgICAgIC8vIE9yY2hlc3RyYXRvciBhY3Rpb25zIC0gY29vcmRpbmF0ZSBhY3Jvc3MgbXVsdGlwbGUgc2xpY2VzXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTWFrZXMgYSB1c2VyIG1vdmUgd2l0aCBmdWxsIHZhbGlkYXRpb24gYW5kIHRhYmxlYmFzZSBpbnRlZ3JhdGlvblxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHBhcmFtIHtDaGVzc0pzTW92ZSB8IHtmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IHByb21vdGlvbj86IHN0cmluZ30gfCBzdHJpbmd9IG1vdmUgLSBUaGUgbW92ZSB0byBtYWtlXG4gICAgICAgICAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFdoZXRoZXIgdGhlIG1vdmUgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAgICogVGhpcyBvcmNoZXN0cmF0b3IgY29vcmRpbmF0ZXMgYWNyb3NzIG11bHRpcGxlIHNsaWNlczpcbiAgICAgICAgICAgKiAtIFZhbGlkYXRlcyBtb3ZlIHRocm91Z2ggR2FtZSBzbGljZVxuICAgICAgICAgICAqIC0gVXBkYXRlcyBUcmFpbmluZyBzbGljZSB3aXRoIG1vdmUgcmVzdWx0XG4gICAgICAgICAgICogLSBSZXF1ZXN0cyB0YWJsZWJhc2UgYW5hbHlzaXMgdmlhIFRhYmxlYmFzZSBzbGljZVxuICAgICAgICAgICAqIC0gVXBkYXRlcyBQcm9ncmVzcyBzbGljZSB3aXRoIGF0dGVtcHQgZGF0YVxuICAgICAgICAgICAqIC0gU2hvd3MgVUkgZmVlZGJhY2sgZm9yIGVycm9yc1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAgICogY29uc3QgaGFuZGxlUGxheWVyTW92ZSA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmhhbmRsZVBsYXllck1vdmUpO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogY29uc3QgaGFuZGxlTW92ZSA9IGFzeW5jIChmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgKiAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCBoYW5kbGVQbGF5ZXJNb3ZlKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgICAgICogICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAqICAgICBsb2dnZXIuaW5mbygnTW92ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgICogICB9XG4gICAgICAgICAgICogfTtcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBoYW5kbGVQbGF5ZXJNb3ZlOiBhc3luYyAoXG4gICAgICAgICAgICBtb3ZlOlxuICAgICAgICAgICAgICB8IENoZXNzSnNNb3ZlXG4gICAgICAgICAgICAgIHwgeyBmcm9tOiBzdHJpbmc7IHRvOiBzdHJpbmc7IHByb21vdGlvbj86IHN0cmluZyB9XG4gICAgICAgICAgICAgIHwgc3RyaW5nLFxuICAgICAgICAgICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCkuc2V0Q29udGV4dChcIlJvb3RTdG9yZVwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcImhhbmRsZVBsYXllck1vdmUgY2FsbGVkXCIsIHsgbW92ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlQXBpID0geyBnZXRTdGF0ZTogZ2V0LCBzZXRTdGF0ZTogc2V0IH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJDYWxsaW5nIGhhbmRsZVBsYXllck1vdmVPcmNoZXN0cmF0b3JcIik7XG4gICAgICAgICAgICAvLyBBZGQgdGltZW91dCBmb3IgRTJFIHRlc3RzIHRvIHByZXZlbnQgaGFuZ2luZ1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JU19FMkVfVEVTVCA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgICAgICBoYW5kbGVQbGF5ZXJNb3ZlT3JjaGVzdHJhdG9yKHN0b3JlQXBpLCBtb3ZlKSxcbiAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZTxib29sZWFuPigoXywgcmVqZWN0KSA9PiBcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihcIkUyRSBvcmNoZXN0cmF0b3IgdGltZW91dFwiKSksIDUwMDApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGhhbmRsZVBsYXllck1vdmVPcmNoZXN0cmF0b3Ioc3RvcmVBcGksIG1vdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiaGFuZGxlUGxheWVyTW92ZU9yY2hlc3RyYXRvciByZXN1bHRcIiwgeyByZXN1bHQgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBOb3RlOiBoYW5kbGVPcHBvbmVudFR1cm4gYW5kIHJlcXVlc3RQb3NpdGlvbkV2YWx1YXRpb24gcmVtb3ZlZFxuICAgICAgICAgIC8vIFRoZWlyIGZ1bmN0aW9uYWxpdHkgaXMgbm93IGluIGNoZXNzU2VydmljZSBhbmQgaGFuZGxlUGxheWVyTW92ZSBvcmNoZXN0cmF0b3JcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIExvYWRzIHRyYWluaW5nIGNvbnRleHQgZm9yIGEgcG9zaXRpb25cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBwYXJhbSB7RW5kZ2FtZVBvc2l0aW9ufSBwb3NpdGlvbiAtIFRoZSBlbmRnYW1lIHBvc2l0aW9uIHRvIGxvYWRcbiAgICAgICAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQ29tcGxldGVzIHdoZW4gY29udGV4dCBpcyBsb2FkZWRcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEByZW1hcmtzXG4gICAgICAgICAgICogVGhpcyBvcmNoZXN0cmF0b3Igc2V0cyB1cCB0aGUgY29tcGxldGUgdHJhaW5pbmcgY29udGV4dDpcbiAgICAgICAgICAgKiAtIExvYWRzIHBvc2l0aW9uIGludG8gR2FtZSBzbGljZVxuICAgICAgICAgICAqIC0gSW5pdGlhbGl6ZXMgVHJhaW5pbmcgc2xpY2Ugc3RhdGVcbiAgICAgICAgICAgKiAtIFJlc2V0cyBVSSBhbmQgUHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICAgICAgICAgKiAtIFByZXBhcmVzIGZvciB1c2VyIGludGVyYWN0aW9uXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICAgKiBjb25zdCBsb2FkQ29udGV4dCA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmxvYWRUcmFpbmluZ0NvbnRleHQpO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogY29uc3Qgc3RhcnRUcmFpbmluZyA9IGFzeW5jIChwb3NpdGlvbjogRW5kZ2FtZVBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICogICBhd2FpdCBsb2FkQ29udGV4dChwb3NpdGlvbik7XG4gICAgICAgICAgICogICBsb2dnZXIuaW5mbygnVHJhaW5pbmcgY29udGV4dCBsb2FkZWQnKTtcbiAgICAgICAgICAgKiB9O1xuICAgICAgICAgICAqIGBgYFxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxvYWRUcmFpbmluZ0NvbnRleHQ6IGFzeW5jIChcbiAgICAgICAgICAgIHBvc2l0aW9uOiBFbmRnYW1lUG9zaXRpb24sXG4gICAgICAgICAgKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZUFwaSA9IHsgZ2V0U3RhdGU6IGdldCwgc2V0U3RhdGU6IHNldCB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGxvYWRUcmFpbmluZ0NvbnRleHRPcmNoZXN0cmF0b3Ioc3RvcmVBcGksIHBvc2l0aW9uKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogUmVzZXRzIGVudGlyZSBzdG9yZSB0byBpbml0aWFsIHN0YXRlXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcmVtYXJrc1xuICAgICAgICAgICAqIFVzZXMgcHJlLWNvbXB1dGVkIGluaXRpYWwgc3RhdGUgZm9yIGVmZmljaWVudCBhbmQgcmVsaWFibGUgcmVzZXQuXG4gICAgICAgICAgICogV2l0aCBTbGljZS1pbi1TbGljZSBwYXR0ZXJuLCBhY3Rpb25zIGFyZSBwcmVzZXJ2ZWQgYXV0b21hdGljYWxseS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAvLyBSZXNldCBzbGljZXMgdG8gdGhlaXIgaW5pdGlhbCBzdGF0ZXMgKGFjdGlvbnMgcHJlc2VydmVkIGF1dG9tYXRpY2FsbHkpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBHYW1lIHNsaWNlIC0gbWVyZ2UgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLmdhbWUsIGluaXRpYWxHYW1lU3RhdGUpO1xuXG4gICAgICAgICAgICAgIC8vIFRyYWluaW5nIHNsaWNlIC0gbWVyZ2Ugb25seSBzdGF0ZSBwcm9wZXJ0aWVzIChhY3Rpb25zIHByZXNlcnZlZClcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS50cmFpbmluZywge1xuICAgICAgICAgICAgICAgIC4uLmluaXRpYWxUcmFpbmluZ1N0YXRlLFxuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIGFjdGlvbiBmdW5jdGlvbnMgdGhhdCBhcmUgbWl4ZWQgaW5cbiAgICAgICAgICAgICAgICBzZXRQb3NpdGlvbjogc3RhdGUudHJhaW5pbmcuc2V0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgc2V0TmF2aWdhdGlvblBvc2l0aW9uczogc3RhdGUudHJhaW5pbmcuc2V0TmF2aWdhdGlvblBvc2l0aW9ucyxcbiAgICAgICAgICAgICAgICBzZXROYXZpZ2F0aW9uTG9hZGluZzogc3RhdGUudHJhaW5pbmcuc2V0TmF2aWdhdGlvbkxvYWRpbmcsXG4gICAgICAgICAgICAgICAgc2V0TmF2aWdhdGlvbkVycm9yOiBzdGF0ZS50cmFpbmluZy5zZXROYXZpZ2F0aW9uRXJyb3IsXG4gICAgICAgICAgICAgICAgc2V0Q2hhcHRlclByb2dyZXNzOiBzdGF0ZS50cmFpbmluZy5zZXRDaGFwdGVyUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgc2V0UGxheWVyVHVybjogc3RhdGUudHJhaW5pbmcuc2V0UGxheWVyVHVybixcbiAgICAgICAgICAgICAgICBjbGVhck9wcG9uZW50VGhpbmtpbmc6IHN0YXRlLnRyYWluaW5nLmNsZWFyT3Bwb25lbnRUaGlua2luZyxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZVRyYWluaW5nOiBzdGF0ZS50cmFpbmluZy5jb21wbGV0ZVRyYWluaW5nLFxuICAgICAgICAgICAgICAgIGluY3JlbWVudEhpbnQ6IHN0YXRlLnRyYWluaW5nLmluY3JlbWVudEhpbnQsXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50TWlzdGFrZTogc3RhdGUudHJhaW5pbmcuaW5jcmVtZW50TWlzdGFrZSxcbiAgICAgICAgICAgICAgICBzZXRNb3ZlRXJyb3JEaWFsb2c6IHN0YXRlLnRyYWluaW5nLnNldE1vdmVFcnJvckRpYWxvZyxcbiAgICAgICAgICAgICAgICBzZXRNb3ZlU3VjY2Vzc0RpYWxvZzogc3RhdGUudHJhaW5pbmcuc2V0TW92ZVN1Y2Nlc3NEaWFsb2csXG4gICAgICAgICAgICAgICAgYWRkVHJhaW5pbmdNb3ZlOiBzdGF0ZS50cmFpbmluZy5hZGRUcmFpbmluZ01vdmUsXG4gICAgICAgICAgICAgICAgcmVzZXRUcmFpbmluZzogc3RhdGUudHJhaW5pbmcucmVzZXRUcmFpbmluZyxcbiAgICAgICAgICAgICAgICByZXNldFBvc2l0aW9uOiBzdGF0ZS50cmFpbmluZy5yZXNldFBvc2l0aW9uLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAvLyBUYWJsZWJhc2Ugc2xpY2UgLSBtZXJnZSBvbmx5IHN0YXRlIHByb3BlcnRpZXMgKGFjdGlvbnMgcHJlc2VydmVkKVxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLnRhYmxlYmFzZSwge1xuICAgICAgICAgICAgICAgIC4uLmluaXRpYWxUYWJsZWJhc2VTdGF0ZSxcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBhY3Rpb24gZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgc2V0VGFibGViYXNlTW92ZTogc3RhdGUudGFibGViYXNlLnNldFRhYmxlYmFzZU1vdmUsXG4gICAgICAgICAgICAgICAgc2V0QW5hbHlzaXNTdGF0dXM6IHN0YXRlLnRhYmxlYmFzZS5zZXRBbmFseXNpc1N0YXR1cyxcbiAgICAgICAgICAgICAgICBhZGRFdmFsdWF0aW9uOiBzdGF0ZS50YWJsZWJhc2UuYWRkRXZhbHVhdGlvbixcbiAgICAgICAgICAgICAgICBzZXRFdmFsdWF0aW9uczogc3RhdGUudGFibGViYXNlLnNldEV2YWx1YXRpb25zLFxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRFdmFsdWF0aW9uOiBzdGF0ZS50YWJsZWJhc2Uuc2V0Q3VycmVudEV2YWx1YXRpb24sXG4gICAgICAgICAgICAgICAgY2xlYXJUYWJsZWJhc2VTdGF0ZTogc3RhdGUudGFibGViYXNlLmNsZWFyVGFibGViYXNlU3RhdGUsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIFByb2dyZXNzIHNsaWNlIC0gbWVyZ2UgaW5pdGlhbCBzdGF0ZVxuICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0YXRlLnByb2dyZXNzLCBpbml0aWFsUHJvZ3Jlc3NTdGF0ZSk7XG5cbiAgICAgICAgICAgICAgLy8gVUkgc2xpY2UgLSBtZXJnZSBpbml0aWFsIHN0YXRlICBcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS51aSwgaW5pdGlhbFVJU3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEh5ZHJhdGVzIHN0b3JlIHdpdGggcGFydGlhbCBzdGF0ZSBkYXRhXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAcGFyYW0ge1BhcnRpYWw8Um9vdFN0YXRlPn0gc3RhdGUgLSBQYXJ0aWFsIHN0YXRlIHRvIG1lcmdlIGludG8gY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQHJlbWFya3NcbiAgICAgICAgICAgKiBUaGlzIGFjdGlvbiBpcyB1c2VmdWwgZm9yOlxuICAgICAgICAgICAqIC0gTG9hZGluZyBzdGF0ZSBmcm9tIGV4dGVybmFsIHNvdXJjZXMgKGxvY2FsU3RvcmFnZSwgQVBJKVxuICAgICAgICAgICAqIC0gU2VydmVyLXNpZGUgcmVuZGVyaW5nIGh5ZHJhdGlvblxuICAgICAgICAgICAqIC0gU3RhdGUgc3luY2hyb25pemF0aW9uIGJldHdlZW4gdGFic1xuICAgICAgICAgICAqIC0gUGFydGlhbCBzdGF0ZSByZXN0b3JhdGlvbiBmcm9tIGJhY2t1cHNcbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIFRoZSBtZXRob2QgcGVyZm9ybXMgYSBzaGFsbG93IG1lcmdlIG9mIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgICAgICAgICAqIHdpdGggdGhlIGN1cnJlbnQgc3RhdGUsIHByZXNlcnZpbmcgYW55IGZpZWxkcyBub3Qgc3BlY2lmaWVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICAgICAgICogY29uc3QgaHlkcmF0ZSA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmh5ZHJhdGUpO1xuICAgICAgICAgICAqXG4gICAgICAgICAgICogLy8gUmVzdG9yZSB1c2VyIGRhdGEgZnJvbSBBUElcbiAgICAgICAgICAgKiBjb25zdCByZXN0b3JlVXNlckRhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICogICBjb25zdCB1c2VyRGF0YSA9IGF3YWl0IGFwaS5nZXRVc2VyRGF0YSgpO1xuICAgICAgICAgICAqICAgaHlkcmF0ZSh7XG4gICAgICAgICAgICogICAgIGlkOiB1c2VyRGF0YS5pZCxcbiAgICAgICAgICAgKiAgICAgdXNlcm5hbWU6IHVzZXJEYXRhLnVzZXJuYW1lLFxuICAgICAgICAgICAqICAgICBwcmVmZXJlbmNlczogdXNlckRhdGEucHJlZmVyZW5jZXNcbiAgICAgICAgICAgKiAgIH0pO1xuICAgICAgICAgICAqIH07XG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiAvLyBTeW5jIHNldHRpbmdzIGZyb20gYW5vdGhlciB0YWJcbiAgICAgICAgICAgKiBjb25zdCBzeW5jU2V0dGluZ3MgPSAoc2V0dGluZ3NEYXRhKSA9PiB7XG4gICAgICAgICAgICogICBoeWRyYXRlKHtcbiAgICAgICAgICAgKiAgICAgdGhlbWU6IHNldHRpbmdzRGF0YS50aGVtZSxcbiAgICAgICAgICAgKiAgICAgbGFuZ3VhZ2U6IHNldHRpbmdzRGF0YS5sYW5ndWFnZVxuICAgICAgICAgICAqICAgfSk7XG4gICAgICAgICAgICogfTtcbiAgICAgICAgICAgKiBgYGBcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBoeWRyYXRlOiAoc3RhdGU6IFBhcnRpYWw8Um9vdFN0YXRlPikgPT4ge1xuICAgICAgICAgICAgc2V0KChjdXJyZW50U3RhdGUpID0+ICh7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAge1xuICAgICAgICBuYW1lOiBcImVuZGdhbWUtdHJhaW5lci1zdG9yZVwiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBzdG9yYWdlOiBjcmVhdGVKU09OU3RvcmFnZSgoKSA9PiBzYWZlU3RvcmFnZSksIC8vIFNhZmUgc3RvcmFnZSB0aGF0IGhhbmRsZXMgZXJyb3JzIGdyYWNlZnVsbHlcbiAgICAgICAgLy8gT25seSBwZXJzaXN0IHRyYWluaW5nIHBvc2l0aW9uIGZvciBzZXNzaW9uIGNvbnRpbnVpdHlcbiAgICAgICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiAoe1xuICAgICAgICAgIC8vIFRyYWluaW5nIHBvc2l0aW9uIC0gcGVyc2lzdCBmb3Igc2Vzc2lvbiBjb250aW51aXR5XG4gICAgICAgICAgdHJhaW5pbmc6IHtcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbjogc3RhdGUudHJhaW5pbmcuY3VycmVudFBvc2l0aW9uLFxuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBBbGwgb3RoZXIgc3RhdGUgcmVtb3ZlZCAtIHdhcyBvdmVyLWVuZ2luZWVyZWQgYW5kIHVudXNlZCBpbiBVSTpcbiAgICAgICAgICAvLyAtIFVzZXIgZGF0YSAoYXV0aGVudGljYXRpb24sIHByb2ZpbGUsIHByZWZlcmVuY2VzKSAtIG5vdCBpbXBsZW1lbnRlZFxuICAgICAgICAgIC8vIC0gU2V0dGluZ3MgKHJlc3RhcnQgZmxhZ3MsIGNvbmZpZykgLSBub3QgdXNlZCBieSBVSVxuICAgICAgICAgIC8vIC0gUHJvZ3Jlc3MgZGF0YSAoc3RhdGlzdGljcywgYWNoaWV2ZW1lbnRzKSAtIG5vdCBkaXNwbGF5ZWRcbiAgICAgICAgICAvLyAtIEdhbWUgc3RhdGUgLSBlcGhlbWVyYWwgKHJlc2V0IG9uIHBhZ2UgcmVsb2FkKVxuICAgICAgICAgIC8vIC0gVUkgc3RhdGUgLSBlcGhlbWVyYWwgKHRvYXN0cywgbW9kYWxzLCBsb2FkaW5nKVxuICAgICAgICAgIC8vIC0gVGFibGViYXNlIHN0YXRlIC0gZXBoZW1lcmFsIChhbmFseXNpcyBkYXRhKVxuICAgICAgICB9KSxcbiAgICAgICAgLy8gTWVyZ2Ugc3RyYXRlZ3kgdG8gcHJldmVudCBvdmVyd3JpdGluZyB0aGUgZW50aXJlIHNsaWNlXG4gICAgICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4ge1xuICAgICAgICAgIC8vIERlZXAgbWVyZ2UgdG8gcHJlc2VydmUgc2xpY2Ugc3RydWN0dXJlIGFuZCBmdW5jdGlvbnNcbiAgICAgICAgICBjb25zdCBtZXJnZWQgPSB7IC4uLmN1cnJlbnRTdGF0ZSB9O1xuXG4gICAgICAgICAgaWYgKHBlcnNpc3RlZFN0YXRlICYmIHR5cGVvZiBwZXJzaXN0ZWRTdGF0ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgcGVyc2lzdGVkID0gcGVyc2lzdGVkU3RhdGUgYXMgYW55O1xuXG4gICAgICAgICAgICAvLyBPbmx5IG1lcmdlIHRoZSBzcGVjaWZpYyBwZXJzaXN0ZWQgcHJvcGVydGllcywgbm90IHRoZSBlbnRpcmUgc2xpY2VcbiAgICAgICAgICAgIGlmIChwZXJzaXN0ZWQudHJhaW5pbmc/LmN1cnJlbnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICBtZXJnZWQudHJhaW5pbmcgPSB7XG4gICAgICAgICAgICAgICAgLi4uY3VycmVudFN0YXRlLnRyYWluaW5nLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbjogcGVyc2lzdGVkLnRyYWluaW5nLmN1cnJlbnRQb3NpdGlvbixcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICApLFxuICAgIHtcbiAgICAgIG5hbWU6IFwiRW5kZ2FtZVRyYWluZXIgU3RvcmVcIixcbiAgICAgIGVuYWJsZWQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIsXG4gICAgfSxcbiAgKSxcbik7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIENoZXNzU2VydmljZSBldmVudHMgZm9yIGF1dG9tYXRpYyBzdGF0ZSBzeW5jaHJvbml6YXRpb25cbiAqIFRoaXMgZW5zdXJlcyB0aGUgc3RvcmUgc3RheXMgaW4gc3luYyB3aXRoIHRoZSBDaGVzc1NlcnZpY2Ugc2luZ2xldG9uXG4gKi9cbmNvbnN0IHVuc3Vic2NyaWJlQ2hlc3NTZXJ2aWNlID0gY2hlc3NTZXJ2aWNlLnN1YnNjcmliZShcbiAgKGV2ZW50OiBDaGVzc1NlcnZpY2VFdmVudCkgPT4ge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcInN0YXRlVXBkYXRlXCI6XG4gICAgICAgIC8vIFVzZSBiYXRjaGVkIHBheWxvYWQgZm9yIGF0b21pYyBzdGF0ZSB1cGRhdGVcbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGNvbnNpc3RlbmN5IGFuZCByZWR1Y2VzIGdldHRlciBjYWxsc1xuICAgICAgICB1c2VTdG9yZS5zZXRTdGF0ZSgoZHJhZnQpID0+IHtcbiAgICAgICAgICBkcmFmdC5nYW1lLmN1cnJlbnRGZW4gPSBldmVudC5wYXlsb2FkLmZlbjtcbiAgICAgICAgICBkcmFmdC5nYW1lLmN1cnJlbnRQZ24gPSBldmVudC5wYXlsb2FkLnBnbjtcbiAgICAgICAgICBkcmFmdC5nYW1lLm1vdmVIaXN0b3J5ID0gZXZlbnQucGF5bG9hZC5tb3ZlSGlzdG9yeTtcbiAgICAgICAgICBkcmFmdC5nYW1lLmN1cnJlbnRNb3ZlSW5kZXggPSBldmVudC5wYXlsb2FkLmN1cnJlbnRNb3ZlSW5kZXg7XG4gICAgICAgICAgZHJhZnQuZ2FtZS5pc0dhbWVGaW5pc2hlZCA9IGV2ZW50LnBheWxvYWQuaXNHYW1lT3ZlcjtcbiAgICAgICAgICBkcmFmdC5nYW1lLmdhbWVSZXN1bHQgPSBldmVudC5wYXlsb2FkLmdhbWVSZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgIC8vIEhhbmRsZSBlcnJvcnMgZnJvbSBDaGVzc1NlcnZpY2VcbiAgICAgICAgdXNlU3RvcmUuc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XG4gICAgICAgICAgZHJhZnQudWkudG9hc3RzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBldmVudC5wYXlsb2FkLm1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIExvZ2dpbmcgYWxyZWFkeSBkb25lIGluIENoZXNzU2VydmljZSwgYXZvaWQgZHVwbGljYXRpb25cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuKTtcblxuLy8gU3RvcmUgY2xlYW51cCBmdW5jdGlvbiBmb3IgaG90LW1vZHVsZSByZWxvYWQgb3IgdGVzdGluZ1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgKHdpbmRvdyBhcyBhbnkpLl9fY2xlYW51cENoZXNzU2VydmljZSA9IHVuc3Vic2NyaWJlQ2hlc3NTZXJ2aWNlO1xufVxuXG4vKipcbiAqIEhvb2sgZm9yIGFjY2Vzc2luZyB0aGUgY29tcGxldGUgc3RvcmUgc3RhdGUgYW5kIGFjdGlvbnNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBpcyB0aGUgbWFpbiBob29rIGZvciBhY2Nlc3NpbmcgdGhlIHN0b3JlLiBJdCBwcm92aWRlcyBhY2Nlc3MgdG86XG4gKiAtIEFsbCBzbGljZSBzdGF0ZSBhbmQgYWN0aW9ucyAoR2FtZSwgVHJhaW5pbmcsIFRhYmxlYmFzZSwgUHJvZ3Jlc3MsIFVJLCBTZXR0aW5ncywgVXNlcilcbiAqIC0gT3JjaGVzdHJhdG9yIGFjdGlvbnMgZm9yIGNvbXBsZXggb3BlcmF0aW9uc1xuICogLSBHbG9iYWwgcmVzZXQgYW5kIGh5ZHJhdGlvbiBtZXRob2RzXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlLXNlbnNpdGl2ZSBjb21wb25lbnRzLCBjb25zaWRlciB1c2luZyBzcGVjaWZpYyBzZWxlY3RvcnNcbiAqIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnMgd2hlbiB1bnJlbGF0ZWQgc3RhdGUgY2hhbmdlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gRnVsbCBzdG9yZSBhY2Nlc3NcbiAqIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKTtcbiAqXG4gKiAvLyBTZWxlY3RpdmUgYWNjZXNzIChiZXR0ZXIgcGVyZm9ybWFuY2UpXG4gKiBjb25zdCByZXN0YXJ0UmVxdWlyZWQgPSB1c2VTdG9yZShzdGF0ZSA9PiBzdGF0ZS5yZXN0YXJ0UmVxdWlyZWQpO1xuICogY29uc3QgY2xlYXJSZXN0YXJ0ID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuY2xlYXJSZXN0YXJ0UmVxdWlyZWQpO1xuICpcbiAqIC8vIFRyYWluaW5nIHN0YXRlIGFjY2VzcyAocmVwbGFjZXMgdXNlVHJhaW5pbmdTdGF0ZSBob29rKVxuICogY29uc3QgY3VycmVudFBvc2l0aW9uID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuY3VycmVudFBvc2l0aW9uKTtcbiAqIGNvbnN0IGlzUGxheWVyVHVybiA9IHVzZVN0b3JlKHN0YXRlID0+IHN0YXRlLmlzUGxheWVyVHVybik7XG4gKiBjb25zdCBzZXRQbGF5ZXJUdXJuID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUuc2V0UGxheWVyVHVybik7XG4gKlxuICogLy8gR2FtZSBzdGF0ZSBhY2Nlc3NcbiAqIGNvbnN0IGN1cnJlbnRGZW4gPSB1c2VTdG9yZShzdGF0ZSA9PiBzdGF0ZS5jdXJyZW50RmVuKTtcbiAqIGNvbnN0IG1ha2VNb3ZlID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUubWFrZU1vdmUpO1xuICpcbiAqIC8vIE11bHRpcGxlIHNlbGVjdGlvbnMgd2l0aCB1c2VTaGFsbG93IGZvciBjb21wbGV4IG9iamVjdHNcbiAqIGltcG9ydCB7IHVzZVNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3JlYWN0L3NoYWxsb3cnO1xuICogY29uc3QgeyBjdXJyZW50UG9zaXRpb24sIGlzUGxheWVyVHVybiwgaGludHNVc2VkIH0gPSB1c2VTdG9yZShcbiAqICAgdXNlU2hhbGxvdyhzdGF0ZSA9PiAoe1xuICogICAgIGN1cnJlbnRQb3NpdGlvbjogc3RhdGUuY3VycmVudFBvc2l0aW9uLFxuICogICAgIGlzUGxheWVyVHVybjogc3RhdGUuaXNQbGF5ZXJUdXJuLFxuICogICAgIGhpbnRzVXNlZDogc3RhdGUuaGludHNVc2VkXG4gKiAgIH0pKVxuICogKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCB1c2VTdG9yZTtcblxuLyoqXG4gKiBUeXBlLXNhZmUgc3RvcmUgaW5zdGFuY2UgZm9yIHRlc3RpbmcgYW5kIGV4dGVybmFsIGFjY2Vzc1xuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIHByb3ZpZGVzIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIHN0b3JlIGluc3RhbmNlIGZvcjpcbiAqIC0gVW5pdCB0ZXN0aW5nIHdpdGggc3RvcmUuZ2V0U3RhdGUoKSBhbmQgc3RvcmUuc2V0U3RhdGUoKVxuICogLSBJbnRlZ3JhdGlvbiB0ZXN0aW5nIHdpdGggc3RhdGUgbWFuaXB1bGF0aW9uXG4gKiAtIEV4dGVybmFsIHN0YXRlIGFjY2VzcyBvdXRzaWRlIG9mIFJlYWN0IGNvbXBvbmVudHNcbiAqIC0gU3RvcmUgaW5zcGVjdGlvbiBhbmQgZGVidWdnaW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIEluIHRlc3RzXG4gKiBpbXBvcnQgeyBzdG9yZSB9IGZyb20gJ0Avc3RvcmUvcm9vdFN0b3JlJztcbiAqXG4gKiB0ZXN0KCdzaG91bGQgY2xlYXIgcmVzdGFydCBmbGFnJywgKCkgPT4ge1xuICogICBzdG9yZS5nZXRTdGF0ZSgpLmNsZWFyUmVzdGFydFJlcXVpcmVkKCk7XG4gKiAgIGV4cGVjdChzdG9yZS5nZXRTdGF0ZSgpLnJlc3RhcnRSZXF1aXJlZCkudG9CZShmYWxzZSk7XG4gKiB9KTtcbiAqXG4gKiAvLyBFeHRlcm5hbCBzdGF0ZSBhY2Nlc3NcbiAqIGNvbnN0IGN1cnJlbnRVc2VyID0gc3RvcmUuZ2V0U3RhdGUoKS51c2VybmFtZTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZTtcbiJdLCJuYW1lcyI6WyJzdG9yZSIsInVzZVN0b3JlIiwic2FmZVN0b3JhZ2UiLCJnZXRJdGVtIiwibmFtZSIsIndpbmRvdyIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iLCJjcmVhdGUiLCJkZXZ0b29scyIsInBlcnNpc3QiLCJpbW1lciIsInNldCIsImdldCIsImdhbWVTbGljZSIsImNyZWF0ZUdhbWVTbGljZSIsInByb2dyZXNzU2xpY2UiLCJjcmVhdGVQcm9ncmVzc1NsaWNlIiwidWlTbGljZSIsImNyZWF0ZVVJU2xpY2UiLCJnYW1lIiwidHJhaW5pbmciLCJjcmVhdGVUcmFpbmluZ1N0YXRlIiwiY3JlYXRlVHJhaW5pbmdBY3Rpb25zIiwidGFibGViYXNlIiwiY3JlYXRlVGFibGViYXNlU3RhdGUiLCJjcmVhdGVUYWJsZWJhc2VBY3Rpb25zIiwicHJvZ3Jlc3MiLCJ1aSIsImhhbmRsZVBsYXllck1vdmUiLCJtb3ZlIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImRlYnVnIiwic3RvcmVBcGkiLCJnZXRTdGF0ZSIsInNldFN0YXRlIiwicmVzdWx0IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0lTX0UyRV9URVNUIiwiUHJvbWlzZSIsInJhY2UiLCJoYW5kbGVQbGF5ZXJNb3ZlT3JjaGVzdHJhdG9yIiwiXyIsInJlamVjdCIsInNldFRpbWVvdXQiLCJFcnJvciIsImxvYWRUcmFpbmluZ0NvbnRleHQiLCJwb3NpdGlvbiIsImxvYWRUcmFpbmluZ0NvbnRleHRPcmNoZXN0cmF0b3IiLCJyZXNldCIsInN0YXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiaW5pdGlhbEdhbWVTdGF0ZSIsImluaXRpYWxUcmFpbmluZ1N0YXRlIiwic2V0UG9zaXRpb24iLCJzZXROYXZpZ2F0aW9uUG9zaXRpb25zIiwic2V0TmF2aWdhdGlvbkxvYWRpbmciLCJzZXROYXZpZ2F0aW9uRXJyb3IiLCJzZXRDaGFwdGVyUHJvZ3Jlc3MiLCJzZXRQbGF5ZXJUdXJuIiwiY2xlYXJPcHBvbmVudFRoaW5raW5nIiwiY29tcGxldGVUcmFpbmluZyIsImluY3JlbWVudEhpbnQiLCJpbmNyZW1lbnRNaXN0YWtlIiwic2V0TW92ZUVycm9yRGlhbG9nIiwic2V0TW92ZVN1Y2Nlc3NEaWFsb2ciLCJhZGRUcmFpbmluZ01vdmUiLCJyZXNldFRyYWluaW5nIiwicmVzZXRQb3NpdGlvbiIsImluaXRpYWxUYWJsZWJhc2VTdGF0ZSIsInNldFRhYmxlYmFzZU1vdmUiLCJzZXRBbmFseXNpc1N0YXR1cyIsImFkZEV2YWx1YXRpb24iLCJzZXRFdmFsdWF0aW9ucyIsInNldEN1cnJlbnRFdmFsdWF0aW9uIiwiY2xlYXJUYWJsZWJhc2VTdGF0ZSIsImluaXRpYWxQcm9ncmVzc1N0YXRlIiwiaW5pdGlhbFVJU3RhdGUiLCJoeWRyYXRlIiwiY3VycmVudFN0YXRlIiwidmVyc2lvbiIsInN0b3JhZ2UiLCJjcmVhdGVKU09OU3RvcmFnZSIsInBhcnRpYWxpemUiLCJjdXJyZW50UG9zaXRpb24iLCJtZXJnZSIsInBlcnNpc3RlZFN0YXRlIiwibWVyZ2VkIiwicGVyc2lzdGVkIiwiZW5hYmxlZCIsIk5PREVfRU5WIiwidW5zdWJzY3JpYmVDaGVzc1NlcnZpY2UiLCJjaGVzc1NlcnZpY2UiLCJzdWJzY3JpYmUiLCJldmVudCIsInR5cGUiLCJkcmFmdCIsImN1cnJlbnRGZW4iLCJwYXlsb2FkIiwiZmVuIiwiY3VycmVudFBnbiIsInBnbiIsIm1vdmVIaXN0b3J5IiwiY3VycmVudE1vdmVJbmRleCIsImlzR2FtZUZpbmlzaGVkIiwiaXNHYW1lT3ZlciIsImdhbWVSZXN1bHQiLCJ0b2FzdHMiLCJwdXNoIiwiaWQiLCJjcnlwdG8iLCJyYW5kb21VVUlEIiwibWVzc2FnZSIsImR1cmF0aW9uIiwiX19jbGVhbnVwQ2hlc3NTZXJ2aWNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0EwQkM7Ozs7Ozs7Ozs7O1FBc1pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0NDLEdBQ0Q7ZUFBQTs7UUEwQmFBO2VBQUFBOztRQTdXQUM7ZUFBQUE7Ozt5QkExR1U7NEJBQzRDO3VCQUM3QzsyQkFHNEI7Z0NBSzNDOytCQUtBOytCQUlBO3lCQUN1Qzs4QkFNdkM7d0JBQ21CO3FDQUc2Qzt1QkFDTjtBQU9qRSw0RUFBNEU7QUFFNUU7Ozs7Q0FJQyxHQUNELE1BQU1DLGNBQTRCO0lBQ2hDQyxTQUFTLENBQUNDO1FBQ1IsSUFBSTtZQUNGLElBQUksT0FBT0MsV0FBVyxhQUFhLE9BQU87WUFDMUMsT0FBT0MsYUFBYUgsT0FBTyxDQUFDQztRQUM5QixFQUFFLE9BQU07WUFDTiw2REFBNkQ7WUFDN0QsT0FBTztRQUNUO0lBQ0Y7SUFDQUcsU0FBUyxDQUFDSCxNQUFNSTtRQUNkLElBQUk7WUFDRixJQUFJLE9BQU9ILFdBQVcsYUFBYTtZQUNuQ0MsYUFBYUMsT0FBTyxDQUFDSCxNQUFNSTtRQUM3QixFQUFFLE9BQU07UUFDTiwyQ0FBMkM7UUFDM0MsMkVBQTJFO1FBQzdFO0lBQ0Y7SUFDQUMsWUFBWSxDQUFDTDtRQUNYLElB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