{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/orchestrators/handlePlayerMove/OpponentTurnHandler.ts"],"sourcesContent":["/**\n * @file Opponent turn handler module\n * @module store/orchestrators/handlePlayerMove/OpponentTurnHandler\n *\n * @description\n * Handles comprehensive opponent turn management in chess training sessions.\n * Provides sophisticated scheduling, execution, and cancellation of opponent moves\n * with race condition prevention and robust error handling.\n *\n * @remarks\n * Key architectural features:\n * - **Race condition prevention**: Multiple cancellation checks prevent stale executions\n * - **Encapsulated state management**: OpponentTurnManager class for clean state isolation\n * - **Tablebase integration**: Fetches optimal opponent moves from tablebase API\n * - **State synchronization**: Coordinates with training state for turn management\n * - **Error resilience**: Graceful handling of tablebase API failures\n * - **Cross-platform support**: Works in browser and Node.js test environments\n *\n * The handler prevents common issues like:\n * - Executing opponent moves after user undo operations\n * - Multiple concurrent opponent turns\n * - Memory leaks from uncleaned timeouts\n * - State desynchronization between UI and game logic\n *\n * @example\n * ```typescript\n * import { getOpponentTurnManager } from './OpponentTurnHandler';\n * \n * const manager = getOpponentTurnManager();\n * \n * // Schedule opponent move with default delay\n * manager.schedule(storeApi);\n *\n * // Schedule with custom delay\n * manager.schedule(storeApi, 1000);\n *\n * // Cancel any pending opponent move (e.g., during undo)\n * manager.cancel();\n * ```\n */\n\nimport type { StoreApi } from \"../types\";\nimport { chessService } from \"@shared/services/ChessService\";\nimport {\n  tablebaseService,\n  type TablebaseMove,\n} from \"@shared/services/TablebaseService\";\nimport { ErrorService } from \"@shared/services/ErrorService\";\nimport { handleTrainingCompletion } from \"./move.completion\";\nimport { getLogger } from \"@shared/services/logging\";\n\n/** Default delay for opponent moves in milliseconds - provides natural game feel */\nconst OPPONENT_TURN_DELAY = 500;\n\n/**\n * Manages opponent turn scheduling and execution with encapsulated state\n * \n * @class OpponentTurnManager\n * \n * @description\n * Encapsulates timeout management and cancellation state to prevent race conditions\n * and provide clean separation of concerns. This eliminates the need for module-level\n * global state that could cause issues in concurrent scenarios.\n * \n * @example\n * ```typescript\n * const manager = new OpponentTurnManager();\n * \n * // Schedule opponent turn\n * manager.schedule(api, 500);\n * \n * // Cancel if needed (e.g., during undo)\n * manager.cancel();\n * ```\n */\nclass OpponentTurnManager {\n  private timeout?: NodeJS.Timeout;\n  private isCancelled = false;\n\n  /**\n   * Cancels any scheduled opponent turn to prevent race conditions\n   *\n   * @description\n   * Provides immediate cancellation of pending opponent moves, essential for:\n   * - Undo operations that revert game state\n   * - User navigation away from training session\n   * - Game completion or interruption scenarios\n   *\n   * @remarks\n   * Uses two-phase cancellation strategy:\n   * 1. Sets cancellation flag for timeout callbacks\n   * 2. Clears active timeout to prevent execution\n   *\n   * This dual approach ensures no opponent moves execute after cancellation,\n   * even if the timeout has already fired but not yet executed.\n   */\n  cancel(): void {\n    this.isCancelled = true;\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      this.timeout = undefined;\n      getLogger().debug(\n        \"[OpponentTurnHandler] Successfully cancelled scheduled opponent turn\",\n      );\n    } else {\n      getLogger().debug(\n        \"[OpponentTurnHandler] WARNING: No timeout to cancel, but set cancellation flag\",\n      );\n    }\n  }\n\n  /**\n   * Schedules optimal opponent move execution with sophisticated timing control\n   *\n   * @param {StoreApi} api - Zustand store API for state management\n   * @param {number} [delay=500] - Delay in milliseconds before executing opponent move\n   * @param {Object} [options] - Optional configuration\n   * @param {Function} [options.onOpponentMoveComplete] - Callback after opponent move completes\n   *\n   * @description\n   * Coordinates the scheduling and execution of optimal opponent moves using tablebase data.\n   * Provides natural game pacing while ensuring clean state management and error handling.\n   *\n   * @remarks\n   * **Race Condition Prevention:**\n   * - Cancels any existing scheduled opponent turn before scheduling new one\n   * - Resets cancellation flags for clean state\n   * - Multiple state checks before execution\n   */\n  schedule(\n    api: StoreApi,\n    delay: number = OPPONENT_TURN_DELAY,\n    options?: { onOpponentMoveComplete?: () => Promise<void> | void }\n  ): void {\n    const currentState = api.getState();\n    getLogger().info(\n      `[OpponentTurnHandler] ðŸŽ¯ scheduleOpponentTurn called - delay: ${delay}ms`,\n      {\n        isPlayerTurn: currentState.training.isPlayerTurn,\n        isOpponentThinking: currentState.training.isOpponentThinking,\n        currentFen: chessService.getFen(),\n        currentTurn: chessService.turn(),\n        colorToTrain: currentState.training.currentPosition?.colorToTrain,\n      }\n    );\n\n    // Cancel any previously scheduled opponent turn\n    this.cancel();\n\n    // Clear the cancellation flag when scheduling new turn\n    this.isCancelled = false;\n\n    if (typeof window !== \"undefined\") {\n      // Schedule new opponent turn with cancellable timeout\n      this.timeout = setTimeout(async () => {\n        getLogger().debug(\n          \"[OpponentTurnHandler] Timeout fired, checking if we should execute opponent turn\",\n        );\n\n        // Check if this turn was cancelled\n        if (this.isCancelled) {\n          getLogger().debug(\n            \"[OpponentTurnHandler] ABORTING - Turn was cancelled by undo\",\n          );\n          return;\n        }\n\n        // Check state again before executing - player might have undone the move\n        const currentState = api.getState();\n        if (currentState.training.isPlayerTurn) {\n          getLogger().debug(\n            \"[OpponentTurnHandler] ABORTING - It's now player's turn (move was undone)\",\n          );\n          return;\n        }\n\n        getLogger().debug(\"[OpponentTurnHandler] Executing opponent turn\");\n        await this.executeOpponentTurn(api, options?.onOpponentMoveComplete);\n\n        // Clear the timeout reference after execution\n        this.timeout = undefined;\n      }, delay);\n    } else {\n      // Fallback for non-browser environments (tests)\n      (async () => {\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        if (!this.isCancelled) {\n          await this.executeOpponentTurn(api, options?.onOpponentMoveComplete);\n        }\n      })();\n    }\n  }\n\n  /**\n   * Executes optimal opponent move using tablebase recommendations\n   *\n   * @param {StoreApi} api - Zustand store API for state management\n   * @param {Function} [onComplete] - Optional callback after move completion\n   * @returns {Promise<void>} Promise that resolves when opponent move execution is complete\n   *\n   * @private\n   * @description\n   * Core opponent move execution with comprehensive state validation and error handling.\n   * Fetches the best move from tablebase API and executes it with proper state updates.\n   */\n  private async executeOpponentTurn(\n    api: StoreApi,\n    onComplete?: () => Promise<void> | void\n  ): Promise<void> {\n    const { getState, setState } = api;\n\n    // Check if we should actually execute opponent turn\n    const state = getState();\n    getLogger().info(\"[OpponentTurnHandler] ðŸ” executeOpponentTurn called:\", {\n      isPlayerTurn: state.training.isPlayerTurn,\n      isOpponentThinking: state.training.isOpponentThinking,\n      currentFen: chessService.getFen(),\n      currentTurn: chessService.turn(),\n      trainingColor: state.training.currentPosition?.colorToTrain,\n      wasCancelled: this.isCancelled,\n    });\n\n    // Check cancellation flag first\n    if (this.isCancelled) {\n      getLogger().warn(\"[OpponentTurnHandler] âŒ ABORTING - Turn was cancelled!\");\n      return;\n    }\n\n    // Don't execute if it's the player's turn\n    if (state.training.isPlayerTurn) {\n      getLogger().warn(\"[OpponentTurnHandler] âŒ ABORTING - It's player's turn! This is the issue!\");\n      getLogger().warn(\"This prevents opponent from moving after 'Weiterspielen' click\");\n      return;\n    }\n\n    try {\n      // Get current position\n      const currentFen = chessService.getFen();\n\n      // Fetch ALL moves from tablebase to find optimal one based on DTM\n      // We need all moves to properly evaluate defense in losing positions\n      const topMoves = await tablebaseService.getTopMoves(currentFen, 10);\n\n      getLogger().info(\n        \"[OpponentTurnHandler] DEBUG: Fetched moves from tablebase:\",\n        {\n          fen: currentFen,\n          movesCount: topMoves.moves?.length || 0,\n          moves: topMoves.moves?.map((m) => ({\n            san: m.san,\n            dtm: m.dtm,\n            wdl: m.wdl,\n            category: m.category,\n          })),\n          firstMove: topMoves.moves?.[0]\n            ? {\n                san: topMoves.moves[0].san,\n                dtm: topMoves.moves[0].dtm,\n                note: \"This is what TablebaseService returned as first/best\",\n              }\n            : null,\n        },\n      );\n\n      if (\n        !topMoves.isAvailable ||\n        !topMoves.moves ||\n        topMoves.moves.length === 0\n      ) {\n        // No tablebase move available - just return control to player\n        setState((draft) => {\n          draft.training.isPlayerTurn = true;\n          draft.training.isOpponentThinking = false;\n        });\n        return;\n      }\n\n      // Select the optimal move based on game theory:\n      // 1. Prefer best outcome (win > draw > loss) by WDL\n      // 2. Within same outcome:\n      //    - If winning: pick move with LOWEST DTM (fastest win)\n      //    - If losing: pick move with HIGHEST DTM (slowest loss - best defense)\n      //    - If drawing: pick any (all equivalent)\n      const bestMove = selectOptimalMove(topMoves.moves);\n\n      // Execute the opponent move (tablebase moves should always be valid)\n      const move = chessService.move(bestMove.san);\n      if (!move) {\n        throw new Error(`Failed to execute tablebase move: ${bestMove.san}`);\n      }\n\n      // Update state - switch back to player's turn\n      setState((draft) => {\n        draft.training.isPlayerTurn = true;\n        draft.training.isOpponentThinking = false;\n\n        // Note: Removed opponent move toast to reduce UI clutter\n      });\n\n      // Check if game ended after opponent move\n      if (chessService.isGameOver()) {\n        await handleTrainingCompletion(api, false); // Player didn't win\n      }\n\n      // Call completion callback if provided\n      if (onComplete) {\n        try {\n          await onComplete();\n          getLogger().debug(\"[OpponentTurnHandler] Completion callback executed successfully\");\n        } catch (error) {\n          getLogger().error(\"[OpponentTurnHandler] Completion callback failed:\", error);\n        }\n      }\n    } catch (error) {\n      // Handle opponent move errors\n      const userMessage = ErrorService.handleUIError(\n        error instanceof Error ? error : new Error(String(error)),\n        \"OpponentMove\",\n        {\n          component: \"OpponentMove\",\n          action: \"execute\",\n        },\n      );\n\n      setState((draft) => {\n        draft.ui.toasts.push({\n          id: Date.now().toString(),\n          message: userMessage,\n          type: \"error\",\n        });\n        // Reset to player's turn and clear thinking flag on error\n        draft.training.isPlayerTurn = true;\n        draft.training.isOpponentThinking = false;\n      });\n    }\n  }\n}\n\n/**\n * Selects the optimal move from available tablebase moves based on game theory\n *\n * @param moves - Array of available tablebase moves\n * @returns The optimal move to play\n *\n * @description\n * Implements sophisticated move selection based on endgame principles:\n *\n * **Selection Strategy:**\n * 1. **Outcome Priority**: Win > Draw > Loss (by WDL value)\n * 2. **Within Same Outcome**:\n *    - **Winning** (WDL > 0): Choose move with LOWEST DTM (fastest win)\n *    - **Losing** (WDL < 0): Choose move with HIGHEST DTM (best defense, delays mate)\n *    - **Drawing** (WDL = 0): All moves equivalent, pick first\n *\n * **Rationale:**\n * - In winning positions: Convert advantage efficiently\n * - In losing positions: Maximize resistance, make opponent prove technique\n * - In drawn positions: Maintain draw with any legal move\n *\n * @example\n * ```typescript\n * // Losing position - will pick Kd7 (DTM -27) over Kc7 (DTM -15)\n * const moves = [\n *   { san: \"Kc7\", dtm: -15, wdl: -1000 },\n *   { san: \"Kd7\", dtm: -27, wdl: -1000 }, // Selected - delays mate longest\n * ];\n * const best = selectOptimalMove(moves);\n * ```\n */\nfunction selectOptimalMove(moves: TablebaseMove[]): TablebaseMove {\n  // VALIDATION: Check DTM sign consistency\n  moves.forEach((move) => {\n    if (move.wdl < 0 && move.dtm && move.dtm > 0) {\n      getLogger().warn(\n        \"[OpponentTurnHandler] WARNING: Positive DTM in losing position!\",\n        {\n          san: move.san,\n          wdl: move.wdl,\n          dtm: move.dtm,\n          category: move.category,\n        },\n      );\n    }\n  });\n\n  // Sort moves by optimal criteria\n  const sortedMoves = [...moves].sort((a, b) => {\n    // First priority: Sort by outcome (higher WDL is better)\n    if (a.wdl !== b.wdl) {\n      return b.wdl - a.wdl; // Prefer wins over draws over losses\n    }\n\n    // Same outcome - sort by DTM based on position type\n    if (\n      a.dtm === null ||\n      a.dtm === undefined ||\n      b.dtm === null ||\n      b.dtm === undefined\n    ) {\n      return 0; // Can't compare if DTM is missing\n    }\n\n    // Check position type based on WDL\n    if (a.wdl > 0) {\n      // These are \"winning\" positions for the opponent after our move\n      // For optimal defense: prefer HIGHER DTM (gives opponent longer path to win)\n      return Math.abs(b.dtm) - Math.abs(a.dtm); // FIXED: Higher DTM first for defense\n    } else if (a.wdl < 0) {\n      // LOSING position: prefer HIGHER DTM (slower loss - better defense)\n      // DTM is negative for losses\n      // Example: -27 is better than -15 (lose in 27 moves vs 15 moves)\n      return Math.abs(b.dtm) - Math.abs(a.dtm);\n    } else {\n      // DRAW: all moves equivalent\n      return 0;\n    }\n  });\n\n  const selected = sortedMoves[0];\n\n  // Log the decision for debugging\n  getLogger().info(\"[OpponentTurnHandler] Move selection:\", {\n    availableMoves: moves.map((m) => ({\n      san: m.san,\n      wdl: m.wdl,\n      dtm: m.dtm,\n      category: m.category,\n    })),\n    selectedMove: {\n      san: selected.san,\n      wdl: selected.wdl,\n      dtm: selected.dtm,\n      category: selected.category,\n    },\n    reason:\n      selected.wdl < 0\n        ? `Best defense - delays mate for ${Math.abs(selected.dtm || 0)} moves`\n        : selected.wdl > 0\n          ? `Fastest win - mate in ${Math.abs(selected.dtm || 0)} moves`\n          : \"Draw maintaining move\",\n  });\n\n  return selected;\n}\n\n// Singleton instance for backward compatibility and global access\nlet managerInstance: OpponentTurnManager | null = null;\n\n/**\n * Gets the singleton instance of OpponentTurnManager\n * \n * @returns {OpponentTurnManager} The singleton manager instance\n * \n * @description\n * Provides a singleton instance for backward compatibility with existing code\n * that expects global functions. This allows gradual migration to the class-based\n * approach while maintaining existing API contracts.\n * \n * @example\n * ```typescript\n * const manager = getOpponentTurnManager();\n * manager.schedule(api);\n * ```\n */\nexport function getOpponentTurnManager(): OpponentTurnManager {\n  if (!managerInstance) {\n    managerInstance = new OpponentTurnManager();\n  }\n  return managerInstance;\n}\n\n/**\n * Schedules opponent turn (backward compatibility wrapper)\n * \n * @deprecated Use getOpponentTurnManager().schedule() instead\n * \n * @param {StoreApi} api - Zustand store API\n * @param {number} [delay] - Delay in milliseconds\n * @param {Object} [options] - Optional configuration\n * \n * @description\n * Legacy wrapper function for backward compatibility with existing code.\n * New code should use the OpponentTurnManager class directly.\n * \n * @example\n * ```typescript\n * // Old way (still works but deprecated)\n * scheduleOpponentTurn(api);\n * \n * // New way (recommended)\n * getOpponentTurnManager().schedule(api);\n * ```\n */\nexport function scheduleOpponentTurn(\n  api: StoreApi,\n  delay?: number,\n  options?: { onOpponentMoveComplete?: () => Promise<void> | void }\n): void {\n  getOpponentTurnManager().schedule(api, delay, options);\n}\n\n/**\n * Cancels scheduled opponent turn (backward compatibility wrapper)\n * \n * @deprecated Use getOpponentTurnManager().cancel() instead\n * \n * @description\n * Legacy wrapper function for backward compatibility with existing code.\n * New code should use the OpponentTurnManager class directly.\n * \n * @example\n * ```typescript\n * // Old way (still works but deprecated)\n * cancelScheduledOpponentTurn();\n * \n * // New way (recommended)\n * getOpponentTurnManager().cancel();\n * ```\n */\nexport function cancelScheduledOpponentTurn(): void {\n  getOpponentTurnManager().cancel();\n}"],"names":["cancelScheduledOpponentTurn","getOpponentTurnManager","scheduleOpponentTurn","OPPONENT_TURN_DELAY","OpponentTurnManager","cancel","isCancelled","timeout","clearTimeout","undefined","getLogger","debug","schedule","api","delay","options","currentState","getState","info","isPlayerTurn","training","isOpponentThinking","currentFen","chessService","getFen","currentTurn","turn","colorToTrain","currentPosition","window","setTimeout","executeOpponentTurn","onOpponentMoveComplete","Promise","resolve","onComplete","state","setState","trainingColor","wasCancelled","warn","topMoves","tablebaseService","getTopMoves","fen","movesCount","moves","length","map","m","san","dtm","wdl","category","firstMove","note","isAvailable","draft","bestMove","selectOptimalMove","move","Error","isGameOver","handleTrainingCompletion","error","userMessage","ErrorService","handleUIError","String","component","action","ui","toasts","push","id","Date","now","toString","message","type","forEach","sortedMoves","sort","a","b","Math","abs","selected","availableMoves","selectedMove","reason","managerInstance"],"mappings":"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"}