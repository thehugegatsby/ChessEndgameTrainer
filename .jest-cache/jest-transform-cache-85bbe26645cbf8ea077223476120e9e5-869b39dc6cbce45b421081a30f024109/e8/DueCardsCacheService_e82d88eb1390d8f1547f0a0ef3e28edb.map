{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/DueCardsCacheService.ts"],"sourcesContent":["/**\n * @file DueCardsCacheService\n * @description High-performance localStorage cache for Due Cards with TTL and LRU\n * \n * This service provides intelligent caching for due cards calculation with:\n * - 24h TTL with midnight invalidation (UTC-based)\n * - LRU-based memory management for large collections\n * - Graceful fallback on cache corruption or localStorage issues\n * - Performance optimization for collections >500 cards\n * \n * @example\n * ```typescript\n * const cacheService = DueCardsCacheService.getInstance();\n * \n * // Get cached due cards (returns null if cache miss/expired)\n * const cachedResult = cacheService.getDueCards(userId);\n * \n * // Cache new calculation result\n * cacheService.setDueCards(userId, { dueCards, timestamp, stats });\n * \n * // Clear cache on user logout\n * cacheService.clearUserCache(userId);\n * ```\n */\n\nimport type { DueCard, DueCardsStats } from '@shared/types/progress';\nimport { getLogger } from '@shared/services/logging/Logger';\n\nconst logger = getLogger().setContext('DueCardsCacheService');\n\n/**\n * Cache entry interface for due cards calculation result\n */\nexport interface DueCacheEntry {\n  /** Array of due cards at time of calculation */\n  dueCards: DueCard[];\n  \n  /** Timestamp when this calculation was performed */\n  calculatedAt: number;\n  \n  /** Statistics at time of calculation */\n  stats: DueCardsStats;\n  \n  /** Input hash for invalidation detection */\n  inputHash: string;\n  \n  /** Entry creation timestamp for TTL */\n  createdAt: number;\n  \n  /** Last access timestamp for LRU */\n  lastAccessedAt: number;\n}\n\n/**\n * Cache metadata for memory management\n */\ninterface CacheMetadata {\n  /** Total number of cached entries */\n  totalEntries: number;\n  \n  /** Combined size estimate in bytes */\n  estimatedSize: number;\n  \n  /** Last cleanup timestamp */\n  lastCleanup: number;\n  \n  /** Cache version for migration support */\n  version: number;\n}\n\n/**\n * Cache configuration constants\n */\nconst CACHE_CONFIG = {\n  /** Cache key prefix in localStorage */\n  KEY_PREFIX: 'endgame_due_cards_',\n  \n  /** Metadata key in localStorage */\n  METADATA_KEY: 'endgame_cache_metadata',\n  \n  /** Current cache version */\n  VERSION: 1,\n  \n  /** TTL in milliseconds (24 hours) */\n  TTL_MS: 24 * 60 * 60 * 1000,\n  \n  /** Maximum entries before LRU cleanup */\n  MAX_ENTRIES: 50,\n  \n  /** Maximum estimated size in bytes (5MB) */\n  MAX_SIZE_BYTES: 5 * 1024 * 1024,\n  \n  /** Cleanup interval in milliseconds (1 hour) */\n  CLEANUP_INTERVAL_MS: 60 * 60 * 1000,\n  \n  /** Large collection threshold for performance warnings */\n  LARGE_COLLECTION_THRESHOLD: 500,\n} as const;\n\n/**\n * High-performance Due Cards cache service with localStorage persistence\n * \n * Features:\n * - Singleton pattern for consistent cache state\n * - UTC-based midnight invalidation \n * - LRU eviction for memory management\n * - Input hash validation for cache invalidation\n * - Performance monitoring and warnings\n * - Graceful error handling with fallback\n */\nexport class DueCardsCacheService {\n  private static instance: DueCardsCacheService | null = null;\n  private cleanupTimeoutId: NodeJS.Timeout | null = null;\n\n  /**\n   * Private constructor for singleton pattern\n   */\n  private constructor() {\n    this.scheduleCleanup();\n    logger.debug('DueCardsCacheService initialized');\n  }\n\n  /**\n   * Get singleton instance\n   * \n   * @returns DueCardsCacheService instance\n   */\n  public static getInstance(): DueCardsCacheService {\n    if (!DueCardsCacheService.instance) {\n      DueCardsCacheService.instance = new DueCardsCacheService();\n    }\n    return DueCardsCacheService.instance;\n  }\n\n  /**\n   * Get cached due cards for a user\n   * \n   * @param userId - User identifier\n   * @param inputHash - Hash of input data for validation\n   * @returns Cached result or null if cache miss/expired\n   */\n  public getDueCards(userId: string, inputHash: string): DueCacheEntry | null {\n    if (!this.isLocalStorageAvailable()) {\n      return null;\n    }\n\n    try {\n      const cacheKey = this.getCacheKey(userId);\n      const cached = localStorage.getItem(cacheKey);\n      \n      if (!cached) {\n        logger.debug('Cache miss for user', { userId });\n        return null;\n      }\n\n      const entry: DueCacheEntry = JSON.parse(cached);\n      \n      // Validate cache entry structure\n      if (!this.isValidCacheEntry(entry)) {\n        logger.warn('Invalid cache entry structure, removing', { userId });\n        this.clearUserCache(userId);\n        return null;\n      }\n\n      // Check TTL expiration\n      if (this.isExpired(entry)) {\n        logger.debug('Cache expired for user', { \n          userId, \n          age: Date.now() - entry.createdAt \n        });\n        this.clearUserCache(userId);\n        return null;\n      }\n\n      // Check midnight invalidation (UTC)\n      if (this.isAfterMidnight(entry.createdAt)) {\n        logger.debug('Cache invalid due to midnight rollover', { userId });\n        this.clearUserCache(userId);\n        return null;\n      }\n\n      // Validate input hash for cache invalidation\n      if (entry.inputHash !== inputHash) {\n        logger.debug('Cache invalid due to input change', { userId });\n        this.clearUserCache(userId);\n        return null;\n      }\n\n      // Update last accessed timestamp for LRU\n      const updatedEntry = {\n        ...entry,\n        lastAccessedAt: Date.now()\n      };\n      localStorage.setItem(cacheKey, JSON.stringify(updatedEntry));\n\n      logger.debug('Cache hit for user', { \n        userId,\n        dueCount: entry.dueCards.length,\n        age: Date.now() - entry.createdAt\n      });\n\n      return updatedEntry;\n\n    } catch (error) {\n      logger.error('Error reading from cache', { \n        userId, \n        error: (error as Error).message \n      });\n      this.clearUserCache(userId);\n      return null;\n    }\n  }\n\n  /**\n   * Cache due cards calculation result\n   * \n   * @param userId - User identifier\n   * @param dueCards - Calculated due cards\n   * @param stats - Calculation statistics\n   * @param inputHash - Hash of input data\n   */\n  public setDueCards(\n    userId: string, \n    dueCards: DueCard[], \n    stats: DueCardsStats,\n    inputHash: string\n  ): void {\n    if (!this.isLocalStorageAvailable()) {\n      return;\n    }\n\n    try {\n      // Performance warning for large collections\n      if (dueCards.length > CACHE_CONFIG.LARGE_COLLECTION_THRESHOLD) {\n        logger.warn('Caching large collection', { \n          userId, \n          count: dueCards.length \n        });\n      }\n\n      const now = Date.now();\n      const entry: DueCacheEntry = {\n        dueCards,\n        calculatedAt: now,\n        stats,\n        inputHash,\n        createdAt: now,\n        lastAccessedAt: now\n      };\n\n      const cacheKey = this.getCacheKey(userId);\n      const serialized = JSON.stringify(entry);\n      \n      // Check if we need to make space\n      this.ensureSpaceAvailable(serialized.length);\n      \n      localStorage.setItem(cacheKey, serialized);\n      this.updateMetadata(1, serialized.length);\n\n      logger.debug('Cached due cards for user', { \n        userId,\n        dueCount: dueCards.length,\n        size: serialized.length\n      });\n\n    } catch (error) {\n      logger.error('Error writing to cache', { \n        userId, \n        error: (error as Error).message \n      });\n    }\n  }\n\n  /**\n   * Clear cache for specific user\n   * \n   * @param userId - User identifier\n   */\n  public clearUserCache(userId: string): void {\n    if (!this.isLocalStorageAvailable()) {\n      return;\n    }\n\n    try {\n      const cacheKey = this.getCacheKey(userId);\n      const existing = localStorage.getItem(cacheKey);\n      \n      if (existing) {\n        localStorage.removeItem(cacheKey);\n        this.updateMetadata(-1, -existing.length);\n        logger.debug('Cleared cache for user', { userId });\n      }\n    } catch (error) {\n      logger.error('Error clearing user cache', { \n        userId, \n        error: (error as Error).message \n      });\n    }\n  }\n\n  /**\n   * Clear all cache entries\n   */\n  public clearAllCache(): void {\n    if (!this.isLocalStorageAvailable()) {\n      return;\n    }\n\n    try {\n      const keysToRemove: string[] = [];\n      \n      // Find all cache keys\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key?.startsWith(CACHE_CONFIG.KEY_PREFIX)) {\n          keysToRemove.push(key);\n        }\n      }\n\n      // Remove all cache entries\n      keysToRemove.forEach(key => localStorage.removeItem(key));\n      \n      // Reset metadata\n      localStorage.removeItem(CACHE_CONFIG.METADATA_KEY);\n      \n      logger.info('Cleared all cache entries', { \n        removedKeys: keysToRemove.length \n      });\n    } catch (error) {\n      logger.error('Error clearing all cache', { \n        error: (error as Error).message \n      });\n    }\n  }\n\n  /**\n   * Get cache statistics\n   * \n   * @returns Cache statistics\n   */\n  public getCacheStats() {\n    if (!this.isLocalStorageAvailable()) {\n      return {\n        available: false,\n        totalEntries: 0,\n        estimatedSize: 0,\n        lastCleanup: null\n      };\n    }\n\n    const metadata = this.getMetadata();\n    return {\n      available: true,\n      totalEntries: metadata.totalEntries,\n      estimatedSize: metadata.estimatedSize,\n      lastCleanup: metadata.lastCleanup ? new Date(metadata.lastCleanup) : null,\n      maxEntries: CACHE_CONFIG.MAX_ENTRIES,\n      maxSize: CACHE_CONFIG.MAX_SIZE_BYTES\n    };\n  }\n\n  /**\n   * Force cleanup of expired and least recently used entries\n   */\n  public forceCleanup(): void {\n    this.performCleanup();\n  }\n\n  /**\n   * Destroy service and cleanup resources\n   */\n  public destroy(): void {\n    if (this.cleanupTimeoutId) {\n      clearTimeout(this.cleanupTimeoutId);\n      this.cleanupTimeoutId = null;\n    }\n    DueCardsCacheService.instance = null;\n    logger.debug('DueCardsCacheService destroyed');\n  }\n\n  // Private helper methods\n\n  /**\n   * Generate cache key for user\n   */\n  private getCacheKey(userId: string): string {\n    return `${CACHE_CONFIG.KEY_PREFIX}${userId}`;\n  }\n\n  /**\n   * Check if localStorage is available\n   */\n  private isLocalStorageAvailable(): boolean {\n    try {\n      const testKey = '__localStorage_test__';\n      localStorage.setItem(testKey, 'test');\n      localStorage.removeItem(testKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Validate cache entry structure\n   */\n  private isValidCacheEntry(entry: any): entry is DueCacheEntry {\n    return (\n      typeof entry === 'object' &&\n      entry !== null &&\n      Array.isArray(entry.dueCards) &&\n      typeof entry.calculatedAt === 'number' &&\n      typeof entry.stats === 'object' &&\n      typeof entry.inputHash === 'string' &&\n      typeof entry.createdAt === 'number' &&\n      typeof entry.lastAccessedAt === 'number'\n    );\n  }\n\n  /**\n   * Check if cache entry is expired\n   */\n  private isExpired(entry: DueCacheEntry): boolean {\n    return Date.now() - entry.createdAt > CACHE_CONFIG.TTL_MS;\n  }\n\n  /**\n   * Check if entry was created before last midnight (UTC)\n   */\n  private isAfterMidnight(createdAt: number): boolean {\n    const now = Date.now();\n    const nowDate = new Date(now);\n    const todayMidnightUTC = new Date(\n      Date.UTC(\n        nowDate.getUTCFullYear(),\n        nowDate.getUTCMonth(),\n        nowDate.getUTCDate(),\n        0, 0, 0, 0\n      )\n    ).getTime();\n    \n    return createdAt < todayMidnightUTC;\n  }\n\n  /**\n   * Get cache metadata\n   */\n  private getMetadata(): CacheMetadata {\n    try {\n      const stored = localStorage.getItem(CACHE_CONFIG.METADATA_KEY);\n      if (stored) {\n        const metadata = JSON.parse(stored) as CacheMetadata;\n        if (metadata.version === CACHE_CONFIG.VERSION) {\n          return metadata;\n        }\n      }\n    } catch {\n      // Fall through to default\n    }\n\n    return {\n      totalEntries: 0,\n      estimatedSize: 0,\n      lastCleanup: 0,\n      version: CACHE_CONFIG.VERSION\n    };\n  }\n\n  /**\n   * Update cache metadata\n   */\n  private updateMetadata(entriesDelta: number, sizeDelta: number): void {\n    try {\n      const metadata = this.getMetadata();\n      metadata.totalEntries = Math.max(0, metadata.totalEntries + entriesDelta);\n      metadata.estimatedSize = Math.max(0, metadata.estimatedSize + sizeDelta);\n      \n      localStorage.setItem(\n        CACHE_CONFIG.METADATA_KEY, \n        JSON.stringify(metadata)\n      );\n    } catch (error) {\n      logger.warn('Failed to update cache metadata', { \n        error: (error as Error).message \n      });\n    }\n  }\n\n  /**\n   * Ensure space is available for new entry\n   */\n  private ensureSpaceAvailable(newEntrySize: number): void {\n    const metadata = this.getMetadata();\n    \n    // Check if cleanup is needed\n    const needsCleanup = (\n      metadata.totalEntries >= CACHE_CONFIG.MAX_ENTRIES ||\n      metadata.estimatedSize + newEntrySize > CACHE_CONFIG.MAX_SIZE_BYTES\n    );\n\n    if (needsCleanup) {\n      logger.debug('Cache space cleanup needed', {\n        totalEntries: metadata.totalEntries,\n        estimatedSize: metadata.estimatedSize,\n        newEntrySize\n      });\n      \n      this.performCleanup();\n    }\n  }\n\n  /**\n   * Perform cache cleanup (expired entries and LRU eviction)\n   */\n  private performCleanup(): void {\n    if (!this.isLocalStorageAvailable()) {\n      return;\n    }\n\n    try {\n      const entries: Array<{ key: string; entry: DueCacheEntry }> = [];\n      const now = Date.now();\n      \n      // Collect all cache entries\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key?.startsWith(CACHE_CONFIG.KEY_PREFIX)) {\n          try {\n            const stored = localStorage.getItem(key);\n            if (stored) {\n              const entry = JSON.parse(stored) as DueCacheEntry;\n              if (this.isValidCacheEntry(entry)) {\n                entries.push({ key, entry });\n              } else {\n                // Remove invalid entry\n                localStorage.removeItem(key);\n              }\n            }\n          } catch {\n            // Remove corrupted entry\n            localStorage.removeItem(key);\n          }\n        }\n      }\n\n      let removedCount = 0;\n      let removedSize = 0;\n\n      // Remove expired entries\n      entries.forEach(({ key, entry }) => {\n        if (this.isExpired(entry) || this.isAfterMidnight(entry.createdAt)) {\n          const serialized = JSON.stringify(entry);\n          localStorage.removeItem(key);\n          removedCount++;\n          removedSize += serialized.length;\n        }\n      });\n\n      // Remove LRU entries if still over limit\n      const remaining = entries.filter(({ key }) => {\n        return localStorage.getItem(key) !== null;\n      });\n\n      if (remaining.length > CACHE_CONFIG.MAX_ENTRIES) {\n        // Sort by last accessed (LRU first)\n        remaining.sort((a, b) => a.entry.lastAccessedAt - b.entry.lastAccessedAt);\n        \n        const toRemove = remaining.length - CACHE_CONFIG.MAX_ENTRIES;\n        for (let i = 0; i < toRemove; i++) {\n          const { key, entry } = remaining[i];\n          const serialized = JSON.stringify(entry);\n          localStorage.removeItem(key);\n          removedCount++;\n          removedSize += serialized.length;\n        }\n      }\n\n      // Update metadata\n      if (removedCount > 0) {\n        this.updateMetadata(-removedCount, -removedSize);\n        \n        const metadata = this.getMetadata();\n        metadata.lastCleanup = now;\n        localStorage.setItem(\n          CACHE_CONFIG.METADATA_KEY, \n          JSON.stringify(metadata)\n        );\n\n        logger.info('Cache cleanup completed', {\n          removedEntries: removedCount,\n          removedSize,\n          remainingEntries: metadata.totalEntries\n        });\n      }\n\n    } catch (error) {\n      logger.error('Cache cleanup failed', { \n        error: (error as Error).message \n      });\n    }\n  }\n\n  /**\n   * Schedule periodic cleanup\n   */\n  private scheduleCleanup(): void {\n    if (this.cleanupTimeoutId) {\n      clearTimeout(this.cleanupTimeoutId);\n    }\n\n    this.cleanupTimeoutId = setTimeout(() => {\n      this.performCleanup();\n      this.scheduleCleanup(); // Reschedule\n    }, CACHE_CONFIG.CLEANUP_INTERVAL_MS);\n  }\n}\n\n/**\n * Create simple hash for input validation\n * \n * @param input - Input to hash\n * @returns Simple hash string\n */\nexport function createInputHash(input: any): string {\n  const str = typeof input === 'string' ? input : JSON.stringify(input);\n  let hash = 0;\n  \n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = ((hash << 5) - hash) + char;\n    hash = hash & hash; // Convert to 32-bit integer\n  }\n  \n  return Math.abs(hash).toString(36);\n}\n\n// Export singleton instance for convenience\nexport const dueCardsCacheService = DueCardsCacheService.getInstance();"],"names":["DueCardsCacheService","createInputHash","dueCardsCacheService","logger","getLogger","setContext","CACHE_CONFIG","KEY_PREFIX","METADATA_KEY","VERSION","TTL_MS","MAX_ENTRIES","MAX_SIZE_BYTES","CLEANUP_INTERVAL_MS","LARGE_COLLECTION_THRESHOLD","getInstance","instance","getDueCards","userId","inputHash","isLocalStorageAvailable","cacheKey","getCacheKey","cached","localStorage","getItem","debug","entry","JSON","parse","isValidCacheEntry","warn","clearUserCache","isExpired","age","Date","now","createdAt","isAfterMidnight","updatedEntry","lastAccessedAt","setItem","stringify","dueCount","dueCards","length","error","message","setDueCards","stats","count","calculatedAt","serialized","ensureSpaceAvailable","updateMetadata","size","existing","removeItem","clearAllCache","keysToRemove","i","key","startsWith","push","forEach","info","removedKeys","getCacheStats","available","totalEntries","estimatedSize","lastCleanup","metadata","getMetadata","maxEntries","maxSize","forceCleanup","performCleanup","destroy","cleanupTimeoutId","clearTimeout","testKey","Array","isArray","nowDate","todayMidnightUTC","UTC","getUTCFullYear","getUTCMonth","getUTCDate","getTime","stored","version","entriesDelta","sizeDelta","Math","max","newEntrySize","needsCleanup","entries","removedCount","removedSize","remaining","filter","sort","a","b","toRemove","removedEntries","remainingEntries","scheduleCleanup","setTimeout","input","str","hash","char","charCodeAt","abs","toString"],"mappings":"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"}