48484b03d1fc9a915512cbbad358f870
/**
 * Optimized Tablebase Service - Single API Call Architecture
 *
 * @remarks
 * This service uses the Lichess Tablebase API's "moves" field to get all move
 * evaluations in a single API call, instead of making N+1 calls.
 *
 * Key improvements:
 * - 1 API call instead of 20-40 for getTopMoves
 * - Caches complete tablebase entries including moves
 * - Correct WDL perspective handling
 * - No chess.js dependency for move generation
 * - FEN normalization for improved cache hit rate
 *
 * Important limitations:
 * - DTM (Distance to Mate) values are only available for positions with ≤5 pieces
 * - Positions with 6-7 pieces only have DTZ (Distance to Zeroing) values
 * - Rate limiting applies (~130 rapid requests trigger limits)
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "tablebaseService", {
    enumerable: true,
    get: function() {
        return tablebaseService;
    }
});
const _fenValidator = require("../utils/fenValidator");
const _logging = require("./logging");
const _constants = require("../../config/constants");
const _zod = require("zod");
const _tablebaseSchemas = require("../types/tablebaseSchemas");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const logger = (0, _logging.getLogger)().setContext("TablebaseService");
class TablebaseService {
    /**
   * Get tablebase evaluation for a position
   * @param {string} fen - Position in FEN notation
   * @returns {Promise<TablebaseEvaluation>} Evaluation result
   *
   * @example
   * const eval = await tablebaseService.getEvaluation(fen);
   * if (eval.isAvailable) {
   *   logger.info(`Position is ${eval.result.category}`);
   * }
   */ async getEvaluation(fen) {
        try {
            const entry = await this._getOrFetchTablebaseEntry(fen);
            if (!entry) {
                return {
                    isAvailable: false
                };
            }
            return {
                isAvailable: true,
                result: {
                    wdl: entry.position.wdl,
                    dtz: entry.position.dtz,
                    dtm: entry.position.dtm,
                    category: entry.position.category,
                    precise: entry.position.precise,
                    evaluation: entry.position.evaluation
                }
            };
        } catch (error) {
            logger.error("Failed to get evaluation", error, {
                fen
            });
            return {
                isAvailable: false,
                error: error instanceof Error ? error.message : "Unknown error"
            };
        }
    }
    /**
   * Get top moves from tablebase
   * @param {string} fen - Position in FEN notation
   * @param {number} limit - Maximum number of moves to return
   * @returns {Promise<TablebaseMovesResult>} Top moves with evaluations
   *
   * @remarks
   * This now makes only ONE API call and returns moves from the cached entry.
   * The Lichess API already provides all moves sorted by quality.
   *
   * @example
   * const moves = await tablebaseService.getTopMoves(fen, 5);
   * if (moves.isAvailable) {
   *   logger.info(`Best move: ${moves.moves[0].san}`);
   * }
   */ async getTopMoves(fen, limit = 3) {
        try {
            var _sortedMoves_;
            const entry = await this._getOrFetchTablebaseEntry(fen);
            if (!entry || !entry.moves.length) {
                return {
                    isAvailable: false,
                    error: "No moves available for this position"
                };
            }
            // Sort moves by quality (WDL value, then DTZ)
            // Higher WDL = better for the player, then lower DTZ = faster to goal
            const sortedMoves = [
                ...entry.moves
            ].sort((a, b)=>{
                // Primary sort: by WDL (higher is better)
                if (a.wdl !== b.wdl) {
                    return b.wdl - a.wdl;
                }
                // Secondary sort: for moves that are "wins" from opponent's perspective after our move,
                // we want to choose the move that gives the opponent the LONGEST path to win (best defense)
                if (a.wdl > 0) {
                    var _a_dtm, _ref;
                    // These are "winning" positions for the opponent after our move
                    // For optimal defense: prefer moves that give opponent HIGHER DTM (slower win for them)
                    const aDtx = (_ref = (_a_dtm = a.dtm) !== null && _a_dtm !== void 0 ? _a_dtm : a.dtz) !== null && _ref !== void 0 ? _ref : 0;
                    var _b_dtm, _ref1;
                    const bDtx = (_ref1 = (_b_dtm = b.dtm) !== null && _b_dtm !== void 0 ? _b_dtm : b.dtz) !== null && _ref1 !== void 0 ? _ref1 : 0;
                    return Math.abs(aDtx) - Math.abs(bDtx); // FIXED: Lower DTM first for faster wins
                } else if (a.wdl < 0) {
                    var _a_dtm1, _ref2;
                    // Losing - prefer slower loss (larger absolute DTM value)
                    const aDtx = (_ref2 = (_a_dtm1 = a.dtm) !== null && _a_dtm1 !== void 0 ? _a_dtm1 : a.dtz) !== null && _ref2 !== void 0 ? _ref2 : 0;
                    var _b_dtm1, _ref3;
                    const bDtx = (_ref3 = (_b_dtm1 = b.dtm) !== null && _b_dtm1 !== void 0 ? _b_dtm1 : b.dtz) !== null && _ref3 !== void 0 ? _ref3 : 0;
                    return Math.abs(bDtx) - Math.abs(aDtx);
                }
                // Draw - prefer maintaining draw (DTZ doesn't matter much)
                return 0;
            });
            var _sortedMoves__wdl;
            // Take only the best moves (same WDL as the absolute best)
            const bestWdl = (_sortedMoves__wdl = (_sortedMoves_ = sortedMoves[0]) === null || _sortedMoves_ === void 0 ? void 0 : _sortedMoves_.wdl) !== null && _sortedMoves__wdl !== void 0 ? _sortedMoves__wdl : 0;
            const bestMoves = sortedMoves.filter((move)=>move.wdl === bestWdl);
            // Return up to 'limit' of the best moves
            const topInternalMoves = bestMoves.slice(0, limit);
            // Convert internal moves to external format (without zeroing field)
            const topMoves = topInternalMoves.map((move)=>({
                    uci: move.uci,
                    san: move.san,
                    wdl: move.wdl,
                    dtz: move.dtz,
                    dtm: move.dtm,
                    category: move.category
                }));
            // ENHANCED DEBUG LOGGING
            logger.info("TablebaseService.getTopMoves DETAILED OUTPUT", {
                fen,
                requestedLimit: limit,
                totalMovesFromAPI: entry.moves.length,
                bestWdl,
                movesWithBestWdl: bestMoves.length,
                returnedMoves: topMoves.length,
                returnedMoveDetails: topMoves.map((m)=>({
                        san: m.san,
                        wdl: m.wdl,
                        dtm: m.dtm,
                        category: m.category
                    })),
                sortingApplied: bestWdl < 0 ? "Defensive (highest DTM first)" : bestWdl > 0 ? "Offensive (lowest DTM first)" : "Draw"
            });
            return {
                isAvailable: true,
                moves: topMoves
            };
        } catch (error) {
            logger.error("Failed to get top moves", error, {
                fen
            });
            return {
                isAvailable: false,
                error: error instanceof Error ? error.message : "Unknown error"
            };
        }
    }
    /**
   * Normalize FEN for tablebase lookup
   * @private
   * @param {string} fen - Full FEN string
   * @returns {string} Normalized FEN (first 4 fields only)
   *
   * @remarks
   * Tablebase only cares about:
   * 1. Piece placement
   * 2. Side to move
   * 3. Castling rights
   * 4. En passant square
   *
   * Halfmove clock and fullmove number are irrelevant for tablebase lookup
   */ _normalizeFen(fen) {
        return fen.split(" ").slice(0, 4).join(" ");
    }
    /**
   * Core method to fetch or retrieve cached tablebase data
   * @private
   * @param {string} fen - Position to look up
   * @returns {Promise<TablebaseEntry | null>} Complete tablebase data or null
   *
   * @remarks
   * This method:
   * 1. Validates and normalizes the FEN
   * 2. Checks the cache
   * 3. Makes ONE API call if needed
   * 4. Transforms the response to our internal format
   * 5. Caches the complete entry including all moves
   */ async _getOrFetchTablebaseEntry(fen) {
        // Validate FEN
        const validation = (0, _fenValidator.validateAndSanitizeFen)(fen);
        if (!validation.isValid) {
            throw new Error(`Invalid FEN: ${validation.errors.join(", ")}`);
        }
        const sanitizedFen = validation.sanitized;
        const normalizedFen = this._normalizeFen(sanitizedFen);
        // Check piece count
        const pieceCount = this._countPieces(sanitizedFen);
        if (pieceCount > this.maxPieces) {
            logger.debug("Too many pieces for tablebase", {
                fen: sanitizedFen,
                pieceCount
            });
            return null;
        }
        // Check cache with normalized FEN
        const cached = this.cache.get(normalizedFen);
        if (cached && cached.expiry > Date.now()) {
            logger.debug("Cache hit for tablebase entry", {
                fen: normalizedFen
            });
            this.metrics.recordCacheHit();
            return cached.entry;
        }
        this.metrics.recordCacheMiss();
        // Check if request already in flight (request deduplication)
        const pending = this.pendingRequests.get(normalizedFen);
        if (pending) {
            logger.debug("Request already in flight, waiting", {
                fen: normalizedFen
            });
            this.metrics.recordDeduplication();
            return pending;
        }
        // Create new request with proper cleanup on both success and failure
        const request = this._fetchAndTransform(sanitizedFen, normalizedFen);
        // Store the promise with cleanup handler
        const promiseWithCleanup = request.finally(()=>{
            // Remove from pending requests on both success and failure
            this.pendingRequests.delete(normalizedFen);
        });
        this.pendingRequests.set(normalizedFen, promiseWithCleanup);
        return promiseWithCleanup;
    }
    /**
   * Fetch from API and transform response
   * @private
   * @param {string} fen - Original sanitized FEN for API call
   * @param {string} normalizedFen - Normalized FEN for caching
   */ async _fetchAndTransform(fen, normalizedFen) {
        const MAX_RETRIES = 3;
        this.metrics.recordApiCall();
        for(let attempt = 1; attempt <= MAX_RETRIES; attempt++){
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(()=>controller.abort(), 5000);
                // Always request moves to get complete tablebase entry
                const response = await fetch(`${_constants.APP_CONFIG.TABLEBASE_API_URL}/standard?fen=${encodeURIComponent(fen)}&moves=20`, {
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                if (!response.ok) {
                    this.metrics.recordApiError(response.status);
                    if (response.status === 404) {
                        // Position not in tablebase - cache this to avoid repeated queries
                        logger.info("Position not in tablebase, caching null", {
                            fen: normalizedFen
                        });
                        this._cacheEntry(normalizedFen, null);
                        return null;
                    }
                    // Rate limiting - retry with exponential backoff
                    if (response.status === 429) {
                        const delay = Math.min(1000 * Math.pow(2, attempt) + Math.random() * 1000, 10000);
                        logger.warn(`Rate limited, retrying in ${delay}ms`, {
                            attempt,
                            delay
                        });
                        await new Promise((resolve)=>setTimeout(resolve, delay));
                        continue;
                    }
                    // Don't retry other client errors
                    if (response.status >= 400 && response.status < 500) {
                        throw new Error(`Client error: ${response.status}`);
                    }
                    throw new Error(`API error: ${response.status}`);
                }
                const responseData = await response.json();
                // Validate the API response structure
                let validatedData;
                try {
                    validatedData = _tablebaseSchemas.LichessTablebaseResponseSchema.parse(responseData);
                } catch (error) {
                    if (error instanceof _zod.z.ZodError) {
                        logger.error("Malformed Lichess API response", {
                            fen,
                            errors: error.issues,
                            received: responseData
                        });
                        throw new Error("Malformed API response");
                    }
                    throw error;
                }
                // Transform to our internal format
                const entry = this._transformApiResponse(validatedData, fen);
                // Cache the transformed entry with normalized FEN
                this._cacheEntry(normalizedFen, entry);
                logger.info("Successfully fetched and cached tablebase entry", {
                    fen,
                    positionCategory: entry.position.category,
                    moveCount: entry.moves.length
                });
                return entry;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : "Unknown error";
                logger.warn(`Tablebase API attempt ${attempt}/${MAX_RETRIES} failed`, {
                    fen,
                    error: errorMessage
                });
                // Don't retry client errors
                if (error instanceof Error && error.message.startsWith("Client error")) {
                    throw error;
                }
                // Last attempt failed
                if (attempt === MAX_RETRIES) {
                    logger.error("API call failed after max retries", {
                        error,
                        fen
                    });
                    if (error instanceof Error && error.name === "AbortError") {
                        throw new Error(`Request timeout after ${MAX_RETRIES} retries`);
                    }
                    throw new Error(`Max retries (${MAX_RETRIES}) exceeded. Last error: ${errorMessage}`);
                }
                // Wait before retry with exponential backoff
                await new Promise((resolve)=>setTimeout(resolve, 250 * attempt));
            }
        }
        // Should never reach here
        throw new Error("Unexpected error in fetch loop");
    }
    /**
   * Transform Lichess API response to internal format
   * @private
   *
   * @remarks
   * Critical transformations:
   * 1. Convert category strings to typed categories
   * 2. Calculate WDL values from categories
   * 3. Invert move evaluations to player-to-move perspective
   * 4. Handle Black's perspective correctly
   */ _transformApiResponse(api, fen) {
        const isBlackToMove = fen.split(" ")[1] === "b";
        // Transform position evaluation
        const positionCategory = api.category;
        let positionWdl = this._categoryToWdl(positionCategory);
        // WDL is already from the perspective of the side to move
        // No need to negate for Black positions - the API gives the result from the mover's perspective
        // Handle -0 case to ensure it's just 0
        if (positionWdl === -0) {
            positionWdl = 0;
        }
        // Transform moves with correct perspective (moves array guaranteed by schema)
        const moves = (api.moves || []).map((apiMove)=>{
            // API gives evaluation AFTER the move (from opponent's perspective)
            // We need to invert it to get the evaluation FROM the mover's perspective
            const moveCategory = this._invertCategory(apiMove.category);
            let moveWdl = this._categoryToWdl(moveCategory);
            // For Black, we need to negate WDL since it's from White's perspective
            if (isBlackToMove) {
                moveWdl = -moveWdl;
            }
            return {
                uci: apiMove.uci,
                san: apiMove.san,
                category: moveCategory,
                wdl: moveWdl,
                dtz: apiMove.dtz,
                dtm: apiMove.dtm,
                zeroing: apiMove.zeroing || false
            };
        });
        var _api_dtm;
        return {
            position: {
                category: positionCategory,
                wdl: positionWdl,
                dtz: api.dtz,
                dtm: (_api_dtm = api.dtm) !== null && _api_dtm !== void 0 ? _api_dtm : null,
                precise: api.precise_dtz !== undefined && api.precise_dtz !== null,
                evaluation: this._getEvaluationText(positionCategory, api.dtz)
            },
            moves,
            fen,
            timestamp: Date.now()
        };
    }
    /**
   * Cache an entry with TTL
   * @private
   */ _cacheEntry(fen, entry) {
        this.cache.set(fen, {
            entry,
            expiry: Date.now() + this.cacheTtl
        });
        // Clean up old entries if cache is getting large
        if (this.cache.size > 200) {
            const now = Date.now();
            for (const [key, value] of this.cache.entries()){
                if (value.expiry < now) {
                    this.cache.delete(key);
                }
            }
        }
    }
    /**
   * Convert category to WDL value
   * @private
   */ _categoryToWdl(category) {
        switch(category){
            case "win":
                return 2;
            case "cursed-win":
            case "maybe-win":
                return 1;
            case "draw":
            case "unknown":
                return 0;
            case "blessed-loss":
            case "maybe-loss":
                return -1;
            case "loss":
                return -2;
            default:
                return 0;
        }
    }
    /**
   * Invert category for perspective change
   * @private
   */ _invertCategory(category) {
        switch(category){
            case "win":
                return "loss";
            case "loss":
                return "win";
            case "cursed-win":
                return "blessed-loss";
            case "blessed-loss":
                return "cursed-win";
            case "maybe-win":
                return "maybe-loss";
            case "maybe-loss":
                return "maybe-win";
            case "draw":
            case "unknown":
            default:
                return category;
        }
    }
    /**
   * Generate evaluation text in German
   * @private
   */ _getEvaluationText(category, dtz) {
        switch(category){
            case "win":
                return dtz ? `Gewinn in ${Math.abs(dtz)} Zügen` : "Theoretisch gewonnen";
            case "cursed-win":
                return dtz ? `Gewinn in ${Math.abs(dtz)} Zügen (50-Zug-Regel)` : "Gewinn mit 50-Zug-Regel";
            case "maybe-win":
                return "Wahrscheinlicher Gewinn";
            case "draw":
                return "Theoretisches Remis";
            case "blessed-loss":
                return dtz ? `Verlust in ${Math.abs(dtz)} Zügen (50-Zug-Regel)` : "Verlust mit 50-Zug-Regel";
            case "maybe-loss":
                return "Wahrscheinlicher Verlust";
            case "loss":
                return dtz ? `Verlust in ${Math.abs(dtz)} Zügen` : "Theoretisch verloren";
            case "unknown":
                return "Unbekannte Bewertung";
            default:
                return "Bewertung nicht verfügbar";
        }
    }
    /**
   * Count pieces in FEN
   * @private
   */ _countPieces(fen) {
        const piecesPart = fen.split(" ")[0];
        return piecesPart.replace(/[^a-zA-Z]/g, "").length;
    }
    /**
   * Clear cache (for testing)
   */ clearCache() {
        this.cache.clear();
        this.pendingRequests.clear();
    }
    /**
   * Get service metrics for monitoring
   * @returns {object} Current metrics
   */ getMetrics() {
        return this.metrics.getMetrics();
    }
    constructor(){
        _define_property(this, "cache", new Map());
        _define_property(this, "maxPieces", 7); // Lichess uses 7-piece Syzygy tablebases
        _define_property(this, "cacheTtl", 300000); // 5 minutes
        _define_property(this, "pendingRequests", new Map());
        // Metrics for monitoring
        _define_property(this, "metrics", {
            cacheHits: 0,
            cacheMisses: 0,
            apiCalls: 0,
            apiErrors: new Map(),
            requestsDeduplicated: 0,
            recordCacheHit () {
                this.cacheHits++;
            },
            recordCacheMiss () {
                this.cacheMisses++;
            },
            recordApiCall () {
                this.apiCalls++;
            },
            recordApiError (status) {
                this.apiErrors.set(status, (this.apiErrors.get(status) || 0) + 1);
            },
            recordDeduplication () {
                this.requestsDeduplicated++;
            },
            getMetrics () {
                const total = this.cacheHits + this.cacheMisses;
                return {
                    cacheHitRate: total > 0 ? this.cacheHits / total : 0,
                    totalApiCalls: this.apiCalls,
                    errorBreakdown: Object.fromEntries(this.apiErrors),
                    dedupedRequests: this.requestsDeduplicated
                };
            }
        });
    }
}
const tablebaseService = new TablebaseService();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3NlcnZpY2VzL1RhYmxlYmFzZVNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcHRpbWl6ZWQgVGFibGViYXNlIFNlcnZpY2UgLSBTaW5nbGUgQVBJIENhbGwgQXJjaGl0ZWN0dXJlXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgc2VydmljZSB1c2VzIHRoZSBMaWNoZXNzIFRhYmxlYmFzZSBBUEkncyBcIm1vdmVzXCIgZmllbGQgdG8gZ2V0IGFsbCBtb3ZlXG4gKiBldmFsdWF0aW9ucyBpbiBhIHNpbmdsZSBBUEkgY2FsbCwgaW5zdGVhZCBvZiBtYWtpbmcgTisxIGNhbGxzLlxuICpcbiAqIEtleSBpbXByb3ZlbWVudHM6XG4gKiAtIDEgQVBJIGNhbGwgaW5zdGVhZCBvZiAyMC00MCBmb3IgZ2V0VG9wTW92ZXNcbiAqIC0gQ2FjaGVzIGNvbXBsZXRlIHRhYmxlYmFzZSBlbnRyaWVzIGluY2x1ZGluZyBtb3Zlc1xuICogLSBDb3JyZWN0IFdETCBwZXJzcGVjdGl2ZSBoYW5kbGluZ1xuICogLSBObyBjaGVzcy5qcyBkZXBlbmRlbmN5IGZvciBtb3ZlIGdlbmVyYXRpb25cbiAqIC0gRkVOIG5vcm1hbGl6YXRpb24gZm9yIGltcHJvdmVkIGNhY2hlIGhpdCByYXRlXG4gKlxuICogSW1wb3J0YW50IGxpbWl0YXRpb25zOlxuICogLSBEVE0gKERpc3RhbmNlIHRvIE1hdGUpIHZhbHVlcyBhcmUgb25seSBhdmFpbGFibGUgZm9yIHBvc2l0aW9ucyB3aXRoIOKJpDUgcGllY2VzXG4gKiAtIFBvc2l0aW9ucyB3aXRoIDYtNyBwaWVjZXMgb25seSBoYXZlIERUWiAoRGlzdGFuY2UgdG8gWmVyb2luZykgdmFsdWVzXG4gKiAtIFJhdGUgbGltaXRpbmcgYXBwbGllcyAofjEzMCByYXBpZCByZXF1ZXN0cyB0cmlnZ2VyIGxpbWl0cylcbiAqL1xuXG5pbXBvcnQgeyB2YWxpZGF0ZUFuZFNhbml0aXplRmVuIH0gZnJvbSBcIi4uL3V0aWxzL2ZlblZhbGlkYXRvclwiO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIi4uL3NlcnZpY2VzL2xvZ2dpbmdcIjtcbmltcG9ydCB7IEFQUF9DT05GSUcgfSBmcm9tIFwiQC9jb25maWcvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyB6IH0gZnJvbSBcInpvZFwiO1xuaW1wb3J0IHsgTGljaGVzc1RhYmxlYmFzZVJlc3BvbnNlU2NoZW1hIH0gZnJvbSBcIi4uL3R5cGVzL3RhYmxlYmFzZVNjaGVtYXNcIjtcbmltcG9ydCB0eXBlIHtcbiAgTGljaGVzc1RhYmxlYmFzZVJlc3BvbnNlLFxuICBUYWJsZWJhc2VFbnRyeSxcbiAgVGFibGViYXNlQ2F0ZWdvcnksXG4gIFRhYmxlYmFzZUNhY2hlRW50cnksXG4gIFRhYmxlYmFzZU1vdmVJbnRlcm5hbCxcbiAgVGFibGViYXNlTW92ZSxcbiAgVGFibGViYXNlUmVzdWx0LFxuICBUYWJsZWJhc2VFdmFsdWF0aW9uLFxuICBUYWJsZWJhc2VNb3Zlc1Jlc3VsdCxcbn0gZnJvbSBcIi4uL3R5cGVzL3RhYmxlYmFzZVwiO1xuXG4vLyBSZS1leHBvcnQgdHlwZXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbmV4cG9ydCB0eXBlIHtcbiAgVGFibGViYXNlTW92ZSxcbiAgVGFibGViYXNlUmVzdWx0LFxuICBUYWJsZWJhc2VFdmFsdWF0aW9uLFxuICBUYWJsZWJhc2VNb3Zlc1Jlc3VsdCxcbn07XG5cbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpLnNldENvbnRleHQoXCJUYWJsZWJhc2VTZXJ2aWNlXCIpO1xuXG5jbGFzcyBUYWJsZWJhc2VTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBUYWJsZWJhc2VDYWNoZUVudHJ5PigpO1xuICBwcml2YXRlIHJlYWRvbmx5IG1heFBpZWNlcyA9IDc7IC8vIExpY2hlc3MgdXNlcyA3LXBpZWNlIFN5enlneSB0YWJsZWJhc2VzXG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGVUdGwgPSAzMDAwMDA7IC8vIDUgbWludXRlc1xuICBwcml2YXRlIHBlbmRpbmdSZXF1ZXN0cyA9IG5ldyBNYXA8c3RyaW5nLCBQcm9taXNlPFRhYmxlYmFzZUVudHJ5IHwgbnVsbD4+KCk7XG5cbiAgLy8gTWV0cmljcyBmb3IgbW9uaXRvcmluZ1xuICBwcml2YXRlIG1ldHJpY3MgPSB7XG4gICAgY2FjaGVIaXRzOiAwLFxuICAgIGNhY2hlTWlzc2VzOiAwLFxuICAgIGFwaUNhbGxzOiAwLFxuICAgIGFwaUVycm9yczogbmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSxcbiAgICByZXF1ZXN0c0RlZHVwbGljYXRlZDogMCxcblxuICAgIHJlY29yZENhY2hlSGl0KCkge1xuICAgICAgdGhpcy5jYWNoZUhpdHMrKztcbiAgICB9LFxuICAgIHJlY29yZENhY2hlTWlzcygpIHtcbiAgICAgIHRoaXMuY2FjaGVNaXNzZXMrKztcbiAgICB9LFxuICAgIHJlY29yZEFwaUNhbGwoKSB7XG4gICAgICB0aGlzLmFwaUNhbGxzKys7XG4gICAgfSxcbiAgICByZWNvcmRBcGlFcnJvcihzdGF0dXM6IG51bWJlcikge1xuICAgICAgdGhpcy5hcGlFcnJvcnMuc2V0KHN0YXR1cywgKHRoaXMuYXBpRXJyb3JzLmdldChzdGF0dXMpIHx8IDApICsgMSk7XG4gICAgfSxcbiAgICByZWNvcmREZWR1cGxpY2F0aW9uKCkge1xuICAgICAgdGhpcy5yZXF1ZXN0c0RlZHVwbGljYXRlZCsrO1xuICAgIH0sXG5cbiAgICBnZXRNZXRyaWNzKCkge1xuICAgICAgY29uc3QgdG90YWwgPSB0aGlzLmNhY2hlSGl0cyArIHRoaXMuY2FjaGVNaXNzZXM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZUhpdFJhdGU6IHRvdGFsID4gMCA/IHRoaXMuY2FjaGVIaXRzIC8gdG90YWwgOiAwLFxuICAgICAgICB0b3RhbEFwaUNhbGxzOiB0aGlzLmFwaUNhbGxzLFxuICAgICAgICBlcnJvckJyZWFrZG93bjogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuYXBpRXJyb3JzKSxcbiAgICAgICAgZGVkdXBlZFJlcXVlc3RzOiB0aGlzLnJlcXVlc3RzRGVkdXBsaWNhdGVkLFxuICAgICAgfTtcbiAgICB9LFxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgdGFibGViYXNlIGV2YWx1YXRpb24gZm9yIGEgcG9zaXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlbiAtIFBvc2l0aW9uIGluIEZFTiBub3RhdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUYWJsZWJhc2VFdmFsdWF0aW9uPn0gRXZhbHVhdGlvbiByZXN1bHRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZXZhbCA9IGF3YWl0IHRhYmxlYmFzZVNlcnZpY2UuZ2V0RXZhbHVhdGlvbihmZW4pO1xuICAgKiBpZiAoZXZhbC5pc0F2YWlsYWJsZSkge1xuICAgKiAgIGxvZ2dlci5pbmZvKGBQb3NpdGlvbiBpcyAke2V2YWwucmVzdWx0LmNhdGVnb3J5fWApO1xuICAgKiB9XG4gICAqL1xuICBhc3luYyBnZXRFdmFsdWF0aW9uKGZlbjogc3RyaW5nKTogUHJvbWlzZTxUYWJsZWJhc2VFdmFsdWF0aW9uPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdGhpcy5fZ2V0T3JGZXRjaFRhYmxlYmFzZUVudHJ5KGZlbik7XG5cbiAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNBdmFpbGFibGU6IGZhbHNlIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICB3ZGw6IGVudHJ5LnBvc2l0aW9uLndkbCxcbiAgICAgICAgICBkdHo6IGVudHJ5LnBvc2l0aW9uLmR0eixcbiAgICAgICAgICBkdG06IGVudHJ5LnBvc2l0aW9uLmR0bSxcbiAgICAgICAgICBjYXRlZ29yeTogZW50cnkucG9zaXRpb24uY2F0ZWdvcnksXG4gICAgICAgICAgcHJlY2lzZTogZW50cnkucG9zaXRpb24ucHJlY2lzZSxcbiAgICAgICAgICBldmFsdWF0aW9uOiBlbnRyeS5wb3NpdGlvbi5ldmFsdWF0aW9uLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBldmFsdWF0aW9uXCIsIGVycm9yIGFzIEVycm9yLCB7IGZlbiB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQXZhaWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJVbmtub3duIGVycm9yXCIsXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdG9wIG1vdmVzIGZyb20gdGFibGViYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZW4gLSBQb3NpdGlvbiBpbiBGRU4gbm90YXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gTWF4aW11bSBudW1iZXIgb2YgbW92ZXMgdG8gcmV0dXJuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFRhYmxlYmFzZU1vdmVzUmVzdWx0Pn0gVG9wIG1vdmVzIHdpdGggZXZhbHVhdGlvbnNcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBub3cgbWFrZXMgb25seSBPTkUgQVBJIGNhbGwgYW5kIHJldHVybnMgbW92ZXMgZnJvbSB0aGUgY2FjaGVkIGVudHJ5LlxuICAgKiBUaGUgTGljaGVzcyBBUEkgYWxyZWFkeSBwcm92aWRlcyBhbGwgbW92ZXMgc29ydGVkIGJ5IHF1YWxpdHkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1vdmVzID0gYXdhaXQgdGFibGViYXNlU2VydmljZS5nZXRUb3BNb3ZlcyhmZW4sIDUpO1xuICAgKiBpZiAobW92ZXMuaXNBdmFpbGFibGUpIHtcbiAgICogICBsb2dnZXIuaW5mbyhgQmVzdCBtb3ZlOiAke21vdmVzLm1vdmVzWzBdLnNhbn1gKTtcbiAgICogfVxuICAgKi9cbiAgYXN5bmMgZ2V0VG9wTW92ZXMoXG4gICAgZmVuOiBzdHJpbmcsXG4gICAgbGltaXQ6IG51bWJlciA9IDMsXG4gICk6IFByb21pc2U8VGFibGViYXNlTW92ZXNSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCB0aGlzLl9nZXRPckZldGNoVGFibGViYXNlRW50cnkoZmVuKTtcblxuICAgICAgaWYgKCFlbnRyeSB8fCAhZW50cnkubW92ZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNBdmFpbGFibGU6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBcIk5vIG1vdmVzIGF2YWlsYWJsZSBmb3IgdGhpcyBwb3NpdGlvblwiLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBTb3J0IG1vdmVzIGJ5IHF1YWxpdHkgKFdETCB2YWx1ZSwgdGhlbiBEVFopXG4gICAgICAvLyBIaWdoZXIgV0RMID0gYmV0dGVyIGZvciB0aGUgcGxheWVyLCB0aGVuIGxvd2VyIERUWiA9IGZhc3RlciB0byBnb2FsXG4gICAgICBjb25zdCBzb3J0ZWRNb3ZlcyA9IFsuLi5lbnRyeS5tb3Zlc10uc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAvLyBQcmltYXJ5IHNvcnQ6IGJ5IFdETCAoaGlnaGVyIGlzIGJldHRlcilcbiAgICAgICAgaWYgKGEud2RsICE9PSBiLndkbCkge1xuICAgICAgICAgIHJldHVybiBiLndkbCAtIGEud2RsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Vjb25kYXJ5IHNvcnQ6IGZvciBtb3ZlcyB0aGF0IGFyZSBcIndpbnNcIiBmcm9tIG9wcG9uZW50J3MgcGVyc3BlY3RpdmUgYWZ0ZXIgb3VyIG1vdmUsXG4gICAgICAgIC8vIHdlIHdhbnQgdG8gY2hvb3NlIHRoZSBtb3ZlIHRoYXQgZ2l2ZXMgdGhlIG9wcG9uZW50IHRoZSBMT05HRVNUIHBhdGggdG8gd2luIChiZXN0IGRlZmVuc2UpXG4gICAgICAgIGlmIChhLndkbCA+IDApIHtcbiAgICAgICAgICAvLyBUaGVzZSBhcmUgXCJ3aW5uaW5nXCIgcG9zaXRpb25zIGZvciB0aGUgb3Bwb25lbnQgYWZ0ZXIgb3VyIG1vdmVcbiAgICAgICAgICAvLyBGb3Igb3B0aW1hbCBkZWZlbnNlOiBwcmVmZXIgbW92ZXMgdGhhdCBnaXZlIG9wcG9uZW50IEhJR0hFUiBEVE0gKHNsb3dlciB3aW4gZm9yIHRoZW0pXG4gICAgICAgICAgY29uc3QgYUR0eCA9IGEuZHRtID8/IGEuZHR6ID8/IDA7XG4gICAgICAgICAgY29uc3QgYkR0eCA9IGIuZHRtID8/IGIuZHR6ID8/IDA7XG4gICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFEdHgpIC0gTWF0aC5hYnMoYkR0eCk7IC8vIEZJWEVEOiBMb3dlciBEVE0gZmlyc3QgZm9yIGZhc3RlciB3aW5zXG4gICAgICAgIH0gZWxzZSBpZiAoYS53ZGwgPCAwKSB7XG4gICAgICAgICAgLy8gTG9zaW5nIC0gcHJlZmVyIHNsb3dlciBsb3NzIChsYXJnZXIgYWJzb2x1dGUgRFRNIHZhbHVlKVxuICAgICAgICAgIGNvbnN0IGFEdHggPSBhLmR0bSA/PyBhLmR0eiA/PyAwO1xuICAgICAgICAgIGNvbnN0IGJEdHggPSBiLmR0bSA/PyBiLmR0eiA/PyAwO1xuICAgICAgICAgIHJldHVybiBNYXRoLmFicyhiRHR4KSAtIE1hdGguYWJzKGFEdHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyAtIHByZWZlciBtYWludGFpbmluZyBkcmF3IChEVFogZG9lc24ndCBtYXR0ZXIgbXVjaClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9KTtcblxuICAgICAgLy8gVGFrZSBvbmx5IHRoZSBiZXN0IG1vdmVzIChzYW1lIFdETCBhcyB0aGUgYWJzb2x1dGUgYmVzdClcbiAgICAgIGNvbnN0IGJlc3RXZGwgPSBzb3J0ZWRNb3Zlc1swXT8ud2RsID8/IDA7XG4gICAgICBjb25zdCBiZXN0TW92ZXMgPSBzb3J0ZWRNb3Zlcy5maWx0ZXIoKG1vdmUpID0+IG1vdmUud2RsID09PSBiZXN0V2RsKTtcblxuICAgICAgLy8gUmV0dXJuIHVwIHRvICdsaW1pdCcgb2YgdGhlIGJlc3QgbW92ZXNcbiAgICAgIGNvbnN0IHRvcEludGVybmFsTW92ZXMgPSBiZXN0TW92ZXMuc2xpY2UoMCwgbGltaXQpO1xuXG4gICAgICAvLyBDb252ZXJ0IGludGVybmFsIG1vdmVzIHRvIGV4dGVybmFsIGZvcm1hdCAod2l0aG91dCB6ZXJvaW5nIGZpZWxkKVxuICAgICAgY29uc3QgdG9wTW92ZXM6IFRhYmxlYmFzZU1vdmVbXSA9IHRvcEludGVybmFsTW92ZXMubWFwKChtb3ZlKSA9PiAoe1xuICAgICAgICB1Y2k6IG1vdmUudWNpLFxuICAgICAgICBzYW46IG1vdmUuc2FuLFxuICAgICAgICB3ZGw6IG1vdmUud2RsLFxuICAgICAgICBkdHo6IG1vdmUuZHR6LFxuICAgICAgICBkdG06IG1vdmUuZHRtLFxuICAgICAgICBjYXRlZ29yeTogbW92ZS5jYXRlZ29yeSxcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRU5IQU5DRUQgREVCVUcgTE9HR0lOR1xuICAgICAgbG9nZ2VyLmluZm8oXCJUYWJsZWJhc2VTZXJ2aWNlLmdldFRvcE1vdmVzIERFVEFJTEVEIE9VVFBVVFwiLCB7XG4gICAgICAgIGZlbixcbiAgICAgICAgcmVxdWVzdGVkTGltaXQ6IGxpbWl0LFxuICAgICAgICB0b3RhbE1vdmVzRnJvbUFQSTogZW50cnkubW92ZXMubGVuZ3RoLFxuICAgICAgICBiZXN0V2RsLFxuICAgICAgICBtb3Zlc1dpdGhCZXN0V2RsOiBiZXN0TW92ZXMubGVuZ3RoLFxuICAgICAgICByZXR1cm5lZE1vdmVzOiB0b3BNb3Zlcy5sZW5ndGgsXG4gICAgICAgIHJldHVybmVkTW92ZURldGFpbHM6IHRvcE1vdmVzLm1hcCgobSkgPT4gKHtcbiAgICAgICAgICBzYW46IG0uc2FuLFxuICAgICAgICAgIHdkbDogbS53ZGwsXG4gICAgICAgICAgZHRtOiBtLmR0bSxcbiAgICAgICAgICBjYXRlZ29yeTogbS5jYXRlZ29yeSxcbiAgICAgICAgfSkpLFxuICAgICAgICBzb3J0aW5nQXBwbGllZDpcbiAgICAgICAgICBiZXN0V2RsIDwgMFxuICAgICAgICAgICAgPyBcIkRlZmVuc2l2ZSAoaGlnaGVzdCBEVE0gZmlyc3QpXCJcbiAgICAgICAgICAgIDogYmVzdFdkbCA+IDBcbiAgICAgICAgICAgICAgPyBcIk9mZmVuc2l2ZSAobG93ZXN0IERUTSBmaXJzdClcIlxuICAgICAgICAgICAgICA6IFwiRHJhd1wiLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICBtb3ZlczogdG9wTW92ZXMsXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHRvcCBtb3Zlc1wiLCBlcnJvciBhcyBFcnJvciwgeyBmZW4gfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc0F2YWlsYWJsZTogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIEZFTiBmb3IgdGFibGViYXNlIGxvb2t1cFxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVuIC0gRnVsbCBGRU4gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IE5vcm1hbGl6ZWQgRkVOIChmaXJzdCA0IGZpZWxkcyBvbmx5KVxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUYWJsZWJhc2Ugb25seSBjYXJlcyBhYm91dDpcbiAgICogMS4gUGllY2UgcGxhY2VtZW50XG4gICAqIDIuIFNpZGUgdG8gbW92ZVxuICAgKiAzLiBDYXN0bGluZyByaWdodHNcbiAgICogNC4gRW4gcGFzc2FudCBzcXVhcmVcbiAgICpcbiAgICogSGFsZm1vdmUgY2xvY2sgYW5kIGZ1bGxtb3ZlIG51bWJlciBhcmUgaXJyZWxldmFudCBmb3IgdGFibGViYXNlIGxvb2t1cFxuICAgKi9cbiAgcHJpdmF0ZSBfbm9ybWFsaXplRmVuKGZlbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gZmVuLnNwbGl0KFwiIFwiKS5zbGljZSgwLCA0KS5qb2luKFwiIFwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIG1ldGhvZCB0byBmZXRjaCBvciByZXRyaWV2ZSBjYWNoZWQgdGFibGViYXNlIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlbiAtIFBvc2l0aW9uIHRvIGxvb2sgdXBcbiAgICogQHJldHVybnMge1Byb21pc2U8VGFibGViYXNlRW50cnkgfCBudWxsPn0gQ29tcGxldGUgdGFibGViYXNlIGRhdGEgb3IgbnVsbFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIG1ldGhvZDpcbiAgICogMS4gVmFsaWRhdGVzIGFuZCBub3JtYWxpemVzIHRoZSBGRU5cbiAgICogMi4gQ2hlY2tzIHRoZSBjYWNoZVxuICAgKiAzLiBNYWtlcyBPTkUgQVBJIGNhbGwgaWYgbmVlZGVkXG4gICAqIDQuIFRyYW5zZm9ybXMgdGhlIHJlc3BvbnNlIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcbiAgICogNS4gQ2FjaGVzIHRoZSBjb21wbGV0ZSBlbnRyeSBpbmNsdWRpbmcgYWxsIG1vdmVzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIF9nZXRPckZldGNoVGFibGViYXNlRW50cnkoXG4gICAgZmVuOiBzdHJpbmcsXG4gICk6IFByb21pc2U8VGFibGViYXNlRW50cnkgfCBudWxsPiB7XG4gICAgLy8gVmFsaWRhdGUgRkVOXG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlQW5kU2FuaXRpemVGZW4oZmVuKTtcbiAgICBpZiAoIXZhbGlkYXRpb24uaXNWYWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEZFTjogJHt2YWxpZGF0aW9uLmVycm9ycy5qb2luKFwiLCBcIil9YCk7XG4gICAgfVxuICAgIGNvbnN0IHNhbml0aXplZEZlbiA9IHZhbGlkYXRpb24uc2FuaXRpemVkO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRGZW4gPSB0aGlzLl9ub3JtYWxpemVGZW4oc2FuaXRpemVkRmVuKTtcblxuICAgIC8vIENoZWNrIHBpZWNlIGNvdW50XG4gICAgY29uc3QgcGllY2VDb3VudCA9IHRoaXMuX2NvdW50UGllY2VzKHNhbml0aXplZEZlbik7XG4gICAgaWYgKHBpZWNlQ291bnQgPiB0aGlzLm1heFBpZWNlcykge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiVG9vIG1hbnkgcGllY2VzIGZvciB0YWJsZWJhc2VcIiwge1xuICAgICAgICBmZW46IHNhbml0aXplZEZlbixcbiAgICAgICAgcGllY2VDb3VudCxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgY2FjaGUgd2l0aCBub3JtYWxpemVkIEZFTlxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuY2FjaGUuZ2V0KG5vcm1hbGl6ZWRGZW4pO1xuICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmV4cGlyeSA+IERhdGUubm93KCkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNhY2hlIGhpdCBmb3IgdGFibGViYXNlIGVudHJ5XCIsIHsgZmVuOiBub3JtYWxpemVkRmVuIH0pO1xuICAgICAgdGhpcy5tZXRyaWNzLnJlY29yZENhY2hlSGl0KCk7XG4gICAgICByZXR1cm4gY2FjaGVkLmVudHJ5O1xuICAgIH1cbiAgICB0aGlzLm1ldHJpY3MucmVjb3JkQ2FjaGVNaXNzKCk7XG5cbiAgICAvLyBDaGVjayBpZiByZXF1ZXN0IGFscmVhZHkgaW4gZmxpZ2h0IChyZXF1ZXN0IGRlZHVwbGljYXRpb24pXG4gICAgY29uc3QgcGVuZGluZyA9IHRoaXMucGVuZGluZ1JlcXVlc3RzLmdldChub3JtYWxpemVkRmVuKTtcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiUmVxdWVzdCBhbHJlYWR5IGluIGZsaWdodCwgd2FpdGluZ1wiLCB7XG4gICAgICAgIGZlbjogbm9ybWFsaXplZEZlbixcbiAgICAgIH0pO1xuICAgICAgdGhpcy5tZXRyaWNzLnJlY29yZERlZHVwbGljYXRpb24oKTtcbiAgICAgIHJldHVybiBwZW5kaW5nO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgcmVxdWVzdCB3aXRoIHByb3BlciBjbGVhbnVwIG9uIGJvdGggc3VjY2VzcyBhbmQgZmFpbHVyZVxuICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9mZXRjaEFuZFRyYW5zZm9ybShzYW5pdGl6ZWRGZW4sIG5vcm1hbGl6ZWRGZW4pO1xuXG4gICAgLy8gU3RvcmUgdGhlIHByb21pc2Ugd2l0aCBjbGVhbnVwIGhhbmRsZXJcbiAgICBjb25zdCBwcm9taXNlV2l0aENsZWFudXAgPSByZXF1ZXN0LmZpbmFsbHkoKCkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gcGVuZGluZyByZXF1ZXN0cyBvbiBib3RoIHN1Y2Nlc3MgYW5kIGZhaWx1cmVcbiAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLmRlbGV0ZShub3JtYWxpemVkRmVuKTtcbiAgICB9KTtcblxuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzLnNldChub3JtYWxpemVkRmVuLCBwcm9taXNlV2l0aENsZWFudXApO1xuICAgIHJldHVybiBwcm9taXNlV2l0aENsZWFudXA7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggZnJvbSBBUEkgYW5kIHRyYW5zZm9ybSByZXNwb25zZVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmVuIC0gT3JpZ2luYWwgc2FuaXRpemVkIEZFTiBmb3IgQVBJIGNhbGxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5vcm1hbGl6ZWRGZW4gLSBOb3JtYWxpemVkIEZFTiBmb3IgY2FjaGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfZmV0Y2hBbmRUcmFuc2Zvcm0oXG4gICAgZmVuOiBzdHJpbmcsXG4gICAgbm9ybWFsaXplZEZlbjogc3RyaW5nLFxuICApOiBQcm9taXNlPFRhYmxlYmFzZUVudHJ5IHwgbnVsbD4ge1xuICAgIGNvbnN0IE1BWF9SRVRSSUVTID0gMztcbiAgICB0aGlzLm1ldHJpY3MucmVjb3JkQXBpQ2FsbCgpO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gTUFYX1JFVFJJRVM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIDUwMDApO1xuXG4gICAgICAgIC8vIEFsd2F5cyByZXF1ZXN0IG1vdmVzIHRvIGdldCBjb21wbGV0ZSB0YWJsZWJhc2UgZW50cnlcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBgJHtBUFBfQ09ORklHLlRBQkxFQkFTRV9BUElfVVJMfS9zdGFuZGFyZD9mZW49JHtlbmNvZGVVUklDb21wb25lbnQoZmVuKX0mbW92ZXM9MjBgLFxuICAgICAgICAgIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCB9LFxuICAgICAgICApO1xuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICB0aGlzLm1ldHJpY3MucmVjb3JkQXBpRXJyb3IocmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgLy8gUG9zaXRpb24gbm90IGluIHRhYmxlYmFzZSAtIGNhY2hlIHRoaXMgdG8gYXZvaWQgcmVwZWF0ZWQgcXVlcmllc1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oXCJQb3NpdGlvbiBub3QgaW4gdGFibGViYXNlLCBjYWNoaW5nIG51bGxcIiwge1xuICAgICAgICAgICAgICBmZW46IG5vcm1hbGl6ZWRGZW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlRW50cnkobm9ybWFsaXplZEZlbiwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSYXRlIGxpbWl0aW5nIC0gcmV0cnkgd2l0aCBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICBjb25zdCBkZWxheSA9IE1hdGgubWluKFxuICAgICAgICAgICAgICAxMDAwICogTWF0aC5wb3coMiwgYXR0ZW1wdCkgKyBNYXRoLnJhbmRvbSgpICogMTAwMCxcbiAgICAgICAgICAgICAgMTAwMDAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFJhdGUgbGltaXRlZCwgcmV0cnlpbmcgaW4gJHtkZWxheX1tc2AsIHtcbiAgICAgICAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBEb24ndCByZXRyeSBvdGhlciBjbGllbnQgZXJyb3JzXG4gICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSA0MDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNTAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENsaWVudCBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoZSBBUEkgcmVzcG9uc2Ugc3RydWN0dXJlXG4gICAgICAgIGxldCB2YWxpZGF0ZWREYXRhOiBMaWNoZXNzVGFibGViYXNlUmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsaWRhdGVkRGF0YSA9IExpY2hlc3NUYWJsZWJhc2VSZXNwb25zZVNjaGVtYS5wYXJzZShyZXNwb25zZURhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHouWm9kRXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIk1hbGZvcm1lZCBMaWNoZXNzIEFQSSByZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgIGZlbixcbiAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvci5pc3N1ZXMsXG4gICAgICAgICAgICAgIHJlY2VpdmVkOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBBUEkgcmVzcG9uc2VcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtIHRvIG91ciBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl90cmFuc2Zvcm1BcGlSZXNwb25zZSh2YWxpZGF0ZWREYXRhLCBmZW4pO1xuXG4gICAgICAgIC8vIENhY2hlIHRoZSB0cmFuc2Zvcm1lZCBlbnRyeSB3aXRoIG5vcm1hbGl6ZWQgRkVOXG4gICAgICAgIHRoaXMuX2NhY2hlRW50cnkobm9ybWFsaXplZEZlbiwgZW50cnkpO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKFwiU3VjY2Vzc2Z1bGx5IGZldGNoZWQgYW5kIGNhY2hlZCB0YWJsZWJhc2UgZW50cnlcIiwge1xuICAgICAgICAgIGZlbixcbiAgICAgICAgICBwb3NpdGlvbkNhdGVnb3J5OiBlbnRyeS5wb3NpdGlvbi5jYXRlZ29yeSxcbiAgICAgICAgICBtb3ZlQ291bnQ6IGVudHJ5Lm1vdmVzLmxlbmd0aCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFwiVW5rbm93biBlcnJvclwiO1xuICAgICAgICBsb2dnZXIud2FybihgVGFibGViYXNlIEFQSSBhdHRlbXB0ICR7YXR0ZW1wdH0vJHtNQVhfUkVUUklFU30gZmFpbGVkYCwge1xuICAgICAgICAgIGZlbixcbiAgICAgICAgICBlcnJvcjogZXJyb3JNZXNzYWdlLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEb24ndCByZXRyeSBjbGllbnQgZXJyb3JzXG4gICAgICAgIGlmIChcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKFwiQ2xpZW50IGVycm9yXCIpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGFzdCBhdHRlbXB0IGZhaWxlZFxuICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gTUFYX1JFVFJJRVMpIHtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJBUEkgY2FsbCBmYWlsZWQgYWZ0ZXIgbWF4IHJldHJpZXNcIiwgeyBlcnJvciwgZmVuIH0pO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3QgdGltZW91dCBhZnRlciAke01BWF9SRVRSSUVTfSByZXRyaWVzYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBNYXggcmV0cmllcyAoJHtNQVhfUkVUUklFU30pIGV4Y2VlZGVkLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeSB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjUwICogYXR0ZW1wdCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCBuZXZlciByZWFjaCBoZXJlXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBlcnJvciBpbiBmZXRjaCBsb29wXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSBMaWNoZXNzIEFQSSByZXNwb25zZSB0byBpbnRlcm5hbCBmb3JtYXRcbiAgICogQHByaXZhdGVcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ3JpdGljYWwgdHJhbnNmb3JtYXRpb25zOlxuICAgKiAxLiBDb252ZXJ0IGNhdGVnb3J5IHN0cmluZ3MgdG8gdHlwZWQgY2F0ZWdvcmllc1xuICAgKiAyLiBDYWxjdWxhdGUgV0RMIHZhbHVlcyBmcm9tIGNhdGVnb3JpZXNcbiAgICogMy4gSW52ZXJ0IG1vdmUgZXZhbHVhdGlvbnMgdG8gcGxheWVyLXRvLW1vdmUgcGVyc3BlY3RpdmVcbiAgICogNC4gSGFuZGxlIEJsYWNrJ3MgcGVyc3BlY3RpdmUgY29ycmVjdGx5XG4gICAqL1xuICBwcml2YXRlIF90cmFuc2Zvcm1BcGlSZXNwb25zZShcbiAgICBhcGk6IExpY2hlc3NUYWJsZWJhc2VSZXNwb25zZSxcbiAgICBmZW46IHN0cmluZyxcbiAgKTogVGFibGViYXNlRW50cnkge1xuICAgIGNvbnN0IGlzQmxhY2tUb01vdmUgPSBmZW4uc3BsaXQoXCIgXCIpWzFdID09PSBcImJcIjtcblxuICAgIC8vIFRyYW5zZm9ybSBwb3NpdGlvbiBldmFsdWF0aW9uXG4gICAgY29uc3QgcG9zaXRpb25DYXRlZ29yeSA9IGFwaS5jYXRlZ29yeSBhcyBUYWJsZWJhc2VDYXRlZ29yeTtcbiAgICBsZXQgcG9zaXRpb25XZGwgPSB0aGlzLl9jYXRlZ29yeVRvV2RsKHBvc2l0aW9uQ2F0ZWdvcnkpO1xuXG4gICAgLy8gV0RMIGlzIGFscmVhZHkgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhlIHNpZGUgdG8gbW92ZVxuICAgIC8vIE5vIG5lZWQgdG8gbmVnYXRlIGZvciBCbGFjayBwb3NpdGlvbnMgLSB0aGUgQVBJIGdpdmVzIHRoZSByZXN1bHQgZnJvbSB0aGUgbW92ZXIncyBwZXJzcGVjdGl2ZVxuICAgIC8vIEhhbmRsZSAtMCBjYXNlIHRvIGVuc3VyZSBpdCdzIGp1c3QgMFxuICAgIGlmIChwb3NpdGlvbldkbCA9PT0gLTApIHtcbiAgICAgIHBvc2l0aW9uV2RsID0gMDtcbiAgICB9XG5cbiAgICAvLyBUcmFuc2Zvcm0gbW92ZXMgd2l0aCBjb3JyZWN0IHBlcnNwZWN0aXZlIChtb3ZlcyBhcnJheSBndWFyYW50ZWVkIGJ5IHNjaGVtYSlcbiAgICBjb25zdCBtb3ZlczogVGFibGViYXNlTW92ZUludGVybmFsW10gPSAoYXBpLm1vdmVzIHx8IFtdKS5tYXAoKGFwaU1vdmUpID0+IHtcbiAgICAgIC8vIEFQSSBnaXZlcyBldmFsdWF0aW9uIEFGVEVSIHRoZSBtb3ZlIChmcm9tIG9wcG9uZW50J3MgcGVyc3BlY3RpdmUpXG4gICAgICAvLyBXZSBuZWVkIHRvIGludmVydCBpdCB0byBnZXQgdGhlIGV2YWx1YXRpb24gRlJPTSB0aGUgbW92ZXIncyBwZXJzcGVjdGl2ZVxuICAgICAgY29uc3QgbW92ZUNhdGVnb3J5ID0gdGhpcy5faW52ZXJ0Q2F0ZWdvcnkoXG4gICAgICAgIGFwaU1vdmUuY2F0ZWdvcnksXG4gICAgICApIGFzIFRhYmxlYmFzZUNhdGVnb3J5O1xuICAgICAgbGV0IG1vdmVXZGwgPSB0aGlzLl9jYXRlZ29yeVRvV2RsKG1vdmVDYXRlZ29yeSk7XG5cbiAgICAgIC8vIEZvciBCbGFjaywgd2UgbmVlZCB0byBuZWdhdGUgV0RMIHNpbmNlIGl0J3MgZnJvbSBXaGl0ZSdzIHBlcnNwZWN0aXZlXG4gICAgICBpZiAoaXNCbGFja1RvTW92ZSkge1xuICAgICAgICBtb3ZlV2RsID0gLW1vdmVXZGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVjaTogYXBpTW92ZS51Y2ksXG4gICAgICAgIHNhbjogYXBpTW92ZS5zYW4sXG4gICAgICAgIGNhdGVnb3J5OiBtb3ZlQ2F0ZWdvcnksXG4gICAgICAgIHdkbDogbW92ZVdkbCxcbiAgICAgICAgZHR6OiBhcGlNb3ZlLmR0eixcbiAgICAgICAgZHRtOiBhcGlNb3ZlLmR0bSxcbiAgICAgICAgemVyb2luZzogYXBpTW92ZS56ZXJvaW5nIHx8IGZhbHNlLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBwb3NpdGlvbjoge1xuICAgICAgICBjYXRlZ29yeTogcG9zaXRpb25DYXRlZ29yeSxcbiAgICAgICAgd2RsOiBwb3NpdGlvbldkbCxcbiAgICAgICAgZHR6OiBhcGkuZHR6LFxuICAgICAgICBkdG06IGFwaS5kdG0gPz8gbnVsbCxcbiAgICAgICAgcHJlY2lzZTogYXBpLnByZWNpc2VfZHR6ICE9PSB1bmRlZmluZWQgJiYgYXBpLnByZWNpc2VfZHR6ICE9PSBudWxsLFxuICAgICAgICBldmFsdWF0aW9uOiB0aGlzLl9nZXRFdmFsdWF0aW9uVGV4dChwb3NpdGlvbkNhdGVnb3J5LCBhcGkuZHR6KSxcbiAgICAgIH0sXG4gICAgICBtb3ZlcyxcbiAgICAgIGZlbixcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhY2hlIGFuIGVudHJ5IHdpdGggVFRMXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9jYWNoZUVudHJ5KGZlbjogc3RyaW5nLCBlbnRyeTogVGFibGViYXNlRW50cnkgfCBudWxsKTogdm9pZCB7XG4gICAgdGhpcy5jYWNoZS5zZXQoZmVuLCB7XG4gICAgICBlbnRyeSxcbiAgICAgIGV4cGlyeTogRGF0ZS5ub3coKSArIHRoaXMuY2FjaGVUdGwsXG4gICAgfSk7XG5cbiAgICAvLyBDbGVhbiB1cCBvbGQgZW50cmllcyBpZiBjYWNoZSBpcyBnZXR0aW5nIGxhcmdlXG4gICAgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+IDIwMCkge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuY2FjaGUuZW50cmllcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5leHBpcnkgPCBub3cpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgY2F0ZWdvcnkgdG8gV0RMIHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9jYXRlZ29yeVRvV2RsKGNhdGVnb3J5OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAoY2F0ZWdvcnkpIHtcbiAgICAgIGNhc2UgXCJ3aW5cIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBjYXNlIFwiY3Vyc2VkLXdpblwiOlxuICAgICAgY2FzZSBcIm1heWJlLXdpblwiOlxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGNhc2UgXCJkcmF3XCI6XG4gICAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNhc2UgXCJibGVzc2VkLWxvc3NcIjpcbiAgICAgIGNhc2UgXCJtYXliZS1sb3NzXCI6XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIGNhc2UgXCJsb3NzXCI6XG4gICAgICAgIHJldHVybiAtMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZlcnQgY2F0ZWdvcnkgZm9yIHBlcnNwZWN0aXZlIGNoYW5nZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfaW52ZXJ0Q2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgc3dpdGNoIChjYXRlZ29yeSkge1xuICAgICAgY2FzZSBcIndpblwiOlxuICAgICAgICByZXR1cm4gXCJsb3NzXCI7XG4gICAgICBjYXNlIFwibG9zc1wiOlxuICAgICAgICByZXR1cm4gXCJ3aW5cIjtcbiAgICAgIGNhc2UgXCJjdXJzZWQtd2luXCI6XG4gICAgICAgIHJldHVybiBcImJsZXNzZWQtbG9zc1wiO1xuICAgICAgY2FzZSBcImJsZXNzZWQtbG9zc1wiOlxuICAgICAgICByZXR1cm4gXCJjdXJzZWQtd2luXCI7XG4gICAgICBjYXNlIFwibWF5YmUtd2luXCI6XG4gICAgICAgIHJldHVybiBcIm1heWJlLWxvc3NcIjtcbiAgICAgIGNhc2UgXCJtYXliZS1sb3NzXCI6XG4gICAgICAgIHJldHVybiBcIm1heWJlLXdpblwiO1xuICAgICAgY2FzZSBcImRyYXdcIjpcbiAgICAgIGNhc2UgXCJ1bmtub3duXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2F0ZWdvcnk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGV2YWx1YXRpb24gdGV4dCBpbiBHZXJtYW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX2dldEV2YWx1YXRpb25UZXh0KGNhdGVnb3J5OiBzdHJpbmcsIGR0ej86IG51bWJlciB8IG51bGwpOiBzdHJpbmcge1xuICAgIHN3aXRjaCAoY2F0ZWdvcnkpIHtcbiAgICAgIGNhc2UgXCJ3aW5cIjpcbiAgICAgICAgcmV0dXJuIGR0elxuICAgICAgICAgID8gYEdld2lubiBpbiAke01hdGguYWJzKGR0eil9IFrDvGdlbmBcbiAgICAgICAgICA6IFwiVGhlb3JldGlzY2ggZ2V3b25uZW5cIjtcbiAgICAgIGNhc2UgXCJjdXJzZWQtd2luXCI6XG4gICAgICAgIHJldHVybiBkdHpcbiAgICAgICAgICA/IGBHZXdpbm4gaW4gJHtNYXRoLmFicyhkdHopfSBaw7xnZW4gKDUwLVp1Zy1SZWdlbClgXG4gICAgICAgICAgOiBcIkdld2lubiBtaXQgNTAtWnVnLVJlZ2VsXCI7XG4gICAgICBjYXNlIFwibWF5YmUtd2luXCI6XG4gICAgICAgIHJldHVybiBcIldhaHJzY2hlaW5saWNoZXIgR2V3aW5uXCI7XG4gICAgICBjYXNlIFwiZHJhd1wiOlxuICAgICAgICByZXR1cm4gXCJUaGVvcmV0aXNjaGVzIFJlbWlzXCI7XG4gICAgICBjYXNlIFwiYmxlc3NlZC1sb3NzXCI6XG4gICAgICAgIHJldHVybiBkdHpcbiAgICAgICAgICA/IGBWZXJsdXN0IGluICR7TWF0aC5hYnMoZHR6KX0gWsO8Z2VuICg1MC1adWctUmVnZWwpYFxuICAgICAgICAgIDogXCJWZXJsdXN0IG1pdCA1MC1adWctUmVnZWxcIjtcbiAgICAgIGNhc2UgXCJtYXliZS1sb3NzXCI6XG4gICAgICAgIHJldHVybiBcIldhaHJzY2hlaW5saWNoZXIgVmVybHVzdFwiO1xuICAgICAgY2FzZSBcImxvc3NcIjpcbiAgICAgICAgcmV0dXJuIGR0elxuICAgICAgICAgID8gYFZlcmx1c3QgaW4gJHtNYXRoLmFicyhkdHopfSBaw7xnZW5gXG4gICAgICAgICAgOiBcIlRoZW9yZXRpc2NoIHZlcmxvcmVuXCI7XG4gICAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgICByZXR1cm4gXCJVbmJla2FubnRlIEJld2VydHVuZ1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiQmV3ZXJ0dW5nIG5pY2h0IHZlcmbDvGdiYXJcIjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ291bnQgcGllY2VzIGluIEZFTlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfY291bnRQaWVjZXMoZmVuOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIGNvbnN0IHBpZWNlc1BhcnQgPSBmZW4uc3BsaXQoXCIgXCIpWzBdO1xuICAgIHJldHVybiBwaWVjZXNQYXJ0LnJlcGxhY2UoL1teYS16QS1aXS9nLCBcIlwiKS5sZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgY2FjaGUgKGZvciB0ZXN0aW5nKVxuICAgKi9cbiAgY2xlYXJDYWNoZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2VydmljZSBtZXRyaWNzIGZvciBtb25pdG9yaW5nXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IEN1cnJlbnQgbWV0cmljc1xuICAgKi9cbiAgZ2V0TWV0cmljcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXRyaWNzLmdldE1ldHJpY3MoKTtcbiAgfVxufVxuXG4vKipcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZSBvZiBvcHRpbWl6ZWQgVGFibGViYXNlU2VydmljZVxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyB0YWJsZWJhc2VTZXJ2aWNlIH0gZnJvbSAnQHNoYXJlZC9zZXJ2aWNlcy9UYWJsZWJhc2VTZXJ2aWNlJztcbiAqXG4gKiAvLyBHZXQgcG9zaXRpb24gZXZhbHVhdGlvbiAoMSBBUEkgY2FsbClcbiAqIGNvbnN0IGV2YWwgPSBhd2FpdCB0YWJsZWJhc2VTZXJ2aWNlLmdldEV2YWx1YXRpb24oZmVuKTtcbiAqXG4gKiAvLyBHZXQgdG9wIG1vdmVzICh1c2VzIHNhbWUgQVBJIGNhbGwsIG5vIGFkZGl0aW9uYWwgcmVxdWVzdHMhKVxuICogY29uc3QgbW92ZXMgPSBhd2FpdCB0YWJsZWJhc2VTZXJ2aWNlLmdldFRvcE1vdmVzKGZlbiwgNSk7XG4gKi9cbmV4cG9ydCBjb25zdCB0YWJsZWJhc2VTZXJ2aWNlID0gbmV3IFRhYmxlYmFzZVNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJ0YWJsZWJhc2VTZXJ2aWNlIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsIlRhYmxlYmFzZVNlcnZpY2UiLCJnZXRFdmFsdWF0aW9uIiwiZmVuIiwiZW50cnkiLCJfZ2V0T3JGZXRjaFRhYmxlYmFzZUVudHJ5IiwiaXNBdmFpbGFibGUiLCJyZXN1bHQiLCJ3ZGwiLCJwb3NpdGlvbiIsImR0eiIsImR0bSIsImNhdGVnb3J5IiwicHJlY2lzZSIsImV2YWx1YXRpb24iLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImdldFRvcE1vdmVzIiwibGltaXQiLCJzb3J0ZWRNb3ZlcyIsIm1vdmVzIiwibGVuZ3RoIiwic29ydCIsImEiLCJiIiwiYUR0eCIsImJEdHgiLCJNYXRoIiwiYWJzIiwiYmVzdFdkbCIsImJlc3RNb3ZlcyIsImZpbHRlciIsIm1vdmUiLCJ0b3BJbnRlcm5hbE1vdmVzIiwic2xpY2UiLCJ0b3BNb3ZlcyIsIm1hcCIsInVjaSIsInNhbiIsImluZm8iLCJyZXF1ZXN0ZWRMaW1pdCIsInRvdGFsTW92ZXNGcm9tQVBJIiwibW92ZXNXaXRoQmVzdFdkbCIsInJldHVybmVkTW92ZXMiLCJyZXR1cm5lZE1vdmVEZXRhaWxzIiwibSIsInNvcnRpbmdBcHBsaWVkIiwiX25vcm1hbGl6ZUZlbiIsInNwbGl0Iiwiam9pbiIsInZhbGlkYXRpb24iLCJ2YWxpZGF0ZUFuZFNhbml0aXplRmVuIiwiaXNWYWxpZCIsImVycm9ycyIsInNhbml0aXplZEZlbiIsInNhbml0aXplZCIsIm5vcm1hbGl6ZWRGZW4iLCJwaWVjZUNvdW50IiwiX2NvdW50UGllY2VzIiwibWF4UGllY2VzIiwiZGVidWciLCJjYWNoZWQiLCJjYWNoZSIsImdldCIsImV4cGlyeSIsIkRhdGUiLCJub3ciLCJtZXRyaWNzIiwicmVjb3JkQ2FjaGVIaXQiLCJyZWNvcmRDYWNoZU1pc3MiLCJwZW5kaW5nIiwicGVuZGluZ1JlcXVlc3RzIiwicmVjb3JkRGVkdXBsaWNhdGlvbiIsInJlcXVlc3QiLCJfZmV0Y2hBbmRUcmFuc2Zvcm0iLCJwcm9taXNlV2l0aENsZWFudXAiLCJmaW5hbGx5IiwiZGVsZXRlIiwic2V0IiwiTUFYX1JFVFJJRVMiLCJyZWNvcmRBcGlDYWxsIiwiYXR0ZW1wdCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwiQVBQX0NPTkZJRyIsIlRBQkxFQkFTRV9BUElfVVJMIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJyZWNvcmRBcGlFcnJvciIsInN0YXR1cyIsIl9jYWNoZUVudHJ5IiwiZGVsYXkiLCJtaW4iLCJwb3ciLCJyYW5kb20iLCJ3YXJuIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXNwb25zZURhdGEiLCJqc29uIiwidmFsaWRhdGVkRGF0YSIsIkxpY2hlc3NUYWJsZWJhc2VSZXNwb25zZVNjaGVtYSIsInBhcnNlIiwieiIsIlpvZEVycm9yIiwiaXNzdWVzIiwicmVjZWl2ZWQiLCJfdHJhbnNmb3JtQXBpUmVzcG9uc2UiLCJwb3NpdGlvbkNhdGVnb3J5IiwibW92ZUNvdW50IiwiZXJyb3JNZXNzYWdlIiwic3RhcnRzV2l0aCIsIm5hbWUiLCJhcGkiLCJpc0JsYWNrVG9Nb3ZlIiwicG9zaXRpb25XZGwiLCJfY2F0ZWdvcnlUb1dkbCIsImFwaU1vdmUiLCJtb3ZlQ2F0ZWdvcnkiLCJfaW52ZXJ0Q2F0ZWdvcnkiLCJtb3ZlV2RsIiwiemVyb2luZyIsInByZWNpc2VfZHR6IiwidW5kZWZpbmVkIiwiX2dldEV2YWx1YXRpb25UZXh0IiwidGltZXN0YW1wIiwiY2FjaGVUdGwiLCJzaXplIiwia2V5IiwidmFsdWUiLCJlbnRyaWVzIiwicGllY2VzUGFydCIsInJlcGxhY2UiLCJjbGVhckNhY2hlIiwiY2xlYXIiLCJnZXRNZXRyaWNzIiwiTWFwIiwiY2FjaGVIaXRzIiwiY2FjaGVNaXNzZXMiLCJhcGlDYWxscyIsImFwaUVycm9ycyIsInJlcXVlc3RzRGVkdXBsaWNhdGVkIiwidG90YWwiLCJjYWNoZUhpdFJhdGUiLCJ0b3RhbEFwaUNhbGxzIiwiZXJyb3JCcmVha2Rvd24iLCJPYmplY3QiLCJmcm9tRW50cmllcyIsImRlZHVwZWRSZXF1ZXN0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQzs7OzsrQkFrb0JZQTs7O2VBQUFBOzs7OEJBaG9CMEI7eUJBQ2I7MkJBQ0M7cUJBQ1Q7a0NBQzZCOzs7Ozs7Ozs7Ozs7OztBQXFCL0MsTUFBTUMsU0FBU0MsSUFBQUEsa0JBQVMsSUFBR0MsVUFBVSxDQUFDO0FBRXRDLE1BQU1DO0lBeUNKOzs7Ozs7Ozs7O0dBVUMsR0FDRCxNQUFNQyxjQUFjQyxHQUFXLEVBQWdDO1FBQzdELElBQUk7WUFDRixNQUFNQyxRQUFRLE1BQU0sSUFBSSxDQUFDQyx5QkFBeUIsQ0FBQ0Y7WUFFbkQsSUFBSSxDQUFDQyxPQUFPO2dCQUNWLE9BQU87b0JBQUVFLGFBQWE7Z0JBQU07WUFDOUI7WUFFQSxPQUFPO2dCQUNMQSxhQUFhO2dCQUNiQyxRQUFRO29CQUNOQyxLQUFLSixNQUFNSyxRQUFRLENBQUNELEdBQUc7b0JBQ3ZCRSxLQUFLTixNQUFNSyxRQUFRLENBQUNDLEdBQUc7b0JBQ3ZCQyxLQUFLUCxNQUFNSyxRQUFRLENBQUNFLEdBQUc7b0JBQ3ZCQyxVQUFVUixNQUFNSyxRQUFRLENBQUNHLFFBQVE7b0JBQ2pDQyxTQUFTVCxNQUFNSyxRQUFRLENBQUNJLE9BQU87b0JBQy9CQyxZQUFZVixNQUFNSyxRQUFRLENBQUNLLFVBQVU7Z0JBQ3ZDO1lBQ0Y7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZGpCLE9BQU9pQixLQUFLLENBQUMsNEJBQTRCQSxP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