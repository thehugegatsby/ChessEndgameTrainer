{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/slices/trainingSlice.ts"],"sourcesContent":["/**\n * @file Training state slice for Zustand store\n * @module store/slices/trainingSlice\n * @description Manages chess training session state including position management,\n * navigation, progress tracking, and training-specific game features.\n * This slice handles the core training logic and user interaction flow.\n *\n * @example\n * ```typescript\n * // Using the training slice in a component\n * import { useStore } from '@/store';\n * import { trainingSelectors } from '@/store/slices/trainingSlice';\n *\n * function TrainingSession() {\n *   const currentPosition = useStore(trainingSelectors.selectCurrentPosition);\n *   const isPlayerTurn = useStore(trainingSelectors.selectIsPlayerTurn);\n *   const hintsUsed = useStore(trainingSelectors.selectHintsUsed);\n *   const incrementHint = useStore(state => state.incrementHint);\n *\n *   const handleHintRequest = () => {\n *     if (hintsUsed < 3) incrementHint();\n *   };\n * }\n * ```\n */\n\nimport { ImmerStateCreator, TrainingSlice, TrainingState, TrainingActions } from \"./types\";\nimport type { EndgamePosition as BaseEndgamePosition } from \"@shared/types/endgame\";\nimport type { ValidatedMove } from \"@shared/types/chess\";\nimport type { MoveSuccessDialog } from \"@shared/store/orchestrators/handlePlayerMove/move.types\";\nimport { getLogger } from \"@shared/services/logging\";\n\n/**\n * Extended EndgamePosition with training-specific fields\n * @interface TrainingPosition\n * @extends BaseEndgamePosition\n */\nexport interface TrainingPosition extends BaseEndgamePosition {\n  /**\n   * Color the user is training (determines which side to play)\n   */\n  colorToTrain: \"white\" | \"black\";\n\n  /**\n   * Expected outcome for successful training completion\n   */\n  targetOutcome: \"1-0\" | \"0-1\" | \"1/2-1/2\";\n\n  /**\n   * Optional time limit in seconds\n   */\n  timeLimit?: number;\n\n  /**\n   * Chapter ID this position belongs to\n   */\n  chapterId?: string;\n}\n\n/**\n * Initial state for the training slice\n * Exported separately to enable proper store reset in tests\n */\nexport const initialTrainingState = {\n  currentPosition: undefined as TrainingPosition | undefined,\n  nextPosition: undefined as TrainingPosition | null | undefined,\n  previousPosition: undefined as TrainingPosition | null | undefined,\n  isLoadingNavigation: false,\n  navigationError: null as string | null,\n  chapterProgress: null as { completed: number; total: number } | null,\n  isPlayerTurn: true,\n  isOpponentThinking: false,\n  isSuccess: false,\n  sessionStartTime: undefined as number | undefined,\n  sessionEndTime: undefined as number | undefined,\n  hintsUsed: 0,\n  mistakeCount: 0,\n  moveErrorDialog: null as {\n    isOpen: boolean;\n    wdlBefore?: number;\n    wdlAfter?: number;\n    bestMove?: string;\n  } | null,\n  moveSuccessDialog: null as MoveSuccessDialog | null,\n  evaluationBaseline: null as {\n    wdl: number | null;\n    fen: string | null;\n    timestamp: number | null;\n  } | null,\n};\n\n/**\n * Creates the initial training state with default values\n * @deprecated Use initialTrainingState export directly\n */\nexport const createInitialTrainingState = () => ({ ...initialTrainingState });\n\n/**\n * Creates the training state (data only, no actions)\n *\n * @returns {TrainingState} Training state properties only\n *\n * @remarks\n * This function creates only the state properties for training slice.\n * Actions are created separately to avoid Immer middleware stripping functions.\n *\n * @example\n * ```typescript\n * const trainingState = createTrainingState();\n * const trainingActions = createTrainingActions(set, get);\n * ```\n */\nexport const createTrainingState = (): TrainingState => ({\n  currentPosition: undefined as TrainingPosition | undefined,\n  nextPosition: undefined as TrainingPosition | null | undefined,\n  previousPosition: undefined as TrainingPosition | null | undefined,\n  isLoadingNavigation: false,\n  navigationError: null as string | null,\n  chapterProgress: null as { completed: number; total: number } | null,\n  isPlayerTurn: true,\n  isOpponentThinking: false,\n  isSuccess: false,\n  sessionStartTime: undefined as number | undefined,\n  sessionEndTime: undefined as number | undefined,\n  hintsUsed: 0,\n  mistakeCount: 0,\n  moveErrorDialog: null as {\n    isOpen: boolean;\n    wdlBefore?: number;\n    wdlAfter?: number;\n    bestMove?: string;\n  } | null,\n  moveSuccessDialog: null as MoveSuccessDialog | null,\n  evaluationBaseline: null as {\n    wdl: number | null;\n    fen: string | null;\n    timestamp: number | null;\n  } | null,\n});\n\n/**\n * Creates the training actions (functions only, no state)\n *\n * @param {Function} set - Zustand's set function for state updates\n * @param {Function} get - Zustand's get function for accessing current state\n * @returns {TrainingActions} Training action functions\n *\n * @remarks\n * This function creates only the action functions for training slice.\n * Actions are kept separate from state to prevent Immer middleware from stripping them.\n *\n * @example\n * ```typescript\n * const trainingActions = createTrainingActions(set, get);\n * ```\n */\nconst logger = getLogger().setContext(\"TrainingSlice\");\n\nexport const createTrainingActions = (\n  set: any,\n  get: any,\n): TrainingActions => ({\n\n  /**\n   * Sets the current training position\n   *\n   * @param {TrainingPosition} position - The position to set as current\n   *\n   * @fires stateChange - When position is updated\n   *\n   * @remarks\n   * This action sets the active training position and resets session-specific\n   * state like hints and mistakes. It should be called when starting a new\n   * training session or switching positions. The actual game initialization\n   * should be handled by an orchestrator that coordinates with GameSlice.\n   *\n   * @example\n   * ```typescript\n   * const position: TrainingPosition = {\n   *   id: 1,\n   *   title: \"King and Rook vs King\",\n   *   fen: \"8/8/8/8/8/8/R7/K3k3 w - - 0 1\",\n   *   colorToTrain: \"white\",\n   *   targetOutcome: \"1-0\",\n   *   // ... other fields\n   * };\n   *\n   * store.getState().setPosition(position);\n   * ```\n   */\n  setPosition: (position: TrainingPosition) => {\n    set((state) => {\n      state.training.currentPosition = position;\n      state.training.isSuccess = false;\n      state.training.sessionStartTime = Date.now();\n      state.training.sessionEndTime = undefined;\n      state.training.hintsUsed = 0;\n      state.training.mistakeCount = 0;\n      // Set initial turn based on position\n      state.training.isPlayerTurn =\n        position.sideToMove === position.colorToTrain;\n      // Clear evaluation baseline when setting new position\n      state.training.evaluationBaseline = null;\n    });\n  },\n\n  /**\n   * Sets navigation positions (next/previous)\n   *\n   * @param {TrainingPosition|null} [next] - Next position in sequence\n   * @param {TrainingPosition|null} [previous] - Previous position in sequence\n   *\n   * @fires stateChange - When navigation positions are updated\n   *\n   * @remarks\n   * Used to enable navigation between positions in a training sequence.\n   * Null indicates no position available in that direction. Undefined\n   * parameters leave the respective position unchanged.\n   *\n   * @example\n   * ```typescript\n   * // Set both navigation positions\n   * store.getState().setNavigationPositions(nextPos, prevPos);\n   *\n   * // Only update next position\n   * store.getState().setNavigationPositions(nextPos);\n   *\n   * // Clear navigation\n   * store.getState().setNavigationPositions(null, null);\n   * ```\n   */\n  setNavigationPositions: (\n    next?: TrainingPosition | null,\n    previous?: TrainingPosition | null,\n  ) => {\n    set((state) => {\n      if (next !== undefined) {\n        state.training.nextPosition = next;\n      }\n      if (previous !== undefined) {\n        state.training.previousPosition = previous;\n      }\n    });\n  },\n\n  /**\n   * Sets navigation loading state\n   *\n   * @param {boolean} loading - Whether navigation is loading\n   *\n   * @fires stateChange - When loading state changes\n   *\n   * @remarks\n   * Used to show loading indicators during position navigation.\n   * Should be set to true when fetching navigation data and\n   * false when complete or on error.\n   *\n   * @example\n   * ```typescript\n   * // Start loading\n   * store.getState().setNavigationLoading(true);\n   *\n   * // After loading completes\n   * store.getState().setNavigationLoading(false);\n   * ```\n   */\n  setNavigationLoading: (loading: boolean) => {\n    set((state) => {\n      state.training.isLoadingNavigation = loading;\n    });\n  },\n\n  /**\n   * Sets navigation error message\n   *\n   * @param {string|null} error - Error message or null to clear\n   *\n   * @fires stateChange - When error state changes\n   *\n   * @remarks\n   * Used to display error messages when navigation fails.\n   * Set to null to clear the error state.\n   *\n   * @example\n   * ```typescript\n   * // Set error\n   * store.getState().setNavigationError(\"Position nicht gefunden\");\n   *\n   * // Clear error\n   * store.getState().setNavigationError(null);\n   * ```\n   */\n  setNavigationError: (error: string | null) => {\n    set((state) => {\n      state.training.navigationError = error;\n    });\n  },\n\n  /**\n   * Sets chapter progress information\n   *\n   * @param {Object|null} progress - Progress data or null to clear\n   * @param {number} progress.completed - Number of completed positions\n   * @param {number} progress.total - Total positions in chapter\n   *\n   * @fires stateChange - When progress is updated\n   *\n   * @remarks\n   * Tracks progress through a chapter or training sequence.\n   * Used to display progress indicators in the UI.\n   *\n   * @example\n   * ```typescript\n   * // Set progress\n   * store.getState().setChapterProgress({\n   *   completed: 3,\n   *   total: 10\n   * });\n   *\n   * // Clear progress\n   * store.getState().setChapterProgress(null);\n   * ```\n   */\n  setChapterProgress: (\n    progress: { completed: number; total: number } | null,\n  ) => {\n    set((state) => {\n      state.training.chapterProgress = progress;\n    });\n  },\n\n  /**\n   * Sets whether it's the player's turn\n   *\n   * @param {boolean} isPlayerTurn - Whether player can make moves\n   *\n   * @fires stateChange - When turn state changes\n   *\n   * @remarks\n   * Controls when the user can interact with the board.\n   * Should be updated after each move based on game state\n   * and training configuration.\n   *\n   * @example\n   * ```typescript\n   * // Enable player moves\n   * store.getState().setPlayerTurn(true);\n   *\n   * // Disable during computer's turn\n   * store.getState().setPlayerTurn(false);\n   * ```\n   */\n  setPlayerTurn: (isPlayerTurn: boolean) => {\n    set((state) => {\n      state.training.isPlayerTurn = isPlayerTurn;\n    });\n  },\n\n  /**\n   * Clears the opponent thinking flag\n   *\n   * @fires stateChange - When flag is cleared\n   *\n   * @remarks\n   * Used when cancelling opponent moves, particularly after\n   * undoing a suboptimal move. Ensures the UI properly reflects\n   * that the opponent is no longer calculating a move.\n   *\n   * @example\n   * ```typescript\n   * // Clear flag after cancelling opponent turn\n   * store.getState().clearOpponentThinking();\n   * ```\n   */\n  clearOpponentThinking: () => {\n    set((state) => {\n      state.training.isOpponentThinking = false;\n    });\n  },\n\n  /**\n   * Completes the training session\n   *\n   * @param {boolean} success - Whether training was completed successfully\n   *\n   * @fires stateChange - When training completes\n   *\n   * @remarks\n   * Marks the training session as complete and records the end time.\n   * Success is typically determined by reaching the target outcome\n   * (win/draw) as specified in the position configuration.\n   *\n   * @example\n   * ```typescript\n   * // Successful completion\n   * store.getState().completeTraining(true);\n   *\n   * // Failed completion\n   * store.getState().completeTraining(false);\n   * ```\n   */\n  completeTraining: (success: boolean) => {\n    set((state) => {\n      state.training.isSuccess = success;\n      state.training.sessionEndTime = Date.now();\n    });\n  },\n\n  /**\n   * Increments the hint counter\n   *\n   * @fires stateChange - When hint count increases\n   *\n   * @remarks\n   * Increments the hint counter for the current session.\n   * This affects performance metrics and achievements.\n   * The actual hint display should be handled by the UI\n   * based on the position's hint data.\n   *\n   * @example\n   * ```typescript\n   * // User requests a hint\n   * store.getState().incrementHint();\n   *\n   * // Check hint usage\n   * const hintsUsed = store.getState().hintsUsed;\n   * if (hintsUsed >= 3) {\n   *   // Maybe disable hint button\n   * }\n   * ```\n   */\n  incrementHint: () => {\n    set((state) => {\n      state.training.hintsUsed = state.training.hintsUsed + 1;\n    });\n  },\n\n  /**\n   * Increments the mistake counter\n   *\n   * @fires stateChange - When mistake count increases\n   *\n   * @remarks\n   * Called when the user makes a suboptimal or incorrect move.\n   * This affects performance metrics and is used for training\n   * analytics. What constitutes a \"mistake\" is determined by\n   * the orchestrator based on tablebase evaluation.\n   *\n   * @example\n   * ```typescript\n   * // User made a mistake\n   * store.getState().incrementMistake();\n   *\n   * // Check total mistakes\n   * const mistakes = store.getState().mistakeCount;\n   * ```\n   */\n  incrementMistake: () => {\n    set((state) => {\n      state.training.mistakeCount = state.training.mistakeCount + 1;\n    });\n  },\n\n  /**\n   * Sets the move error dialog configuration\n   *\n   * @param {Object|null} dialog - Dialog configuration or null to close\n   * @param {boolean} dialog.isOpen - Whether the dialog should be open\n   * @param {number} [dialog.wdlBefore] - WDL value before the move\n   * @param {number} [dialog.wdlAfter] - WDL value after the move\n   * @param {string} [dialog.bestMove] - The best move in the position\n   *\n   * @fires stateChange - When dialog state changes\n   *\n   * @remarks\n   * This dialog is shown when a user makes a suboptimal move during training.\n   * It displays the position evaluation before and after the move, helping\n   * users understand why their move was not optimal.\n   *\n   * @example\n   * ```typescript\n   * // Show error dialog\n   * setMoveErrorDialog({\n   *   isOpen: true,\n   *   wdlBefore: 1000,\n   *   wdlAfter: 0,\n   *   bestMove: 'Qb7'\n   * });\n   *\n   * // Close dialog\n   * setMoveErrorDialog(null);\n   * ```\n   */\n  setMoveErrorDialog: (\n    dialog: {\n      isOpen: boolean;\n      wdlBefore?: number;\n      wdlAfter?: number;\n      bestMove?: string;\n    } | null,\n  ) => {\n    set((state) => {\n      state.training.moveErrorDialog = dialog;\n    });\n  },\n\n  /**\n   * Sets the move success dialog configuration\n   *\n   * @param {Object|null} dialog - Dialog configuration or null to close\n   * @param {boolean} dialog.isOpen - Whether the dialog should be open\n   * @param {string} [dialog.promotionPiece] - The piece promoted to (German label)\n   * @param {string} [dialog.moveDescription] - Description of the winning move\n   *\n   * @fires stateChange - When dialog state changes\n   *\n   * @remarks\n   * This dialog is shown when a user makes a successful move that leads to victory,\n   * particularly after pawn promotion. It provides positive feedback and celebration\n   * to motivate continued learning.\n   *\n   * @example\n   * ```typescript\n   * // Show success dialog\n   * setMoveSuccessDialog({\n   *   isOpen: true,\n   *   promotionPiece: \"Dame\",\n   *   moveDescription: \"e8=Q+\"\n   * });\n   *\n   * // Close dialog\n   * setMoveSuccessDialog(null);\n   * ```\n   */\n  setMoveSuccessDialog: (\n    dialog: {\n      isOpen: boolean;\n      promotionPiece?: string;\n      moveDescription?: string;\n    } | null,\n  ) => {\n    set((state) => {\n      state.training.moveSuccessDialog = dialog;\n    });\n  },\n\n  /**\n   * Adds a move to the training history\n   *\n   * @param {any} move - The move to add (ValidatedMove with training metadata)\n   *\n   * @fires stateChange - When move is added\n   *\n   * @remarks\n   * This action is called by orchestrators to track moves made during\n   * training. The move object should include training-specific metadata\n   * like whether it was optimal, user-made, etc. The actual implementation\n   * of moveHistory is handled by orchestrators.\n   *\n   * @example\n   * ```typescript\n   * // Called by orchestrator\n   * store.getState().addTrainingMove({\n   *   ...validatedMove,\n   *   userMove: true,\n   *   isOptimal: false,\n   *   mistakeReason: \"Missed checkmate\"\n   * });\n   * ```\n   */\n  addTrainingMove: (move: ValidatedMove) => {\n    // This is a placeholder - actual implementation will be in orchestrator\n    // as it needs to coordinate with game state\n    logger.debug(\"Training move added\", { move });\n  },\n\n  /**\n   * Resets all training state to initial values\n   *\n   * @fires stateChange - When state is reset\n   *\n   * @remarks\n   * Completely resets the training slice to initial state.\n   * Useful when switching between training modes or starting fresh.\n   * Note that this doesn't reset the game state - that should be\n   * handled by an orchestrator.\n   *\n   * @example\n   * ```typescript\n   * // Reset everything\n   * store.getState().resetTraining();\n   *\n   * // Common pattern with other slices\n   * store.getState().resetGame();\n   * store.getState().resetTraining();\n   * store.getState().clearTablebaseState();\n   * ```\n   */\n  resetTraining: () => {\n    set((state) => {\n      Object.assign(state.training, createInitialTrainingState());\n    });\n  },\n\n  /**\n   * Resets the current position to its initial state\n   *\n   * @fires stateChange - When position is reset\n   *\n   * @remarks\n   * This method resets all training-specific state while keeping the current position.\n   * It clears move history, evaluations, and resets all counters. The game will\n   * need to be reloaded to the initial position FEN by the game slice.\n   *\n   * @example\n   * ```typescript\n   * // Reset to start of training\n   * store.getState().resetPosition();\n   * ```\n   */\n  resetPosition: () => {\n    const currentPos = get().training.currentPosition;\n    set((state) => {\n      // moveHistory is in game slice, not training slice\n      state.game.moveHistory = [];\n      state.training.hintsUsed = 0;\n      state.training.mistakeCount = 0;\n      state.training.isSuccess = false;\n      state.training.sessionStartTime = Date.now();\n      state.training.sessionEndTime = undefined;\n      // Reset turn based on position\n      state.training.isPlayerTurn = currentPos\n        ? currentPos.sideToMove === currentPos.colorToTrain\n        : true;\n      // Clear evaluation baseline when resetting position\n      state.training.evaluationBaseline = null;\n    });\n  },\n\n  /**\n   * Sets the evaluation baseline for subsequent move quality assessments\n   *\n   * @param {number} wdl - WDL evaluation to use as baseline\n   * @param {string} fen - FEN position when baseline was established\n   *\n   * @fires stateChange - When baseline is updated\n   *\n   * @remarks\n   * This method is called after \"Weiterspielen\" when the opponent has moved,\n   * establishing a new evaluation baseline for the training session. Subsequent\n   * player moves will be evaluated relative to this baseline rather than the\n   * original training position expectation.\n   *\n   * @example\n   * ```typescript\n   * // After opponent move following \"Weiterspielen\"\n   * const currentFen = chessService.getFen();\n   * const evaluation = await tablebaseService.getEvaluation(currentFen);\n   * if (evaluation.isAvailable) {\n   *   trainingActions.setEvaluationBaseline(evaluation.result.wdl, currentFen);\n   * }\n   * ```\n   */\n  setEvaluationBaseline: (wdl: number, fen: string) => {\n    set((state) => {\n      state.training.evaluationBaseline = {\n        wdl,\n        fen,\n        timestamp: Date.now(),\n      };\n    });\n    logger.info(\"Evaluation baseline updated\", { wdl, fen });\n  },\n\n  /**\n   * Clears the evaluation baseline, reverting to original position expectations\n   *\n   * @fires stateChange - When baseline is cleared\n   *\n   * @remarks\n   * This method is called when resetting training sessions or navigating\n   * to different positions. It ensures move evaluation returns to normal\n   * behavior based on the original training position expectations.\n   *\n   * @example\n   * ```typescript\n   * // Clear baseline when starting new training session\n   * trainingActions.clearEvaluationBaseline();\n   * ```\n   */\n  clearEvaluationBaseline: () => {\n    set((state) => {\n      state.training.evaluationBaseline = null;\n    });\n    logger.info(\"Evaluation baseline cleared\");\n  },\n});\n\n/**\n * Legacy slice creator for backwards compatibility\n * @deprecated Use createTrainingState() and createTrainingActions() separately\n */\nexport const createTrainingSlice: ImmerStateCreator<TrainingSlice> = (\n  set,\n  get,\n) => ({\n  ...createTrainingState(),\n  ...createTrainingActions(set, get),\n});\n\n/**\n * Selector functions for efficient state access\n *\n * @remarks\n * These selectors provide a consistent API for accessing training state\n * and can be used with Zustand's subscribe mechanism for optimal\n * re-renders. Use these instead of inline selectors when possible.\n *\n * The selectors include both direct state access and computed values\n * for common use cases like session duration and performance metrics.\n *\n * @example\n * ```typescript\n * import { useStore } from '@/store';\n * import { trainingSelectors } from '@/store/slices/trainingSlice';\n *\n * // In a component\n * const position = useStore(trainingSelectors.selectCurrentPosition);\n * const canNavigateNext = useStore(trainingSelectors.selectCanNavigateNext);\n * const accuracy = useStore(trainingSelectors.selectAccuracy);\n * ```\n */\nexport const trainingSelectors = {\n  /**\n   * Selects the current training position\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {TrainingPosition|undefined} Current position or undefined\n   */\n  selectCurrentPosition: (state: TrainingSlice) => state.currentPosition,\n\n  /**\n   * Selects the next position\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {TrainingPosition|null|undefined} Next position\n   */\n  selectNextPosition: (state: TrainingSlice) => state.nextPosition,\n\n  /**\n   * Selects the previous position\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {TrainingPosition|null|undefined} Previous position\n   */\n  selectPreviousPosition: (state: TrainingSlice) => state.previousPosition,\n\n  /**\n   * Selects navigation loading state\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} Whether navigation is loading\n   */\n  selectIsLoadingNavigation: (state: TrainingSlice) =>\n    state.isLoadingNavigation ?? false,\n\n  /**\n   * Selects navigation error\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {string|null} Error message or null\n   */\n  selectNavigationError: (state: TrainingSlice) => state.navigationError,\n\n  /**\n   * Selects chapter progress\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {Object|null} Progress data or null\n   */\n  selectChapterProgress: (state: TrainingSlice) => state.chapterProgress,\n\n  /**\n   * Selects whether it's the player's turn\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} Whether player can make moves\n   */\n  selectIsPlayerTurn: (state: TrainingSlice) => state.isPlayerTurn,\n\n  /**\n   * Selects training success state\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} Whether training was successful\n   */\n  selectIsSuccess: (state: TrainingSlice) => state.isSuccess,\n\n  /**\n   * Selects session start time\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number|undefined} Start timestamp or undefined\n   */\n  selectSessionStartTime: (state: TrainingSlice) => state.sessionStartTime,\n\n  /**\n   * Selects session end time\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number|undefined} End timestamp or undefined\n   */\n  selectSessionEndTime: (state: TrainingSlice) => state.sessionEndTime,\n\n  /**\n   * Selects number of hints used\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number} Hint count\n   */\n  selectHintsUsed: (state: TrainingSlice) => state.hintsUsed,\n\n  /**\n   * Selects mistake count\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number} Number of mistakes\n   */\n  selectMistakeCount: (state: TrainingSlice) => state.mistakeCount,\n\n  /**\n   * Selects the move error dialog configuration\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {Object|null} The move error dialog configuration or null\n   */\n  selectMoveErrorDialog: (state: TrainingSlice) => state.moveErrorDialog,\n\n  /**\n   * Selects whether navigation to next position is available\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} True if can navigate next\n   */\n  selectCanNavigateNext: (state: TrainingSlice) =>\n    state.nextPosition !== undefined && state.nextPosition !== null,\n\n  /**\n   * Selects whether navigation to previous position is available\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} True if can navigate previous\n   */\n  selectCanNavigatePrevious: (state: TrainingSlice) =>\n    state.previousPosition !== undefined && state.previousPosition !== null,\n\n  /**\n   * Selects whether training is in progress\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {boolean} True if session started but not ended\n   */\n  selectIsTrainingActive: (state: TrainingSlice) =>\n    state.sessionStartTime !== undefined && state.sessionEndTime === undefined,\n\n  /**\n   * Selects session duration in milliseconds\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number|null} Duration or null if not available\n   */\n  selectSessionDuration: (state: TrainingSlice) => {\n    if (!state.sessionStartTime) return null;\n    const endTime = state.sessionEndTime ?? Date.now();\n    return endTime - state.sessionStartTime;\n  },\n\n  /**\n   * Selects performance accuracy (hints as negative impact)\n   * @param {TrainingSlice} state - The training slice of the store\n   * @returns {number} Accuracy percentage (0-100)\n   *\n   * @remarks\n   * Simple accuracy calculation based on mistakes and hints.\n   * A more sophisticated calculation would consider move optimality.\n   */\n  selectAccuracy: (state: TrainingSlice) => {\n    const penalties = state.mistakeCount + state.hintsUsed * 0.5;\n    return Math.max(0, 100 - penalties * 10);\n  },\n};\n"],"names":["createInitialTrainingState","createTrainingActions","createTrainingSlice","createTrainingState","initialTrainingState","trainingSelectors","currentPosition","undefined","nextPosition","previousPosition","isLoadingNavigation","navigationError","chapterProgress","isPlayerTurn","isOpponentThinking","isSuccess","sessionStartTime","sessionEndTime","hintsUsed","mistakeCount","moveErrorDialog","moveSuccessDialog","evaluationBaseline","logger","getLogger","setContext","set","get","setPosition","position","state","training","Date","now","sideToMove","colorToTrain","setNavigationPositions","next","previous","setNavigationLoading","loading","setNavigationError","error","setChapterProgress","progress","setPlayerTurn","clearOpponentThinking","completeTraining","success","incrementHint","incrementMistake","setMoveErrorDialog","dialog","setMoveSuccessDialog","addTrainingMove","move","debug","resetTraining","Object","assign","resetPosition","currentPos","game","moveHistory","setEvaluationBaseline","wdl","fen","timestamp","info","clearEvaluationBaseline","selectCurrentPosition","selectNextPosition","selectPreviousPosition","selectIsLoadingNavigation","selectNavigationError","selectChapterProgress","selectIsPlayerTurn","selectIsSuccess","selectSessionStartTime","selectSessionEndTime","selectHintsUsed","selectMistakeCount","selectMoveErrorDialog","selectCanNavigateNext","selectCanNavigatePrevious","selectIsTrainingActive","selectSessionDuration","endTime","selectAccuracy","penalties","Math","max"],"mappings":"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"}