1b7ff537a645820a8a4d8a1166311aa2
/**
 * @file ChessService PGN Loading Tests
 * @description Coverage tests for PGN loading and reconstruction (Lines 482-518)
 * Target: loadPgn() method - biggest coverage gain (37 lines)
 */ "use strict";
// Mock chess.js following existing pattern
jest.mock("chess.js");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ChessService = require("../../../shared/services/ChessService");
const _chess = require("chess.js");
const MockedChess = _chess.Chess;
describe("ChessService PGN Loading Tests", ()=>{
    let chessService;
    let mockChessInstance;
    // PGN test fixtures for comprehensive testing
    const pgnTestFixtures = {
        valid: "1. e4 e5 2. Nf3 Nc6 3. Bb5",
        complex: "1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 4. Ba4 Nf6 5. O-O Be7 6. Re1 b5 7. Bb3 d6",
        shortGame: "1. e4 e5 2. Qh5 Nc6 3. Bc4 Nf6 4. Qxf7#",
        empty: "",
        whitespace: "   \n  \t  ",
        invalid: "1. xx yy zz",
        malformed: "this is not pgn at all",
        partialValid: "1. e4 e5 2. Nf3 invalid_move"
    };
    // Mock move objects for history reconstruction
    const mockMoves = [
        {
            from: "e2",
            to: "e4",
            san: "e4",
            piece: "p",
            color: "w"
        },
        {
            from: "e7",
            to: "e5",
            san: "e5",
            piece: "p",
            color: "b"
        },
        {
            from: "g1",
            to: "f3",
            san: "Nf3",
            piece: "n",
            color: "w"
        }
    ];
    beforeEach(()=>{
        MockedChess.mockClear();
        // Create comprehensive mock Chess instance
        mockChessInstance = {
            move: jest.fn(),
            fen: jest.fn().mockReturnValue("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"),
            pgn: jest.fn().mockReturnValue(""),
            history: jest.fn().mockReturnValue([]),
            load: jest.fn(),
            loadPgn: jest.fn(),
            isGameOver: jest.fn().mockReturnValue(false),
            turn: jest.fn().mockReturnValue("w"),
            moves: jest.fn().mockReturnValue([
                "e4",
                "e3",
                "Nf3"
            ]),
            isCheck: jest.fn().mockReturnValue(false),
            isCheckmate: jest.fn().mockReturnValue(false),
            isStalemate: jest.fn().mockReturnValue(false),
            isDraw: jest.fn().mockReturnValue(false)
        };
        MockedChess.mockImplementation(()=>mockChessInstance);
        chessService = new _ChessService.ChessService();
    });
    describe("loadPgn() - Lines 482-518", ()=>{
        it("should load valid PGN and reconstruct move history", ()=>{
            // Setup mock for successful PGN loading
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(mockMoves);
            // Mock the chess position reconstruction
            let fenCounter = 0;
            const fens = [
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1",
                "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2",
                "rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2"
            ];
            mockChessInstance.fen.mockImplementation(()=>fens[fenCounter] || fens[0]);
            mockChessInstance.move.mockImplementation(()=>{
                fenCounter++;
                return mockMoves[fenCounter - 1] || null;
            });
            // Mock event listener to track state updates
            const mockListener = jest.fn();
            chessService.subscribe(mockListener);
            // Test PGN loading
            const result = chessService.loadPgn(pgnTestFixtures.valid);
            // Verify success
            expect(result).toBe(true);
            expect(mockChessInstance.loadPgn).toHaveBeenCalledWith(pgnTestFixtures.valid);
            expect(mockChessInstance.history).toHaveBeenCalledWith({
                verbose: true
            });
            // Verify move history reconstruction
            const moveHistory = chessService.getMoveHistory();
            expect(moveHistory).toHaveLength(mockMoves.length);
            // Verify current move index is set correctly
            expect(chessService.getCurrentMoveIndex()).toBe(mockMoves.length - 1);
            // Verify state update event was emitted
            expect(mockListener).toHaveBeenCalledWith(expect.objectContaining({
                type: "stateUpdate",
                source: "load",
                payload: expect.objectContaining({
                    moveHistory: expect.any(Array),
                    currentMoveIndex: mockMoves.length - 1
                })
            }));
        });
        it("should handle complex PGN with castling", ()=>{
            // Setup more complex move sequence
            const complexMoves = [
                {
                    from: "e2",
                    to: "e4",
                    san: "e4",
                    piece: "p",
                    color: "w"
                },
                {
                    from: "e7",
                    to: "e5",
                    san: "e5",
                    piece: "p",
                    color: "b"
                },
                {
                    from: "g1",
                    to: "f3",
                    san: "Nf3",
                    piece: "n",
                    color: "w"
                },
                {
                    from: "b8",
                    to: "c6",
                    san: "Nc6",
                    piece: "n",
                    color: "b"
                },
                {
                    from: "f1",
                    to: "b5",
                    san: "Bb5",
                    piece: "b",
                    color: "w"
                },
                {
                    from: "e1",
                    to: "g1",
                    san: "O-O",
                    piece: "k",
                    color: "w"
                }
            ];
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(complexMoves);
            let moveCounter = 0;
            mockChessInstance.move.mockImplementation(()=>{
                moveCounter++;
                return complexMoves[moveCounter - 1] || null;
            });
            const result = chessService.loadPgn(pgnTestFixtures.complex);
            expect(result).toBe(true);
            expect(chessService.getMoveHistory()).toHaveLength(complexMoves.length);
            expect(chessService.getCurrentMoveIndex()).toBe(complexMoves.length - 1);
        });
        it("should handle empty PGN string", ()=>{
            // Setup for empty PGN
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue([]);
            const result = chessService.loadPgn(pgnTestFixtures.empty);
            expect(result).toBe(true);
            expect(mockChessInstance.loadPgn).toHaveBeenCalledWith("");
            expect(chessService.getMoveHistory()).toHaveLength(0);
            expect(chessService.getCurrentMoveIndex()).toBe(-1);
        });
        it("should handle whitespace-only PGN", ()=>{
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue([]);
            const result = chessService.loadPgn(pgnTestFixtures.whitespace);
            expect(result).toBe(true);
            expect(chessService.getMoveHistory()).toHaveLength(0);
        });
        it("should handle invalid PGN and emit error event", ()=>{
            // Setup mock to throw error for invalid PGN
            const pgnError = new Error("Invalid PGN format");
            mockChessInstance.loadPgn.mockImplementation(()=>{
                throw pgnError;
            });
            // Mock event listener to capture error
            const mockListener = jest.fn();
            chessService.subscribe(mockListener);
            const result = chessService.loadPgn(pgnTestFixtures.invalid);
            // Verify failure and error handling
            expect(result).toBe(false);
            expect(mockChessInstance.loadPgn).toHaveBeenCalledWith(pgnTestFixtures.invalid);
            // Verify error event was emitted
            expect(mockListener).toHaveBeenCalledWith(expect.objectContaining({
                type: "error",
                payload: expect.objectContaining({
                    error: expect.any(Error),
                    message: "Ungültiges PGN-Format"
                })
            }));
        });
        it("should handle malformed PGN string", ()=>{
            const malformedError = new Error("Not a valid PGN");
            mockChessInstance.loadPgn.mockImplementation(()=>{
                throw malformedError;
            });
            const mockListener = jest.fn();
            chessService.subscribe(mockListener);
            const result = chessService.loadPgn(pgnTestFixtures.malformed);
            expect(result).toBe(false);
            expect(mockListener).toHaveBeenCalledWith(expect.objectContaining({
                type: "error",
                payload: expect.objectContaining({
                    message: "Ungültiges PGN-Format"
                })
            }));
        });
        it("should handle partially valid PGN", ()=>{
            const partialError = new Error("Invalid move in PGN");
            mockChessInstance.loadPgn.mockImplementation(()=>{
                throw partialError;
            });
            const result = chessService.loadPgn(pgnTestFixtures.partialValid);
            expect(result).toBe(false);
            expect(mockChessInstance.loadPgn).toHaveBeenCalledWith(pgnTestFixtures.partialValid);
        });
        it("should reset chess instance and rebuild from scratch", ()=>{
            // This tests the critical logic in lines 485-496
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(mockMoves);
            const initialCallCount = MockedChess.mock.calls.length;
            chessService.loadPgn(pgnTestFixtures.valid);
            // Verify Chess constructor was called for reset (line 487: this.chess = new Chess())
            expect(MockedChess.mock.calls.length).toBeGreaterThan(initialCallCount);
            // Verify moves were replayed (lines 490-496)
            expect(mockChessInstance.move).toHaveBeenCalledTimes(mockMoves.length);
        });
        it("should preserve validated move structure in history", ()=>{
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(mockMoves);
            // Mock FEN progression for move validation
            let fenIndex = 0;
            const fenProgression = [
                "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
                "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1",
                "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq e6 0 2",
                "rnbqkbnr/pppp1ppp/8/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R b KQkq - 1 2"
            ];
            mockChessInstance.fen.mockImplementation(()=>fenProgression[fenIndex] || fenProgression[0]);
            mockChessInstance.move.mockImplementation(()=>{
                const move = mockMoves[fenIndex];
                fenIndex++;
                return move || null;
            });
            chessService.loadPgn(pgnTestFixtures.valid);
            const moveHistory = chessService.getMoveHistory();
            // Verify each move in history has required ValidatedMove structure
            moveHistory.forEach((move, index)=>{
                expect(move).toHaveProperty('from');
                expect(move).toHaveProperty('to');
                expect(move).toHaveProperty('san');
                expect(move).toHaveProperty('fenBefore');
                expect(move).toHaveProperty('fenAfter');
            });
        });
        it("should handle error during move reconstruction", ()=>{
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(mockMoves);
            // Mock move() to throw error during reconstruction
            mockChessInstance.move.mockImplementation(()=>{
                throw new Error("Move reconstruction failed");
            });
            const mockListener = jest.fn();
            chessService.subscribe(mockListener);
            const result = chessService.loadPgn(pgnTestFixtures.valid);
            // Should fail gracefully
            expect(result).toBe(false);
            expect(mockListener).toHaveBeenCalledWith(expect.objectContaining({
                type: "error"
            }));
        });
    });
    describe("PGN Integration with other methods", ()=>{
        it("should maintain consistency after PGN load", ()=>{
            mockChessInstance.loadPgn.mockImplementation(()=>true);
            mockChessInstance.history.mockReturnValue(mockMoves);
            mockChessInstance.pgn.mockReturnValue(pgnTestFixtures.valid);
            chessService.loadPgn(pgnTestFixtures.valid);
            // Verify consistency with other methods
            expect(chessService.getCurrentMoveIndex()).toBe(mockMoves.length - 1);
            expect(chessService.getMoveHistory()).toHaveLength(mockMoves.length);
            expect(chessService.getPgn()).toBe(pgnTestFixtures.valid);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2UucGduLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBDaGVzc1NlcnZpY2UgUEdOIExvYWRpbmcgVGVzdHNcbiAqIEBkZXNjcmlwdGlvbiBDb3ZlcmFnZSB0ZXN0cyBmb3IgUEdOIGxvYWRpbmcgYW5kIHJlY29uc3RydWN0aW9uIChMaW5lcyA0ODItNTE4KVxuICogVGFyZ2V0OiBsb2FkUGduKCkgbWV0aG9kIC0gYmlnZ2VzdCBjb3ZlcmFnZSBnYWluICgzNyBsaW5lcylcbiAqL1xuXG5pbXBvcnQgeyBDaGVzc1NlcnZpY2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2VcIjtcbmltcG9ydCB7IENoZXNzIH0gZnJvbSBcImNoZXNzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVWYWxpZGF0ZWRNb3ZlIH0gZnJvbSBcIkBzaGFyZWQvdHlwZXMvY2hlc3NcIjtcblxuLy8gTW9jayBjaGVzcy5qcyBmb2xsb3dpbmcgZXhpc3RpbmcgcGF0dGVyblxuamVzdC5tb2NrKFwiY2hlc3MuanNcIik7XG5cbmNvbnN0IE1vY2tlZENoZXNzID0gQ2hlc3MgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgQ2hlc3M+O1xuXG5kZXNjcmliZShcIkNoZXNzU2VydmljZSBQR04gTG9hZGluZyBUZXN0c1wiLCAoKSA9PiB7XG4gIGxldCBjaGVzc1NlcnZpY2U6IENoZXNzU2VydmljZTtcbiAgbGV0IG1vY2tDaGVzc0luc3RhbmNlOiBqZXN0Lk1vY2tlZDxJbnN0YW5jZVR5cGU8dHlwZW9mIENoZXNzPj47XG5cbiAgLy8gUEdOIHRlc3QgZml4dHVyZXMgZm9yIGNvbXByZWhlbnNpdmUgdGVzdGluZ1xuICBjb25zdCBwZ25UZXN0Rml4dHVyZXMgPSB7XG4gICAgdmFsaWQ6IFwiMS4gZTQgZTUgMi4gTmYzIE5jNiAzLiBCYjVcIiwgLy8gU2ltcGxlIFNwYW5pc2ggT3BlbmluZ1xuICAgIGNvbXBsZXg6IFwiMS4gZTQgZTUgMi4gTmYzIE5jNiAzLiBCYjUgYTYgNC4gQmE0IE5mNiA1LiBPLU8gQmU3IDYuIFJlMSBiNSA3LiBCYjMgZDZcIiwgLy8gQ29tcGxleCB3aXRoIGNhc3RsaW5nXG4gICAgc2hvcnRHYW1lOiBcIjEuIGU0IGU1IDIuIFFoNSBOYzYgMy4gQmM0IE5mNiA0LiBReGY3I1wiLCAvLyBRdWljayBjaGVja21hdGVcbiAgICBlbXB0eTogXCJcIixcbiAgICB3aGl0ZXNwYWNlOiBcIiAgIFxcbiAgXFx0ICBcIiwgLy8gT25seSB3aGl0ZXNwYWNlXG4gICAgaW52YWxpZDogXCIxLiB4eCB5eSB6elwiLCAvLyBNYWxmb3JtZWQgbW92ZXNcbiAgICBtYWxmb3JtZWQ6IFwidGhpcyBpcyBub3QgcGduIGF0IGFsbFwiLFxuICAgIHBhcnRpYWxWYWxpZDogXCIxLiBlNCBlNSAyLiBOZjMgaW52YWxpZF9tb3ZlXCIsIC8vIFZhbGlkIHN0YXJ0LCBpbnZhbGlkIGNvbnRpbnVhdGlvblxuICB9O1xuXG4gIC8vIE1vY2sgbW92ZSBvYmplY3RzIGZvciBoaXN0b3J5IHJlY29uc3RydWN0aW9uXG4gIGNvbnN0IG1vY2tNb3ZlcyA9IFtcbiAgICB7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiwgc2FuOiBcImU0XCIsIHBpZWNlOiBcInBcIiwgY29sb3I6IFwid1wiIH0sXG4gICAgeyBmcm9tOiBcImU3XCIsIHRvOiBcImU1XCIsIHNhbjogXCJlNVwiLCBwaWVjZTogXCJwXCIsIGNvbG9yOiBcImJcIiB9LFxuICAgIHsgZnJvbTogXCJnMVwiLCB0bzogXCJmM1wiLCBzYW46IFwiTmYzXCIsIHBpZWNlOiBcIm5cIiwgY29sb3I6IFwid1wiIH0sXG4gIF07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgTW9ja2VkQ2hlc3MubW9ja0NsZWFyKCk7XG5cbiAgICAvLyBDcmVhdGUgY29tcHJlaGVuc2l2ZSBtb2NrIENoZXNzIGluc3RhbmNlXG4gICAgbW9ja0NoZXNzSW5zdGFuY2UgPSB7XG4gICAgICBtb3ZlOiBqZXN0LmZuKCksXG4gICAgICBmZW46IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiKSxcbiAgICAgIHBnbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShcIlwiKSxcbiAgICAgIGhpc3Rvcnk6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoW10pLFxuICAgICAgbG9hZDogamVzdC5mbigpLFxuICAgICAgbG9hZFBnbjogamVzdC5mbigpLFxuICAgICAgaXNHYW1lT3ZlcjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgICB0dXJuOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFwid1wiKSxcbiAgICAgIG1vdmVzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFtcImU0XCIsIFwiZTNcIiwgXCJOZjNcIl0pLFxuICAgICAgaXNDaGVjazogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgICBpc0NoZWNrbWF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgICBpc1N0YWxlbWF0ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgICBpc0RyYXc6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpLFxuICAgIH0gYXMgYW55O1xuXG4gICAgTW9ja2VkQ2hlc3MubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tDaGVzc0luc3RhbmNlKTtcbiAgICBjaGVzc1NlcnZpY2UgPSBuZXcgQ2hlc3NTZXJ2aWNlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwibG9hZFBnbigpIC0gTGluZXMgNDgyLTUxOFwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgbG9hZCB2YWxpZCBQR04gYW5kIHJlY29uc3RydWN0IG1vdmUgaGlzdG9yeVwiLCAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCBtb2NrIGZvciBzdWNjZXNzZnVsIFBHTiBsb2FkaW5nXG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0cnVlIGFzIGFueSk7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5oaXN0b3J5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrTW92ZXMgYXMgYW55KTtcbiAgICAgIFxuICAgICAgLy8gTW9jayB0aGUgY2hlc3MgcG9zaXRpb24gcmVjb25zdHJ1Y3Rpb25cbiAgICAgIGxldCBmZW5Db3VudGVyID0gMDtcbiAgICAgIGNvbnN0IGZlbnMgPSBbXG4gICAgICAgIFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIiwgLy8gU3RhcnRpbmdcbiAgICAgICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvNFAzLzgvUFBQUDFQUFAvUk5CUUtCTlIgYiBLUWtxIGUzIDAgMVwiLCAvLyBBZnRlciAxLmU0XG4gICAgICAgIFwicm5icWtibnIvcHBwcDFwcHAvOC80cDMvNFAzLzgvUFBQUDFQUFAvUk5CUUtCTlIgdyBLUWtxIGU2IDAgMlwiLCAvLyBBZnRlciAxLi4uZTVcbiAgICAgICAgXCJybmJxa2Juci9wcHBwMXBwcC84LzRwMy80UDMvNU4yL1BQUFAxUFBQL1JOQlFLQjFSIGIgS1FrcSAtIDEgMlwiLCAvLyBBZnRlciAyLk5mM1xuICAgICAgXTtcblxuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuZmVuLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBmZW5zW2ZlbkNvdW50ZXJdIHx8IGZlbnNbMF0pO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubW92ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBmZW5Db3VudGVyKys7XG4gICAgICAgIHJldHVybiAobW9ja01vdmVzW2ZlbkNvdW50ZXIgLSAxXSB8fCBudWxsKSBhcyBhbnk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayBldmVudCBsaXN0ZW5lciB0byB0cmFjayBzdGF0ZSB1cGRhdGVzXG4gICAgICBjb25zdCBtb2NrTGlzdGVuZXIgPSBqZXN0LmZuKCk7XG4gICAgICBjaGVzc1NlcnZpY2Uuc3Vic2NyaWJlKG1vY2tMaXN0ZW5lcik7XG5cbiAgICAgIC8vIFRlc3QgUEdOIGxvYWRpbmdcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5sb2FkUGduKHBnblRlc3RGaXh0dXJlcy52YWxpZCk7XG5cbiAgICAgIC8vIFZlcmlmeSBzdWNjZXNzXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KG1vY2tDaGVzc0luc3RhbmNlLmxvYWRQZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBnblRlc3RGaXh0dXJlcy52YWxpZCk7XG4gICAgICBleHBlY3QobW9ja0NoZXNzSW5zdGFuY2UuaGlzdG9yeSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB2ZXJib3NlOiB0cnVlIH0pO1xuXG4gICAgICAvLyBWZXJpZnkgbW92ZSBoaXN0b3J5IHJlY29uc3RydWN0aW9uXG4gICAgICBjb25zdCBtb3ZlSGlzdG9yeSA9IGNoZXNzU2VydmljZS5nZXRNb3ZlSGlzdG9yeSgpO1xuICAgICAgZXhwZWN0KG1vdmVIaXN0b3J5KS50b0hhdmVMZW5ndGgobW9ja01vdmVzLmxlbmd0aCk7XG5cbiAgICAgIC8vIFZlcmlmeSBjdXJyZW50IG1vdmUgaW5kZXggaXMgc2V0IGNvcnJlY3RseVxuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRDdXJyZW50TW92ZUluZGV4KCkpLnRvQmUobW9ja01vdmVzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAvLyBWZXJpZnkgc3RhdGUgdXBkYXRlIGV2ZW50IHdhcyBlbWl0dGVkXG4gICAgICBleHBlY3QobW9ja0xpc3RlbmVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwic3RhdGVVcGRhdGVcIixcbiAgICAgICAgICBzb3VyY2U6IFwibG9hZFwiLFxuICAgICAgICAgIHBheWxvYWQ6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIG1vdmVIaXN0b3J5OiBleHBlY3QuYW55KEFycmF5KSxcbiAgICAgICAgICAgIGN1cnJlbnRNb3ZlSW5kZXg6IG1vY2tNb3Zlcy5sZW5ndGggLSAxLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBjb21wbGV4IFBHTiB3aXRoIGNhc3RsaW5nXCIsICgpID0+IHtcbiAgICAgIC8vIFNldHVwIG1vcmUgY29tcGxleCBtb3ZlIHNlcXVlbmNlXG4gICAgICBjb25zdCBjb21wbGV4TW92ZXMgPSBbXG4gICAgICAgIHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiwgcGllY2U6IFwicFwiLCBjb2xvcjogXCJ3XCIgfSxcbiAgICAgICAgeyBmcm9tOiBcImU3XCIsIHRvOiBcImU1XCIsIHNhbjogXCJlNVwiLCBwaWVjZTogXCJwXCIsIGNvbG9yOiBcImJcIiB9LFxuICAgICAgICB7IGZyb206IFwiZzFcIiwgdG86IFwiZjNcIiwgc2FuOiBcIk5mM1wiLCBwaWVjZTogXCJuXCIsIGNvbG9yOiBcIndcIiB9LFxuICAgICAgICB7IGZyb206IFwiYjhcIiwgdG86IFwiYzZcIiwgc2FuOiBcIk5jNlwiLCBwaWVjZTogXCJuXCIsIGNvbG9yOiBcImJcIiB9LFxuICAgICAgICB7IGZyb206IFwiZjFcIiwgdG86IFwiYjVcIiwgc2FuOiBcIkJiNVwiLCBwaWVjZTogXCJiXCIsIGNvbG9yOiBcIndcIiB9LFxuICAgICAgICB7IGZyb206IFwiZTFcIiwgdG86IFwiZzFcIiwgc2FuOiBcIk8tT1wiLCBwaWVjZTogXCJrXCIsIGNvbG9yOiBcIndcIiB9LCAvLyBDYXN0bGluZ1xuICAgICAgXTtcblxuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubG9hZFBnbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuaGlzdG9yeS5tb2NrUmV0dXJuVmFsdWUoY29tcGxleE1vdmVzIGFzIGFueSk7XG5cbiAgICAgIGxldCBtb3ZlQ291bnRlciA9IDA7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5tb3ZlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIG1vdmVDb3VudGVyKys7XG4gICAgICAgIHJldHVybiAoY29tcGxleE1vdmVzW21vdmVDb3VudGVyIC0gMV0gfHwgbnVsbCkgYXMgYW55O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5sb2FkUGduKHBnblRlc3RGaXh0dXJlcy5jb21wbGV4KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKGNvbXBsZXhNb3Zlcy5sZW5ndGgpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRDdXJyZW50TW92ZUluZGV4KCkpLnRvQmUoY29tcGxleE1vdmVzLmxlbmd0aCAtIDEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIGVtcHR5IFBHTiBzdHJpbmdcIiwgKCkgPT4ge1xuICAgICAgLy8gU2V0dXAgZm9yIGVtcHR5IFBHTlxuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubG9hZFBnbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuaGlzdG9yeS5tb2NrUmV0dXJuVmFsdWUoW10gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLmxvYWRQZ24ocGduVGVzdEZpeHR1cmVzLmVtcHR5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcIlwiKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRDdXJyZW50TW92ZUluZGV4KCkpLnRvQmUoLTEpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHdoaXRlc3BhY2Utb25seSBQR05cIiwgKCkgPT4ge1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubG9hZFBnbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuaGlzdG9yeS5tb2NrUmV0dXJuVmFsdWUoW10gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLmxvYWRQZ24ocGduVGVzdEZpeHR1cmVzLndoaXRlc3BhY2UpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRNb3ZlSGlzdG9yeSgpKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgaW52YWxpZCBQR04gYW5kIGVtaXQgZXJyb3IgZXZlbnRcIiwgKCkgPT4ge1xuICAgICAgLy8gU2V0dXAgbW9jayB0byB0aHJvdyBlcnJvciBmb3IgaW52YWxpZCBQR05cbiAgICAgIGNvbnN0IHBnbkVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCBQR04gZm9ybWF0XCIpO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubG9hZFBnbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBwZ25FcnJvcjtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGV2ZW50IGxpc3RlbmVyIHRvIGNhcHR1cmUgZXJyb3JcbiAgICAgIGNvbnN0IG1vY2tMaXN0ZW5lciA9IGplc3QuZm4oKTtcbiAgICAgIGNoZXNzU2VydmljZS5zdWJzY3JpYmUobW9ja0xpc3RlbmVyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLmxvYWRQZ24ocGduVGVzdEZpeHR1cmVzLmludmFsaWQpO1xuXG4gICAgICAvLyBWZXJpZnkgZmFpbHVyZSBhbmQgZXJyb3IgaGFuZGxpbmdcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG1vY2tDaGVzc0luc3RhbmNlLmxvYWRQZ24pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHBnblRlc3RGaXh0dXJlcy5pbnZhbGlkKTtcblxuICAgICAgLy8gVmVyaWZ5IGVycm9yIGV2ZW50IHdhcyBlbWl0dGVkXG4gICAgICBleHBlY3QobW9ja0xpc3RlbmVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICBwYXlsb2FkOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBlcnJvcjogZXhwZWN0LmFueShFcnJvciksXG4gICAgICAgICAgICBtZXNzYWdlOiBcIlVuZ8O8bHRpZ2VzIFBHTi1Gb3JtYXRcIixcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgbWFsZm9ybWVkIFBHTiBzdHJpbmdcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbWFsZm9ybWVkRXJyb3IgPSBuZXcgRXJyb3IoXCJOb3QgYSB2YWxpZCBQR05cIik7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG1hbGZvcm1lZEVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tMaXN0ZW5lciA9IGplc3QuZm4oKTtcbiAgICAgIGNoZXNzU2VydmljZS5zdWJzY3JpYmUobW9ja0xpc3RlbmVyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLmxvYWRQZ24ocGduVGVzdEZpeHR1cmVzLm1hbGZvcm1lZCk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG1vY2tMaXN0ZW5lcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgcGF5bG9hZDogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbmfDvGx0aWdlcyBQR04tRm9ybWF0XCIsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHBhcnRpYWxseSB2YWxpZCBQR05cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgcGFydGlhbEVycm9yID0gbmV3IEVycm9yKFwiSW52YWxpZCBtb3ZlIGluIFBHTlwiKTtcbiAgICAgIG1vY2tDaGVzc0luc3RhbmNlLmxvYWRQZ24ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgcGFydGlhbEVycm9yO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5sb2FkUGduKHBnblRlc3RGaXh0dXJlcy5wYXJ0aWFsVmFsaWQpO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChwZ25UZXN0Rml4dHVyZXMucGFydGlhbFZhbGlkKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHJlc2V0IGNoZXNzIGluc3RhbmNlIGFuZCByZWJ1aWxkIGZyb20gc2NyYXRjaFwiLCAoKSA9PiB7XG4gICAgICAvLyBUaGlzIHRlc3RzIHRoZSBjcml0aWNhbCBsb2dpYyBpbiBsaW5lcyA0ODUtNDk2XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0cnVlIGFzIGFueSk7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5oaXN0b3J5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrTW92ZXMgYXMgYW55KTtcblxuICAgICAgY29uc3QgaW5pdGlhbENhbGxDb3VudCA9IE1vY2tlZENoZXNzLm1vY2suY2FsbHMubGVuZ3RoO1xuICAgICAgXG4gICAgICBjaGVzc1NlcnZpY2UubG9hZFBnbihwZ25UZXN0Rml4dHVyZXMudmFsaWQpO1xuXG4gICAgICAvLyBWZXJpZnkgQ2hlc3MgY29uc3RydWN0b3Igd2FzIGNhbGxlZCBmb3IgcmVzZXQgKGxpbmUgNDg3OiB0aGlzLmNoZXNzID0gbmV3IENoZXNzKCkpXG4gICAgICBleHBlY3QoTW9ja2VkQ2hlc3MubW9jay5jYWxscy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbihpbml0aWFsQ2FsbENvdW50KTtcbiAgICAgIC8vIFZlcmlmeSBtb3ZlcyB3ZXJlIHJlcGxheWVkIChsaW5lcyA0OTAtNDk2KVxuICAgICAgZXhwZWN0KG1vY2tDaGVzc0luc3RhbmNlLm1vdmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhtb2NrTW92ZXMubGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHByZXNlcnZlIHZhbGlkYXRlZCBtb3ZlIHN0cnVjdHVyZSBpbiBoaXN0b3J5XCIsICgpID0+IHtcbiAgICAgIG1vY2tDaGVzc0luc3RhbmNlLmxvYWRQZ24ubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHRydWUgYXMgYW55KTtcbiAgICAgIG1vY2tDaGVzc0luc3RhbmNlLmhpc3RvcnkubW9ja1JldHVyblZhbHVlKG1vY2tNb3ZlcyBhcyBhbnkpO1xuXG4gICAgICAvLyBNb2NrIEZFTiBwcm9ncmVzc2lvbiBmb3IgbW92ZSB2YWxpZGF0aW9uXG4gICAgICBsZXQgZmVuSW5kZXggPSAwO1xuICAgICAgY29uc3QgZmVuUHJvZ3Jlc3Npb24gPSBbXG4gICAgICAgIFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIixcbiAgICAgICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvNFAzLzgvUFBQUDFQUFAvUk5CUUtCTlIgYiBLUWtxIGUzIDAgMVwiLFxuICAgICAgICBcInJuYnFrYm5yL3BwcHAxcHBwLzgvNHAzLzRQMy84L1BQUFAxUFBQL1JOQlFLQk5SIHcgS1FrcSBlNiAwIDJcIixcbiAgICAgICAgXCJybmJxa2Juci9wcHBwMXBwcC84LzRwMy80UDMvNU4yL1BQUFAxUFBQL1JOQlFLQjFSIGIgS1FrcSAtIDEgMlwiLFxuICAgICAgXTtcblxuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuZmVuLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBmZW5Qcm9ncmVzc2lvbltmZW5JbmRleF0gfHwgZmVuUHJvZ3Jlc3Npb25bMF0pO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubW92ZS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICBjb25zdCBtb3ZlID0gbW9ja01vdmVzW2ZlbkluZGV4XTtcbiAgICAgICAgZmVuSW5kZXgrKztcbiAgICAgICAgcmV0dXJuIChtb3ZlIHx8IG51bGwpIGFzIGFueTtcbiAgICAgIH0pO1xuXG4gICAgICBjaGVzc1NlcnZpY2UubG9hZFBnbihwZ25UZXN0Rml4dHVyZXMudmFsaWQpO1xuXG4gICAgICBjb25zdCBtb3ZlSGlzdG9yeSA9IGNoZXNzU2VydmljZS5nZXRNb3ZlSGlzdG9yeSgpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgZWFjaCBtb3ZlIGluIGhpc3RvcnkgaGFzIHJlcXVpcmVkIFZhbGlkYXRlZE1vdmUgc3RydWN0dXJlXG4gICAgICBtb3ZlSGlzdG9yeS5mb3JFYWNoKChtb3ZlLCBpbmRleCkgPT4ge1xuICAgICAgICBleHBlY3QobW92ZSkudG9IYXZlUHJvcGVydHkoJ2Zyb20nKTtcbiAgICAgICAgZXhwZWN0KG1vdmUpLnRvSGF2ZVByb3BlcnR5KCd0bycpO1xuICAgICAgICBleHBlY3QobW92ZSkudG9IYXZlUHJvcGVydHkoJ3NhbicpO1xuICAgICAgICBleHBlY3QobW92ZSkudG9IYXZlUHJvcGVydHkoJ2ZlbkJlZm9yZScpO1xuICAgICAgICBleHBlY3QobW92ZSkudG9IYXZlUHJvcGVydHkoJ2ZlbkFmdGVyJyk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBlcnJvciBkdXJpbmcgbW92ZSByZWNvbnN0cnVjdGlvblwiLCAoKSA9PiB7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5sb2FkUGduLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0cnVlIGFzIGFueSk7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5oaXN0b3J5Lm1vY2tSZXR1cm5WYWx1ZShtb2NrTW92ZXMgYXMgYW55KTtcblxuICAgICAgLy8gTW9jayBtb3ZlKCkgdG8gdGhyb3cgZXJyb3IgZHVyaW5nIHJlY29uc3RydWN0aW9uXG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5tb3ZlLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vdmUgcmVjb25zdHJ1Y3Rpb24gZmFpbGVkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IG1vY2tMaXN0ZW5lciA9IGplc3QuZm4oKTtcbiAgICAgIGNoZXNzU2VydmljZS5zdWJzY3JpYmUobW9ja0xpc3RlbmVyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLmxvYWRQZ24ocGduVGVzdEZpeHR1cmVzLnZhbGlkKTtcblxuICAgICAgLy8gU2hvdWxkIGZhaWwgZ3JhY2VmdWxseVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QobW9ja0xpc3RlbmVyKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUEdOIEludGVncmF0aW9uIHdpdGggb3RoZXIgbWV0aG9kc1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gY29uc2lzdGVuY3kgYWZ0ZXIgUEdOIGxvYWRcIiwgKCkgPT4ge1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubG9hZFBnbi5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdHJ1ZSBhcyBhbnkpO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuaGlzdG9yeS5tb2NrUmV0dXJuVmFsdWUobW9ja01vdmVzIGFzIGFueSk7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5wZ24ubW9ja1JldHVyblZhbHVlKHBnblRlc3RGaXh0dXJlcy52YWxpZCk7XG5cbiAgICAgIGNoZXNzU2VydmljZS5sb2FkUGduKHBnblRlc3RGaXh0dXJlcy52YWxpZCk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIG1ldGhvZHNcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKG1vY2tNb3Zlcy5sZW5ndGggLSAxKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKG1vY2tNb3Zlcy5sZW5ndGgpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRQZ24oKSkudG9CZShwZ25UZXN0Rml4dHVyZXMudmFsaWQpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsIk1vY2tlZENoZXNzIiwiQ2hlc3MiLCJkZXNjcmliZSIsImNoZXNzU2VydmljZSIsIm1vY2tDaGVzc0luc3RhbmNlIiwicGduVGVzdEZpeHR1cmVzIiwidmFsaWQiLCJjb21wbGV4Iiwic2hvcnRHYW1lIiwiZW1wdHkiLCJ3aGl0ZXNwYWNlIiwiaW52YWxpZCIsIm1hbGZvcm1lZCIsInBhcnRpYWxWYWxpZCIsIm1vY2tNb3ZlcyIsImZyb20iLCJ0byIsInNhbiIsInBpZWNlIiwiY29sb3IiLCJiZWZvcmVFYWNoIiwibW9ja0NsZWFyIiwibW92ZSIsImZuIiwiZmVuIiwibW9ja1JldHVyblZhbHVlIiwicGduIiwiaGlzdG9yeSIsImxvYWQiLCJsb2FkUGduIiwiaXNHYW1lT3ZlciIsInR1cm4iLCJtb3ZlcyIsImlzQ2hlY2siLCJpc0NoZWNrbWF0ZSIsImlzU3RhbGVtYXRlIiwiaXNEcmF3IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiQ2hlc3NTZXJ2aWNlIiwiaXQiLCJmZW5Db3VudGVyIiwiZmVucyIsIm1vY2tMaXN0ZW5lciIsInN1YnNjcmliZSIsInJlc3VsdCIsImV4cGVjdCIsInRvQmUiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsInZlcmJvc2UiLCJtb3ZlSGlzdG9yeSIsImdldE1vdmVIaXN0b3J5IiwidG9IYXZlTGVuZ3RoIiwibGVuZ3RoIiwiZ2V0Q3VycmVudE1vdmVJbmRleCIsIm9iamVjdENvbnRhaW5pbmciLCJ0eXBlIiwic291cmNlIiwicGF5bG9hZCIsImFueSIsIkFycmF5IiwiY3VycmVudE1vdmVJbmRleCIsImNvbXBsZXhNb3ZlcyIsIm1vdmVDb3VudGVyIiwicGduRXJyb3IiLCJFcnJvciIsImVycm9yIiwibWVzc2FnZSIsIm1hbGZvcm1lZEVycm9yIiwicGFydGlhbEVycm9yIiwiaW5pdGlhbENhbGxDb3VudCIsImNhbGxzIiwidG9CZUdyZWF0ZXJUaGFuIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwiZmVuSW5kZXgiLCJmZW5Qcm9ncmVzc2lvbiIsImZvckVhY2giLCJpbmRleCIsInRvSGF2ZVByb3BlcnR5IiwiZ2V0UGduIl0sIm1hcHBpbmdzIjoiQUFBQTs7OztDQUlDO0FBTUQsMkNBQTJDO0FBQzNDQSxLQUFLQyxJQUFJLENBQUM7Ozs7OEJBTG1CO3VCQUNQO0FBTXRCLE1BQU1DLGNBQWNDLFlBQUs7QUFFekJDLFNBQVMsa0NBQWtDO0lBQ3pDLElBQUlDO0lBQ0osSUFBSUM7SUFFSiw4Q0FBOEM7SUFDOUMsTUFBTUMsa0JBQWtCO1FBQ3RCQyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsV0FBVztRQUNYQyxPQUFPO1FBQ1BDLFlBQVk7UUFDWkMsU0FBUztRQUNUQyxXQUFXO1FBQ1hDLGNBQWM7SUFDaEI7SUFFQSwrQ0FBK0M7SUFDL0MsTUFBTUMsWUFBWTtRQUNoQjtZQUFFQyxNQUFNO1lBQU1DLElBQUk7WUFBTUMsS0FBSztZQUFNQyxPQUFPO1lBQUtDLE9BQU87UUFBSTtRQUMxRDtZQUFFSixNQUFNO1lBQU1DLElBQUk7WUFBTUMsS0FBSztZQUFNQyxPQUFPO1lBQUtDLE9BQU87UUFBSTtRQUMxRDtZQUFFSixNQUFNO1lBQU1DLElBQUk7WUFBTUMsS0FBSztZQUFPQyxPQUFPO1lBQUtDLE9BQU87UUFBSTtLQUM1RDtJQUVEQyxXQUFXO1FBQ1RwQixZQUFZcUIsU0FBUztRQUVyQiwyQ0FBMkM7UUFDM0NqQixvQkFBb0I7WUFDbEJrQixNQUFNeEIsS0FBS3lCLEVBQUU7WUFDYkMsS0FBSzFCLEtBQUt5QixFQUFFLEdBQUdFLGVBQWUsQ0FBQztZQUMvQkMsS0FBSzVCLEtBQUt5QixFQUFFLEdBQUdFLGVBQWUsQ0FBQztZQUMvQkUsU0FBUzdCLEtBQUt5QixFQUFFLEdBQUdFLGVBQWUsQ0FBQyxFQUFFO1lBQ3JDRyxNQUFNOUIsS0FBS3lCLEVBQUU7WUFDYk0sU0FBUy9CLEtBQUt5QixFQUFFO1lBQ2hCTyxZQUFZaEMsS0FBS3lCLEVBQUUsR0FBR0UsZUFBZSxDQUFDO1lBQ3RDTSxNQUFNakMs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