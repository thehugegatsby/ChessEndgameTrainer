c59dc1538da2f6560c0f6df379bf45ec
/**
 * @file Core Logger implementation
 * @module services/logging/Logger
 *
 * @description
 * Provides structured, multi-level logging with different transports.
 * Supports console, file, and remote logging with configurable log levels,
 * filtering, and formatting. Designed for both development and production use.
 *
 * @remarks
 * Key features:
 * - Multiple log levels (DEBUG, INFO, WARN, ERROR)
 * - Contextual logging with metadata
 * - Configurable transports (console, file, remote)
 * - Circular buffer for log history
 * - Error tracking with stack traces
 * - Performance monitoring
 * - Filtered logging by context or level
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Logger () {
        return Logger;
    },
    get RemoteTransport () {
        return RemoteTransport;
    },
    get createLogger () {
        return createLogger;
    },
    get getLogger () {
        return getLogger;
    },
    get resetLogger () {
        return resetLogger;
    }
});
const _types = require("./types");
const _platform = require("../platform");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// Default configuration
const DEFAULT_CONFIG = {
    minLevel: process.env.NODE_ENV === "production" ? _types.LogLevel.INFO : _types.LogLevel.DEBUG,
    enableConsole: true,
    enableRemote: false,
    enableFileLogging: false,
    maxLogSize: 1000
};
/**
 * Default log formatter implementation
 *
 * @class DefaultLogFormatter
 * @implements {ILogFormatter}
 *
 * @description
 * Formats log entries into human-readable strings with timestamp,
 * level, context, message, and optional data/error information.
 */ class DefaultLogFormatter {
    /**
   * Formats a log entry into a string
   *
   * @param {LogEntry} entry - The log entry to format
   * @returns {string} Formatted log message
   *
   * @example
   * ```typescript
   * const formatter = new DefaultLogFormatter();
   * const formatted = formatter.format({
   *   timestamp: new Date(),
   *   level: LogLevel.INFO,
   *   message: "User logged in",
   *   context: "Auth",
   *   data: { userId: 123 }
   * });
   * // "2024-01-20T10:30:00.000Z INFO [Auth] User logged in { userId: 123 }"
   * ```
   */ format(entry) {
        const timestamp = entry.timestamp.toISOString();
        const level = _types.LogLevel[entry.level];
        const context = entry.context ? `[${entry.context}]` : "";
        let message = `${timestamp} ${level} ${context} ${entry.message}`;
        if (entry.data) {
            try {
                message += ` ${JSON.stringify(entry.data, null, 2)}`;
            } catch (e) {
                // Fallback for circular references or other stringify errors
                message += ` ${String(entry.data)}`;
            }
        }
        if (entry.error) {
            message += ` Error: ${entry.error.message}`;
            if (entry.stack) {
                message += `\nStack: ${entry.stack}`;
            }
        }
        return message;
    }
}
/**
 * Console transport implementation for logging
 *
 * @class ConsoleTransport
 * @implements {ILogTransport}
 *
 * @description
 * Outputs log entries to the browser console with appropriate log levels.
 * Uses native console methods (debug, info, warn, error) based on log level
 * for better developer experience.
 *
 * @example
 * ```typescript
 * const transport = new ConsoleTransport();
 * transport.log({
 *   level: LogLevel.INFO,
 *   message: "Application started",
 *   timestamp: new Date(),
 *   context: "Main"
 * });
 * ```
 */ class ConsoleTransport {
    /**
   * Logs an entry to the console
   *
   * @param {LogEntry} entry - The log entry to output
   *
   * @remarks
   * Maps log levels to appropriate console methods:
   * - DEBUG → console.debug()
   * - INFO → console.info()
   * - WARN → console.warn()
   * - ERROR/FATAL → console.error()
   *
   * If the entry contains data, it's logged as a second parameter
   * for better console formatting.
   */ log(entry) {
        const formatted = this.formatter.format(entry);
        // If there's additional data, log it separately for better visibility
        if (entry.data) {
            switch(entry.level){
                case _types.LogLevel.DEBUG:
                    console.debug(formatted, entry.data);
                    break;
                case _types.LogLevel.INFO:
                    console.info(formatted, entry.data);
                    break;
                case _types.LogLevel.WARN:
                    console.warn(formatted, entry.data);
                    break;
                case _types.LogLevel.ERROR:
                case _types.LogLevel.FATAL:
                    console.error(formatted, entry.data);
                    break;
            }
        } else {
            switch(entry.level){
                case _types.LogLevel.DEBUG:
                    console.debug(formatted);
                    break;
                case _types.LogLevel.INFO:
                    console.info(formatted);
                    break;
                case _types.LogLevel.WARN:
                    console.warn(formatted);
                    break;
                case _types.LogLevel.ERROR:
                case _types.LogLevel.FATAL:
                    console.error(formatted);
                    break;
            }
        }
    }
    /**
   * Flushes pending logs (no-op for console transport)
   *
   * @returns {Promise<void>} Resolves immediately as console has no buffer
   *
   * @remarks
   * Console transport writes immediately, so no flushing is needed.
   * This method exists to satisfy the ILogTransport interface.
   */ async flush() {
    // Console doesn't need flushing
    }
    /**
   * Creates a new console transport
   *
   * @param {ILogFormatter} [formatter] - Optional custom formatter, defaults to DefaultLogFormatter
   */ constructor(formatter){
        _define_property(this, "formatter", void 0);
        this.formatter = formatter || new DefaultLogFormatter();
    }
}
/**
 * Remote transport implementation for centralized logging
 *
 * @class RemoteTransport
 * @implements {ILogTransport}
 *
 * @description
 * Buffers log entries and sends them to a remote endpoint in batches.
 * Includes retry logic and maintains chronological order of logs.
 * Useful for production monitoring and debugging.
 *
 * @example
 * ```typescript
 * const transport = new RemoteTransport('https://logs.myapp.com/ingest');
 * transport.log({
 *   level: LogLevel.ERROR,
 *   message: "Database connection failed",
 *   timestamp: new Date(),
 *   error: new Error("Connection timeout")
 * });
 * // Logs are buffered and sent in batches
 * await transport.flush(); // Force send pending logs
 * ```
 */ class RemoteTransport {
    /**
   * Adds a log entry to the buffer and triggers flush if needed
   *
   * @param {LogEntry} entry - The log entry to buffer
   *
   * @remarks
   * Logs are buffered until batch size is reached, then automatically
   * sent to the remote endpoint. Use flush() to send immediately.
   */ log(entry) {
        this.buffer.push(entry);
        if (this.buffer.length >= this.batchSize) {
            this.flush().catch(console.error);
        }
    }
    /**
   * Flushes buffered logs to the remote endpoint
   *
   * @returns {Promise<void>} Resolves when flush completes or fails
   *
   * @remarks
   * - Prevents concurrent flushes
   * - Preserves log order on failure by re-buffering
   * - Uses console.error as fallback for logging failures
   * - Automatically called when buffer reaches batch size
   *
   * @example
   * ```typescript
   * // Force send all pending logs
   * await transport.flush();
   *
   * // Ensure logs are sent before shutdown
   * process.on('SIGTERM', async () => {
   *   await transport.flush();
   *   process.exit(0);
   * });
   * ```
   */ async flush() {
        // Prevent concurrent flushes and exit if there's nothing to do
        if (this.isFlushing || this.buffer.length === 0 || !this.endpoint) {
            return;
        }
        this.isFlushing = true;
        // Atomically grab the current logs and clear the buffer for new entries
        const entriesToFlush = [
            ...this.buffer
        ];
        this.buffer.length = 0;
        try {
            const response = await fetch(this.endpoint, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    logs: entriesToFlush
                })
            });
            if (!response.ok) {
                // The request was made, but the server responded with an error
                throw new Error(`Server responded with status ${response.status}`);
            }
        } catch (error) {
            // FALLBACK: Using console.error as last resort when logging infrastructure itself fails
            // This prevents infinite loops and ensures critical logging failures are still visible
            console.error("Failed to send logs to remote:", error);
            // If the request fails, put the logs back at the front of the buffer to be retried
            // This preserves chronological order
            this.buffer.unshift(...entriesToFlush);
        } finally{
            // Ensure we always reset the flushing state
            this.isFlushing = false;
        }
    }
    /**
   * Creates a new remote transport
   *
   * @param {string} endpoint - The URL to send logs to
   *
   * @example
   * ```typescript
   * const transport = new RemoteTransport('https://logs.myapp.com/ingest');
   * ```
   */ constructor(endpoint){
        _define_property(this, "buffer", []);
        _define_property(this, "batchSize", 50);
        _define_property(this, "endpoint", void 0);
        _define_property(this, "isFlushing", false);
        this.endpoint = endpoint;
    }
}
class Logger {
    /**
   * Sets up logging transports based on configuration
   *
   * @private
   * @remarks
   * Called during initialization and when configuration changes.
   * Creates console and/or remote transports as configured.
   */ setupTransports() {
        this.transports = [];
        if (this.config.enableConsole) {
            this.transports.push(new ConsoleTransport());
        }
        if (this.config.enableRemote && this.config.remoteEndpoint) {
            this.transports.push(new RemoteTransport(this.config.remoteEndpoint));
        }
    }
    /**
   * Determines if a log entry should be processed
   *
   * @private
   * @param {LogLevel} level - The log level to check
   * @param {string} [context] - Optional context to check against filters
   * @returns {boolean} True if the log should be processed
   *
   * @remarks
   * Checks against minimum level, context whitelist, and blacklist
   */ shouldLog(level, context) {
        var _this_config_contextWhitelist, _this_config_contextBlacklist;
        if (level < this.config.minLevel) return false;
        const logContext = context || this.context;
        if (logContext && ((_this_config_contextWhitelist = this.config.contextWhitelist) === null || _this_config_contextWhitelist === void 0 ? void 0 : _this_config_contextWhitelist.length)) {
            return this.config.contextWhitelist.includes(logContext);
        }
        if (logContext && ((_this_config_contextBlacklist = this.config.contextBlacklist) === null || _this_config_contextBlacklist === void 0 ? void 0 : _this_config_contextBlacklist.length)) {
            return !this.config.contextBlacklist.includes(logContext);
        }
        return true;
    }
    /**
   * Core logging method used by all public log methods
   *
   * @private
   * @param {LogLevel} level - The severity level
   * @param {string} message - The log message
   * @param {Error|any} [error] - Optional error object
   * @param {any} [data] - Optional structured data
   *
   * @remarks
   * - Checks if log should be processed
   * - Creates log entry with metadata
   * - Adds to memory buffer
   * - Sends to all configured transports
   */ log(level, message, error, data) {
        if (!this.shouldLog(level, this.context)) return;
        const entry = {
            level,
            message,
            timestamp: new Date(),
            context: this.context,
            data: {
                ...this.fields,
                ...data
            }
        };
        if (error !== undefined && error !== null) {
            if (error instanceof Error) {
                entry.error = error;
                entry.stack = error.stack;
            } else {
                entry.error = new Error(String(error));
            }
        }
        // Add to memory log
        this.logs.push(entry);
        if (this.logs.length > this.config.maxLogSize) {
            this.logs.shift();
        }
        // Send to transports
        this.transports.forEach((transport)=>transport.log(entry));
    }
    /**
   * Logs a message at the DEBUG level.
   *
   * Debug messages are intended for detailed information that is typically only
   * of interest when diagnosing problems or during development. They will be
   * filtered out in production environments unless explicitly enabled.
   *
   * @param {string} message - The primary log message to record.
   * @param {any} [data] - Optional structured data to include with the log entry.
   *   This data will be serialized and attached to the log for additional context.
   * @returns {void}
   * @example
   * // Simple debug message
   * logger.debug('Application initialization complete');
   *
   * @example
   * // Debug message with structured data
   * logger.debug('Processing user request', { userId: 123, requestId: 'abc-xyz' });
   *
   * @see {@link Logger.info} - For general informational messages
   * @see {@link Logger.withFields} - To add persistent fields to all logs
   * @memberof Logger
   */ debug(message, data) {
        this.log(_types.LogLevel.DEBUG, message, undefined, data);
    }
    /**
   * Logs a message at the INFO level.
   *
   * Info messages are for general informational events that highlight the
   * progress of the application at a coarse-grained level. These are typically
   * shown in production environments.
   *
   * @param {string} message - The primary log message to record.
   * @param {any} [data] - Optional structured data to include with the log entry.
   *   This data will be serialized and attached to the log for additional context.
   * @returns {void}
   * @example
   * // Simple info message
   * logger.info('Server started on port 3000');
   *
   * @example
   * // Info message with structured data
   * logger.info('User logged in', { userId: 456, timestamp: Date.now() });
   *
   * @see {@link Logger.debug} - For detailed debugging information
   * @see {@link Logger.warn} - For warning messages
   * @memberof Logger
   */ info(message, data) {
        this.log(_types.LogLevel.INFO, message, undefined, data);
    }
    /**
   * Logs a message at the WARN level.
   *
   * Warning messages indicate potentially harmful situations or deprecated usage
   * that should be addressed but don't prevent the application from functioning.
   *
   * @param {string} message - The primary log message to record.
   * @param {any} [data] - Optional structured data to include with the log entry.
   *   This data will be serialized and attached to the log for additional context.
   * @returns {void}
   * @example
   * // Simple warning
   * logger.warn('API rate limit approaching');
   *
   * @example
   * // Warning with context
   * logger.warn('Deprecated method called', { method: 'oldFunction', replacement: 'newFunction' });
   *
   * @see {@link Logger.error} - For error conditions
   * @see {@link Logger.info} - For general information
   * @memberof Logger
   */ warn(message, data) {
        this.log(_types.LogLevel.WARN, message, undefined, data);
    }
    /**
   * Logs a message at the ERROR level.
   *
   * Error messages indicate error conditions that might still allow the application
   * to continue running. Stack traces are automatically captured when an Error
   * object is provided.
   *
   * @param {string} message - The primary log message describing the error.
   * @param {Error|any} [error] - Optional error object or any value that caused the error.
   *   If an Error object is provided, its stack trace will be captured.
   * @param {any} [data] - Optional additional context data about the error.
   * @returns {void}
   * @example
   * // Simple error message
   * logger.error('Failed to connect to database');
   *
   * @example
   * // Error with exception object
   * try {
   *   await connectToDatabase();
   * } catch (err) {
   *   logger.error('Database connection failed', err, { retryCount: 3 });
   * }
   *
   * @see {@link Logger.fatal} - For unrecoverable errors
   * @see {@link Logger.warn} - For warning conditions
   * @memberof Logger
   */ error(message, error, data) {
        this.log(_types.LogLevel.ERROR, message, error, data);
    }
    /**
   * Logs a message at the FATAL level.
   *
   * Fatal messages indicate severe error conditions that will likely cause the
   * application to abort. These should be reserved for unrecoverable errors.
   *
   * @param {string} message - The primary log message describing the fatal error.
   * @param {Error|any} [error] - Optional error object or any value that caused the fatal error.
   *   If an Error object is provided, its stack trace will be captured.
   * @param {any} [data] - Optional additional context data about the fatal error.
   * @returns {void}
   * @example
   * // Fatal error with process exit
   * logger.fatal('Critical configuration missing');
   * process.exit(1);
   *
   * @example
   * // Fatal error with exception
   * try {
   *   loadCriticalResource();
   * } catch (err) {
   *   logger.fatal('Failed to load critical resource', err, { resource: 'config.json' });
   *   process.exit(1);
   * }
   *
   * @see {@link Logger.error} - For recoverable errors
   * @memberof Logger
   */ fatal(message, error, data) {
        this.log(_types.LogLevel.FATAL, message, error, data);
    }
    /**
   * Creates a new logger instance with the specified context.
   *
   * The context is a string identifier that helps categorize logs by their source
   * (e.g., module name, component name, service name). The context appears in
   * formatted log output and can be used for filtering. The returned logger
   * shares configuration and log storage with the parent logger.
   *
   * @param {string} context - The context identifier for the new logger instance.
   * @returns {ILogger} A new logger instance with the specified context.
   * @example
   * // Create a logger for a specific module
   * const userLogger = logger.setContext('UserService');
   * userLogger.info('User created'); // Logs: [UserService] User created
   *
   * @example
   * // Create nested contexts
   * const apiLogger = logger.setContext('API');
   * const authLogger = apiLogger.setContext('API.Auth');
   * authLogger.info('Authentication successful');
   *
   * @see {@link Logger.clearContext} - To remove the context
   * @see {@link Logger.withFields} - To add persistent fields
   * @memberof Logger
   */ setContext(context) {
        const contextLogger = new Logger({
            ...this.config,
            transports: this.transports
        });
        contextLogger.context = context;
        contextLogger.logs = this.logs; // Share log storage
        contextLogger.fields = {
            ...this.fields
        };
        return contextLogger;
    }
    /**
   * Removes the context from this logger instance.
   *
   * After calling this method, logs will no longer include a context identifier.
   * This is useful when transitioning from module-specific logging back to
   * general application logging.
   *
   * @returns {void}
   * @example
   * const moduleLogger = logger.setContext('DataProcessor');
   * moduleLogger.info('Processing started');
   * // ... processing logic ...
   * moduleLogger.clearContext();
   * moduleLogger.info('Back to general logging'); // No context in output
   *
   * @see {@link Logger.setContext} - To set a context
   * @memberof Logger
   */ clearContext() {
        this.context = undefined;
    }
    /**
   * Returns a copy of the current logger configuration.
   *
   * This method provides read-only access to the logger's configuration,
   * including minimum log level, enabled transports, and other settings.
   * The returned object is a shallow copy to prevent external modifications.
   *
   * @returns {LoggerConfig} A copy of the current logger configuration.
   * @example
   * const config = logger.getConfig();
   * console.log('Current log level:', LogLevel[config.minLevel]);
   * console.log('Console logging enabled:', config.enableConsole);
   *
   * @see {@link Logger.updateConfig} - To modify the configuration
   * @memberof Logger
   */ getConfig() {
        return {
            ...this.config
        };
    }
    /**
   * Updates the logger configuration with the provided settings.
   *
   * This method allows runtime modification of logger behavior, including
   * changing the minimum log level, enabling/disabling transports, and
   * updating other configuration options. Only the provided properties
   * are updated; others retain their current values.
   *
   * @param {Partial<LoggerConfig>} config - Configuration properties to update.
   *   Only specified properties will be changed.
   * @returns {void}
   * @example
   * // Change minimum log level to WARN in production
   * if (process.env.NODE_ENV === 'production') {
   *   logger.updateConfig({ minLevel: LogLevel.WARN });
   * }
   *
   * @example
   * // Enable remote logging with custom endpoint
   * logger.updateConfig({
   *   enableRemote: true,
   *   remoteEndpoint: 'https://logs.myapp.com/ingest'
   * });
   *
   * @see {@link Logger.getConfig} - To read current configuration
   * @memberof Logger
   */ updateConfig(config) {
        this.config = {
            ...this.config,
            ...config
        };
        // Only setup transports if no custom transports were provided
        if (!config.transports) {
            this.setupTransports();
        } else {
            this.transports = config.transports;
        }
    }
    /**
   * Retrieves stored log entries, optionally filtered by criteria.
   *
   * This method returns logs that have been stored in memory (up to maxLogSize).
   * When a filter is provided, only logs matching ALL specified criteria are returned.
   * The returned array is a copy to prevent external modifications.
   *
   * @param {LogFilter} [filter] - Optional filter criteria to apply.
   * @param {LogLevel} [filter.minLevel] - Minimum log level to include.
   * @param {LogLevel} [filter.maxLevel] - Maximum log level to include.
   * @param {string} [filter.context] - Only include logs with this exact context.
   * @param {Date} [filter.startTime] - Only include logs after this time.
   * @param {Date} [filter.endTime] - Only include logs before this time.
   * @param {string} [filter.searchText] - Text to search for in message, context, or data.
   * @returns {LogEntry[]} Array of log entries matching the filter criteria.
   * @example
   * // Get all stored logs
   * const allLogs = logger.getLogs();
   *
   * @example
   * // Get only error and fatal logs
   * const errors = logger.getLogs({ minLevel: LogLevel.ERROR });
   *
   * @example
   * // Get logs from the last hour containing "user"
   * const recentUserLogs = logger.getLogs({
   *   startTime: new Date(Date.now() - 3600000),
   *   searchText: 'user'
   * });
   *
   * @see {@link Logger.clearLogs} - To remove all stored logs
   * @memberof Logger
   */ getLogs(filter) {
        if (!filter) return [
            ...this.logs
        ];
        return this.logs.filter((log)=>{
            if (filter.minLevel !== undefined && log.level < filter.minLevel) return false;
            if (filter.maxLevel !== undefined && log.level > filter.maxLevel) return false;
            if (filter.context && log.context !== filter.context) return false;
            if (filter.startTime && log.timestamp < filter.startTime) return false;
            if (filter.endTime && log.timestamp > filter.endTime) return false;
            if (filter.searchText) {
                var _log_context;
                const searchLower = filter.searchText.toLowerCase();
                const inMessage = log.message.toLowerCase().includes(searchLower);
                const inContext = (_log_context = log.context) === null || _log_context === void 0 ? void 0 : _log_context.toLowerCase().includes(searchLower);
                const inData = JSON.stringify(log.data).toLowerCase().includes(searchLower);
                return inMessage || inContext || inData;
            }
            return true;
        });
    }
    /**
   * Removes all stored log entries from memory.
   *
   * This method clears the internal log buffer. It does not affect logs
   * that have already been sent to transports (console, remote, etc.).
   * Useful for testing or when you want to free memory.
   *
   * @returns {void}
   * @example
   * // Clear logs after processing
   * const logs = logger.getLogs();
   * await processLogs(logs);
   * logger.clearLogs();
   *
   * @see {@link Logger.getLogs} - To retrieve stored logs
   * @memberof Logger
   */ clearLogs() {
        this.logs = [];
    }
    /**
   * Starts a timer with the specified label.
   *
   * Creates a named timer that can be used to measure the duration of operations.
   * The timer continues until {@link Logger.timeEnd} is called with the same label.
   * Multiple timers can run concurrently with different labels.
   *
   * @param {string} label - Unique identifier for this timer.
   * @returns {void}
   * @example
   * logger.time('apiCall');
   * const result = await fetchDataFromAPI();
   * logger.timeEnd('apiCall'); // Logs: "apiCall: 234.56ms"
   *
   * @example
   * // Nested timers for detailed performance analysis
   * logger.time('fullProcess');
   * logger.time('step1');
   * await processStep1();
   * logger.timeEnd('step1');
   * logger.time('step2');
   * await processStep2();
   * logger.timeEnd('step2');
   * logger.timeEnd('fullProcess');
   *
   * @see {@link Logger.timeEnd} - To stop the timer and log duration
   * @memberof Logger
   */ time(label) {
        this.timers.set(label, performance.now());
    }
    /**
   * Stops a timer and logs the elapsed time.
   *
   * Stops the timer identified by the label and logs the duration at DEBUG level.
   * If the timer doesn't exist, a warning is logged instead. The timer is
   * automatically removed after logging.
   *
   * @param {string} label - The identifier of the timer to stop.
   * @returns {void}
   * @example
   * logger.time('databaseQuery');
   * const users = await db.query('SELECT * FROM users');
   * logger.timeEnd('databaseQuery'); // Logs: "databaseQuery: 45.23ms"
   *
   * @example
   * // Handling non-existent timer
   * logger.timeEnd('nonExistentTimer'); // Logs warning: "Timer 'nonExistentTimer' does not exist"
   *
   * @see {@link Logger.time} - To start a timer
   * @memberof Logger
   */ timeEnd(label) {
        const start = this.timers.get(label);
        if (start === undefined) {
            this.warn(`Timer '${label}' does not exist`);
            return;
        }
        const duration = performance.now() - start;
        this.timers.delete(label);
        this.debug(`${label}: ${duration.toFixed(2)}ms`, {
            duration
        });
    }
    /**
   * Creates a new logger instance with additional persistent fields.
   *
   * The returned logger will automatically include the specified fields in
   * every log entry. This is useful for adding consistent metadata like
   * request IDs, user IDs, or session information. Fields are merged with
   * any fields provided directly to log methods.
   *
   * @param {Record<string, any>} fields - Key-value pairs to include in all logs
   *   from the returned logger instance.
   * @returns {ILogger} A new logger instance with the additional fields.
   * @example
   * // Add request ID to all logs for a request handler
   * app.use((req, res, next) => {
   *   req.logger = logger.withFields({ requestId: req.id });
   *   next();
   * });
   *
   * @example
   * // Chain with setContext for rich logging
   * const userLogger = logger
   *   .setContext('UserService')
   *   .withFields({ userId: user.id, sessionId: session.id });
   * userLogger.info('User action performed'); // Includes context and fields
   *
   * @see {@link Logger.setContext} - To add a context identifier
   * @memberof Logger
   */ withFields(fields) {
        const fieldLogger = new Logger({
            ...this.config,
            transports: this.transports
        });
        fieldLogger.context = this.context;
        fieldLogger.logs = this.logs;
        fieldLogger.fields = {
            ...this.fields,
            ...fields
        };
        return fieldLogger;
    }
    /**
   * Flushes all pending logs from all transports.
   *
   * This asynchronous method ensures that any buffered logs are written to their
   * destinations. It's crucial to call this before application shutdown to prevent
   * log loss. The method waits for all transports to complete their flush operations.
   *
   * @returns {Promise<void>} A promise that resolves when all transports have
   *   successfully flushed their buffers.
   * @throws {Error} If any transport fails to flush. The error from the first
   *   failing transport is thrown.
   * @example
   * // Graceful shutdown
   * process.on('SIGTERM', async () => {
   *   logger.info('Shutting down gracefully');
   *   await logger.flush();
   *   process.exit(0);
   * });
   *
   * @example
   * // Ensure logs are flushed after batch operation
   * await processBatchJob();
   * await logger.flush(); // Make sure all logs are persisted
   *
   * @async
   * @memberof Logger
   */ async flush() {
        await Promise.all(this.transports.map((t)=>t.flush()));
    }
    /**
   * Creates a new logger instance
   *
   * @param {Partial<LoggerConfig>} [config] - Configuration options
   *
   * @example
   * ```typescript
   * // Default logger
   * const logger = new Logger();
   *
   * // Production logger with custom config
   * const prodLogger = new Logger({
   *   minLevel: LogLevel.WARN,
   *   enableRemote: true,
   *   remoteEndpoint: 'https://logs.myapp.com',
   *   maxLogSize: 5000
   * });
   * ```
   */ constructor(config){
        _define_property(this, "config", void 0);
        _define_property(this, "context", void 0);
        _define_property(this, "logs", []);
        _define_property(this, "transports", []);
        _define_property(this, "timers", new Map());
        _define_property(this, "fields", {});
        this.config = {
            ...DEFAULT_CONFIG,
            ...config
        };
        // Use injected transports if provided, otherwise setup default transports
        if ((config === null || config === void 0 ? void 0 : config.transports) && config.transports.length > 0) {
            this.transports = config.transports;
        } else {
            this.setupTransports();
        }
    }
}
// Singleton instance
let loggerInstance = null;
function getLogger() {
    if (!loggerInstance) {
        loggerInstance = new Logger();
        // Add platform info to all logs
        const platform = (0, _platform.getPlatformDetection)();
        loggerInstance = loggerInstance.withFields({
            platform: {
                isWeb: platform.isWeb(),
                isMobile: platform.isMobile(),
                isAndroid: platform.isAndroid(),
                isIOS: platform.isIOS()
            }
        });
    }
    return loggerInstance;
}
function createLogger(config) {
    return new Logger(config);
}
function resetLogger() {
    loggerInstance = null;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgQ29yZSBMb2dnZXIgaW1wbGVtZW50YXRpb25cbiAqIEBtb2R1bGUgc2VydmljZXMvbG9nZ2luZy9Mb2dnZXJcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIHN0cnVjdHVyZWQsIG11bHRpLWxldmVsIGxvZ2dpbmcgd2l0aCBkaWZmZXJlbnQgdHJhbnNwb3J0cy5cbiAqIFN1cHBvcnRzIGNvbnNvbGUsIGZpbGUsIGFuZCByZW1vdGUgbG9nZ2luZyB3aXRoIGNvbmZpZ3VyYWJsZSBsb2cgbGV2ZWxzLFxuICogZmlsdGVyaW5nLCBhbmQgZm9ybWF0dGluZy4gRGVzaWduZWQgZm9yIGJvdGggZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24gdXNlLlxuICpcbiAqIEByZW1hcmtzXG4gKiBLZXkgZmVhdHVyZXM6XG4gKiAtIE11bHRpcGxlIGxvZyBsZXZlbHMgKERFQlVHLCBJTkZPLCBXQVJOLCBFUlJPUilcbiAqIC0gQ29udGV4dHVhbCBsb2dnaW5nIHdpdGggbWV0YWRhdGFcbiAqIC0gQ29uZmlndXJhYmxlIHRyYW5zcG9ydHMgKGNvbnNvbGUsIGZpbGUsIHJlbW90ZSlcbiAqIC0gQ2lyY3VsYXIgYnVmZmVyIGZvciBsb2cgaGlzdG9yeVxuICogLSBFcnJvciB0cmFja2luZyB3aXRoIHN0YWNrIHRyYWNlc1xuICogLSBQZXJmb3JtYW5jZSBtb25pdG9yaW5nXG4gKiAtIEZpbHRlcmVkIGxvZ2dpbmcgYnkgY29udGV4dCBvciBsZXZlbFxuICovXG5cbmltcG9ydCB7XG4gIElMb2dnZXIsXG4gIExvZ0xldmVsLFxuICBMb2dFbnRyeSxcbiAgTG9nZ2VyQ29uZmlnLFxuICBMb2dGaWx0ZXIsXG4gIElMb2dUcmFuc3BvcnQsXG4gIElMb2dGb3JtYXR0ZXIsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybURldGVjdGlvbiB9IGZyb20gXCIuLi9wbGF0Zm9ybVwiO1xuXG4vLyBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbmNvbnN0IERFRkFVTFRfQ09ORklHOiBMb2dnZXJDb25maWcgPSB7XG4gIG1pbkxldmVsOlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IExvZ0xldmVsLklORk8gOiBMb2dMZXZlbC5ERUJVRyxcbiAgZW5hYmxlQ29uc29sZTogdHJ1ZSxcbiAgZW5hYmxlUmVtb3RlOiBmYWxzZSxcbiAgZW5hYmxlRmlsZUxvZ2dpbmc6IGZhbHNlLFxuICBtYXhMb2dTaXplOiAxMDAwLFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IGxvZyBmb3JtYXR0ZXIgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAY2xhc3MgRGVmYXVsdExvZ0Zvcm1hdHRlclxuICogQGltcGxlbWVudHMge0lMb2dGb3JtYXR0ZXJ9XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBGb3JtYXRzIGxvZyBlbnRyaWVzIGludG8gaHVtYW4tcmVhZGFibGUgc3RyaW5ncyB3aXRoIHRpbWVzdGFtcCxcbiAqIGxldmVsLCBjb250ZXh0LCBtZXNzYWdlLCBhbmQgb3B0aW9uYWwgZGF0YS9lcnJvciBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgRGVmYXVsdExvZ0Zvcm1hdHRlciBpbXBsZW1lbnRzIElMb2dGb3JtYXR0ZXIge1xuICAvKipcbiAgICogRm9ybWF0cyBhIGxvZyBlbnRyeSBpbnRvIGEgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TG9nRW50cnl9IGVudHJ5IC0gVGhlIGxvZyBlbnRyeSB0byBmb3JtYXRcbiAgICogQHJldHVybnMge3N0cmluZ30gRm9ybWF0dGVkIGxvZyBtZXNzYWdlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZm9ybWF0dGVyID0gbmV3IERlZmF1bHRMb2dGb3JtYXR0ZXIoKTtcbiAgICogY29uc3QgZm9ybWF0dGVkID0gZm9ybWF0dGVyLmZvcm1hdCh7XG4gICAqICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgKiAgIGxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICAgKiAgIG1lc3NhZ2U6IFwiVXNlciBsb2dnZWQgaW5cIixcbiAgICogICBjb250ZXh0OiBcIkF1dGhcIixcbiAgICogICBkYXRhOiB7IHVzZXJJZDogMTIzIH1cbiAgICogfSk7XG4gICAqIC8vIFwiMjAyNC0wMS0yMFQxMDozMDowMC4wMDBaIElORk8gW0F1dGhdIFVzZXIgbG9nZ2VkIGluIHsgdXNlcklkOiAxMjMgfVwiXG4gICAqIGBgYFxuICAgKi9cbiAgZm9ybWF0KGVudHJ5OiBMb2dFbnRyeSk6IHN0cmluZyB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gZW50cnkudGltZXN0YW1wLnRvSVNPU3RyaW5nKCk7XG4gICAgY29uc3QgbGV2ZWwgPSBMb2dMZXZlbFtlbnRyeS5sZXZlbF07XG4gICAgY29uc3QgY29udGV4dCA9IGVudHJ5LmNvbnRleHQgPyBgWyR7ZW50cnkuY29udGV4dH1dYCA6IFwiXCI7XG5cbiAgICBsZXQgbWVzc2FnZSA9IGAke3RpbWVzdGFtcH0gJHtsZXZlbH0gJHtjb250ZXh0fSAke2VudHJ5Lm1lc3NhZ2V9YDtcblxuICAgIGlmIChlbnRyeS5kYXRhKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlICs9IGAgJHtKU09OLnN0cmluZ2lmeShlbnRyeS5kYXRhLCBudWxsLCAyKX1gO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBGYWxsYmFjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBvciBvdGhlciBzdHJpbmdpZnkgZXJyb3JzXG4gICAgICAgIG1lc3NhZ2UgKz0gYCAke1N0cmluZyhlbnRyeS5kYXRhKX1gO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeS5lcnJvcikge1xuICAgICAgbWVzc2FnZSArPSBgIEVycm9yOiAke2VudHJ5LmVycm9yLm1lc3NhZ2V9YDtcbiAgICAgIGlmIChlbnRyeS5zdGFjaykge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5TdGFjazogJHtlbnRyeS5zdGFja31gO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG59XG5cbi8qKlxuICogQ29uc29sZSB0cmFuc3BvcnQgaW1wbGVtZW50YXRpb24gZm9yIGxvZ2dpbmdcbiAqXG4gKiBAY2xhc3MgQ29uc29sZVRyYW5zcG9ydFxuICogQGltcGxlbWVudHMge0lMb2dUcmFuc3BvcnR9XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBPdXRwdXRzIGxvZyBlbnRyaWVzIHRvIHRoZSBicm93c2VyIGNvbnNvbGUgd2l0aCBhcHByb3ByaWF0ZSBsb2cgbGV2ZWxzLlxuICogVXNlcyBuYXRpdmUgY29uc29sZSBtZXRob2RzIChkZWJ1ZywgaW5mbywgd2FybiwgZXJyb3IpIGJhc2VkIG9uIGxvZyBsZXZlbFxuICogZm9yIGJldHRlciBkZXZlbG9wZXIgZXhwZXJpZW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdHJhbnNwb3J0ID0gbmV3IENvbnNvbGVUcmFuc3BvcnQoKTtcbiAqIHRyYW5zcG9ydC5sb2coe1xuICogICBsZXZlbDogTG9nTGV2ZWwuSU5GTyxcbiAqICAgbWVzc2FnZTogXCJBcHBsaWNhdGlvbiBzdGFydGVkXCIsXG4gKiAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAqICAgY29udGV4dDogXCJNYWluXCJcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIENvbnNvbGVUcmFuc3BvcnQgaW1wbGVtZW50cyBJTG9nVHJhbnNwb3J0IHtcbiAgcHJpdmF0ZSBmb3JtYXR0ZXI6IElMb2dGb3JtYXR0ZXI7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29uc29sZSB0cmFuc3BvcnRcbiAgICpcbiAgICogQHBhcmFtIHtJTG9nRm9ybWF0dGVyfSBbZm9ybWF0dGVyXSAtIE9wdGlvbmFsIGN1c3RvbSBmb3JtYXR0ZXIsIGRlZmF1bHRzIHRvIERlZmF1bHRMb2dGb3JtYXR0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGZvcm1hdHRlcj86IElMb2dGb3JtYXR0ZXIpIHtcbiAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlciB8fCBuZXcgRGVmYXVsdExvZ0Zvcm1hdHRlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYW4gZW50cnkgdG8gdGhlIGNvbnNvbGVcbiAgICpcbiAgICogQHBhcmFtIHtMb2dFbnRyeX0gZW50cnkgLSBUaGUgbG9nIGVudHJ5IHRvIG91dHB1dFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBNYXBzIGxvZyBsZXZlbHMgdG8gYXBwcm9wcmlhdGUgY29uc29sZSBtZXRob2RzOlxuICAgKiAtIERFQlVHIOKGkiBjb25zb2xlLmRlYnVnKClcbiAgICogLSBJTkZPIOKGkiBjb25zb2xlLmluZm8oKVxuICAgKiAtIFdBUk4g4oaSIGNvbnNvbGUud2FybigpXG4gICAqIC0gRVJST1IvRkFUQUwg4oaSIGNvbnNvbGUuZXJyb3IoKVxuICAgKlxuICAgKiBJZiB0aGUgZW50cnkgY29udGFpbnMgZGF0YSwgaXQncyBsb2dnZWQgYXMgYSBzZWNvbmQgcGFyYW1ldGVyXG4gICAqIGZvciBiZXR0ZXIgY29uc29sZSBmb3JtYXR0aW5nLlxuICAgKi9cbiAgbG9nKGVudHJ5OiBMb2dFbnRyeSk6IHZvaWQge1xuICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdChlbnRyeSk7XG5cbiAgICAvLyBJZiB0aGVyZSdzIGFkZGl0aW9uYWwgZGF0YSwgbG9nIGl0IHNlcGFyYXRlbHkgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgaWYgKGVudHJ5LmRhdGEpIHtcbiAgICAgIHN3aXRjaCAoZW50cnkubGV2ZWwpIHtcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5ERUJVRzpcbiAgICAgICAgICBjb25zb2xlLmRlYnVnKGZvcm1hdHRlZCwgZW50cnkuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuSU5GTzpcbiAgICAgICAgICBjb25zb2xlLmluZm8oZm9ybWF0dGVkLCBlbnRyeS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5XQVJOOlxuICAgICAgICAgIGNvbnNvbGUud2Fybihmb3JtYXR0ZWQsIGVudHJ5LmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExvZ0xldmVsLkVSUk9SOlxuICAgICAgICBjYXNlIExvZ0xldmVsLkZBVEFMOlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZm9ybWF0dGVkLCBlbnRyeS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChlbnRyeS5sZXZlbCkge1xuICAgICAgICBjYXNlIExvZ0xldmVsLkRFQlVHOlxuICAgICAgICAgIGNvbnNvbGUuZGVidWcoZm9ybWF0dGVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMb2dMZXZlbC5JTkZPOlxuICAgICAgICAgIGNvbnNvbGUuaW5mbyhmb3JtYXR0ZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExvZ0xldmVsLldBUk46XG4gICAgICAgICAgY29uc29sZS53YXJuKGZvcm1hdHRlZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuRVJST1I6XG4gICAgICAgIGNhc2UgTG9nTGV2ZWwuRkFUQUw6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXR0ZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaGVzIHBlbmRpbmcgbG9ncyAobm8tb3AgZm9yIGNvbnNvbGUgdHJhbnNwb3J0KVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgaW1tZWRpYXRlbHkgYXMgY29uc29sZSBoYXMgbm8gYnVmZmVyXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENvbnNvbGUgdHJhbnNwb3J0IHdyaXRlcyBpbW1lZGlhdGVseSwgc28gbm8gZmx1c2hpbmcgaXMgbmVlZGVkLlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gc2F0aXNmeSB0aGUgSUxvZ1RyYW5zcG9ydCBpbnRlcmZhY2UuXG4gICAqL1xuICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBDb25zb2xlIGRvZXNuJ3QgbmVlZCBmbHVzaGluZ1xuICB9XG59XG5cbi8qKlxuICogUmVtb3RlIHRyYW5zcG9ydCBpbXBsZW1lbnRhdGlvbiBmb3IgY2VudHJhbGl6ZWQgbG9nZ2luZ1xuICpcbiAqIEBjbGFzcyBSZW1vdGVUcmFuc3BvcnRcbiAqIEBpbXBsZW1lbnRzIHtJTG9nVHJhbnNwb3J0fVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQnVmZmVycyBsb2cgZW50cmllcyBhbmQgc2VuZHMgdGhlbSB0byBhIHJlbW90ZSBlbmRwb2ludCBpbiBiYXRjaGVzLlxuICogSW5jbHVkZXMgcmV0cnkgbG9naWMgYW5kIG1haW50YWlucyBjaHJvbm9sb2dpY2FsIG9yZGVyIG9mIGxvZ3MuXG4gKiBVc2VmdWwgZm9yIHByb2R1Y3Rpb24gbW9uaXRvcmluZyBhbmQgZGVidWdnaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB0cmFuc3BvcnQgPSBuZXcgUmVtb3RlVHJhbnNwb3J0KCdodHRwczovL2xvZ3MubXlhcHAuY29tL2luZ2VzdCcpO1xuICogdHJhbnNwb3J0LmxvZyh7XG4gKiAgIGxldmVsOiBMb2dMZXZlbC5FUlJPUixcbiAqICAgbWVzc2FnZTogXCJEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZFwiLFxuICogICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gKiAgIGVycm9yOiBuZXcgRXJyb3IoXCJDb25uZWN0aW9uIHRpbWVvdXRcIilcbiAqIH0pO1xuICogLy8gTG9ncyBhcmUgYnVmZmVyZWQgYW5kIHNlbnQgaW4gYmF0Y2hlc1xuICogYXdhaXQgdHJhbnNwb3J0LmZsdXNoKCk7IC8vIEZvcmNlIHNlbmQgcGVuZGluZyBsb2dzXG4gKiBgYGBcbiAqL1xuY2xhc3MgUmVtb3RlVHJhbnNwb3J0IGltcGxlbWVudHMgSUxvZ1RyYW5zcG9ydCB7XG4gIHByaXZhdGUgYnVmZmVyOiBMb2dFbnRyeVtdID0gW107XG4gIHByaXZhdGUgYmF0Y2hTaXplID0gNTA7XG4gIHByaXZhdGUgZW5kcG9pbnQ6IHN0cmluZztcbiAgcHJpdmF0ZSBpc0ZsdXNoaW5nID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcmVtb3RlIHRyYW5zcG9ydFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnQgLSBUaGUgVVJMIHRvIHNlbmQgbG9ncyB0b1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBSZW1vdGVUcmFuc3BvcnQoJ2h0dHBzOi8vbG9ncy5teWFwcC5jb20vaW5nZXN0Jyk7XG4gICAqIGBgYFxuICAgKi9cbiAgY29uc3RydWN0b3IoZW5kcG9pbnQ6IHN0cmluZykge1xuICAgIHRoaXMuZW5kcG9pbnQgPSBlbmRwb2ludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbG9nIGVudHJ5IHRvIHRoZSBidWZmZXIgYW5kIHRyaWdnZXJzIGZsdXNoIGlmIG5lZWRlZFxuICAgKlxuICAgKiBAcGFyYW0ge0xvZ0VudHJ5fSBlbnRyeSAtIFRoZSBsb2cgZW50cnkgdG8gYnVmZmVyXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIExvZ3MgYXJlIGJ1ZmZlcmVkIHVudGlsIGJhdGNoIHNpemUgaXMgcmVhY2hlZCwgdGhlbiBhdXRvbWF0aWNhbGx5XG4gICAqIHNlbnQgdG8gdGhlIHJlbW90ZSBlbmRwb2ludC4gVXNlIGZsdXNoKCkgdG8gc2VuZCBpbW1lZGlhdGVseS5cbiAgICovXG4gIGxvZyhlbnRyeTogTG9nRW50cnkpOiB2b2lkIHtcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGVudHJ5KTtcblxuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPj0gdGhpcy5iYXRjaFNpemUpIHtcbiAgICAgIHRoaXMuZmx1c2goKS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyBidWZmZXJlZCBsb2dzIHRvIHRoZSByZW1vdGUgZW5kcG9pbnRcbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHdoZW4gZmx1c2ggY29tcGxldGVzIG9yIGZhaWxzXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIC0gUHJldmVudHMgY29uY3VycmVudCBmbHVzaGVzXG4gICAqIC0gUHJlc2VydmVzIGxvZyBvcmRlciBvbiBmYWlsdXJlIGJ5IHJlLWJ1ZmZlcmluZ1xuICAgKiAtIFVzZXMgY29uc29sZS5lcnJvciBhcyBmYWxsYmFjayBmb3IgbG9nZ2luZyBmYWlsdXJlc1xuICAgKiAtIEF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW4gYnVmZmVyIHJlYWNoZXMgYmF0Y2ggc2l6ZVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIC8vIEZvcmNlIHNlbmQgYWxsIHBlbmRpbmcgbG9nc1xuICAgKiBhd2FpdCB0cmFuc3BvcnQuZmx1c2goKTtcbiAgICpcbiAgICogLy8gRW5zdXJlIGxvZ3MgYXJlIHNlbnQgYmVmb3JlIHNodXRkb3duXG4gICAqIHByb2Nlc3Mub24oJ1NJR1RFUk0nLCBhc3luYyAoKSA9PiB7XG4gICAqICAgYXdhaXQgdHJhbnNwb3J0LmZsdXNoKCk7XG4gICAqICAgcHJvY2Vzcy5leGl0KDApO1xuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBQcmV2ZW50IGNvbmN1cnJlbnQgZmx1c2hlcyBhbmQgZXhpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAodGhpcy5pc0ZsdXNoaW5nIHx8IHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCB8fCAhdGhpcy5lbmRwb2ludCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNGbHVzaGluZyA9IHRydWU7XG5cbiAgICAvLyBBdG9taWNhbGx5IGdyYWIgdGhlIGN1cnJlbnQgbG9ncyBhbmQgY2xlYXIgdGhlIGJ1ZmZlciBmb3IgbmV3IGVudHJpZXNcbiAgICBjb25zdCBlbnRyaWVzVG9GbHVzaCA9IFsuLi50aGlzLmJ1ZmZlcl07XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuZW5kcG9pbnQsIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGxvZ3M6IGVudHJpZXNUb0ZsdXNoIH0pLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgLy8gVGhlIHJlcXVlc3Qgd2FzIG1hZGUsIGJ1dCB0aGUgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGFuIGVycm9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoIHN0YXR1cyAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRkFMTEJBQ0s6IFVzaW5nIGNvbnNvbGUuZXJyb3IgYXMgbGFzdCByZXNvcnQgd2hlbiBsb2dnaW5nIGluZnJhc3RydWN0dXJlIGl0c2VsZiBmYWlsc1xuICAgICAgLy8gVGhpcyBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcyBhbmQgZW5zdXJlcyBjcml0aWNhbCBsb2dnaW5nIGZhaWx1cmVzIGFyZSBzdGlsbCB2aXNpYmxlXG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNlbmQgbG9ncyB0byByZW1vdGU6XCIsIGVycm9yKTtcblxuICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgZmFpbHMsIHB1dCB0aGUgbG9ncyBiYWNrIGF0IHRoZSBmcm9udCBvZiB0aGUgYnVmZmVyIHRvIGJlIHJldHJpZWRcbiAgICAgIC8vIFRoaXMgcHJlc2VydmVzIGNocm9ub2xvZ2ljYWwgb3JkZXJcbiAgICAgIHRoaXMuYnVmZmVyLnVuc2hpZnQoLi4uZW50cmllc1RvRmx1c2gpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIHJlc2V0IHRoZSBmbHVzaGluZyBzdGF0ZVxuICAgICAgdGhpcy5pc0ZsdXNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFpbiBMb2dnZXIgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBAY2xhc3MgTG9nZ2VyXG4gKiBAaW1wbGVtZW50cyB7SUxvZ2dlcn1cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvcmUgbG9nZ2luZyBzZXJ2aWNlIHByb3ZpZGluZyBzdHJ1Y3R1cmVkLCBtdWx0aS1sZXZlbCBsb2dnaW5nIHdpdGhcbiAqIGNvbmZpZ3VyYWJsZSB0cmFuc3BvcnRzLCBjb250ZXh0cywgYW5kIGZpbHRlcmluZy4gU3VwcG9ydHMgZGV2ZWxvcG1lbnRcbiAqIGFuZCBwcm9kdWN0aW9uIHVzZSBjYXNlcyB3aXRoIGZlYXR1cmVzIGxpa2UgdGltaW5nLCBmaWVsZCBlbnJpY2htZW50LFxuICogYW5kIGxvZyBidWZmZXJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIENyZWF0ZSBhIGxvZ2dlciB3aXRoIGN1c3RvbSBjb25maWd1cmF0aW9uXG4gKiBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHtcbiAqICAgbWluTGV2ZWw6IExvZ0xldmVsLklORk8sXG4gKiAgIGVuYWJsZVJlbW90ZTogdHJ1ZSxcbiAqICAgcmVtb3RlRW5kcG9pbnQ6ICdodHRwczovL2xvZ3MubXlhcHAuY29tL2luZ2VzdCdcbiAqIH0pO1xuICpcbiAqIC8vIENyZWF0ZSBhIGNvbnRleHQtc3BlY2lmaWMgbG9nZ2VyXG4gKiBjb25zdCBhdXRoTG9nZ2VyID0gbG9nZ2VyLnNldENvbnRleHQoJ0F1dGhTZXJ2aWNlJyk7XG4gKlxuICogLy8gTG9nIHdpdGggc3RydWN0dXJlZCBkYXRhXG4gKiBhdXRoTG9nZ2VyLmluZm8oJ1VzZXIgYXV0aGVudGljYXRlZCcsIHtcbiAqICAgdXNlcklkOiAxMjMsXG4gKiAgIG1ldGhvZDogJ09BdXRoMidcbiAqIH0pO1xuICpcbiAqIC8vIE1lYXN1cmUgcGVyZm9ybWFuY2VcbiAqIGxvZ2dlci50aW1lKCdhcGktY2FsbCcpO1xuICogYXdhaXQgZmV0Y2hEYXRhKCk7XG4gKiBsb2dnZXIudGltZUVuZCgnYXBpLWNhbGwnKTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgTG9nZ2VyIGltcGxlbWVudHMgSUxvZ2dlciB7XG4gIHByaXZhdGUgY29uZmlnOiBMb2dnZXJDb25maWc7XG4gIHByaXZhdGUgY29udGV4dD86IHN0cmluZztcbiAgcHJpdmF0ZSBsb2dzOiBMb2dFbnRyeVtdID0gW107XG4gIHByaXZhdGUgdHJhbnNwb3J0czogSUxvZ1RyYW5zcG9ydFtdID0gW107XG4gIHByaXZhdGUgdGltZXJzOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBwcml2YXRlIGZpZWxkczogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGxvZ2dlciBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8TG9nZ2VyQ29uZmlnPn0gW2NvbmZpZ10gLSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBEZWZhdWx0IGxvZ2dlclxuICAgKiBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4gICAqXG4gICAqIC8vIFByb2R1Y3Rpb24gbG9nZ2VyIHdpdGggY3VzdG9tIGNvbmZpZ1xuICAgKiBjb25zdCBwcm9kTG9nZ2VyID0gbmV3IExvZ2dlcih7XG4gICAqICAgbWluTGV2ZWw6IExvZ0xldmVsLldBUk4sXG4gICAqICAgZW5hYmxlUmVtb3RlOiB0cnVlLFxuICAgKiAgIHJlbW90ZUVuZHBvaW50OiAnaHR0cHM6Ly9sb2dzLm15YXBwLmNvbScsXG4gICAqICAgbWF4TG9nU2l6ZTogNTAwMFxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25maWc/OiBQYXJ0aWFsPExvZ2dlckNvbmZpZz4pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuXG4gICAgLy8gVXNlIGluamVjdGVkIHRyYW5zcG9ydHMgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBzZXR1cCBkZWZhdWx0IHRyYW5zcG9ydHNcbiAgICBpZiAoY29uZmlnPy50cmFuc3BvcnRzICYmIGNvbmZpZy50cmFuc3BvcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudHJhbnNwb3J0cyA9IGNvbmZpZy50cmFuc3BvcnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldHVwVHJhbnNwb3J0cygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGxvZ2dpbmcgdHJhbnNwb3J0cyBiYXNlZCBvbiBjb25maWd1cmF0aW9uXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZW1hcmtzXG4gICAqIENhbGxlZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24gYW5kIHdoZW4gY29uZmlndXJhdGlvbiBjaGFuZ2VzLlxuICAgKiBDcmVhdGVzIGNvbnNvbGUgYW5kL29yIHJlbW90ZSB0cmFuc3BvcnRzIGFzIGNvbmZpZ3VyZWQuXG4gICAqL1xuICBwcml2YXRlIHNldHVwVHJhbnNwb3J0cygpOiB2b2lkIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMgPSBbXTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDb25zb2xlKSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHMucHVzaChuZXcgQ29uc29sZVRyYW5zcG9ydCgpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlUmVtb3RlICYmIHRoaXMuY29uZmlnLnJlbW90ZUVuZHBvaW50KSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHMucHVzaChuZXcgUmVtb3RlVHJhbnNwb3J0KHRoaXMuY29uZmlnLnJlbW90ZUVuZHBvaW50KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgYSBsb2cgZW50cnkgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0xvZ0xldmVsfSBsZXZlbCAtIFRoZSBsb2cgbGV2ZWwgdG8gY2hlY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb250ZXh0XSAtIE9wdGlvbmFsIGNvbnRleHQgdG8gY2hlY2sgYWdhaW5zdCBmaWx0ZXJzXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBsb2cgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBDaGVja3MgYWdhaW5zdCBtaW5pbXVtIGxldmVsLCBjb250ZXh0IHdoaXRlbGlzdCwgYW5kIGJsYWNrbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBzaG91bGRMb2cobGV2ZWw6IExvZ0xldmVsLCBjb250ZXh0Pzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKGxldmVsIDwgdGhpcy5jb25maWcubWluTGV2ZWwpIHJldHVybiBmYWxzZTtcblxuICAgIGNvbnN0IGxvZ0NvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcblxuICAgIGlmIChsb2dDb250ZXh0ICYmIHRoaXMuY29uZmlnLmNvbnRleHRXaGl0ZWxpc3Q/Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmNvbnRleHRXaGl0ZWxpc3QuaW5jbHVkZXMobG9nQ29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGxvZ0NvbnRleHQgJiYgdGhpcy5jb25maWcuY29udGV4dEJsYWNrbGlzdD8ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuY29uZmlnLmNvbnRleHRCbGFja2xpc3QuaW5jbHVkZXMobG9nQ29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCB1c2VkIGJ5IGFsbCBwdWJsaWMgbG9nIG1ldGhvZHNcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtMb2dMZXZlbH0gbGV2ZWwgLSBUaGUgc2V2ZXJpdHkgbGV2ZWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbG9nIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtFcnJvcnxhbnl9IFtlcnJvcl0gLSBPcHRpb25hbCBlcnJvciBvYmplY3RcbiAgICogQHBhcmFtIHthbnl9IFtkYXRhXSAtIE9wdGlvbmFsIHN0cnVjdHVyZWQgZGF0YVxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiAtIENoZWNrcyBpZiBsb2cgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgKiAtIENyZWF0ZXMgbG9nIGVudHJ5IHdpdGggbWV0YWRhdGFcbiAgICogLSBBZGRzIHRvIG1lbW9yeSBidWZmZXJcbiAgICogLSBTZW5kcyB0byBhbGwgY29uZmlndXJlZCB0cmFuc3BvcnRzXG4gICAqL1xuICBwcml2YXRlIGxvZyhcbiAgICBsZXZlbDogTG9nTGV2ZWwsXG4gICAgbWVzc2FnZTogc3RyaW5nLFxuICAgIGVycm9yPzogRXJyb3IgfCBhbnksXG4gICAgZGF0YT86IGFueSxcbiAgKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnNob3VsZExvZyhsZXZlbCwgdGhpcy5jb250ZXh0KSkgcmV0dXJuO1xuXG4gICAgY29uc3QgZW50cnk6IExvZ0VudHJ5ID0ge1xuICAgICAgbGV2ZWwsXG4gICAgICBtZXNzYWdlLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgZGF0YTogeyAuLi50aGlzLmZpZWxkcywgLi4uZGF0YSB9LFxuICAgIH07XG5cbiAgICBpZiAoZXJyb3IgIT09IHVuZGVmaW5lZCAmJiBlcnJvciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgZW50cnkuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgZW50cnkuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5LmVycm9yID0gbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0byBtZW1vcnkgbG9nXG4gICAgdGhpcy5sb2dzLnB1c2goZW50cnkpO1xuICAgIGlmICh0aGlzLmxvZ3MubGVuZ3RoID4gdGhpcy5jb25maWcubWF4TG9nU2l6ZSkge1xuICAgICAgdGhpcy5sb2dzLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0byB0cmFuc3BvcnRzXG4gICAgdGhpcy50cmFuc3BvcnRzLmZvckVhY2goKHRyYW5zcG9ydCkgPT4gdHJhbnNwb3J0LmxvZyhlbnRyeSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBERUJVRyBsZXZlbC5cbiAgICpcbiAgICogRGVidWcgbWVzc2FnZXMgYXJlIGludGVuZGVkIGZvciBkZXRhaWxlZCBpbmZvcm1hdGlvbiB0aGF0IGlzIHR5cGljYWxseSBvbmx5XG4gICAqIG9mIGludGVyZXN0IHdoZW4gZGlhZ25vc2luZyBwcm9ibGVtcyBvciBkdXJpbmcgZGV2ZWxvcG1lbnQuIFRoZXkgd2lsbCBiZVxuICAgKiBmaWx0ZXJlZCBvdXQgaW4gcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgdW5sZXNzIGV4cGxpY2l0bHkgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgcHJpbWFyeSBsb2cgbWVzc2FnZSB0byByZWNvcmQuXG4gICAqIEBwYXJhbSB7YW55fSBbZGF0YV0gLSBPcHRpb25hbCBzdHJ1Y3R1cmVkIGRhdGEgdG8gaW5jbHVkZSB3aXRoIHRoZSBsb2cgZW50cnkuXG4gICAqICAgVGhpcyBkYXRhIHdpbGwgYmUgc2VyaWFsaXplZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGxvZyBmb3IgYWRkaXRpb25hbCBjb250ZXh0LlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2ltcGxlIGRlYnVnIG1lc3NhZ2VcbiAgICogbG9nZ2VyLmRlYnVnKCdBcHBsaWNhdGlvbiBpbml0aWFsaXphdGlvbiBjb21wbGV0ZScpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBEZWJ1ZyBtZXNzYWdlIHdpdGggc3RydWN0dXJlZCBkYXRhXG4gICAqIGxvZ2dlci5kZWJ1ZygnUHJvY2Vzc2luZyB1c2VyIHJlcXVlc3QnLCB7IHVzZXJJZDogMTIzLCByZXF1ZXN0SWQ6ICdhYmMteHl6JyB9KTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgTG9nZ2VyLmluZm99IC0gRm9yIGdlbmVyYWwgaW5mb3JtYXRpb25hbCBtZXNzYWdlc1xuICAgKiBAc2VlIHtAbGluayBMb2dnZXIud2l0aEZpZWxkc30gLSBUbyBhZGQgcGVyc2lzdGVudCBmaWVsZHMgdG8gYWxsIGxvZ3NcbiAgICogQG1lbWJlcm9mIExvZ2dlclxuICAgKi9cbiAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5sb2coTG9nTGV2ZWwuREVCVUcsIG1lc3NhZ2UsIHVuZGVmaW5lZCwgZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgYXQgdGhlIElORk8gbGV2ZWwuXG4gICAqXG4gICAqIEluZm8gbWVzc2FnZXMgYXJlIGZvciBnZW5lcmFsIGluZm9ybWF0aW9uYWwgZXZlbnRzIHRoYXQgaGlnaGxpZ2h0IHRoZVxuICAgKiBwcm9ncmVzcyBvZiB0aGUgYXBwbGljYXRpb24gYXQgYSBjb2Fyc2UtZ3JhaW5lZCBsZXZlbC4gVGhlc2UgYXJlIHR5cGljYWxseVxuICAgKiBzaG93biBpbiBwcm9kdWN0aW9uIGVudmlyb25tZW50cy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgcHJpbWFyeSBsb2cgbWVzc2FnZSB0byByZWNvcmQuXG4gICAqIEBwYXJhbSB7YW55fSBbZGF0YV0gLSBPcHRpb25hbCBzdHJ1Y3R1cmVkIGRhdGEgdG8gaW5jbHVkZSB3aXRoIHRoZSBsb2cgZW50cnkuXG4gICAqICAgVGhpcyBkYXRhIHdpbGwgYmUgc2VyaWFsaXplZCBhbmQgYXR0YWNoZWQgdG8gdGhlIGxvZyBmb3IgYWRkaXRpb25hbCBjb250ZXh0LlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gU2ltcGxlIGluZm8gbWVzc2FnZVxuICAgKiBsb2dnZXIuaW5mbygnU2VydmVyIHN0YXJ0ZWQgb24gcG9ydCAzMDAwJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEluZm8gbWVzc2FnZSB3aXRoIHN0cnVjdHVyZWQgZGF0YVxuICAgKiBsb2dnZXIuaW5mbygnVXNlciBsb2dnZWQgaW4nLCB7IHVzZXJJZDogNDU2LCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5kZWJ1Z30gLSBGb3IgZGV0YWlsZWQgZGVidWdnaW5nIGluZm9ybWF0aW9uXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci53YXJufSAtIEZvciB3YXJuaW5nIG1lc3NhZ2VzXG4gICAqIEBtZW1iZXJvZiBMb2dnZXJcbiAgICovXG4gIGluZm8obWVzc2FnZTogc3RyaW5nLCBkYXRhPzogYW55KTogdm9pZCB7XG4gICAgdGhpcy5sb2coTG9nTGV2ZWwuSU5GTywgbWVzc2FnZSwgdW5kZWZpbmVkLCBkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgV0FSTiBsZXZlbC5cbiAgICpcbiAgICogV2FybmluZyBtZXNzYWdlcyBpbmRpY2F0ZSBwb3RlbnRpYWxseSBoYXJtZnVsIHNpdHVhdGlvbnMgb3IgZGVwcmVjYXRlZCB1c2FnZVxuICAgKiB0aGF0IHNob3VsZCBiZSBhZGRyZXNzZWQgYnV0IGRvbid0IHByZXZlbnQgdGhlIGFwcGxpY2F0aW9uIGZyb20gZnVuY3Rpb25pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHByaW1hcnkgbG9nIG1lc3NhZ2UgdG8gcmVjb3JkLlxuICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIC0gT3B0aW9uYWwgc3RydWN0dXJlZCBkYXRhIHRvIGluY2x1ZGUgd2l0aCB0aGUgbG9nIGVudHJ5LlxuICAgKiAgIFRoaXMgZGF0YSB3aWxsIGJlIHNlcmlhbGl6ZWQgYW5kIGF0dGFjaGVkIHRvIHRoZSBsb2cgZm9yIGFkZGl0aW9uYWwgY29udGV4dC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNpbXBsZSB3YXJuaW5nXG4gICAqIGxvZ2dlci53YXJuKCdBUEkgcmF0ZSBsaW1pdCBhcHByb2FjaGluZycpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBXYXJuaW5nIHdpdGggY29udGV4dFxuICAgKiBsb2dnZXIud2FybignRGVwcmVjYXRlZCBtZXRob2QgY2FsbGVkJywgeyBtZXRob2Q6ICdvbGRGdW5jdGlvbicsIHJlcGxhY2VtZW50OiAnbmV3RnVuY3Rpb24nIH0pO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayBMb2dnZXIuZXJyb3J9IC0gRm9yIGVycm9yIGNvbmRpdGlvbnNcbiAgICogQHNlZSB7QGxpbmsgTG9nZ2VyLmluZm99IC0gRm9yIGdlbmVyYWwgaW5mb3JtYXRpb25cbiAgICogQG1lbWJlcm9mIExvZ2dlclxuICAgKi9cbiAgd2FybihtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmxvZyhMb2dMZXZlbC5XQVJOLCBtZXNzYWdlLCB1bmRlZmluZWQsIGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBFUlJPUiBsZXZlbC5cbiAgICpcbiAgICogRXJyb3IgbWVzc2FnZXMgaW5kaWNhdGUgZXJyb3IgY29uZGl0aW9ucyB0aGF0IG1pZ2h0IHN0aWxsIGFsbG93IHRoZSBhcHBsaWNhdGlvblxuICAgKiB0byBjb250aW51ZSBydW5uaW5nLiBTdGFjayB0cmFjZXMgYXJlIGF1dG9tYXRpY2FsbHkgY2FwdHVyZWQgd2hlbiBhbiBFcnJvclxuICAgKiBvYmplY3QgaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHByaW1hcnkgbG9nIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7RXJyb3J8YW55fSBbZXJyb3JdIC0gT3B0aW9uYWwgZXJyb3Igb2JqZWN0IG9yIGFueSB2YWx1ZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuXG4gICAqICAgSWYgYW4gRXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdHMgc3RhY2sgdHJhY2Ugd2lsbCBiZSBjYXB0dXJlZC5cbiAgICogQHBhcmFtIHthbnl9IFtkYXRhXSAtIE9wdGlvbmFsIGFkZGl0aW9uYWwgY29udGV4dCBkYXRhIGFib3V0IHRoZSBlcnJvci5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIFNpbXBsZSBlcnJvciBtZXNzYWdlXG4gICAqIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgdG8gZGF0YWJhc2UnKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRXJyb3Igd2l0aCBleGNlcHRpb24gb2JqZWN0XG4gICAqIHRyeSB7XG4gICAqICAgYXdhaXQgY29ubmVjdFRvRGF0YWJhc2UoKTtcbiAgICogfSBjYXRjaCAoZXJyKSB7XG4gICAqICAgbG9nZ2VyLmVycm9yKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcsIGVyciwgeyByZXRyeUNvdW50OiAzIH0pO1xuICAgKiB9XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5mYXRhbH0gLSBGb3IgdW5yZWNvdmVyYWJsZSBlcnJvcnNcbiAgICogQHNlZSB7QGxpbmsgTG9nZ2VyLndhcm59IC0gRm9yIHdhcm5pbmcgY29uZGl0aW9uc1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGVycm9yPzogRXJyb3IgfCBhbnksIGRhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmxvZyhMb2dMZXZlbC5FUlJPUiwgbWVzc2FnZSwgZXJyb3IsIGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBGQVRBTCBsZXZlbC5cbiAgICpcbiAgICogRmF0YWwgbWVzc2FnZXMgaW5kaWNhdGUgc2V2ZXJlIGVycm9yIGNvbmRpdGlvbnMgdGhhdCB3aWxsIGxpa2VseSBjYXVzZSB0aGVcbiAgICogYXBwbGljYXRpb24gdG8gYWJvcnQuIFRoZXNlIHNob3VsZCBiZSByZXNlcnZlZCBmb3IgdW5yZWNvdmVyYWJsZSBlcnJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHByaW1hcnkgbG9nIG1lc3NhZ2UgZGVzY3JpYmluZyB0aGUgZmF0YWwgZXJyb3IuXG4gICAqIEBwYXJhbSB7RXJyb3J8YW55fSBbZXJyb3JdIC0gT3B0aW9uYWwgZXJyb3Igb2JqZWN0IG9yIGFueSB2YWx1ZSB0aGF0IGNhdXNlZCB0aGUgZmF0YWwgZXJyb3IuXG4gICAqICAgSWYgYW4gRXJyb3Igb2JqZWN0IGlzIHByb3ZpZGVkLCBpdHMgc3RhY2sgdHJhY2Ugd2lsbCBiZSBjYXB0dXJlZC5cbiAgICogQHBhcmFtIHthbnl9IFtkYXRhXSAtIE9wdGlvbmFsIGFkZGl0aW9uYWwgY29udGV4dCBkYXRhIGFib3V0IHRoZSBmYXRhbCBlcnJvci5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEZhdGFsIGVycm9yIHdpdGggcHJvY2VzcyBleGl0XG4gICAqIGxvZ2dlci5mYXRhbCgnQ3JpdGljYWwgY29uZmlndXJhdGlvbiBtaXNzaW5nJyk7XG4gICAqIHByb2Nlc3MuZXhpdCgxKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRmF0YWwgZXJyb3Igd2l0aCBleGNlcHRpb25cbiAgICogdHJ5IHtcbiAgICogICBsb2FkQ3JpdGljYWxSZXNvdXJjZSgpO1xuICAgKiB9IGNhdGNoIChlcnIpIHtcbiAgICogICBsb2dnZXIuZmF0YWwoJ0ZhaWxlZCB0byBsb2FkIGNyaXRpY2FsIHJlc291cmNlJywgZXJyLCB7IHJlc291cmNlOiAnY29uZmlnLmpzb24nIH0pO1xuICAgKiAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICogfVxuICAgKlxuICAgKiBAc2VlIHtAbGluayBMb2dnZXIuZXJyb3J9IC0gRm9yIHJlY292ZXJhYmxlIGVycm9yc1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBmYXRhbChtZXNzYWdlOiBzdHJpbmcsIGVycm9yPzogRXJyb3IgfCBhbnksIGRhdGE/OiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmxvZyhMb2dMZXZlbC5GQVRBTCwgbWVzc2FnZSwgZXJyb3IsIGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbG9nZ2VyIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICAgKlxuICAgKiBUaGUgY29udGV4dCBpcyBhIHN0cmluZyBpZGVudGlmaWVyIHRoYXQgaGVscHMgY2F0ZWdvcml6ZSBsb2dzIGJ5IHRoZWlyIHNvdXJjZVxuICAgKiAoZS5nLiwgbW9kdWxlIG5hbWUsIGNvbXBvbmVudCBuYW1lLCBzZXJ2aWNlIG5hbWUpLiBUaGUgY29udGV4dCBhcHBlYXJzIGluXG4gICAqIGZvcm1hdHRlZCBsb2cgb3V0cHV0IGFuZCBjYW4gYmUgdXNlZCBmb3IgZmlsdGVyaW5nLiBUaGUgcmV0dXJuZWQgbG9nZ2VyXG4gICAqIHNoYXJlcyBjb25maWd1cmF0aW9uIGFuZCBsb2cgc3RvcmFnZSB3aXRoIHRoZSBwYXJlbnQgbG9nZ2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dCAtIFRoZSBjb250ZXh0IGlkZW50aWZpZXIgZm9yIHRoZSBuZXcgbG9nZ2VyIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7SUxvZ2dlcn0gQSBuZXcgbG9nZ2VyIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBjb250ZXh0LlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBDcmVhdGUgYSBsb2dnZXIgZm9yIGEgc3BlY2lmaWMgbW9kdWxlXG4gICAqIGNvbnN0IHVzZXJMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dCgnVXNlclNlcnZpY2UnKTtcbiAgICogdXNlckxvZ2dlci5pbmZvKCdVc2VyIGNyZWF0ZWQnKTsgLy8gTG9nczogW1VzZXJTZXJ2aWNlXSBVc2VyIGNyZWF0ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ3JlYXRlIG5lc3RlZCBjb250ZXh0c1xuICAgKiBjb25zdCBhcGlMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dCgnQVBJJyk7XG4gICAqIGNvbnN0IGF1dGhMb2dnZXIgPSBhcGlMb2dnZXIuc2V0Q29udGV4dCgnQVBJLkF1dGgnKTtcbiAgICogYXV0aExvZ2dlci5pbmZvKCdBdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsJyk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5jbGVhckNvbnRleHR9IC0gVG8gcmVtb3ZlIHRoZSBjb250ZXh0XG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci53aXRoRmllbGRzfSAtIFRvIGFkZCBwZXJzaXN0ZW50IGZpZWxkc1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBzZXRDb250ZXh0KGNvbnRleHQ6IHN0cmluZyk6IElMb2dnZXIge1xuICAgIGNvbnN0IGNvbnRleHRMb2dnZXIgPSBuZXcgTG9nZ2VyKHtcbiAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgdHJhbnNwb3J0czogdGhpcy50cmFuc3BvcnRzLFxuICAgIH0pO1xuICAgIGNvbnRleHRMb2dnZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgY29udGV4dExvZ2dlci5sb2dzID0gdGhpcy5sb2dzOyAvLyBTaGFyZSBsb2cgc3RvcmFnZVxuICAgIGNvbnRleHRMb2dnZXIuZmllbGRzID0geyAuLi50aGlzLmZpZWxkcyB9O1xuICAgIHJldHVybiBjb250ZXh0TG9nZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNvbnRleHQgZnJvbSB0aGlzIGxvZ2dlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgbG9ncyB3aWxsIG5vIGxvbmdlciBpbmNsdWRlIGEgY29udGV4dCBpZGVudGlmaWVyLlxuICAgKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHRyYW5zaXRpb25pbmcgZnJvbSBtb2R1bGUtc3BlY2lmaWMgbG9nZ2luZyBiYWNrIHRvXG4gICAqIGdlbmVyYWwgYXBwbGljYXRpb24gbG9nZ2luZy5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IG1vZHVsZUxvZ2dlciA9IGxvZ2dlci5zZXRDb250ZXh0KCdEYXRhUHJvY2Vzc29yJyk7XG4gICAqIG1vZHVsZUxvZ2dlci5pbmZvKCdQcm9jZXNzaW5nIHN0YXJ0ZWQnKTtcbiAgICogLy8gLi4uIHByb2Nlc3NpbmcgbG9naWMgLi4uXG4gICAqIG1vZHVsZUxvZ2dlci5jbGVhckNvbnRleHQoKTtcbiAgICogbW9kdWxlTG9nZ2VyLmluZm8oJ0JhY2sgdG8gZ2VuZXJhbCBsb2dnaW5nJyk7IC8vIE5vIGNvbnRleHQgaW4gb3V0cHV0XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5zZXRDb250ZXh0fSAtIFRvIHNldCBhIGNvbnRleHRcbiAgICogQG1lbWJlcm9mIExvZ2dlclxuICAgKi9cbiAgY2xlYXJDb250ZXh0KCk6IHZvaWQge1xuICAgIHRoaXMuY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgY3VycmVudCBsb2dnZXIgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcHJvdmlkZXMgcmVhZC1vbmx5IGFjY2VzcyB0byB0aGUgbG9nZ2VyJ3MgY29uZmlndXJhdGlvbixcbiAgICogaW5jbHVkaW5nIG1pbmltdW0gbG9nIGxldmVsLCBlbmFibGVkIHRyYW5zcG9ydHMsIGFuZCBvdGhlciBzZXR0aW5ncy5cbiAgICogVGhlIHJldHVybmVkIG9iamVjdCBpcyBhIHNoYWxsb3cgY29weSB0byBwcmV2ZW50IGV4dGVybmFsIG1vZGlmaWNhdGlvbnMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtMb2dnZXJDb25maWd9IEEgY29weSBvZiB0aGUgY3VycmVudCBsb2dnZXIgY29uZmlndXJhdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgY29uZmlnID0gbG9nZ2VyLmdldENvbmZpZygpO1xuICAgKiBjb25zb2xlLmxvZygnQ3VycmVudCBsb2cgbGV2ZWw6JywgTG9nTGV2ZWxbY29uZmlnLm1pbkxldmVsXSk7XG4gICAqIGNvbnNvbGUubG9nKCdDb25zb2xlIGxvZ2dpbmcgZW5hYmxlZDonLCBjb25maWcuZW5hYmxlQ29uc29sZSk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci51cGRhdGVDb25maWd9IC0gVG8gbW9kaWZ5IHRoZSBjb25maWd1cmF0aW9uXG4gICAqIEBtZW1iZXJvZiBMb2dnZXJcbiAgICovXG4gIGdldENvbmZpZygpOiBMb2dnZXJDb25maWcge1xuICAgIHJldHVybiB7IC4uLnRoaXMuY29uZmlnIH07XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9nZ2VyIGNvbmZpZ3VyYXRpb24gd2l0aCB0aGUgcHJvdmlkZWQgc2V0dGluZ3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGFsbG93cyBydW50aW1lIG1vZGlmaWNhdGlvbiBvZiBsb2dnZXIgYmVoYXZpb3IsIGluY2x1ZGluZ1xuICAgKiBjaGFuZ2luZyB0aGUgbWluaW11bSBsb2cgbGV2ZWwsIGVuYWJsaW5nL2Rpc2FibGluZyB0cmFuc3BvcnRzLCBhbmRcbiAgICogdXBkYXRpbmcgb3RoZXIgY29uZmlndXJhdGlvbiBvcHRpb25zLiBPbmx5IHRoZSBwcm92aWRlZCBwcm9wZXJ0aWVzXG4gICAqIGFyZSB1cGRhdGVkOyBvdGhlcnMgcmV0YWluIHRoZWlyIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BhcnRpYWw8TG9nZ2VyQ29uZmlnPn0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZS5cbiAgICogICBPbmx5IHNwZWNpZmllZCBwcm9wZXJ0aWVzIHdpbGwgYmUgY2hhbmdlZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIENoYW5nZSBtaW5pbXVtIGxvZyBsZXZlbCB0byBXQVJOIGluIHByb2R1Y3Rpb25cbiAgICogaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICogICBsb2dnZXIudXBkYXRlQ29uZmlnKHsgbWluTGV2ZWw6IExvZ0xldmVsLldBUk4gfSk7XG4gICAqIH1cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gRW5hYmxlIHJlbW90ZSBsb2dnaW5nIHdpdGggY3VzdG9tIGVuZHBvaW50XG4gICAqIGxvZ2dlci51cGRhdGVDb25maWcoe1xuICAgKiAgIGVuYWJsZVJlbW90ZTogdHJ1ZSxcbiAgICogICByZW1vdGVFbmRwb2ludDogJ2h0dHBzOi8vbG9ncy5teWFwcC5jb20vaW5nZXN0J1xuICAgKiB9KTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgTG9nZ2VyLmdldENvbmZpZ30gLSBUbyByZWFkIGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnOiBQYXJ0aWFsPExvZ2dlckNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuXG4gICAgLy8gT25seSBzZXR1cCB0cmFuc3BvcnRzIGlmIG5vIGN1c3RvbSB0cmFuc3BvcnRzIHdlcmUgcHJvdmlkZWRcbiAgICBpZiAoIWNvbmZpZy50cmFuc3BvcnRzKSB7XG4gICAgICB0aGlzLnNldHVwVHJhbnNwb3J0cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHMgPSBjb25maWcudHJhbnNwb3J0cztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHN0b3JlZCBsb2cgZW50cmllcywgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBjcml0ZXJpYS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgcmV0dXJucyBsb2dzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBpbiBtZW1vcnkgKHVwIHRvIG1heExvZ1NpemUpLlxuICAgKiBXaGVuIGEgZmlsdGVyIGlzIHByb3ZpZGVkLCBvbmx5IGxvZ3MgbWF0Y2hpbmcgQUxMIHNwZWNpZmllZCBjcml0ZXJpYSBhcmUgcmV0dXJuZWQuXG4gICAqIFRoZSByZXR1cm5lZCBhcnJheSBpcyBhIGNvcHkgdG8gcHJldmVudCBleHRlcm5hbCBtb2RpZmljYXRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge0xvZ0ZpbHRlcn0gW2ZpbHRlcl0gLSBPcHRpb25hbCBmaWx0ZXIgY3JpdGVyaWEgdG8gYXBwbHkuXG4gICAqIEBwYXJhbSB7TG9nTGV2ZWx9IFtmaWx0ZXIubWluTGV2ZWxdIC0gTWluaW11bSBsb2cgbGV2ZWwgdG8gaW5jbHVkZS5cbiAgICogQHBhcmFtIHtMb2dMZXZlbH0gW2ZpbHRlci5tYXhMZXZlbF0gLSBNYXhpbXVtIGxvZyBsZXZlbCB0byBpbmNsdWRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZpbHRlci5jb250ZXh0XSAtIE9ubHkgaW5jbHVkZSBsb2dzIHdpdGggdGhpcyBleGFjdCBjb250ZXh0LlxuICAgKiBAcGFyYW0ge0RhdGV9IFtmaWx0ZXIuc3RhcnRUaW1lXSAtIE9ubHkgaW5jbHVkZSBsb2dzIGFmdGVyIHRoaXMgdGltZS5cbiAgICogQHBhcmFtIHtEYXRlfSBbZmlsdGVyLmVuZFRpbWVdIC0gT25seSBpbmNsdWRlIGxvZ3MgYmVmb3JlIHRoaXMgdGltZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWx0ZXIuc2VhcmNoVGV4dF0gLSBUZXh0IHRvIHNlYXJjaCBmb3IgaW4gbWVzc2FnZSwgY29udGV4dCwgb3IgZGF0YS5cbiAgICogQHJldHVybnMge0xvZ0VudHJ5W119IEFycmF5IG9mIGxvZyBlbnRyaWVzIG1hdGNoaW5nIHRoZSBmaWx0ZXIgY3JpdGVyaWEuXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBhbGwgc3RvcmVkIGxvZ3NcbiAgICogY29uc3QgYWxsTG9ncyA9IGxvZ2dlci5nZXRMb2dzKCk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdldCBvbmx5IGVycm9yIGFuZCBmYXRhbCBsb2dzXG4gICAqIGNvbnN0IGVycm9ycyA9IGxvZ2dlci5nZXRMb2dzKHsgbWluTGV2ZWw6IExvZ0xldmVsLkVSUk9SIH0pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBHZXQgbG9ncyBmcm9tIHRoZSBsYXN0IGhvdXIgY29udGFpbmluZyBcInVzZXJcIlxuICAgKiBjb25zdCByZWNlbnRVc2VyTG9ncyA9IGxvZ2dlci5nZXRMb2dzKHtcbiAgICogICBzdGFydFRpbWU6IG5ldyBEYXRlKERhdGUubm93KCkgLSAzNjAwMDAwKSxcbiAgICogICBzZWFyY2hUZXh0OiAndXNlcidcbiAgICogfSk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5jbGVhckxvZ3N9IC0gVG8gcmVtb3ZlIGFsbCBzdG9yZWQgbG9nc1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBnZXRMb2dzKGZpbHRlcj86IExvZ0ZpbHRlcik6IExvZ0VudHJ5W10ge1xuICAgIGlmICghZmlsdGVyKSByZXR1cm4gWy4uLnRoaXMubG9nc107XG5cbiAgICByZXR1cm4gdGhpcy5sb2dzLmZpbHRlcigobG9nKSA9PiB7XG4gICAgICBpZiAoZmlsdGVyLm1pbkxldmVsICE9PSB1bmRlZmluZWQgJiYgbG9nLmxldmVsIDwgZmlsdGVyLm1pbkxldmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZmlsdGVyLm1heExldmVsICE9PSB1bmRlZmluZWQgJiYgbG9nLmxldmVsID4gZmlsdGVyLm1heExldmVsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZmlsdGVyLmNvbnRleHQgJiYgbG9nLmNvbnRleHQgIT09IGZpbHRlci5jb250ZXh0KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoZmlsdGVyLnN0YXJ0VGltZSAmJiBsb2cudGltZXN0YW1wIDwgZmlsdGVyLnN0YXJ0VGltZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGZpbHRlci5lbmRUaW1lICYmIGxvZy50aW1lc3RhbXAgPiBmaWx0ZXIuZW5kVGltZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGZpbHRlci5zZWFyY2hUZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaExvd2VyID0gZmlsdGVyLnNlYXJjaFRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaW5NZXNzYWdlID0gbG9nLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hMb3dlcik7XG4gICAgICAgIGNvbnN0IGluQ29udGV4dCA9IGxvZy5jb250ZXh0Py50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaExvd2VyKTtcbiAgICAgICAgY29uc3QgaW5EYXRhID0gSlNPTi5zdHJpbmdpZnkobG9nLmRhdGEpXG4gICAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAuaW5jbHVkZXMoc2VhcmNoTG93ZXIpO1xuICAgICAgICByZXR1cm4gaW5NZXNzYWdlIHx8IGluQ29udGV4dCB8fCBpbkRhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBzdG9yZWQgbG9nIGVudHJpZXMgZnJvbSBtZW1vcnkuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGNsZWFycyB0aGUgaW50ZXJuYWwgbG9nIGJ1ZmZlci4gSXQgZG9lcyBub3QgYWZmZWN0IGxvZ3NcbiAgICogdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBzZW50IHRvIHRyYW5zcG9ydHMgKGNvbnNvbGUsIHJlbW90ZSwgZXRjLikuXG4gICAqIFVzZWZ1bCBmb3IgdGVzdGluZyBvciB3aGVuIHlvdSB3YW50IHRvIGZyZWUgbWVtb3J5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ2xlYXIgbG9ncyBhZnRlciBwcm9jZXNzaW5nXG4gICAqIGNvbnN0IGxvZ3MgPSBsb2dnZXIuZ2V0TG9ncygpO1xuICAgKiBhd2FpdCBwcm9jZXNzTG9ncyhsb2dzKTtcbiAgICogbG9nZ2VyLmNsZWFyTG9ncygpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayBMb2dnZXIuZ2V0TG9nc30gLSBUbyByZXRyaWV2ZSBzdG9yZWQgbG9nc1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBjbGVhckxvZ3MoKTogdm9pZCB7XG4gICAgdGhpcy5sb2dzID0gW107XG4gIH1cblxuICAvKipcbiAgICogU3RhcnRzIGEgdGltZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGxhYmVsLlxuICAgKlxuICAgKiBDcmVhdGVzIGEgbmFtZWQgdGltZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBtZWFzdXJlIHRoZSBkdXJhdGlvbiBvZiBvcGVyYXRpb25zLlxuICAgKiBUaGUgdGltZXIgY29udGludWVzIHVudGlsIHtAbGluayBMb2dnZXIudGltZUVuZH0gaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgbGFiZWwuXG4gICAqIE11bHRpcGxlIHRpbWVycyBjYW4gcnVuIGNvbmN1cnJlbnRseSB3aXRoIGRpZmZlcmVudCBsYWJlbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAtIFVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIHRpbWVyLlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICogQGV4YW1wbGVcbiAgICogbG9nZ2VyLnRpbWUoJ2FwaUNhbGwnKTtcbiAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZmV0Y2hEYXRhRnJvbUFQSSgpO1xuICAgKiBsb2dnZXIudGltZUVuZCgnYXBpQ2FsbCcpOyAvLyBMb2dzOiBcImFwaUNhbGw6IDIzNC41Nm1zXCJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gTmVzdGVkIHRpbWVycyBmb3IgZGV0YWlsZWQgcGVyZm9ybWFuY2UgYW5hbHlzaXNcbiAgICogbG9nZ2VyLnRpbWUoJ2Z1bGxQcm9jZXNzJyk7XG4gICAqIGxvZ2dlci50aW1lKCdzdGVwMScpO1xuICAgKiBhd2FpdCBwcm9jZXNzU3RlcDEoKTtcbiAgICogbG9nZ2VyLnRpbWVFbmQoJ3N0ZXAxJyk7XG4gICAqIGxvZ2dlci50aW1lKCdzdGVwMicpO1xuICAgKiBhd2FpdCBwcm9jZXNzU3RlcDIoKTtcbiAgICogbG9nZ2VyLnRpbWVFbmQoJ3N0ZXAyJyk7XG4gICAqIGxvZ2dlci50aW1lRW5kKCdmdWxsUHJvY2VzcycpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayBMb2dnZXIudGltZUVuZH0gLSBUbyBzdG9wIHRoZSB0aW1lciBhbmQgbG9nIGR1cmF0aW9uXG4gICAqIEBtZW1iZXJvZiBMb2dnZXJcbiAgICovXG4gIHRpbWUobGFiZWw6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMudGltZXJzLnNldChsYWJlbCwgcGVyZm9ybWFuY2Uubm93KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIGEgdGltZXIgYW5kIGxvZ3MgdGhlIGVsYXBzZWQgdGltZS5cbiAgICpcbiAgICogU3RvcHMgdGhlIHRpbWVyIGlkZW50aWZpZWQgYnkgdGhlIGxhYmVsIGFuZCBsb2dzIHRoZSBkdXJhdGlvbiBhdCBERUJVRyBsZXZlbC5cbiAgICogSWYgdGhlIHRpbWVyIGRvZXNuJ3QgZXhpc3QsIGEgd2FybmluZyBpcyBsb2dnZWQgaW5zdGVhZC4gVGhlIHRpbWVyIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciBsb2dnaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWwgLSBUaGUgaWRlbnRpZmllciBvZiB0aGUgdGltZXIgdG8gc3RvcC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBleGFtcGxlXG4gICAqIGxvZ2dlci50aW1lKCdkYXRhYmFzZVF1ZXJ5Jyk7XG4gICAqIGNvbnN0IHVzZXJzID0gYXdhaXQgZGIucXVlcnkoJ1NFTEVDVCAqIEZST00gdXNlcnMnKTtcbiAgICogbG9nZ2VyLnRpbWVFbmQoJ2RhdGFiYXNlUXVlcnknKTsgLy8gTG9nczogXCJkYXRhYmFzZVF1ZXJ5OiA0NS4yM21zXCJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSGFuZGxpbmcgbm9uLWV4aXN0ZW50IHRpbWVyXG4gICAqIGxvZ2dlci50aW1lRW5kKCdub25FeGlzdGVudFRpbWVyJyk7IC8vIExvZ3Mgd2FybmluZzogXCJUaW1lciAnbm9uRXhpc3RlbnRUaW1lcicgZG9lcyBub3QgZXhpc3RcIlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBMb2dnZXIudGltZX0gLSBUbyBzdGFydCBhIHRpbWVyXG4gICAqIEBtZW1iZXJvZiBMb2dnZXJcbiAgICovXG4gIHRpbWVFbmQobGFiZWw6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy50aW1lcnMuZ2V0KGxhYmVsKTtcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53YXJuKGBUaW1lciAnJHtsYWJlbH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgIHRoaXMudGltZXJzLmRlbGV0ZShsYWJlbCk7XG5cbiAgICB0aGlzLmRlYnVnKGAke2xhYmVsfTogJHtkdXJhdGlvbi50b0ZpeGVkKDIpfW1zYCwgeyBkdXJhdGlvbiB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGxvZ2dlciBpbnN0YW5jZSB3aXRoIGFkZGl0aW9uYWwgcGVyc2lzdGVudCBmaWVsZHMuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBsb2dnZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGluY2x1ZGUgdGhlIHNwZWNpZmllZCBmaWVsZHMgaW5cbiAgICogZXZlcnkgbG9nIGVudHJ5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgYWRkaW5nIGNvbnNpc3RlbnQgbWV0YWRhdGEgbGlrZVxuICAgKiByZXF1ZXN0IElEcywgdXNlciBJRHMsIG9yIHNlc3Npb24gaW5mb3JtYXRpb24uIEZpZWxkcyBhcmUgbWVyZ2VkIHdpdGhcbiAgICogYW55IGZpZWxkcyBwcm92aWRlZCBkaXJlY3RseSB0byBsb2cgbWV0aG9kcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBhbnk+fSBmaWVsZHMgLSBLZXktdmFsdWUgcGFpcnMgdG8gaW5jbHVkZSBpbiBhbGwgbG9nc1xuICAgKiAgIGZyb20gdGhlIHJldHVybmVkIGxvZ2dlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0lMb2dnZXJ9IEEgbmV3IGxvZ2dlciBpbnN0YW5jZSB3aXRoIHRoZSBhZGRpdGlvbmFsIGZpZWxkcy5cbiAgICogQGV4YW1wbGVcbiAgICogLy8gQWRkIHJlcXVlc3QgSUQgdG8gYWxsIGxvZ3MgZm9yIGEgcmVxdWVzdCBoYW5kbGVyXG4gICAqIGFwcC51c2UoKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAqICAgcmVxLmxvZ2dlciA9IGxvZ2dlci53aXRoRmllbGRzKHsgcmVxdWVzdElkOiByZXEuaWQgfSk7XG4gICAqICAgbmV4dCgpO1xuICAgKiB9KTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gQ2hhaW4gd2l0aCBzZXRDb250ZXh0IGZvciByaWNoIGxvZ2dpbmdcbiAgICogY29uc3QgdXNlckxvZ2dlciA9IGxvZ2dlclxuICAgKiAgIC5zZXRDb250ZXh0KCdVc2VyU2VydmljZScpXG4gICAqICAgLndpdGhGaWVsZHMoeyB1c2VySWQ6IHVzZXIuaWQsIHNlc3Npb25JZDogc2Vzc2lvbi5pZCB9KTtcbiAgICogdXNlckxvZ2dlci5pbmZvKCdVc2VyIGFjdGlvbiBwZXJmb3JtZWQnKTsgLy8gSW5jbHVkZXMgY29udGV4dCBhbmQgZmllbGRzXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIExvZ2dlci5zZXRDb250ZXh0fSAtIFRvIGFkZCBhIGNvbnRleHQgaWRlbnRpZmllclxuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICB3aXRoRmllbGRzKGZpZWxkczogUmVjb3JkPHN0cmluZywgYW55Pik6IElMb2dnZXIge1xuICAgIGNvbnN0IGZpZWxkTG9nZ2VyID0gbmV3IExvZ2dlcih7XG4gICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgIHRyYW5zcG9ydHM6IHRoaXMudHJhbnNwb3J0cyxcbiAgICB9KTtcbiAgICBmaWVsZExvZ2dlci5jb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgIGZpZWxkTG9nZ2VyLmxvZ3MgPSB0aGlzLmxvZ3M7XG4gICAgZmllbGRMb2dnZXIuZmllbGRzID0geyAuLi50aGlzLmZpZWxkcywgLi4uZmllbGRzIH07XG4gICAgcmV0dXJuIGZpZWxkTG9nZ2VyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgYWxsIHBlbmRpbmcgbG9ncyBmcm9tIGFsbCB0cmFuc3BvcnRzLlxuICAgKlxuICAgKiBUaGlzIGFzeW5jaHJvbm91cyBtZXRob2QgZW5zdXJlcyB0aGF0IGFueSBidWZmZXJlZCBsb2dzIGFyZSB3cml0dGVuIHRvIHRoZWlyXG4gICAqIGRlc3RpbmF0aW9ucy4gSXQncyBjcnVjaWFsIHRvIGNhbGwgdGhpcyBiZWZvcmUgYXBwbGljYXRpb24gc2h1dGRvd24gdG8gcHJldmVudFxuICAgKiBsb2cgbG9zcy4gVGhlIG1ldGhvZCB3YWl0cyBmb3IgYWxsIHRyYW5zcG9ydHMgdG8gY29tcGxldGUgdGhlaXIgZmx1c2ggb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYWxsIHRyYW5zcG9ydHMgaGF2ZVxuICAgKiAgIHN1Y2Nlc3NmdWxseSBmbHVzaGVkIHRoZWlyIGJ1ZmZlcnMuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhbnkgdHJhbnNwb3J0IGZhaWxzIHRvIGZsdXNoLiBUaGUgZXJyb3IgZnJvbSB0aGUgZmlyc3RcbiAgICogICBmYWlsaW5nIHRyYW5zcG9ydCBpcyB0aHJvd24uXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEdyYWNlZnVsIHNodXRkb3duXG4gICAqIHByb2Nlc3Mub24oJ1NJR1RFUk0nLCBhc3luYyAoKSA9PiB7XG4gICAqICAgbG9nZ2VyLmluZm8oJ1NodXR0aW5nIGRvd24gZ3JhY2VmdWxseScpO1xuICAgKiAgIGF3YWl0IGxvZ2dlci5mbHVzaCgpO1xuICAgKiAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICogfSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEVuc3VyZSBsb2dzIGFyZSBmbHVzaGVkIGFmdGVyIGJhdGNoIG9wZXJhdGlvblxuICAgKiBhd2FpdCBwcm9jZXNzQmF0Y2hKb2IoKTtcbiAgICogYXdhaXQgbG9nZ2VyLmZsdXNoKCk7IC8vIE1ha2Ugc3VyZSBhbGwgbG9ncyBhcmUgcGVyc2lzdGVkXG4gICAqXG4gICAqIEBhc3luY1xuICAgKiBAbWVtYmVyb2YgTG9nZ2VyXG4gICAqL1xuICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLnRyYW5zcG9ydHMubWFwKCh0KSA9PiB0LmZsdXNoKCkpKTtcbiAgfVxufVxuXG4vLyBTaW5nbGV0b24gaW5zdGFuY2VcbmxldCBsb2dnZXJJbnN0YW5jZTogTG9nZ2VyIHwgbnVsbCA9IG51bGw7XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBnbG9iYWwgc2luZ2xldG9uIGxvZ2dlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGFwcGxpY2F0aW9uJ3Mgc2hhcmVkIGxvZ2dlciBpbnN0YW5jZSwgY3JlYXRpbmcgaXRcbiAqIG9uIGZpcnN0IGNhbGwuIFRoZSBsb2dnZXIgaXMgYXV0b21hdGljYWxseSBjb25maWd1cmVkIHdpdGggcGxhdGZvcm0gZGV0ZWN0aW9uXG4gKiBmaWVsZHMuIFRoaXMgaXMgdGhlIHJlY29tbWVuZGVkIHdheSB0byBhY2Nlc3MgbG9nZ2luZyBmdW5jdGlvbmFsaXR5IHRocm91Z2hvdXRcbiAqIHRoZSBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7SUxvZ2dlcn0gVGhlIGdsb2JhbCBsb2dnZXIgaW5zdGFuY2UuXG4gKiBAZXhhbXBsZVxuICogLy8gQmFzaWMgdXNhZ2VcbiAqIGltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2luZy9Mb2dnZXInO1xuICogY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCk7XG4gKiBsb2dnZXIuaW5mbygnQXBwbGljYXRpb24gc3RhcnRlZCcpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXaXRoIGNvbnRleHQgZm9yIG1vZHVsZS1zcGVjaWZpYyBsb2dnaW5nXG4gKiBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KCdBdXRoTW9kdWxlJyk7XG4gKiBsb2dnZXIuZGVidWcoJ1Byb2Nlc3NpbmcgYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNyZWF0ZUxvZ2dlcn0gLSBUbyBjcmVhdGUgYSBjdXN0b20gbG9nZ2VyIGluc3RhbmNlXG4gKiBAc2VlIHtAbGluayByZXNldExvZ2dlcn0gLSBUbyByZXNldCB0aGUgZ2xvYmFsIGluc3RhbmNlICh0ZXN0aW5nKVxuICogQHNpbmNlIDEuMC4wXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2dnZXIoKTogSUxvZ2dlciB7XG4gIGlmICghbG9nZ2VySW5zdGFuY2UpIHtcbiAgICBsb2dnZXJJbnN0YW5jZSA9IG5ldyBMb2dnZXIoKTtcblxuICAgIC8vIEFkZCBwbGF0Zm9ybSBpbmZvIHRvIGFsbCBsb2dzXG4gICAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybURldGVjdGlvbigpO1xuICAgIGxvZ2dlckluc3RhbmNlID0gbG9nZ2VySW5zdGFuY2Uud2l0aEZpZWxkcyh7XG4gICAgICBwbGF0Zm9ybToge1xuICAgICAgICBpc1dlYjogcGxhdGZvcm0uaXNXZWIoKSxcbiAgICAgICAgaXNNb2JpbGU6IHBsYXRmb3JtLmlzTW9iaWxlKCksXG4gICAgICAgIGlzQW5kcm9pZDogcGxhdGZvcm0uaXNBbmRyb2lkKCksXG4gICAgICAgIGlzSU9TOiBwbGF0Zm9ybS5pc0lPUygpLFxuICAgICAgfSxcbiAgICB9KSBhcyBMb2dnZXI7XG4gIH1cbiAgcmV0dXJuIGxvZ2dlckluc3RhbmNlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbG9nZ2VyIGluc3RhbmNlIHdpdGggY3VzdG9tIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gd2hlbiB5b3UgbmVlZCBhIGxvZ2dlciB3aXRoIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgZGlmZmVyXG4gKiBmcm9tIHRoZSBnbG9iYWwgbG9nZ2VyLiBFYWNoIGNyZWF0ZWQgbG9nZ2VyIGlzIGluZGVwZW5kZW50IGFuZCBtYWludGFpbnNcbiAqIGl0cyBvd24gY29uZmlndXJhdGlvbiBhbmQgbG9nIHN0b3JhZ2UuXG4gKlxuICogQHBhcmFtIHtQYXJ0aWFsPExvZ2dlckNvbmZpZz59IFtjb25maWddIC0gQ3VzdG9tIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSB7TG9nTGV2ZWx9IFtjb25maWcubWluTGV2ZWxdIC0gTWluaW11bSBsZXZlbCBmb3IgbG9ncyB0byBiZSBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuZW5hYmxlQ29uc29sZV0gLSBXaGV0aGVyIHRvIG91dHB1dCBsb2dzIHRvIGNvbnNvbGUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuZW5hYmxlUmVtb3RlXSAtIFdoZXRoZXIgdG8gc2VuZCBsb2dzIHRvIHJlbW90ZSBlbmRwb2ludC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLnJlbW90ZUVuZHBvaW50XSAtIFVSTCBmb3IgcmVtb3RlIGxvZyBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4TG9nU2l6ZT0xMDAwXSAtIE1heGltdW0gbnVtYmVyIG9mIGxvZ3MgdG8gc3RvcmUgaW4gbWVtb3J5LlxuICogQHBhcmFtIHtJTG9nVHJhbnNwb3J0W119IFtjb25maWcudHJhbnNwb3J0c10gLSBDdXN0b20gdHJhbnNwb3J0cyAoZm9yIHRlc3RpbmcvZXh0ZW5zaW9ucykuXG4gKiBAcmV0dXJucyB7SUxvZ2dlcn0gQSBuZXcgbG9nZ2VyIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICogQGV4YW1wbGVcbiAqIC8vIENyZWF0ZSBhIGxvZ2dlciBmb3IgdGVzdGluZyB3aXRoIG9ubHkgY29uc29sZSBvdXRwdXRcbiAqIGNvbnN0IHRlc3RMb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICogICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gKiAgIGVuYWJsZUNvbnNvbGU6IHRydWUsXG4gKiAgIGVuYWJsZVJlbW90ZTogZmFsc2VcbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDcmVhdGUgYSBwcm9kdWN0aW9uIGxvZ2dlciB3aXRoIHJlbW90ZSBsb2dnaW5nXG4gKiBjb25zdCBwcm9kTG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAqICAgbWluTGV2ZWw6IExvZ0xldmVsLklORk8sXG4gKiAgIGVuYWJsZVJlbW90ZTogdHJ1ZSxcbiAqICAgcmVtb3RlRW5kcG9pbnQ6ICdodHRwczovL2xvZ3MubXlhcHAuY29tL2luZ2VzdCcsXG4gKiAgIG1heExvZ1NpemU6IDUwMDBcbiAqIH0pO1xuICpcbiAqIEBzZWUge0BsaW5rIGdldExvZ2dlcn0gLSBGb3IgdGhlIGdsb2JhbCBzaW5nbGV0b24gbG9nZ2VyXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihjb25maWc/OiBQYXJ0aWFsPExvZ2dlckNvbmZpZz4pOiBJTG9nZ2VyIHtcbiAgcmV0dXJuIG5ldyBMb2dnZXIoY29uZmlnKTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIGdsb2JhbCBsb2dnZXIgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjbGVhcnMgdGhlIHNpbmdsZXRvbiBsb2dnZXIgaW5zdGFuY2UsIGZvcmNpbmcgYSBuZXcgaW5zdGFuY2VcbiAqIHRvIGJlIGNyZWF0ZWQgb24gdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgZ2V0TG9nZ2VyfS4gVGhpcyBpcyBwcmltYXJpbHlcbiAqIHVzZWZ1bCBmb3IgdGVzdGluZyBzY2VuYXJpb3Mgd2hlcmUgeW91IG5lZWQgYSBmcmVzaCBsb2dnZXIgc3RhdGUgYmV0d2VlbiB0ZXN0cy5cbiAqXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiAvLyBJbiB0ZXN0IHNldHVwXG4gKiBiZWZvcmVFYWNoKCgpID0+IHtcbiAqICAgcmVzZXRMb2dnZXIoKTtcbiAqIH0pO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZXNldCBsb2dnZXIgYWZ0ZXIgY2hhbmdpbmcgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKiBwcm9jZXNzLmVudi5OT0RFX0VOViA9ICd0ZXN0JztcbiAqIHJlc2V0TG9nZ2VyKCk7IC8vIE5leHQgZ2V0TG9nZ2VyKCkgY2FsbCB3aWxsIHVzZSB0ZXN0IGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAc2VlIHtAbGluayBnZXRMb2dnZXJ9IC0gVG8gZ2V0IHRoZSBnbG9iYWwgbG9nZ2VyIGluc3RhbmNlXG4gKiBAc2luY2UgMS4wLjBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0TG9nZ2VyKCk6IHZvaWQge1xuICBsb2dnZXJJbnN0YW5jZSA9IG51bGw7XG59XG5cbi8vIEV4cG9ydCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuZXhwb3J0IHsgUmVtb3RlVHJhbnNwb3J0IH07XG4iXSwibmFtZXMiOlsiTG9nZ2VyIiwiUmVtb3RlVHJhbnNwb3J0IiwiY3JlYXRlTG9nZ2VyIiwiZ2V0TG9nZ2VyIiwicmVzZXRMb2dnZXIiLCJERUZBVUxUX0NPTkZJRyIsIm1pbkxldmVsIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiTG9nTGV2ZWwiLCJJTkZPIiwiREVCVUciLCJlbmFibGVDb25zb2xlIiwiZW5hYmxlUmVtb3RlIiwiZW5hYmxlRmlsZUxvZ2dpbmciLCJtYXhMb2dTaXplIiwiRGVmYXVsdExvZ0Zvcm1hdHRlciIsImZvcm1hdCIsImVudHJ5IiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJsZXZlbCIsImNvbnRleHQiLCJtZXNzYWdlIiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwiU3RyaW5nIiwiZXJyb3IiLCJzdGFjayIsIkNvbnNvbGVUcmFuc3BvcnQiLCJsb2ciLCJmb3JtYXR0ZWQiLCJmb3JtYXR0ZXIiLCJjb25zb2xlIiwiZGVidWciLCJpbmZvIiwiV0FSTiIsIndhcm4iLCJFUlJPUiIsIkZBVEFMIiwiZmx1c2giLCJidWZmZXIiLCJwdXNoIiwibGVuZ3RoIiwiYmF0Y2hTaXplIiwiY2F0Y2giLCJpc0ZsdXNoaW5nIiwiZW5kcG9pbnQiLCJlbnRyaWVzVG9GbHVzaCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsImxvZ3MiLCJvayIsIkVycm9yIiwic3RhdHVzIiwidW5zaGlmdCIsInNldHVwVHJhbnNwb3J0cyIsInRyYW5zcG9ydHMiLCJjb25maWciLCJyZW1vdGVFbmRwb2ludCIsInNob3VsZExvZyIsImxvZ0NvbnRleHQiLCJjb250ZXh0V2hpdGVsaXN0IiwiaW5jbHVkZXMiLCJjb250ZXh0QmxhY2tsaXN0IiwiRGF0ZSIsImZpZWxkcyIsInVuZGVmaW5lZCIsInNoaWZ0IiwiZm9yRWFjaCIsInRyYW5zcG9ydCIsImZhdGFsIiwic2V0Q29udGV4dCIsImNvbnRleHRMb2dnZXIiLCJjbGVhckNvbnRleHQiLCJnZXRDb25maWciLCJ1cGRhdGVDb25maWciLCJnZXRMb2dzIiwiZmlsdGVyIiwibWF4TGV2ZWwiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwic2VhcmNoVGV4dCIsInNlYXJjaExvd2VyIiwidG9Mb3dlckNhc2UiLCJpbk1lc3NhZ2UiLCJpbkNvbnRleHQiLCJpbkRhdGEiLCJjbGVhckxvZ3MiLCJ0aW1lIiwibGFiZWwiLCJ0aW1lcnMiLCJzZXQiLCJwZXJmb3JtYW5jZSIsIm5vdyIsInRpbWVFbmQiLCJzdGFydCIsImdldCIsImR1cmF0aW9uIiwiZGVsZXRlIiwidG9GaXhlZCIsIndpdGhGaWVsZHMiLCJmaWVsZExvZ2dlciIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJ0IiwiTWFwIiwibG9nZ2VySW5zdGFuY2UiLCJwbGF0Zm9ybSIsImdldFBsYXRmb3JtRGV0ZWN0aW9uIiwiaXNXZWIiLCJpc01vYmlsZSIsImlzQW5kcm9pZCIsImlzSU9TIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBa0JDOzs7Ozs7Ozs7OztRQXNWWUE7ZUFBQUE7O1FBaXRCSkM7ZUFBQUE7O1FBL0JPQztlQUFBQTs7UUFyREFDO2VBQUFBOztRQStFQUM7ZUFBQUE7Ozt1QkF4aENUOzBCQUM4Qjs7Ozs7Ozs7Ozs7Ozs7QUFFckMsd0JBQXdCO0FBQ3hCLE1BQU1DLGlCQUErQjtJQUNuQ0MsVUFDRUMsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLEtBQUssZUFBZUMsZUFBUSxDQUFDQyxJQUFJLEdBQUdELGVBQVEsQ0FBQ0UsS0FBSztJQUN4RUMsZUFBZTtJQUNmQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsWUFBWTtBQUNkO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JDLEdBQ0RDLE9BQU9DLEtBQWUsRUFBVTtRQUM5QixNQUFNQyxZQUFZRCxNQUFNQyxTQUFTLENBQUNDLFdBQVc7UUFDN0MsTUFBTUMsUUFBUVosZUFBUSxDQUFDUyxNQUFNRyxLQUFLLENBQUM7UUFDbkMsTUFBTUMsVUFBVUosTUFBTUksT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFSixNQUFNSSxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFFdkQsSUFBSUMsVUFBVSxHQUFHSixVQUFVLENBQUMsRUFBRUUsTUFBTSxDQUFDLEVBQUVDLFFBQVEsQ0FBQyxFQUFFSixNQUFNSyxPQUFPLEVBQUU7UUFFakUsSUFBSUwsTUFBTU0sSUFBSSxFQUFFO1lBQ2QsSUFBSTtnQkFDRkQsV0FBVyxDQUFDLENBQUMsRUFBRUUsS0FBS0MsU0FBUyxDQUFDUixNQUFNTSxJQUFJLEVBQUUsTUFBTSxJQUFJO1lBQ3RELEVBQUUsT0FBT0csR0FBRztnQkFDViw2REFBNkQ7Z0JBQzdESixXQUFXLENBQUMsQ0FBQyxFQUFFSyxPQUFPVixNQUFNTSxJQUFJLEdBQUc7WUFDckM7UUFDRjtRQUVBLElBQUlOLE1BQU1XLEtBQUssRUFBRTtZQUNmTixXQUFXLENBQUMsUUFBUSxFQUFFTCxNQUFNVyxLQUFLLENBQUNOLE9BQU8sRUFBRTtZQUMzQyxJQUFJTCxNQUFNWSxLQUFLLEVBQUU7Z0JBQ2ZQLFdBQVcsQ0FBQyxTQUFTLEVBQUVMLE1BQU1ZLEtBQUssRUFBRTtZQUN0QztRQUNGO1FBRUEsT0FBT1A7SUFDVDtBQUNGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXFCQyxHQUNELE1BQU1RO0lBWUo7Ozs7Ozs7Ozs7Ozs7O0dBY0MsR0FDREMsSUFBSWQsS0FBZSxFQUFRO1FBQ3pCLE1BQU1lLFlBQVksSUFBSSxDQUFDQyxTQUFTLENBQUNqQixNQUFNLENBQUNDO1FBRXhDLHNFQUFzRTtRQUN0RSxJQUFJQSxNQUFNTSxJQUFJLEVBQUU7WUFDZCxPQUFRTixNQUFNRyxLQUFLO2dCQUNqQixLQUFLWixlQUFRLENBQUNFLEtBQUs7b0JBQ2pCd0IsUUFBUUMsS0FBSyxDQUFDSCxXQUFXZixNQUFNTSxJQUFJO29CQUNuQztnQkFDRixLQUFLZixlQUFRLENBQUNDLElBQUk7b0JBQ2hCeUIsUUFBUUUsSUFBSSxDQUFDSixXQUFXZixNQUFNTSxJQUFJO29CQUNsQztnQkFDRixLQUFLZixlQUFRLENBQUM2QixJQUFJO29CQUNoQkgsUUFBUUksSUFBSSxDQUFDTixXQUFXZixNQUFNTSxJQUFJO29CQUNsQztnQkFDRixLQUFLZixlQUFRLENBQUMrQixLQUFLO2dCQUNuQixLQUFLL0IsZUFBUSxDQUFDZ0MsS0FBSztvQkFDakJOLFFBQVFOLEtBQUssQ0FBQ0ksV0FBV2YsTUFBTU0sSUFBSTtvQkFDbkM7WUFDSjtRQUNGLE9BQU87WUFDTCxPQUFRTixNQUFNRyxLQUFLO2dCQUNqQixLQUFLWixlQUFRLENBQUNFLEtBQUs7b0JBQ2pCd0IsUUFBUUMsS0FBSyxDQUFDSDtvQkFDZDtnQkFDRixLQUFLeEIsZUFBUSxDQUFDQyxJQUFJO29CQUNoQnlCLFFBQVFFLElBQUksQ0FBQ0o7b0JBQ2I7Z0JBQ0YsS0FBS3hCLGVBQVEsQ0FBQzZCLElBQUk7b0JBQ2hCSCxRQUFRSSxJQUFJLENBQUNOO29CQUNiO2dCQUNGLEtBQUt4QixlQUFRLENBQUMrQixLQUFLO2dCQUNuQixLQUFLL0IsZUFBUSxDQUFDZ0MsS0FBSztvQkFDakJOLFFBQVFOLEtBQUssQ0FBQ0k7b0JBQ2Q7WUFDSjtRQUNGO0lBQ0Y7SUFFQTs7Ozs7Ozs7R0FRQyxHQUNELE1BQU1TLFFBQXVCO0lBQzNCLGdDQUFnQztJQUNsQztJQTFFQTs7OztHQUlDLEdBQ0QsWUFBWVIsU0FBeUIsQ0FBRTtRQVB2Qyx1QkFBUUEsYUFBUixLQUFBO1FBUUUsSUFBSSxDQUFDQSxTQUFTLEdBQUdBLGFBQWEsSUFBSWxCO0lBQ3BDO0FBb0VGO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJDLEdBQ0QsTUFBTWhCO0lBb0JKOzs7Ozs7OztHQVFDLEdBQ0RnQyxJQUFJZCxLQUFlLEVBQVE7UUFDekIsSUFBSSxDQUFDeUIsTUFBTSxDQUFDQyxJQUFJLENBQUMxQjtRQUVqQixJQUFJLElBQUksQ0FBQ3lCLE1BQU0sQ0FBQ0UsTUFBTSxJQUFJLElBQUksQ0FBQ0MsU0FBUyxFQUFFO1lBQ3hDLElBQUksQ0FBQ0osS0FBSyxHQUFHSyxLQUFLLENBQUNaLFFBQVFOLEtBQUs7UUFDbEM7SUFDRjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBc0JDLEdBQ0QsTUFBTWEsUUFBdUI7UUFDM0IsK0RBQStEO1FBQy9ELElBQUksSUFBSSxDQUFDTSxVQUFVLElBQUksSUFBSSxDQUFDTCxNQUFNLENBQUNFLE1BQU0sS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDSSxRQUFRLEVBQUU7WUFDakU7UUFDRjtRQUVBLElBQUksQ0FBQ0QsVUFBVSxHQUFHO1FBRWxCLHdFQUF3RTtRQUN4RSxNQUFNRSxpQkFBaUI7ZUFBSSxJQUFJLENBQUNQLE1BQU07U0FBQztRQUN2QyxJQUFJLENBQUNBLE1BQU0sQ0FBQ0UsTUFBTSxHQUFHO1FBRXJCLElBQUk7WUFDRixNQUFNTSxXQUFXLE1BQU1DLE1BQU0sSUFBSSxDQUFDSCxRQUFRLEVBQUU7Z0JBQzFDSSxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU05QixLQUFLQyxTQUFTLENBQUM7b0JBQUU4QixNQUFNTjtnQkFBZTtZQUM5QztZQUVBLElBQUksQ0FBQ0MsU0FBU00sRUFBRSxFQUFFO2dCQUNoQiwrREFBK0Q7Z0JBQy9ELE1BQU0sSUFBSUMsTUFBTSxDQUFDLDZCQUE2QixFQUFFUCxTQUFTUSxNQUFNLEVBQUU7WUFDbkU7UUFDRixFQUFFLE9BQU85QixPQUFPO1lBQ2Qsd0ZBQXdGO1lBQ3hGLHVGQUF1RjtZQUN2Rk0sUUFBUU4sS0FBSyxDQUFDLGtDQUFrQ0E7WUFFaEQsbUZBQW1GO1lBQ25GLHFDQUFxQztZQUNyQyxJQUFJLENBQUNjLE1BQU0sQ0FBQ2lCLE9BQU8sSUFBSVY7UUFDekIsU0FBVTtZQUNSLDRDQUE0QztZQUM1QyxJQUFJLENBQUNGLFVBQVUsR0FBRztRQUNwQjtJQUNGO0lBM0ZBOzs7Ozs7Ozs7R0FTQyxHQUNELFlBQVlDLFFBQWdCLENBQUU7UUFmOUIsdUJBQVFOLFVBQXFCLEVBQUU7UUFDL0IsdUJBQVFHLGFBQVk7UUFDcEIsdUJBQVFHLFlBQVIsS0FBQTtRQUNBLHVCQUFRRCxjQUFhO1FBYW5CLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtJQUNsQjtBQWdGRjtBQXNDTyxNQUFNbEQ7SUFzQ1g7Ozs7Ozs7R0FPQyxHQUNELEFBQVE4RCxrQkFBd0I7UUFDOUIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsRUFBRTtRQUVwQixJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDbkQsYUFBYSxFQUFFO1lBQzdCLElBQUksQ0FBQ2tELFVBQVUsQ0FBQ2xCLElBQUksQ0FBQyxJQUFJYjtRQUMzQjtRQUVBLElBQUksSUFBSSxDQUFDZ0MsTUFBTSxDQUFDbEQsWUFBWSxJQUFJLElBQUksQ0FBQ2tELE1BQU0sQ0FBQ0MsY0FBYyxFQUFFO1lBQzFELElBQUksQ0FBQ0YsVUFBVSxDQUFDbEIsSUFBSSxDQUFDLElBQUk1QyxnQkFBZ0IsSUFBSSxDQUFDK0QsTUFBTSxDQUFDQyxjQUFjO1FBQ3JFO0lBQ0Y7SUFFQTs7Ozs7Ozs7OztHQVVDLEdBQ0QsQUFBUUMsVUFBVTVDLEtBQWUsRUFBRUMsT0FBZ0IsRUFBVztZQUsxQywrQkFJQTtRQVJsQixJQUFJRCxRQUFRLElBQUksQ0FBQzBDLE1BQU0sQ0FBQzFELFFBQVEsRUFBRSxPQUFPO1FBRXpDLE1BQU02RCxhQUFhNUMsV0FBVyxJQUFJLENBQUNBLE9BQU87UUFFMUMsSUFBSTRDLGdCQUFjLGdDQUFBLElBQUksQ0FBQ0gsTUFBTSxDQUFDSSxnQkFBZ0IsY0FBNUIsb0RBQUEsOEJBQThCdEIsTUFBTSxHQUFFO1lBQ3RELE9BQU8sSUFBSSxDQUFDa0IsTUFBTSxDQUFDSSxnQkFBZ0IsQ0FBQ0MsUUFBUSxDQUFDRjtRQUMvQztRQUVBLElBQUlBLGdCQUFjLGdDQUFBLElBQUksQ0FBQ0gsTUFBTSxDQUFDTSxnQkFBZ0IsY0FBNUIsb0RBQUEsOEJBQThCeEIsTUFBTSxHQUFFO1lBQ3RELE9BQU8sQ0FBQyxJQUFJLENBQUNrQixNQUFNLENBQUNNLGdCQUFnQixDQUFDRCxRQUFRLENBQUNGO1FBQ2hEO1FBRUEsT0FBTztJQUNUO0lBRUE7Ozs7Ozs7Ozs7Ozs7O0dBY0MsR0FDRCxBQUFRbEMsSUFDTlgsS0FBZSxFQUNmRSxPQUFlLEVBQ2ZNLEtBQW1CLEVBQ25CTCxJQUFVLEVBQ0o7UUFDTixJQUFJLENBQUMsSUFBSSxDQUFDeUMsU0FBUyxDQUFDNUMsT0FBTyxJQUFJLENBQUNDLE9BQU8sR0FBRztRQUUxQyxNQUFNSixRQUFrQjtZQUN0Qkc7WUFDQUU7WUFDQUosV0FBVyxJQUFJbUQ7WUFDZmhELFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCRSxNQUFNO2dCQUFFLEdBQUcsSUFBSSxDQUFDK0MsTUFBTTtnQkFBRSxHQUFHL0MsSUFBSTtZQUFDO1FBQ2xDO1FBRUEsSUFBSUssVUFBVTJDLGFBQWEzQyxVQUFVLE1BQU07WUFDekMsSUFBSUEsaUJBQWlCNkIsT0FBTztnQkFDMUJ4QyxNQUFNVyxLQUFLLEdBQUdBO2dCQUNkWCxNQUFNWSxLQUFLLEdBQUdELE1BQU1DLEtBQUs7WUFDM0IsT0FBTztnQkFDTFosTUFBTVcsS0FBSyxHQUFHLElBQUk2QixNQUFNOUIsT0FBT0M7WUFDakM7UUFDRjtRQUVBLG9CQUFvQjtRQUNwQixJQUFJLENBQUMyQixJQUFJLENBQUNaLElBQUksQ0FBQzFCO1FBQ2YsSUFBSSxJQUFJLENBQUNzQyxJQUFJLENBQUNYLE1BQU0sR0FBRyxJQUFJLENBQUNrQixNQUFNLENBQUNoRCxVQUFVLEVBQUU7WUFDN0MsSUFBSSxDQUFDeUMsSUFBSSxDQUFDaUIsS0FBSztRQUNqQjtRQUVBLHFCQUFxQjtRQUNyQixJQUFJLENBQUNYLFVBQVUsQ0FBQ1ksT0FBTyxDQUFDLENBQUNDLFlBQWNBLFVBQVUzQyxHQUFHLENBQUNkO0lBQ3ZEO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FzQkMsR0FDRGtCLE1BQU1iLE9BQWUsRUFBRUMsSUFBVSxFQUFRO1FBQ3ZDLElBQUksQ0FBQ1EsR0FBRyxDQUFDdkIsZUFBUSxDQUFDRSxLQUFLLEVBQUVZLFNBQVNpRCxXQUFXaEQ7SUFDL0M7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCQyxHQUNEYSxLQUFLZCxPQUFlLEVBQUVDLElBQVUsRUFBUTtRQUN0QyxJQUFJLENBQUNRLEdBQUcsQ0FBQ3ZCLGVBQVEsQ0FBQ0MsSUFBSSxFQUFFYSxTQUFTaUQsV0FBV2hEO0lBQzlDO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXFCQyxHQUNEZSxLQUFLaEIsT0FBZSxFQUFFQyxJQUFVLEVBQVE7UUFDdEMsSUFBSSxDQUFDUSxHQUFHLENBQUN2QixlQUFRLENBQUM2QixJQUFJLEVBQUVmLFNBQVNpRCxXQUFXaEQ7SUFDOUM7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJDLEdBQ0RLLE1BQU1OLE9BQWUsRUFBRU0sS0FBbUIsRUFBRUwsSUFBVSxFQUFRO1FBQzVELElBQUksQ0FBQ1EsR0FBRyxDQUFDdkIsZUFBUSxDQUFDK0IsS0FBSyxFQUFFakIsU0FBU00sT0FBT0w7SUFDM0M7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJDLEdBQ0RvRCxNQUFNckQsT0FBZSxFQUFFTSxLQUFtQixFQUFFTCxJQUFVLEVBQVE7UUFDNUQsSUFBSSxDQUFDUSxHQUFHLENBQUN2QixlQUFRLENBQUNnQyxLQUFLLEVBQUVsQixTQUFTTSxPQUFPTDtJQUMzQztJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F3QkMsR0FDRHFELFdBQVd2RCxPQUFlLEVBQVc7UUFDbkMsTUFBTXdELGdCQUFnQixJQUFJL0UsT0FBTztZQUMvQixHQUFHLElBQUksQ0FBQ2dFLE1BQU07WUFDZEQsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDN0I7UUFDQWdCLGNBQWN4RCxPQUFPLEdBQUdBO1FBQ3hCd0QsY0FBY3RCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUksRUFBRSxvQkFBb0I7UUFDcERzQixjQUFjUCxNQUFNLEdBQUc7WUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtRQUFDO1FBQ3hDLE9BQU9PO0lBQ1Q7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkMsR0FDREMsZUFBcUI7UUFDbkIsSUFBSSxDQUFDekQsT0FBTyxHQUFHa0Q7SUFDakI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUMsR0FDRFEsWUFBMEI7UUFDeEIsT0FBTztZQUFFLEdBQUcsSUFBSSxDQUFDakIsTUFBTTtRQUFDO0lBQzFCO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMEJDLEdBQ0RrQixhQUFhbEIsTUFBNkIsRUFBUTtRQUNoRCxJQUFJLENBQUNBLE1BQU0sR0FBRztZQUFFLEdBQUcsSUFBSSxDQUFDQSxNQUFNO1lBQUUsR0FBR0EsTUFBTTtRQUFDO1FBRTFDLDhEQUE4RDtRQUM5RCxJQUFJLENBQUNBLE9BQU9ELFVBQVUsRUFBRTtZQUN0QixJQUFJLENBQUNELGVBQWU7UUFDdEIsT0FBTztZQUNMLElBQUksQ0FBQ0MsVUFBVSxHQUFHQyxPQUFPRCxVQUFVO1FBQ3JDO0lBQ0Y7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQ0MsR0FDRG9CLFFBQVFDLE1BQWtCLEVBQWM7UUFDdEMsSUFBSSxDQUFDQSxRQUFRLE9BQU87ZUFBSSxJQUFJLENBQUMzQixJQUFJO1NBQUM7UUFFbEMsT0FBTyxJQUFJLENBQUNBLElBQUksQ0FBQzJCLE1BQU0sQ0FBQyxDQUFDbkQ7WUFDdkIsSUFBSW1ELE9BQU85RSxRQUFRLEtBQUttRSxhQUFheEMsSUFBSVgsS0FBSyxHQUFHOEQsT0FBTzlFLFFBQVEsRUFDOUQsT0FBTztZQUNULElBQUk4RSxPQUFPQyxRQUFRLEtBQUtaLGFBQWF4QyxJQUFJWCxLQUFLLEdBQUc4RCxPQUFPQyxRQUFRLEVBQzlELE9BQU87WUFDVCxJQUFJRCxPQUFPN0QsT0FBTyxJQUFJVSxJQUFJVixPQUFPLEtBQUs2RCxPQUFPN0QsT0FBTyxFQUFFLE9BQU87WUFDN0QsSUFBSTZELE9BQU9FLFNBQVMsSUFBSXJELElBQUliLFNBQVMsR0FBR2dFLE9BQU9FLFNBQVMsRUFBRSxPQUFPO1lBQ2pFLElBQUlGLE9BQU9HLE9BQU8sSUFBSXRELElBQUliLFNBQVMsR0FBR2dFLE9BQU9HLE9BQU8sRUFBRSxPQUFPO1lBQzdELElBQUlILE9BQU9JLFVBQVUsRUFBRTtvQkFHSHZEO2dCQUZsQixNQUFNd0QsY0FBY0wsT0FBT0ksVUFBVSxDQUFDRSxXQUFXO2dCQUNqRCxNQUFNQyxZQUFZMUQsSUFBSVQsT0FBTyxDQUFDa0UsV0FBVyxHQUFHckIsUUFBUSxDQUFDb0I7Z0JBQ3JELE1BQU1HLGFBQVkzRCxlQUFBQSxJQUFJVixPQUFPLGNBQVhVLG1DQUFBQSxhQUFheUQsV0FBVyxHQUFHckIsUUFBUSxDQUFDb0I7Z0JBQ3RELE1BQU1JLFNBQVNuRSxLQUFLQyxTQUFTLENBQUNNLElBQUlSLElBQUksRUFDbkNpRSxXQUFXLEdBQ1hyQixRQUFRLENBQUNvQjtnQkFDWixPQUFPRSxhQUFhQyxhQUFhQztZQUNuQztZQUNBLE9BQU87UUFDVDtJQUNGO0lBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkMsR0FDREMsWUFBa0I7UUFDaEIsSUFBSSxDQUFDckMsSUFBSSxHQUFHLEVBQUU7SUFDaEI7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJDLEdBQ0RzQyxLQUFLQyxLQUFhLEVBQVE7UUFDeEIsSUFBSSxDQUFDQyxNQUFNLENBQUNDLEdBQUcsQ0FBQ0YsT0FBT0csWUFBWUMsR0FBRztJQUN4QztJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQyxHQUNEQyxRQUFRTCxLQUFhLEVBQVE7UUFDM0IsTUFBTU0sUUFBUSxJQUFJLENBQUNMLE1BQU0sQ0FBQ00sR0FBRyxDQUFDUDtRQUM5QixJQUFJTSxVQUFVN0IsV0FBVztZQUN2QixJQUFJLENBQUNqQyxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUV3RCxNQUFNLGdCQUFnQixDQUFDO1lBQzNDO1FBQ0Y7UUFFQSxNQUFNUSxXQUFXTCxZQUFZQyxHQUFHLEtBQUtFO1FBQ3JDLElBQUksQ0FBQ0wsTUFBTSxDQUFDUSxNQUFNLENBQUNUO1FBRW5CLElBQUksQ0FBQzNELEtBQUssQ0FBQyxHQUFHMkQsTUFBTSxFQUFFLEVBQUVRLFNBQVNFLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFO1lBQUVGO1FBQVM7SUFDOUQ7SUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMkJDLEdBQ0RHLFdBQVduQyxNQUEyQixFQUFXO1FBQy9DLE1BQU1vQyxjQUFjLElBQUk1RyxPQUFPO1lBQzdCLEdBQUcsSUFBSSxDQUFDZ0UsTUFBTTtZQUNkRCxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUM3QjtRQUNBNkMsWUFBWXJGLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDbENxRixZQUFZbkQsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtRQUM1Qm1ELFlBQVlwQyxNQUFNLEdBQUc7WUFBRSxHQUFHLElBQUksQ0FBQ0EsTUFBTTtZQUFFLEdBQUdBLE1BQU07UUFBQztRQUNqRCxPQUFPb0M7SUFDVDtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBCQyxHQUNELE1BQU1qRSxRQUF1QjtRQUMzQixNQUFNa0UsUUFBUUMsR0FBRyxDQUFDLElBQUksQ0FBQy9DLFVBQVUsQ0FBQ2dELEdBQUcsQ0FBQyxDQUFDQyxJQUFNQSxFQUFFckUsS0FBSztJQUN0RDtJQXZsQkE7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCQyxHQUNELFlBQVlxQixNQUE4QixDQUFFO1FBMUI1Qyx1QkFBUUEsVUFBUixLQUFBO1FBQ0EsdUJBQVF6QyxXQUFSLEtBQUE7UUFDQSx1QkFBUWtDLFFBQW1CLEVBQUU7UUFDN0IsdUJBQVFNLGNBQThCLEVBQUU7UUFDeEMsdUJBQVFrQyxVQUE4QixJQUFJZ0I7UUFDMUMsdUJBQVF6QyxVQUE4QixDQUFDO1FBc0JyQyxJQUFJLENBQUNSLE1BQU0sR0FBRztZQUFFLEdBQUczRCxjQUFjO1lBQUUsR0FBRzJELE1BQU07UUFBQztRQUU3QywwRUFBMEU7UUFDMUUsSUFBSUEsQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRRCxVQUFVLEtBQUlDLE9BQU9ELFVBQVUsQ0FBQ2pCLE1BQU0sR0FBRyxHQUFHO1lBQ3RELElBQUksQ0FBQ2lCLFVBQVUsR0FBR0MsT0FBT0QsVUFBVTtRQUNyQyxPQUFPO1lBQ0wsSUFBSSxDQUFDRCxlQUFlO1FBQ3RCO0lBQ0Y7QUE0akJGO0FBRUEscUJBQXFCO0FBQ3JCLElBQUlvRCxpQkFBZ0M7QUEwQjdCLFNBQVMvRztJQUNkLElBQUksQ0FBQytHLGdCQUFnQjtRQUNuQkEsaUJBQWlCLElBQUlsSDtRQUVyQixnQ0FBZ0M7UUFDaEMsTUFBTW1ILFdBQVdDLElBQUFBLDhCQUFvQjtRQUNyQ0YsaUJBQWlCQSxlQUFlUCxVQUFVLENBQUM7WUFDekNRLFVBQVU7Z0JBQ1JFLE9BQU9GLFNBQVNFLEtBQUs7Z0JBQ3JCQyxVQUFVSCxTQUFTRyxRQUFRO2dCQUMzQkMsV0FBV0osU0FBU0ksU0FBUztnQkFDN0JDLE9BQU9MLFNBQVNLLEtBQUs7WUFDdkI7UUFDRjtJQUNGO0lBQ0EsT0FBT047QUFDVDtBQXFDTyxTQUFTaEgsYUFBYThELE1BQThCO0lBQ3pELE9BQU8sSUFBSWhFLE9BQU9nRTtBQUNwQjtBQXdCTyxTQUFTNUQ7SUFDZDhHLGlCQUFpQjtBQUNuQiJ9