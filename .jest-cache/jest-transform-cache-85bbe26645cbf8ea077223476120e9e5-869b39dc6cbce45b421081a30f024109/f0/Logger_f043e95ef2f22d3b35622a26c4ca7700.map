{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/logging/Logger.ts"],"sourcesContent":["/**\n * @file Core Logger implementation\n * @module services/logging/Logger\n *\n * @description\n * Provides structured, multi-level logging with different transports.\n * Supports console, file, and remote logging with configurable log levels,\n * filtering, and formatting. Designed for both development and production use.\n *\n * @remarks\n * Key features:\n * - Multiple log levels (DEBUG, INFO, WARN, ERROR)\n * - Contextual logging with metadata\n * - Configurable transports (console, file, remote)\n * - Circular buffer for log history\n * - Error tracking with stack traces\n * - Performance monitoring\n * - Filtered logging by context or level\n */\n\nimport {\n  ILogger,\n  LogLevel,\n  LogEntry,\n  LoggerConfig,\n  LogFilter,\n  ILogTransport,\n  ILogFormatter,\n} from \"./types\";\nimport { getPlatformDetection } from \"../platform\";\n\n// Default configuration\nconst DEFAULT_CONFIG: LoggerConfig = {\n  minLevel:\n    process.env.NODE_ENV === \"production\" ? LogLevel.INFO : LogLevel.DEBUG,\n  enableConsole: true,\n  enableRemote: false,\n  enableFileLogging: false,\n  maxLogSize: 1000,\n};\n\n/**\n * Default log formatter implementation\n *\n * @class DefaultLogFormatter\n * @implements {ILogFormatter}\n *\n * @description\n * Formats log entries into human-readable strings with timestamp,\n * level, context, message, and optional data/error information.\n */\nclass DefaultLogFormatter implements ILogFormatter {\n  /**\n   * Formats a log entry into a string\n   *\n   * @param {LogEntry} entry - The log entry to format\n   * @returns {string} Formatted log message\n   *\n   * @example\n   * ```typescript\n   * const formatter = new DefaultLogFormatter();\n   * const formatted = formatter.format({\n   *   timestamp: new Date(),\n   *   level: LogLevel.INFO,\n   *   message: \"User logged in\",\n   *   context: \"Auth\",\n   *   data: { userId: 123 }\n   * });\n   * // \"2024-01-20T10:30:00.000Z INFO [Auth] User logged in { userId: 123 }\"\n   * ```\n   */\n  format(entry: LogEntry): string {\n    const timestamp = entry.timestamp.toISOString();\n    const level = LogLevel[entry.level];\n    const context = entry.context ? `[${entry.context}]` : \"\";\n\n    let message = `${timestamp} ${level} ${context} ${entry.message}`;\n\n    if (entry.data) {\n      try {\n        message += ` ${JSON.stringify(entry.data, null, 2)}`;\n      } catch (e) {\n        // Fallback for circular references or other stringify errors\n        message += ` ${String(entry.data)}`;\n      }\n    }\n\n    if (entry.error) {\n      message += ` Error: ${entry.error.message}`;\n      if (entry.stack) {\n        message += `\\nStack: ${entry.stack}`;\n      }\n    }\n\n    return message;\n  }\n}\n\n/**\n * Console transport implementation for logging\n *\n * @class ConsoleTransport\n * @implements {ILogTransport}\n *\n * @description\n * Outputs log entries to the browser console with appropriate log levels.\n * Uses native console methods (debug, info, warn, error) based on log level\n * for better developer experience.\n *\n * @example\n * ```typescript\n * const transport = new ConsoleTransport();\n * transport.log({\n *   level: LogLevel.INFO,\n *   message: \"Application started\",\n *   timestamp: new Date(),\n *   context: \"Main\"\n * });\n * ```\n */\nclass ConsoleTransport implements ILogTransport {\n  private formatter: ILogFormatter;\n\n  /**\n   * Creates a new console transport\n   *\n   * @param {ILogFormatter} [formatter] - Optional custom formatter, defaults to DefaultLogFormatter\n   */\n  constructor(formatter?: ILogFormatter) {\n    this.formatter = formatter || new DefaultLogFormatter();\n  }\n\n  /**\n   * Logs an entry to the console\n   *\n   * @param {LogEntry} entry - The log entry to output\n   *\n   * @remarks\n   * Maps log levels to appropriate console methods:\n   * - DEBUG → console.debug()\n   * - INFO → console.info()\n   * - WARN → console.warn()\n   * - ERROR/FATAL → console.error()\n   *\n   * If the entry contains data, it's logged as a second parameter\n   * for better console formatting.\n   */\n  log(entry: LogEntry): void {\n    const formatted = this.formatter.format(entry);\n\n    // If there's additional data, log it separately for better visibility\n    if (entry.data) {\n      switch (entry.level) {\n        case LogLevel.DEBUG:\n          console.debug(formatted, entry.data);\n          break;\n        case LogLevel.INFO:\n          console.info(formatted, entry.data);\n          break;\n        case LogLevel.WARN:\n          console.warn(formatted, entry.data);\n          break;\n        case LogLevel.ERROR:\n        case LogLevel.FATAL:\n          console.error(formatted, entry.data);\n          break;\n      }\n    } else {\n      switch (entry.level) {\n        case LogLevel.DEBUG:\n          console.debug(formatted);\n          break;\n        case LogLevel.INFO:\n          console.info(formatted);\n          break;\n        case LogLevel.WARN:\n          console.warn(formatted);\n          break;\n        case LogLevel.ERROR:\n        case LogLevel.FATAL:\n          console.error(formatted);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Flushes pending logs (no-op for console transport)\n   *\n   * @returns {Promise<void>} Resolves immediately as console has no buffer\n   *\n   * @remarks\n   * Console transport writes immediately, so no flushing is needed.\n   * This method exists to satisfy the ILogTransport interface.\n   */\n  async flush(): Promise<void> {\n    // Console doesn't need flushing\n  }\n}\n\n/**\n * Remote transport implementation for centralized logging\n *\n * @class RemoteTransport\n * @implements {ILogTransport}\n *\n * @description\n * Buffers log entries and sends them to a remote endpoint in batches.\n * Includes retry logic and maintains chronological order of logs.\n * Useful for production monitoring and debugging.\n *\n * @example\n * ```typescript\n * const transport = new RemoteTransport('https://logs.myapp.com/ingest');\n * transport.log({\n *   level: LogLevel.ERROR,\n *   message: \"Database connection failed\",\n *   timestamp: new Date(),\n *   error: new Error(\"Connection timeout\")\n * });\n * // Logs are buffered and sent in batches\n * await transport.flush(); // Force send pending logs\n * ```\n */\nclass RemoteTransport implements ILogTransport {\n  private buffer: LogEntry[] = [];\n  private batchSize = 50;\n  private endpoint: string;\n  private isFlushing = false;\n\n  /**\n   * Creates a new remote transport\n   *\n   * @param {string} endpoint - The URL to send logs to\n   *\n   * @example\n   * ```typescript\n   * const transport = new RemoteTransport('https://logs.myapp.com/ingest');\n   * ```\n   */\n  constructor(endpoint: string) {\n    this.endpoint = endpoint;\n  }\n\n  /**\n   * Adds a log entry to the buffer and triggers flush if needed\n   *\n   * @param {LogEntry} entry - The log entry to buffer\n   *\n   * @remarks\n   * Logs are buffered until batch size is reached, then automatically\n   * sent to the remote endpoint. Use flush() to send immediately.\n   */\n  log(entry: LogEntry): void {\n    this.buffer.push(entry);\n\n    if (this.buffer.length >= this.batchSize) {\n      this.flush().catch(console.error);\n    }\n  }\n\n  /**\n   * Flushes buffered logs to the remote endpoint\n   *\n   * @returns {Promise<void>} Resolves when flush completes or fails\n   *\n   * @remarks\n   * - Prevents concurrent flushes\n   * - Preserves log order on failure by re-buffering\n   * - Uses console.error as fallback for logging failures\n   * - Automatically called when buffer reaches batch size\n   *\n   * @example\n   * ```typescript\n   * // Force send all pending logs\n   * await transport.flush();\n   *\n   * // Ensure logs are sent before shutdown\n   * process.on('SIGTERM', async () => {\n   *   await transport.flush();\n   *   process.exit(0);\n   * });\n   * ```\n   */\n  async flush(): Promise<void> {\n    // Prevent concurrent flushes and exit if there's nothing to do\n    if (this.isFlushing || this.buffer.length === 0 || !this.endpoint) {\n      return;\n    }\n\n    this.isFlushing = true;\n\n    // Atomically grab the current logs and clear the buffer for new entries\n    const entriesToFlush = [...this.buffer];\n    this.buffer.length = 0;\n\n    try {\n      const response = await fetch(this.endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({ logs: entriesToFlush }),\n      });\n\n      if (!response.ok) {\n        // The request was made, but the server responded with an error\n        throw new Error(`Server responded with status ${response.status}`);\n      }\n    } catch (error) {\n      // FALLBACK: Using console.error as last resort when logging infrastructure itself fails\n      // This prevents infinite loops and ensures critical logging failures are still visible\n      console.error(\"Failed to send logs to remote:\", error);\n\n      // If the request fails, put the logs back at the front of the buffer to be retried\n      // This preserves chronological order\n      this.buffer.unshift(...entriesToFlush);\n    } finally {\n      // Ensure we always reset the flushing state\n      this.isFlushing = false;\n    }\n  }\n}\n\n/**\n * Main Logger implementation\n *\n * @class Logger\n * @implements {ILogger}\n *\n * @description\n * Core logging service providing structured, multi-level logging with\n * configurable transports, contexts, and filtering. Supports development\n * and production use cases with features like timing, field enrichment,\n * and log buffering.\n *\n * @example\n * ```typescript\n * // Create a logger with custom configuration\n * const logger = new Logger({\n *   minLevel: LogLevel.INFO,\n *   enableRemote: true,\n *   remoteEndpoint: 'https://logs.myapp.com/ingest'\n * });\n *\n * // Create a context-specific logger\n * const authLogger = logger.setContext('AuthService');\n *\n * // Log with structured data\n * authLogger.info('User authenticated', {\n *   userId: 123,\n *   method: 'OAuth2'\n * });\n *\n * // Measure performance\n * logger.time('api-call');\n * await fetchData();\n * logger.timeEnd('api-call');\n * ```\n */\nexport class Logger implements ILogger {\n  private config: LoggerConfig;\n  private context?: string;\n  private logs: LogEntry[] = [];\n  private transports: ILogTransport[] = [];\n  private timers: Map<string, number> = new Map();\n  private fields: Record<string, any> = {};\n\n  /**\n   * Creates a new logger instance\n   *\n   * @param {Partial<LoggerConfig>} [config] - Configuration options\n   *\n   * @example\n   * ```typescript\n   * // Default logger\n   * const logger = new Logger();\n   *\n   * // Production logger with custom config\n   * const prodLogger = new Logger({\n   *   minLevel: LogLevel.WARN,\n   *   enableRemote: true,\n   *   remoteEndpoint: 'https://logs.myapp.com',\n   *   maxLogSize: 5000\n   * });\n   * ```\n   */\n  constructor(config?: Partial<LoggerConfig>) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n\n    // Use injected transports if provided, otherwise setup default transports\n    if (config?.transports && config.transports.length > 0) {\n      this.transports = config.transports;\n    } else {\n      this.setupTransports();\n    }\n  }\n\n  /**\n   * Sets up logging transports based on configuration\n   *\n   * @private\n   * @remarks\n   * Called during initialization and when configuration changes.\n   * Creates console and/or remote transports as configured.\n   */\n  private setupTransports(): void {\n    this.transports = [];\n\n    if (this.config.enableConsole) {\n      this.transports.push(new ConsoleTransport());\n    }\n\n    if (this.config.enableRemote && this.config.remoteEndpoint) {\n      this.transports.push(new RemoteTransport(this.config.remoteEndpoint));\n    }\n  }\n\n  /**\n   * Determines if a log entry should be processed\n   *\n   * @private\n   * @param {LogLevel} level - The log level to check\n   * @param {string} [context] - Optional context to check against filters\n   * @returns {boolean} True if the log should be processed\n   *\n   * @remarks\n   * Checks against minimum level, context whitelist, and blacklist\n   */\n  private shouldLog(level: LogLevel, context?: string): boolean {\n    if (level < this.config.minLevel) return false;\n\n    const logContext = context || this.context;\n\n    if (logContext && this.config.contextWhitelist?.length) {\n      return this.config.contextWhitelist.includes(logContext);\n    }\n\n    if (logContext && this.config.contextBlacklist?.length) {\n      return !this.config.contextBlacklist.includes(logContext);\n    }\n\n    return true;\n  }\n\n  /**\n   * Core logging method used by all public log methods\n   *\n   * @private\n   * @param {LogLevel} level - The severity level\n   * @param {string} message - The log message\n   * @param {Error|any} [error] - Optional error object\n   * @param {any} [data] - Optional structured data\n   *\n   * @remarks\n   * - Checks if log should be processed\n   * - Creates log entry with metadata\n   * - Adds to memory buffer\n   * - Sends to all configured transports\n   */\n  private log(\n    level: LogLevel,\n    message: string,\n    error?: Error | any,\n    data?: any,\n  ): void {\n    if (!this.shouldLog(level, this.context)) return;\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date(),\n      context: this.context,\n      data: { ...this.fields, ...data },\n    };\n\n    if (error !== undefined && error !== null) {\n      if (error instanceof Error) {\n        entry.error = error;\n        entry.stack = error.stack;\n      } else {\n        entry.error = new Error(String(error));\n      }\n    }\n\n    // Add to memory log\n    this.logs.push(entry);\n    if (this.logs.length > this.config.maxLogSize) {\n      this.logs.shift();\n    }\n\n    // Send to transports\n    this.transports.forEach((transport) => transport.log(entry));\n  }\n\n  /**\n   * Logs a message at the DEBUG level.\n   *\n   * Debug messages are intended for detailed information that is typically only\n   * of interest when diagnosing problems or during development. They will be\n   * filtered out in production environments unless explicitly enabled.\n   *\n   * @param {string} message - The primary log message to record.\n   * @param {any} [data] - Optional structured data to include with the log entry.\n   *   This data will be serialized and attached to the log for additional context.\n   * @returns {void}\n   * @example\n   * // Simple debug message\n   * logger.debug('Application initialization complete');\n   *\n   * @example\n   * // Debug message with structured data\n   * logger.debug('Processing user request', { userId: 123, requestId: 'abc-xyz' });\n   *\n   * @see {@link Logger.info} - For general informational messages\n   * @see {@link Logger.withFields} - To add persistent fields to all logs\n   * @memberof Logger\n   */\n  debug(message: string, data?: any): void {\n    this.log(LogLevel.DEBUG, message, undefined, data);\n  }\n\n  /**\n   * Logs a message at the INFO level.\n   *\n   * Info messages are for general informational events that highlight the\n   * progress of the application at a coarse-grained level. These are typically\n   * shown in production environments.\n   *\n   * @param {string} message - The primary log message to record.\n   * @param {any} [data] - Optional structured data to include with the log entry.\n   *   This data will be serialized and attached to the log for additional context.\n   * @returns {void}\n   * @example\n   * // Simple info message\n   * logger.info('Server started on port 3000');\n   *\n   * @example\n   * // Info message with structured data\n   * logger.info('User logged in', { userId: 456, timestamp: Date.now() });\n   *\n   * @see {@link Logger.debug} - For detailed debugging information\n   * @see {@link Logger.warn} - For warning messages\n   * @memberof Logger\n   */\n  info(message: string, data?: any): void {\n    this.log(LogLevel.INFO, message, undefined, data);\n  }\n\n  /**\n   * Logs a message at the WARN level.\n   *\n   * Warning messages indicate potentially harmful situations or deprecated usage\n   * that should be addressed but don't prevent the application from functioning.\n   *\n   * @param {string} message - The primary log message to record.\n   * @param {any} [data] - Optional structured data to include with the log entry.\n   *   This data will be serialized and attached to the log for additional context.\n   * @returns {void}\n   * @example\n   * // Simple warning\n   * logger.warn('API rate limit approaching');\n   *\n   * @example\n   * // Warning with context\n   * logger.warn('Deprecated method called', { method: 'oldFunction', replacement: 'newFunction' });\n   *\n   * @see {@link Logger.error} - For error conditions\n   * @see {@link Logger.info} - For general information\n   * @memberof Logger\n   */\n  warn(message: string, data?: any): void {\n    this.log(LogLevel.WARN, message, undefined, data);\n  }\n\n  /**\n   * Logs a message at the ERROR level.\n   *\n   * Error messages indicate error conditions that might still allow the application\n   * to continue running. Stack traces are automatically captured when an Error\n   * object is provided.\n   *\n   * @param {string} message - The primary log message describing the error.\n   * @param {Error|any} [error] - Optional error object or any value that caused the error.\n   *   If an Error object is provided, its stack trace will be captured.\n   * @param {any} [data] - Optional additional context data about the error.\n   * @returns {void}\n   * @example\n   * // Simple error message\n   * logger.error('Failed to connect to database');\n   *\n   * @example\n   * // Error with exception object\n   * try {\n   *   await connectToDatabase();\n   * } catch (err) {\n   *   logger.error('Database connection failed', err, { retryCount: 3 });\n   * }\n   *\n   * @see {@link Logger.fatal} - For unrecoverable errors\n   * @see {@link Logger.warn} - For warning conditions\n   * @memberof Logger\n   */\n  error(message: string, error?: Error | any, data?: any): void {\n    this.log(LogLevel.ERROR, message, error, data);\n  }\n\n  /**\n   * Logs a message at the FATAL level.\n   *\n   * Fatal messages indicate severe error conditions that will likely cause the\n   * application to abort. These should be reserved for unrecoverable errors.\n   *\n   * @param {string} message - The primary log message describing the fatal error.\n   * @param {Error|any} [error] - Optional error object or any value that caused the fatal error.\n   *   If an Error object is provided, its stack trace will be captured.\n   * @param {any} [data] - Optional additional context data about the fatal error.\n   * @returns {void}\n   * @example\n   * // Fatal error with process exit\n   * logger.fatal('Critical configuration missing');\n   * process.exit(1);\n   *\n   * @example\n   * // Fatal error with exception\n   * try {\n   *   loadCriticalResource();\n   * } catch (err) {\n   *   logger.fatal('Failed to load critical resource', err, { resource: 'config.json' });\n   *   process.exit(1);\n   * }\n   *\n   * @see {@link Logger.error} - For recoverable errors\n   * @memberof Logger\n   */\n  fatal(message: string, error?: Error | any, data?: any): void {\n    this.log(LogLevel.FATAL, message, error, data);\n  }\n\n  /**\n   * Creates a new logger instance with the specified context.\n   *\n   * The context is a string identifier that helps categorize logs by their source\n   * (e.g., module name, component name, service name). The context appears in\n   * formatted log output and can be used for filtering. The returned logger\n   * shares configuration and log storage with the parent logger.\n   *\n   * @param {string} context - The context identifier for the new logger instance.\n   * @returns {ILogger} A new logger instance with the specified context.\n   * @example\n   * // Create a logger for a specific module\n   * const userLogger = logger.setContext('UserService');\n   * userLogger.info('User created'); // Logs: [UserService] User created\n   *\n   * @example\n   * // Create nested contexts\n   * const apiLogger = logger.setContext('API');\n   * const authLogger = apiLogger.setContext('API.Auth');\n   * authLogger.info('Authentication successful');\n   *\n   * @see {@link Logger.clearContext} - To remove the context\n   * @see {@link Logger.withFields} - To add persistent fields\n   * @memberof Logger\n   */\n  setContext(context: string): ILogger {\n    const contextLogger = new Logger({\n      ...this.config,\n      transports: this.transports,\n    });\n    contextLogger.context = context;\n    contextLogger.logs = this.logs; // Share log storage\n    contextLogger.fields = { ...this.fields };\n    return contextLogger;\n  }\n\n  /**\n   * Removes the context from this logger instance.\n   *\n   * After calling this method, logs will no longer include a context identifier.\n   * This is useful when transitioning from module-specific logging back to\n   * general application logging.\n   *\n   * @returns {void}\n   * @example\n   * const moduleLogger = logger.setContext('DataProcessor');\n   * moduleLogger.info('Processing started');\n   * // ... processing logic ...\n   * moduleLogger.clearContext();\n   * moduleLogger.info('Back to general logging'); // No context in output\n   *\n   * @see {@link Logger.setContext} - To set a context\n   * @memberof Logger\n   */\n  clearContext(): void {\n    this.context = undefined;\n  }\n\n  /**\n   * Returns a copy of the current logger configuration.\n   *\n   * This method provides read-only access to the logger's configuration,\n   * including minimum log level, enabled transports, and other settings.\n   * The returned object is a shallow copy to prevent external modifications.\n   *\n   * @returns {LoggerConfig} A copy of the current logger configuration.\n   * @example\n   * const config = logger.getConfig();\n   * console.log('Current log level:', LogLevel[config.minLevel]);\n   * console.log('Console logging enabled:', config.enableConsole);\n   *\n   * @see {@link Logger.updateConfig} - To modify the configuration\n   * @memberof Logger\n   */\n  getConfig(): LoggerConfig {\n    return { ...this.config };\n  }\n\n  /**\n   * Updates the logger configuration with the provided settings.\n   *\n   * This method allows runtime modification of logger behavior, including\n   * changing the minimum log level, enabling/disabling transports, and\n   * updating other configuration options. Only the provided properties\n   * are updated; others retain their current values.\n   *\n   * @param {Partial<LoggerConfig>} config - Configuration properties to update.\n   *   Only specified properties will be changed.\n   * @returns {void}\n   * @example\n   * // Change minimum log level to WARN in production\n   * if (process.env.NODE_ENV === 'production') {\n   *   logger.updateConfig({ minLevel: LogLevel.WARN });\n   * }\n   *\n   * @example\n   * // Enable remote logging with custom endpoint\n   * logger.updateConfig({\n   *   enableRemote: true,\n   *   remoteEndpoint: 'https://logs.myapp.com/ingest'\n   * });\n   *\n   * @see {@link Logger.getConfig} - To read current configuration\n   * @memberof Logger\n   */\n  updateConfig(config: Partial<LoggerConfig>): void {\n    this.config = { ...this.config, ...config };\n\n    // Only setup transports if no custom transports were provided\n    if (!config.transports) {\n      this.setupTransports();\n    } else {\n      this.transports = config.transports;\n    }\n  }\n\n  /**\n   * Retrieves stored log entries, optionally filtered by criteria.\n   *\n   * This method returns logs that have been stored in memory (up to maxLogSize).\n   * When a filter is provided, only logs matching ALL specified criteria are returned.\n   * The returned array is a copy to prevent external modifications.\n   *\n   * @param {LogFilter} [filter] - Optional filter criteria to apply.\n   * @param {LogLevel} [filter.minLevel] - Minimum log level to include.\n   * @param {LogLevel} [filter.maxLevel] - Maximum log level to include.\n   * @param {string} [filter.context] - Only include logs with this exact context.\n   * @param {Date} [filter.startTime] - Only include logs after this time.\n   * @param {Date} [filter.endTime] - Only include logs before this time.\n   * @param {string} [filter.searchText] - Text to search for in message, context, or data.\n   * @returns {LogEntry[]} Array of log entries matching the filter criteria.\n   * @example\n   * // Get all stored logs\n   * const allLogs = logger.getLogs();\n   *\n   * @example\n   * // Get only error and fatal logs\n   * const errors = logger.getLogs({ minLevel: LogLevel.ERROR });\n   *\n   * @example\n   * // Get logs from the last hour containing \"user\"\n   * const recentUserLogs = logger.getLogs({\n   *   startTime: new Date(Date.now() - 3600000),\n   *   searchText: 'user'\n   * });\n   *\n   * @see {@link Logger.clearLogs} - To remove all stored logs\n   * @memberof Logger\n   */\n  getLogs(filter?: LogFilter): LogEntry[] {\n    if (!filter) return [...this.logs];\n\n    return this.logs.filter((log) => {\n      if (filter.minLevel !== undefined && log.level < filter.minLevel)\n        return false;\n      if (filter.maxLevel !== undefined && log.level > filter.maxLevel)\n        return false;\n      if (filter.context && log.context !== filter.context) return false;\n      if (filter.startTime && log.timestamp < filter.startTime) return false;\n      if (filter.endTime && log.timestamp > filter.endTime) return false;\n      if (filter.searchText) {\n        const searchLower = filter.searchText.toLowerCase();\n        const inMessage = log.message.toLowerCase().includes(searchLower);\n        const inContext = log.context?.toLowerCase().includes(searchLower);\n        const inData = JSON.stringify(log.data)\n          .toLowerCase()\n          .includes(searchLower);\n        return inMessage || inContext || inData;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Removes all stored log entries from memory.\n   *\n   * This method clears the internal log buffer. It does not affect logs\n   * that have already been sent to transports (console, remote, etc.).\n   * Useful for testing or when you want to free memory.\n   *\n   * @returns {void}\n   * @example\n   * // Clear logs after processing\n   * const logs = logger.getLogs();\n   * await processLogs(logs);\n   * logger.clearLogs();\n   *\n   * @see {@link Logger.getLogs} - To retrieve stored logs\n   * @memberof Logger\n   */\n  clearLogs(): void {\n    this.logs = [];\n  }\n\n  /**\n   * Starts a timer with the specified label.\n   *\n   * Creates a named timer that can be used to measure the duration of operations.\n   * The timer continues until {@link Logger.timeEnd} is called with the same label.\n   * Multiple timers can run concurrently with different labels.\n   *\n   * @param {string} label - Unique identifier for this timer.\n   * @returns {void}\n   * @example\n   * logger.time('apiCall');\n   * const result = await fetchDataFromAPI();\n   * logger.timeEnd('apiCall'); // Logs: \"apiCall: 234.56ms\"\n   *\n   * @example\n   * // Nested timers for detailed performance analysis\n   * logger.time('fullProcess');\n   * logger.time('step1');\n   * await processStep1();\n   * logger.timeEnd('step1');\n   * logger.time('step2');\n   * await processStep2();\n   * logger.timeEnd('step2');\n   * logger.timeEnd('fullProcess');\n   *\n   * @see {@link Logger.timeEnd} - To stop the timer and log duration\n   * @memberof Logger\n   */\n  time(label: string): void {\n    this.timers.set(label, performance.now());\n  }\n\n  /**\n   * Stops a timer and logs the elapsed time.\n   *\n   * Stops the timer identified by the label and logs the duration at DEBUG level.\n   * If the timer doesn't exist, a warning is logged instead. The timer is\n   * automatically removed after logging.\n   *\n   * @param {string} label - The identifier of the timer to stop.\n   * @returns {void}\n   * @example\n   * logger.time('databaseQuery');\n   * const users = await db.query('SELECT * FROM users');\n   * logger.timeEnd('databaseQuery'); // Logs: \"databaseQuery: 45.23ms\"\n   *\n   * @example\n   * // Handling non-existent timer\n   * logger.timeEnd('nonExistentTimer'); // Logs warning: \"Timer 'nonExistentTimer' does not exist\"\n   *\n   * @see {@link Logger.time} - To start a timer\n   * @memberof Logger\n   */\n  timeEnd(label: string): void {\n    const start = this.timers.get(label);\n    if (start === undefined) {\n      this.warn(`Timer '${label}' does not exist`);\n      return;\n    }\n\n    const duration = performance.now() - start;\n    this.timers.delete(label);\n\n    this.debug(`${label}: ${duration.toFixed(2)}ms`, { duration });\n  }\n\n  /**\n   * Creates a new logger instance with additional persistent fields.\n   *\n   * The returned logger will automatically include the specified fields in\n   * every log entry. This is useful for adding consistent metadata like\n   * request IDs, user IDs, or session information. Fields are merged with\n   * any fields provided directly to log methods.\n   *\n   * @param {Record<string, any>} fields - Key-value pairs to include in all logs\n   *   from the returned logger instance.\n   * @returns {ILogger} A new logger instance with the additional fields.\n   * @example\n   * // Add request ID to all logs for a request handler\n   * app.use((req, res, next) => {\n   *   req.logger = logger.withFields({ requestId: req.id });\n   *   next();\n   * });\n   *\n   * @example\n   * // Chain with setContext for rich logging\n   * const userLogger = logger\n   *   .setContext('UserService')\n   *   .withFields({ userId: user.id, sessionId: session.id });\n   * userLogger.info('User action performed'); // Includes context and fields\n   *\n   * @see {@link Logger.setContext} - To add a context identifier\n   * @memberof Logger\n   */\n  withFields(fields: Record<string, any>): ILogger {\n    const fieldLogger = new Logger({\n      ...this.config,\n      transports: this.transports,\n    });\n    fieldLogger.context = this.context;\n    fieldLogger.logs = this.logs;\n    fieldLogger.fields = { ...this.fields, ...fields };\n    return fieldLogger;\n  }\n\n  /**\n   * Flushes all pending logs from all transports.\n   *\n   * This asynchronous method ensures that any buffered logs are written to their\n   * destinations. It's crucial to call this before application shutdown to prevent\n   * log loss. The method waits for all transports to complete their flush operations.\n   *\n   * @returns {Promise<void>} A promise that resolves when all transports have\n   *   successfully flushed their buffers.\n   * @throws {Error} If any transport fails to flush. The error from the first\n   *   failing transport is thrown.\n   * @example\n   * // Graceful shutdown\n   * process.on('SIGTERM', async () => {\n   *   logger.info('Shutting down gracefully');\n   *   await logger.flush();\n   *   process.exit(0);\n   * });\n   *\n   * @example\n   * // Ensure logs are flushed after batch operation\n   * await processBatchJob();\n   * await logger.flush(); // Make sure all logs are persisted\n   *\n   * @async\n   * @memberof Logger\n   */\n  async flush(): Promise<void> {\n    await Promise.all(this.transports.map((t) => t.flush()));\n  }\n}\n\n// Singleton instance\nlet loggerInstance: Logger | null = null;\n\n/**\n * Retrieves the global singleton logger instance.\n *\n * This function returns the application's shared logger instance, creating it\n * on first call. The logger is automatically configured with platform detection\n * fields. This is the recommended way to access logging functionality throughout\n * the application.\n *\n * @returns {ILogger} The global logger instance.\n * @example\n * // Basic usage\n * import { getLogger } from '@shared/services/logging/Logger';\n * const logger = getLogger();\n * logger.info('Application started');\n *\n * @example\n * // With context for module-specific logging\n * const logger = getLogger().setContext('AuthModule');\n * logger.debug('Processing authentication request');\n *\n * @see {@link createLogger} - To create a custom logger instance\n * @see {@link resetLogger} - To reset the global instance (testing)\n * @since 1.0.0\n */\nexport function getLogger(): ILogger {\n  if (!loggerInstance) {\n    loggerInstance = new Logger();\n\n    // Add platform info to all logs\n    const platform = getPlatformDetection();\n    loggerInstance = loggerInstance.withFields({\n      platform: {\n        isWeb: platform.isWeb(),\n        isMobile: platform.isMobile(),\n        isAndroid: platform.isAndroid(),\n        isIOS: platform.isIOS(),\n      },\n    }) as Logger;\n  }\n  return loggerInstance;\n}\n\n/**\n * Creates a new logger instance with custom configuration.\n *\n * Use this function when you need a logger with specific settings that differ\n * from the global logger. Each created logger is independent and maintains\n * its own configuration and log storage.\n *\n * @param {Partial<LoggerConfig>} [config] - Custom configuration options.\n * @param {LogLevel} [config.minLevel] - Minimum level for logs to be processed.\n * @param {boolean} [config.enableConsole] - Whether to output logs to console.\n * @param {boolean} [config.enableRemote] - Whether to send logs to remote endpoint.\n * @param {string} [config.remoteEndpoint] - URL for remote log collection.\n * @param {number} [config.maxLogSize=1000] - Maximum number of logs to store in memory.\n * @param {ILogTransport[]} [config.transports] - Custom transports (for testing/extensions).\n * @returns {ILogger} A new logger instance with the specified configuration.\n * @example\n * // Create a logger for testing with only console output\n * const testLogger = createLogger({\n *   minLevel: LogLevel.DEBUG,\n *   enableConsole: true,\n *   enableRemote: false\n * });\n *\n * @example\n * // Create a production logger with remote logging\n * const prodLogger = createLogger({\n *   minLevel: LogLevel.INFO,\n *   enableRemote: true,\n *   remoteEndpoint: 'https://logs.myapp.com/ingest',\n *   maxLogSize: 5000\n * });\n *\n * @see {@link getLogger} - For the global singleton logger\n * @since 1.0.0\n */\nexport function createLogger(config?: Partial<LoggerConfig>): ILogger {\n  return new Logger(config);\n}\n\n/**\n * Resets the global logger instance.\n *\n * This function clears the singleton logger instance, forcing a new instance\n * to be created on the next call to {@link getLogger}. This is primarily\n * useful for testing scenarios where you need a fresh logger state between tests.\n *\n * @returns {void}\n * @example\n * // In test setup\n * beforeEach(() => {\n *   resetLogger();\n * });\n *\n * @example\n * // Reset logger after changing environment variables\n * process.env.NODE_ENV = 'test';\n * resetLogger(); // Next getLogger() call will use test configuration\n *\n * @see {@link getLogger} - To get the global logger instance\n * @since 1.0.0\n */\nexport function resetLogger(): void {\n  loggerInstance = null;\n}\n\n// Export for testing purposes\nexport { RemoteTransport };\n"],"names":["Logger","RemoteTransport","createLogger","getLogger","resetLogger","DEFAULT_CONFIG","minLevel","process","env","NODE_ENV","LogLevel","INFO","DEBUG","enableConsole","enableRemote","enableFileLogging","maxLogSize","DefaultLogFormatter","format","entry","timestamp","toISOString","level","context","message","data","JSON","stringify","e","String","error","stack","ConsoleTransport","log","formatted","formatter","console","debug","info","WARN","warn","ERROR","FATAL","flush","buffer","push","length","batchSize","catch","isFlushing","endpoint","entriesToFlush","response","fetch","method","headers","body","logs","ok","Error","status","unshift","setupTransports","transports","config","remoteEndpoint","shouldLog","logContext","contextWhitelist","includes","contextBlacklist","Date","fields","undefined","shift","forEach","transport","fatal","setContext","contextLogger","clearContext","getConfig","updateConfig","getLogs","filter","maxLevel","startTime","endTime","searchText","searchLower","toLowerCase","inMessage","inContext","inData","clearLogs","time","label","timers","set","performance","now","timeEnd","start","get","duration","delete","toFixed","withFields","fieldLogger","Promise","all","map","t","Map","loggerInstance","platform","getPlatformDetection","isWeb","isMobile","isAndroid","isIOS"],"mappings":"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"}