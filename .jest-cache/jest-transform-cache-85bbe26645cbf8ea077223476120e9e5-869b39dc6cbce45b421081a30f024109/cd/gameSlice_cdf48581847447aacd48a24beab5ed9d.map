{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/slices/gameSlice.ts"],"sourcesContent":["/**\n * @file Game state slice for Zustand store\n * @module store/slices/gameSlice\n * @description Manages chess game state including board position, move history, and game flow.\n * This slice handles the core chess logic and maintains the current game state.\n *\n * @example\n * ```typescript\n * // Using the game slice in a component\n * import { useStore } from '@/store';\n * import { gameSelectors } from '@/store/slices/gameSlice';\n *\n * function ChessBoard() {\n *   const fen = useStore(gameSelectors.selectCurrentFen);\n *   const moveHistory = useStore(gameSelectors.selectMoveHistory);\n *   const makeMove = useStore(state => state.makeMove);\n *\n *   const handleMove = (move) => {\n *     makeMove(move);\n *   };\n * }\n * ```\n */\n\nimport { ImmerStateCreator, GameSlice } from \"./types\";\nimport type { ValidatedMove } from \"@shared/types\";\nimport { chessService } from \"@shared/services/ChessService\";\n// Logger removed - not used in this slice\n\n/**\n * Initial state for the game slice\n * Exported separately to enable proper store reset in tests\n * Note: Chess instance now managed by ChessService, not stored in state\n */\nexport const initialGameState = {\n  // game field removed - Chess instance managed by ChessService\n  currentFen: \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\",\n  currentPgn: \"\",\n  moveHistory: [] as ValidatedMove[],\n  currentMoveIndex: -1,\n  isGameFinished: false,\n  gameResult: null as string | null,\n  // Game status flags\n  isCheckmate: false,\n  isDraw: false,\n  isStalemate: false,\n};\n\n/**\n * Creates the initial game state with default values\n * @deprecated Use initialGameState export directly\n */\nexport const createInitialGameState = () => ({ ...initialGameState });\n\n/**\n * Creates the game slice for the Zustand store\n *\n * @param {Function} set - Zustand's set function for state updates\n * @param {Function} get - Zustand's get function for accessing current state\n * @returns {GameSlice} Complete game slice with state and actions\n *\n * @remarks\n * This slice manages the core chess game state and provides actions for\n * game manipulation. It works closely with the training and tablebase slices\n * for complete functionality. The slice uses chess.js for move validation\n * and game rule enforcement.\n *\n * @example\n * ```typescript\n * // In your root store\n * import { create } from 'zustand';\n * import { createGameSlice } from './slices/gameSlice';\n *\n * const useStore = create<RootState>()((...args) => ({\n *   ...createGameSlice(...args),\n *   ...createUISlice(...args),\n *   // ... other slices\n * }));\n * ```\n */\nexport const createGameSlice: ImmerStateCreator<GameSlice> = (set, get) => ({\n  // Initial state\n  ...createInitialGameState(),\n\n  // Actions\n\n  // State management actions\n  // setGame removed - Chess instances created on-demand from FEN\n  updatePosition: (fen: string, pgn: string) =>\n    set((state) => { \n      state.game.currentFen = fen;\n      state.game.currentPgn = pgn;\n    }),\n  addMove: (move: ValidatedMove) => {\n    const { game: gameState } = get();\n    const newHistory = gameState.moveHistory.slice(0, gameState.currentMoveIndex + 1);\n    newHistory.push(move);\n    set((state) => {\n      state.game.moveHistory = newHistory;\n      state.game.currentMoveIndex = newHistory.length - 1;\n    });\n  },\n  setMoveHistory: (moves: ValidatedMove[]) => set((state) => { state.game.moveHistory = moves; }),\n  setCurrentMoveIndex: (index: number) => set((state) => { state.game.currentMoveIndex = index; }),\n  setGameFinished: (finished: boolean) => set((state) => { state.game.isGameFinished = finished; }),\n  setGameStatus: (isCheckmate: boolean, isDraw: boolean, isStalemate: boolean) => set((state) => {\n    state.game.isCheckmate = isCheckmate;\n    state.game.isDraw = isDraw;  \n    state.game.isStalemate = isStalemate;\n  }),\n\n  /**\n   * Initializes a new chess game with the given FEN position\n   *\n   * @param {string} fen - The FEN string representing the starting position\n   * @returns {boolean} Whether the game was successfully initialized\n   *\n   * @fires stateChange - When game is initialized\n   *\n   * @remarks\n   * - Uses ChessService to validate and initialize position\n   * - Resets move history and game state\n   * - Returns false if FEN is invalid\n   *\n   * @example\n   * ```typescript\n   * // Initialize with standard starting position\n   * const success = store.getState().initializeGame(\n   *   \"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1\"\n   * );\n   *\n   * // Initialize with endgame position\n   * store.getState().initializeGame(\"8/8/8/8/8/8/R7/K3k3 w - - 0 1\");\n   * ```\n   */\n  initializeGame: (fen: string) => {\n    // ChessService will emit 'load' event, triggering automatic sync via rootStore subscription\n    return chessService.initialize(fen);\n  },\n\n  /**\n   * Makes a move on the chess board\n   *\n   * @param {Object|string} move - Move object with from/to/promotion or algebraic notation\n   * @param {string} move.from - Starting square (e.g., \"e2\")\n   * @param {string} move.to - Target square (e.g., \"e4\")\n   * @param {string} [move.promotion] - Promotion piece (\"q\", \"r\", \"b\", \"n\")\n   * @returns {ValidatedMove|null} The validated move object or null if invalid\n   *\n   * @fires stateChange - When move is successfully made\n   *\n   * @remarks\n   * - Validates moves using chess.js rules\n   * - Updates move history and current position\n   * - Checks for game ending conditions\n   * - Handles pawn promotion\n   * - Truncates future moves if moving from middle of history\n   *\n   * @example\n   * ```typescript\n   * // Make a move using object notation\n   * const move = store.getState().makeMove({ from: \"e2\", to: \"e4\" });\n   *\n   * // Make a move with promotion\n   * const promotion = store.getState().makeMove({\n   *   from: \"e7\",\n   *   to: \"e8\",\n   *   promotion: \"q\"\n   * });\n   *\n   * // Make a move using algebraic notation\n   * const algMove = store.getState().makeMove(\"Nf3\");\n   * ```\n   */\n  makeMove: (\n    move: { from: string; to: string; promotion?: string } | string,\n  ) => {\n    // ChessService will emit 'move' event, triggering automatic sync via rootStore subscription\n    return chessService.move(move);\n  },\n\n  /**\n   * Undoes the last move\n   *\n   * @returns {boolean} Whether the undo was successful\n   *\n   * @fires stateChange - When move is undone\n   *\n   * @remarks\n   * - Can only undo if there are moves in history\n   * - Updates the game state to the previous position\n   * - Maintains move history for redo functionality\n   *\n   * @example\n   * ```typescript\n   * // Undo the last move\n   * const success = store.getState().undoMove();\n   * if (!success) {\n   *   console.log(\"No moves to undo\");\n   * }\n   * ```\n   */\n  undoMove: () => {\n    // ChessService will emit 'undo' event, triggering automatic sync via rootStore subscription\n    return chessService.undo();\n  },\n\n  /**\n   * Redoes a previously undone move\n   *\n   * @returns {boolean} Whether the redo was successful\n   *\n   * @fires stateChange - When move is redone\n   *\n   * @remarks\n   * - Can only redo if there are future moves in history\n   * - Restores the game state to the next position\n   * - Preserves the original move timestamps\n   *\n   * @example\n   * ```typescript\n   * // Redo a previously undone move\n   * const success = store.getState().redoMove();\n   * if (!success) {\n   *   console.log(\"No moves to redo\");\n   * }\n   * ```\n   */\n  redoMove: () => {\n    // ChessService will emit 'redo' event, triggering automatic sync via rootStore subscription\n    return chessService.redo();\n  },\n\n  /**\n   * Navigates to a specific move in the game history\n   *\n   * @param {number} moveIndex - The index of the move to go to (-1 for start position)\n   * @returns {boolean} Whether the navigation was successful\n   *\n   * @fires stateChange - When position changes\n   *\n   * @remarks\n   * - Allows jumping to any position in the game history\n   * - Index -1 represents the starting position\n   * - Validates the index is within bounds\n   * - Updates all game state to match the target position\n   *\n   * @example\n   * ```typescript\n   * // Go to starting position\n   * store.getState().goToMove(-1);\n   *\n   * // Go to move 5\n   * store.getState().goToMove(4); // 0-indexed\n   *\n   * // Go to last move\n   * const history = store.getState().moveHistory;\n   * store.getState().goToMove(history.length - 1);\n   * ```\n   */\n  goToMove: (moveIndex: number) => {\n    // ChessService will emit 'load' event, triggering automatic sync via rootStore subscription\n    return chessService.goToMove(moveIndex);\n  },\n\n  /**\n   * Navigates to the first move (starting position)\n   *\n   * @fires stateChange - When position changes\n   *\n   * @remarks\n   * This is a convenience method that calls goToMove(-1)\n   *\n   * @example\n   * ```typescript\n   * // Go to starting position\n   * store.getState().goToFirst();\n   * ```\n   */\n  goToFirst: () => {\n    chessService.goToMove(-1);\n  },\n\n  /**\n   * Navigates to the previous move\n   *\n   * @fires stateChange - When position changes\n   *\n   * @remarks\n   * If no current move index is set, assumes we're at the last move\n   *\n   * @example\n   * ```typescript\n   * // Go to previous move\n   * store.getState().goToPrevious();\n   * ```\n   */\n  goToPrevious: () => {\n    const { game } = get();\n    const currentIndex = game.currentMoveIndex ?? game.moveHistory.length - 1;\n    chessService.goToMove(currentIndex - 1);\n  },\n\n  /**\n   * Navigates to the next move\n   *\n   * @fires stateChange - When position changes\n   *\n   * @remarks\n   * If no current move index is set, assumes we're at the starting position\n   *\n   * @example\n   * ```typescript\n   * // Go to next move\n   * store.getState().goToNext();\n   * ```\n   */\n  goToNext: () => {\n    const { game } = get();\n    const currentIndex = game.currentMoveIndex ?? -1;\n    chessService.goToMove(currentIndex + 1);\n  },\n\n  /**\n   * Navigates to the last move\n   *\n   * @fires stateChange - When position changes\n   *\n   * @remarks\n   * This is a convenience method that navigates to the last move in history\n   *\n   * @example\n   * ```typescript\n   * // Go to last move\n   * store.getState().goToLast();\n   * ```\n   */\n  goToLast: () => {\n    const { game } = get();\n    chessService.goToMove(game.moveHistory.length - 1);\n  },\n\n  /**\n   * Resets the game to the initial position\n   *\n   * @fires stateChange - When game is reset\n   *\n   * @remarks\n   * - Clears all move history\n   * - Resets to standard chess starting position\n   * - Resets all game flags (isGameOver, gameResult)\n   *\n   * @example\n   * ```typescript\n   * // Reset the game\n   * store.getState().resetGame();\n   * ```\n   */\n  resetGame: () => {\n    // ChessService will emit 'reset' event, triggering automatic sync via rootStore subscription\n    chessService.reset();\n  },\n\n  /**\n   * Sets the current FEN position directly\n   *\n   * @param {string} fen - The FEN string to set\n   * @returns {boolean} Whether the FEN was successfully set\n   *\n   * @fires stateChange - When FEN is updated\n   *\n   * @remarks\n   * - Validates the FEN string before setting\n   * - Clears move history when setting a new position\n   * - Use initializeGame instead if you want to start a new game\n   *\n   * @example\n   * ```typescript\n   * // Set an endgame position\n   * const success = store.getState().setCurrentFen(\n   *   \"8/8/8/8/8/8/R7/K3k3 w - - 0 1\"\n   * );\n   * ```\n   */\n  setCurrentFen: (fen: string) => {\n    return chessService.initialize(fen);\n  },\n});\n\n// Helper function removed - now using chessService.getGameResult()\n\n/**\n * Selector functions for efficient state access\n *\n * @remarks\n * These selectors provide a consistent API for accessing game state\n * and can be used with Zustand's subscribe mechanism for optimal\n * re-renders. Use these instead of inline selectors when possible.\n *\n * @example\n * ```typescript\n * import { useStore } from '@/store';\n * import { gameSelectors } from '@/store/slices/gameSlice';\n *\n * // In a component\n * const fen = useStore(gameSelectors.selectCurrentFen);\n * const isWhiteTurn = useStore(gameSelectors.selectIsWhiteTurn);\n * const canUndo = useStore(gameSelectors.selectCanUndo);\n * ```\n */\nexport const gameSelectors = {\n  // selectGame removed - Chess instance now managed by ChessService\n\n  /**\n   * Selects the current FEN position\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {string} The current position in FEN notation\n   */\n  selectCurrentFen: (state: GameSlice) => state.currentFen,\n\n  /**\n   * Selects the move history\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {ValidatedMove[]} Array of validated moves\n   */\n  selectMoveHistory: (state: GameSlice) => state.moveHistory,\n\n  /**\n   * Selects the current move index\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {number} Current position in move history (-1 for start)\n   */\n  selectCurrentMoveIndex: (state: GameSlice) => state.currentMoveIndex,\n\n  /**\n   * Selects whether the game is over\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {boolean} Whether the game has ended\n   */\n  selectIsGameOver: (state: GameSlice) => state.isGameFinished,\n\n  /**\n   * Selects the game result\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {string|null} Game result or null if ongoing\n   */\n  selectGameResult: (state: GameSlice) => state.gameResult,\n\n  /**\n   * Selects whether it's white's turn\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {boolean} True if white to move, false if black\n   */\n  selectIsWhiteTurn: (state: GameSlice) => {\n    // Derive from FEN string (turn is the second part)\n    const parts = state.currentFen.split(' ');\n    return parts[1] === 'w';\n  },\n\n  /**\n   * Selects whether undo is possible\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {boolean} True if there are moves to undo\n   */\n  selectCanUndo: (state: GameSlice) => state.currentMoveIndex >= 0,\n\n  /**\n   * Selects whether redo is possible\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {boolean} True if there are moves to redo\n   */\n  selectCanRedo: (state: GameSlice) =>\n    state.currentMoveIndex < state.moveHistory.length - 1,\n\n  /**\n   * Selects the last move made\n   * @param {GameSlice} state - The game slice of the store\n   * @returns {ValidatedMove|null} The last move or null if no moves\n   */\n  selectLastMove: (state: GameSlice) => {\n    const { currentMoveIndex, moveHistory } = state;\n    return currentMoveIndex >= 0 ? moveHistory[currentMoveIndex] : null;\n  },\n\n  /**\n   * Selects legal moves for a square\n   * @param {string} square - The square to get moves for (e.g., \"e2\")\n   * @returns {Function} Selector function that returns array of legal moves\n   *\n   * @example\n   * ```typescript\n   * const e2Moves = useStore(gameSelectors.selectLegalMoves('e2'));\n   * ```\n   */\n  selectLegalMoves: (square: string) => (_state: GameSlice) => {\n    // Use ChessService to get legal moves\n    try {\n      return chessService.moves({ square, verbose: true });\n    } catch {\n      return [];\n    }\n  },\n};\n"],"names":["createGameSlice","createInitialGameState","gameSelectors","initialGameState","currentFen","currentPgn","moveHistory","currentMoveIndex","isGameFinished","gameResult","isCheckmate","isDraw","isStalemate","set","get","updatePosition","fen","pgn","state","game","addMove","move","gameState","newHistory","slice","push","length","setMoveHistory","moves","setCurrentMoveIndex","index","setGameFinished","finished","setGameStatus","initializeGame","chessService","initialize","makeMove","undoMove","undo","redoMove","redo","goToMove","moveIndex","goToFirst","goToPrevious","currentIndex","goToNext","goToLast","resetGame","reset","setCurrentFen","selectCurrentFen","selectMoveHistory","selectCurrentMoveIndex","selectIsGameOver","selectGameResult","selectIsWhiteTurn","parts","split","selectCanUndo","selectCanRedo","selectLastMove","selectLegalMoves","square","_state","verbose"],"mappings":"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"}