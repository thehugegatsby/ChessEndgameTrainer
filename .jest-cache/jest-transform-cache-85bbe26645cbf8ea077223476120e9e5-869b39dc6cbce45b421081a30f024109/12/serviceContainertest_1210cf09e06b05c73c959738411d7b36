eba9e8a65df7e2f7c956553fc0fa59a0
/**
 * ServiceContainer Validation Test
 * Simple test to validate core Jest 30 migration functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _utils = require("../utils");
const _index = require("../../shared/constants/index");
describe("ServiceContainer Validation - Jest 30 Migration", ()=>{
    describe("Basic Container Functionality", ()=>{
        let container;
        let storageService;
        let mockStorage;
        beforeEach(()=>{
            container = (0, _utils.createTestContainer)();
            storageService = container.resolve("platform.storage");
            mockStorage = container.resolveCustom("browser.localStorage");
        });
        test("should create container with platform services", ()=>{
            expect(container).toBeDefined();
            expect(storageService).toBeDefined();
            expect(mockStorage).toBeDefined();
        });
        test("should resolve storage service correctly", ()=>{
            expect(typeof storageService.save).toBe("function");
            expect(typeof storageService.load).toBe("function");
            expect(typeof storageService.remove).toBe("function");
            expect(typeof storageService.clear).toBe("function");
            expect(typeof storageService.getAllKeys).toBe("function");
        });
        test("should provide working mocks", ()=>{
            expect(jest.isMockFunction(mockStorage.setItem)).toBe(true);
            expect(jest.isMockFunction(mockStorage.getItem)).toBe(true);
            expect(jest.isMockFunction(mockStorage.removeItem)).toBe(true);
        });
        test("should save data with proper prefix", async ()=>{
            const testKey = "validation-key";
            const testData = {
                validation: true,
                count: 42
            };
            await storageService.save(testKey, testData);
            _utils.TestAssertions.expectStorageCall(mockStorage, "setItem", `${_index.STORAGE.PREFIX}validation-key`, JSON.stringify(testData));
        });
        test("should load data correctly", async ()=>{
            const testKey = "load-test";
            const testData = {
                loaded: true
            };
            // Mock return value
            mockStorage.getItem.mockReturnValue(JSON.stringify(testData));
            const result = await storageService.load(testKey);
            expect(mockStorage.getItem).toHaveBeenCalledWith(`${_index.STORAGE.PREFIX}load-test`);
            expect(result).toEqual(testData);
        });
        test("should handle null values", async ()=>{
            mockStorage.getItem.mockReturnValue(null);
            const result = await storageService.load("non-existent");
            expect(result).toBeNull();
        });
        test("should provide perfect test isolation", async ()=>{
            // Test isolation: fresh container = clean state
            const container1 = (0, _utils.createTestContainer)();
            const storage1 = container1.resolve("platform.storage");
            await storage1.save("isolation-test", "data1");
            const container2 = (0, _utils.createTestContainer)();
            const storage2 = container2.resolve("platform.storage");
            const result = await storage2.load("isolation-test");
            expect(result).toBeNull(); // No data leakage
        });
    });
    describe("Pre-configured Scenarios", ()=>{
        test("should work with offline scenario", ()=>{
            const container = _utils.TestScenarios.offline();
            const deviceService = container.resolve("platform.device");
            const networkStatus = deviceService.getNetworkStatus();
            expect(networkStatus.isOnline).toBe(false);
            expect(networkStatus.type).toBe("none");
        });
        test("should work with pre-populated storage", async ()=>{
            const container = _utils.TestScenarios.withStorageData({
                "chess_trainer_test-key": JSON.stringify({
                    preset: "value"
                })
            });
            const storageService = container.resolve("platform.storage");
            const result = await storageService.load("test-key");
            expect(result).toEqual({
                preset: "value"
            });
        });
        test("should work with low memory scenario", ()=>{
            const container = _utils.TestScenarios.lowMemory();
            const deviceService = container.resolve("platform.device");
            const memoryInfo = deviceService.getMemoryInfo();
            expect(memoryInfo.totalMemory).toBeLessThan(4 * 1024 * 1024 * 1024); // Less than 4GB
        });
    });
    describe("Error Handling", ()=>{
        test("should handle storage errors gracefully", async ()=>{
            const failingStorage = {
                setItem: jest.fn().mockImplementation(()=>{
                    throw new Error("QuotaExceededError");
                }),
                getItem: jest.fn(),
                removeItem: jest.fn(),
                clear: jest.fn(),
                key: jest.fn(),
                length: 0
            };
            const container = (0, _utils.createTestContainer)({
                localStorage: failingStorage
            });
            const storageService = container.resolve("platform.storage");
            await expect(storageService.save("key", "data")).rejects.toThrow("Failed to save data");
        });
        test("should handle corrupted JSON gracefully", async ()=>{
            const corruptedStorage = {
                getItem: jest.fn().mockReturnValue("invalid-json{"),
                setItem: jest.fn(),
                removeItem: jest.fn(),
                clear: jest.fn(),
                key: jest.fn(),
                length: 0
            };
            const container = (0, _utils.createTestContainer)({
                localStorage: corruptedStorage
            });
            const storageService = container.resolve("platform.storage");
            const result = await storageService.load("corrupted-key");
            expect(result).toBeNull();
        });
    });
    describe("Performance Validation", ()=>{
        test("container creation should be fast", ()=>{
            const start = performance.now();
            for(let i = 0; i < 50; i++){
                const container = (0, _utils.createTestContainer)();
                container.resolve("platform.storage");
                container.resolve("platform.device");
            }
            const end = performance.now();
            const duration = end - start;
            expect(duration).toBeLessThan(500); // 50 containers in <500ms
        });
        test("multiple services should resolve efficiently", ()=>{
            const container = (0, _utils.createTestContainer)();
            const start = Date.now();
            const storage = container.resolve("platform.storage");
            const device = container.resolve("platform.device");
            const notifications = container.resolve("platform.notifications");
            const performanceService = container.resolve("platform.performance");
            const clipboard = container.resolve("platform.clipboard");
            const share = container.resolve("platform.share");
            const analytics = container.resolve("platform.analytics");
            const end = Date.now();
            const duration = end - start;
            expect(duration).toBeLessThan(50); // All services in <50ms
            expect(storage).toBeDefined();
            expect(device).toBeDefined();
            expect(notifications).toBeDefined();
            expect(performanceService).toBeDefined();
            expect(clipboard).toBeDefined();
            expect(share).toBeDefined();
            expect(analytics).toBeDefined();
        });
    });
    describe("Jest 30 Compatibility Verification", ()=>{
        test("should work without global localStorage mocking", ()=>{
            // This test verifies we're not using global mocks
            const container = (0, _utils.createTestContainer)();
            const mockStorage = container.resolveCustom("browser.localStorage");
            // Mock is isolated to container, not global
            expect(jest.isMockFunction(mockStorage.setItem)).toBe(true);
            // Global localStorage should be unaffected
            if (typeof window !== "undefined" && window.localStorage) {
                expect(jest.isMockFunction(window.localStorage.setItem)).toBe(false);
            }
        });
        test("should provide proper mock isolation", ()=>{
            const container1 = (0, _utils.createTestContainer)();
            const container2 = (0, _utils.createTestContainer)();
            const mock1 = container1.resolveCustom("browser.localStorage");
            const mock2 = container2.resolveCustom("browser.localStorage");
            // Different containers = different mocks
            expect(mock1).not.toBe(mock2);
            // Both should be mocks
            expect(jest.isMockFunction(mock1.setItem)).toBe(true);
            expect(jest.isMockFunction(mock2.setItem)).toBe(true);
        });
        test("should support async patterns with proper cleanup", async ()=>{
            const container = (0, _utils.createTestContainer)();
            const storageService = container.resolve("platform.storage");
            // Multiple async operations should work cleanly
            await Promise.all([
                storageService.save("async1", "data1"),
                storageService.save("async2", "data2"),
                storageService.save("async3", "data3")
            ]);
            const results = await Promise.all([
                storageService.load("async1"),
                storageService.load("async2"),
                storageService.load("async3")
            ]);
            // Note: these will be null because mocks don't persist data by default
            // but the operations should complete successfully
            expect(results).toHaveLength(3);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdmFsaWRhdGlvbi9zZXJ2aWNlQ29udGFpbmVyLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZXJ2aWNlQ29udGFpbmVyIFZhbGlkYXRpb24gVGVzdFxuICogU2ltcGxlIHRlc3QgdG8gdmFsaWRhdGUgY29yZSBKZXN0IDMwIG1pZ3JhdGlvbiBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlVGVzdENvbnRhaW5lciwgVGVzdFNjZW5hcmlvcywgVGVzdEFzc2VydGlvbnMgfSBmcm9tIFwiLi4vdXRpbHNcIjtcbmltcG9ydCB0eXBlIHsgSVBsYXRmb3JtU3RvcmFnZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL3BsYXRmb3JtL3R5cGVzXCI7XG5pbXBvcnQgeyBTVE9SQUdFIH0gZnJvbSBcIkBzaGFyZWQvY29uc3RhbnRzL2luZGV4XCI7XG5cbmRlc2NyaWJlKFwiU2VydmljZUNvbnRhaW5lciBWYWxpZGF0aW9uIC0gSmVzdCAzMCBNaWdyYXRpb25cIiwgKCkgPT4ge1xuICBkZXNjcmliZShcIkJhc2ljIENvbnRhaW5lciBGdW5jdGlvbmFsaXR5XCIsICgpID0+IHtcbiAgICBsZXQgY29udGFpbmVyOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVUZXN0Q29udGFpbmVyPjtcbiAgICBsZXQgc3RvcmFnZVNlcnZpY2U6IElQbGF0Zm9ybVN0b3JhZ2U7XG4gICAgbGV0IG1vY2tTdG9yYWdlOiBTdG9yYWdlO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBjb250YWluZXIgPSBjcmVhdGVUZXN0Q29udGFpbmVyKCk7XG4gICAgICBzdG9yYWdlU2VydmljZSA9IGNvbnRhaW5lci5yZXNvbHZlKFwicGxhdGZvcm0uc3RvcmFnZVwiKTtcbiAgICAgIG1vY2tTdG9yYWdlID0gY29udGFpbmVyLnJlc29sdmVDdXN0b208U3RvcmFnZT4oXCJicm93c2VyLmxvY2FsU3RvcmFnZVwiKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgY3JlYXRlIGNvbnRhaW5lciB3aXRoIHBsYXRmb3JtIHNlcnZpY2VzXCIsICgpID0+IHtcbiAgICAgIGV4cGVjdChjb250YWluZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3RvcmFnZVNlcnZpY2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobW9ja1N0b3JhZ2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHJlc29sdmUgc3RvcmFnZSBzZXJ2aWNlIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBleHBlY3QodHlwZW9mIHN0b3JhZ2VTZXJ2aWNlLnNhdmUpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RvcmFnZVNlcnZpY2UubG9hZCkudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgICAgZXhwZWN0KHR5cGVvZiBzdG9yYWdlU2VydmljZS5yZW1vdmUpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RvcmFnZVNlcnZpY2UuY2xlYXIpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RvcmFnZVNlcnZpY2UuZ2V0QWxsS2V5cykudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBwcm92aWRlIHdvcmtpbmcgbW9ja3NcIiwgKCkgPT4ge1xuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9ja1N0b3JhZ2Uuc2V0SXRlbSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoamVzdC5pc01vY2tGdW5jdGlvbihtb2NrU3RvcmFnZS5nZXRJdGVtKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChqZXN0LmlzTW9ja0Z1bmN0aW9uKG1vY2tTdG9yYWdlLnJlbW92ZUl0ZW0pKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBzYXZlIGRhdGEgd2l0aCBwcm9wZXIgcHJlZml4XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RLZXkgPSBcInZhbGlkYXRpb24ta2V5XCI7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgdmFsaWRhdGlvbjogdHJ1ZSwgY291bnQ6IDQyIH07XG5cbiAgICAgIGF3YWl0IHN0b3JhZ2VTZXJ2aWNlLnNhdmUodGVzdEtleSwgdGVzdERhdGEpO1xuXG4gICAgICBUZXN0QXNzZXJ0aW9ucy5leHBlY3RTdG9yYWdlQ2FsbChcbiAgICAgICAgbW9ja1N0b3JhZ2UsXG4gICAgICAgIFwic2V0SXRlbVwiLFxuICAgICAgICBgJHtTVE9SQUdFLlBSRUZJWH12YWxpZGF0aW9uLWtleWAsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHRlc3REYXRhKSxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIGxvYWQgZGF0YSBjb3JyZWN0bHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdEtleSA9IFwibG9hZC10ZXN0XCI7XG4gICAgICBjb25zdCB0ZXN0RGF0YSA9IHsgbG9hZGVkOiB0cnVlIH07XG5cbiAgICAgIC8vIE1vY2sgcmV0dXJuIHZhbHVlXG4gICAgICAobW9ja1N0b3JhZ2UuZ2V0SXRlbSBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZShcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkodGVzdERhdGEpLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmFnZVNlcnZpY2UubG9hZCh0ZXN0S2V5KTtcblxuICAgICAgZXhwZWN0KG1vY2tTdG9yYWdlLmdldEl0ZW0pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgJHtTVE9SQUdFLlBSRUZJWH1sb2FkLXRlc3RgLFxuICAgICAgKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwodGVzdERhdGEpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgbnVsbCB2YWx1ZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgKG1vY2tTdG9yYWdlLmdldEl0ZW0gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUobnVsbCk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JhZ2VTZXJ2aWNlLmxvYWQoXCJub24tZXhpc3RlbnRcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBwcm92aWRlIHBlcmZlY3QgdGVzdCBpc29sYXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBpc29sYXRpb246IGZyZXNoIGNvbnRhaW5lciA9IGNsZWFuIHN0YXRlXG4gICAgICBjb25zdCBjb250YWluZXIxID0gY3JlYXRlVGVzdENvbnRhaW5lcigpO1xuICAgICAgY29uc3Qgc3RvcmFnZTEgPSBjb250YWluZXIxLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuICAgICAgYXdhaXQgc3RvcmFnZTEuc2F2ZShcImlzb2xhdGlvbi10ZXN0XCIsIFwiZGF0YTFcIik7XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lcjIgPSBjcmVhdGVUZXN0Q29udGFpbmVyKCk7XG4gICAgICBjb25zdCBzdG9yYWdlMiA9IGNvbnRhaW5lcjIucmVzb2x2ZShcInBsYXRmb3JtLnN0b3JhZ2VcIik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzdG9yYWdlMi5sb2FkKFwiaXNvbGF0aW9uLXRlc3RcIik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7IC8vIE5vIGRhdGEgbGVha2FnZVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlByZS1jb25maWd1cmVkIFNjZW5hcmlvc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB3b3JrIHdpdGggb2ZmbGluZSBzY2VuYXJpb1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBUZXN0U2NlbmFyaW9zLm9mZmxpbmUoKTtcbiAgICAgIGNvbnN0IGRldmljZVNlcnZpY2UgPSBjb250YWluZXIucmVzb2x2ZShcInBsYXRmb3JtLmRldmljZVwiKTtcblxuICAgICAgY29uc3QgbmV0d29ya1N0YXR1cyA9IGRldmljZVNlcnZpY2UuZ2V0TmV0d29ya1N0YXR1cygpO1xuICAgICAgZXhwZWN0KG5ldHdvcmtTdGF0dXMuaXNPbmxpbmUpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KG5ldHdvcmtTdGF0dXMudHlwZSkudG9CZShcIm5vbmVcIik7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHdvcmsgd2l0aCBwcmUtcG9wdWxhdGVkIHN0b3JhZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gVGVzdFNjZW5hcmlvcy53aXRoU3RvcmFnZURhdGEoe1xuICAgICAgICBcImNoZXNzX3RyYWluZXJfdGVzdC1rZXlcIjogSlNPTi5zdHJpbmdpZnkoeyBwcmVzZXQ6IFwidmFsdWVcIiB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdG9yYWdlU2VydmljZSA9IGNvbnRhaW5lci5yZXNvbHZlKFwicGxhdGZvcm0uc3RvcmFnZVwiKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0b3JhZ2VTZXJ2aWNlLmxvYWQoXCJ0ZXN0LWtleVwiKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHByZXNldDogXCJ2YWx1ZVwiIH0pO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCB3b3JrIHdpdGggbG93IG1lbW9yeSBzY2VuYXJpb1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBUZXN0U2NlbmFyaW9zLmxvd01lbW9yeSgpO1xuICAgICAgY29uc3QgZGV2aWNlU2VydmljZSA9IGNvbnRhaW5lci5yZXNvbHZlKFwicGxhdGZvcm0uZGV2aWNlXCIpO1xuXG4gICAgICBjb25zdCBtZW1vcnlJbmZvID0gZGV2aWNlU2VydmljZS5nZXRNZW1vcnlJbmZvKCk7XG4gICAgICBleHBlY3QobWVtb3J5SW5mby50b3RhbE1lbW9yeSkudG9CZUxlc3NUaGFuKDQgKiAxMDI0ICogMTAyNCAqIDEwMjQpOyAvLyBMZXNzIHRoYW4gNEdCXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRXJyb3IgSGFuZGxpbmdcIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHN0b3JhZ2UgZXJyb3JzIGdyYWNlZnVsbHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmFpbGluZ1N0b3JhZ2UgPSB7XG4gICAgICAgIHNldEl0ZW06IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlF1b3RhRXhjZWVkZWRFcnJvclwiKTtcbiAgICAgICAgfSksXG4gICAgICAgIGdldEl0ZW06IGplc3QuZm4oKSxcbiAgICAgICAgcmVtb3ZlSXRlbTogamVzdC5mbigpLFxuICAgICAgICBjbGVhcjogamVzdC5mbigpLFxuICAgICAgICBrZXk6IGplc3QuZm4oKSxcbiAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgfSBhcyBTdG9yYWdlO1xuXG4gICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVUZXN0Q29udGFpbmVyKHsgbG9jYWxTdG9yYWdlOiBmYWlsaW5nU3RvcmFnZSB9KTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VTZXJ2aWNlID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuXG4gICAgICBhd2FpdCBleHBlY3Qoc3RvcmFnZVNlcnZpY2Uuc2F2ZShcImtleVwiLCBcImRhdGFcIikpLnJlamVjdHMudG9UaHJvdyhcbiAgICAgICAgXCJGYWlsZWQgdG8gc2F2ZSBkYXRhXCIsXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgY29ycnVwdGVkIEpTT04gZ3JhY2VmdWxseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb3JydXB0ZWRTdG9yYWdlID0ge1xuICAgICAgICBnZXRJdGVtOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFwiaW52YWxpZC1qc29ue1wiKSxcbiAgICAgICAgc2V0SXRlbTogamVzdC5mbigpLFxuICAgICAgICByZW1vdmVJdGVtOiBqZXN0LmZuKCksXG4gICAgICAgIGNsZWFyOiBqZXN0LmZuKCksXG4gICAgICAgIGtleTogamVzdC5mbigpLFxuICAgICAgICBsZW5ndGg6IDAsXG4gICAgICB9IGFzIFN0b3JhZ2U7XG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZVRlc3RDb250YWluZXIoeyBsb2NhbFN0b3JhZ2U6IGNvcnJ1cHRlZFN0b3JhZ2UgfSk7XG4gICAgICBjb25zdCBzdG9yYWdlU2VydmljZSA9IGNvbnRhaW5lci5yZXNvbHZlKFwicGxhdGZvcm0uc3RvcmFnZVwiKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3RvcmFnZVNlcnZpY2UubG9hZChcImNvcnJ1cHRlZC1rZXlcIik7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBlcmZvcm1hbmNlIFZhbGlkYXRpb25cIiwgKCkgPT4ge1xuICAgIHRlc3QoXCJjb250YWluZXIgY3JlYXRpb24gc2hvdWxkIGJlIGZhc3RcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcbiAgICAgICAgY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuICAgICAgICBjb250YWluZXIucmVzb2x2ZShcInBsYXRmb3JtLmRldmljZVwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MDApOyAvLyA1MCBjb250YWluZXJzIGluIDw1MDBtc1xuICAgIH0pO1xuXG4gICAgdGVzdChcIm11bHRpcGxlIHNlcnZpY2VzIHNob3VsZCByZXNvbHZlIGVmZmljaWVudGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcblxuICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuXG4gICAgICBjb25zdCBzdG9yYWdlID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuICAgICAgY29uc3QgZGV2aWNlID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5kZXZpY2VcIik7XG4gICAgICBjb25zdCBub3RpZmljYXRpb25zID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5ub3RpZmljYXRpb25zXCIpO1xuICAgICAgY29uc3QgcGVyZm9ybWFuY2VTZXJ2aWNlID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5wZXJmb3JtYW5jZVwiKTtcbiAgICAgIGNvbnN0IGNsaXBib2FyZCA9IGNvbnRhaW5lci5yZXNvbHZlKFwicGxhdGZvcm0uY2xpcGJvYXJkXCIpO1xuICAgICAgY29uc3Qgc2hhcmUgPSBjb250YWluZXIucmVzb2x2ZShcInBsYXRmb3JtLnNoYXJlXCIpO1xuICAgICAgY29uc3QgYW5hbHl0aWNzID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5hbmFseXRpY3NcIik7XG5cbiAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xuXG4gICAgICBleHBlY3QoZHVyYXRpb24pLnRvQmVMZXNzVGhhbig1MCk7IC8vIEFsbCBzZXJ2aWNlcyBpbiA8NTBtc1xuICAgICAgZXhwZWN0KHN0b3JhZ2UpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGV2aWNlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KG5vdGlmaWNhdGlvbnMpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocGVyZm9ybWFuY2VTZXJ2aWNlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGNsaXBib2FyZCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzaGFyZSkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChhbmFseXRpY3MpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiSmVzdCAzMCBDb21wYXRpYmlsaXR5IFZlcmlmaWNhdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB3b3JrIHdpdGhvdXQgZ2xvYmFsIGxvY2FsU3RvcmFnZSBtb2NraW5nXCIsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdCB2ZXJpZmllcyB3ZSdyZSBub3QgdXNpbmcgZ2xvYmFsIG1vY2tzXG4gICAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVUZXN0Q29udGFpbmVyKCk7XG4gICAgICBjb25zdCBtb2NrU3RvcmFnZSA9IGNvbnRhaW5lci5yZXNvbHZlQ3VzdG9tPFN0b3JhZ2U+KFxuICAgICAgICBcImJyb3dzZXIubG9jYWxTdG9yYWdlXCIsXG4gICAgICApO1xuXG4gICAgICAvLyBNb2NrIGlzIGlzb2xhdGVkIHRvIGNvbnRhaW5lciwgbm90IGdsb2JhbFxuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9ja1N0b3JhZ2Uuc2V0SXRlbSkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIC8vIEdsb2JhbCBsb2NhbFN0b3JhZ2Ugc2hvdWxkIGJlIHVuYWZmZWN0ZWRcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24od2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKSkudG9CZShmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIHByb3ZpZGUgcHJvcGVyIG1vY2sgaXNvbGF0aW9uXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lcjEgPSBjcmVhdGVUZXN0Q29udGFpbmVyKCk7XG4gICAgICBjb25zdCBjb250YWluZXIyID0gY3JlYXRlVGVzdENvbnRhaW5lcigpO1xuXG4gICAgICBjb25zdCBtb2NrMSA9IGNvbnRhaW5lcjEucmVzb2x2ZUN1c3RvbTxTdG9yYWdlPihcImJyb3dzZXIubG9jYWxTdG9yYWdlXCIpO1xuICAgICAgY29uc3QgbW9jazIgPSBjb250YWluZXIyLnJlc29sdmVDdXN0b208U3RvcmFnZT4oXCJicm93c2VyLmxvY2FsU3RvcmFnZVwiKTtcblxuICAgICAgLy8gRGlmZmVyZW50IGNvbnRhaW5lcnMgPSBkaWZmZXJlbnQgbW9ja3NcbiAgICAgIGV4cGVjdChtb2NrMSkubm90LnRvQmUobW9jazIpO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCBiZSBtb2Nrc1xuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9jazEuc2V0SXRlbSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoamVzdC5pc01vY2tGdW5jdGlvbihtb2NrMi5zZXRJdGVtKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcblxuICAgIHRlc3QoXCJzaG91bGQgc3VwcG9ydCBhc3luYyBwYXR0ZXJucyB3aXRoIHByb3BlciBjbGVhbnVwXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2VTZXJ2aWNlID0gY29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuXG4gICAgICAvLyBNdWx0aXBsZSBhc3luYyBvcGVyYXRpb25zIHNob3VsZCB3b3JrIGNsZWFubHlcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgc3RvcmFnZVNlcnZpY2Uuc2F2ZShcImFzeW5jMVwiLCBcImRhdGExXCIpLFxuICAgICAgICBzdG9yYWdlU2VydmljZS5zYXZlKFwiYXN5bmMyXCIsIFwiZGF0YTJcIiksXG4gICAgICAgIHN0b3JhZ2VTZXJ2aWNlLnNhdmUoXCJhc3luYzNcIiwgXCJkYXRhM1wiKSxcbiAgICAgIF0pO1xuXG4gICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzdG9yYWdlU2VydmljZS5sb2FkKFwiYXN5bmMxXCIpLFxuICAgICAgICBzdG9yYWdlU2VydmljZS5sb2FkKFwiYXN5bmMyXCIpLFxuICAgICAgICBzdG9yYWdlU2VydmljZS5sb2FkKFwiYXN5bmMzXCIpLFxuICAgICAgXSk7XG5cbiAgICAgIC8vIE5vdGU6IHRoZXNlIHdpbGwgYmUgbnVsbCBiZWNhdXNlIG1vY2tzIGRvbid0IHBlcnNpc3QgZGF0YSBieSBkZWZhdWx0XG4gICAgICAvLyBidXQgdGhlIG9wZXJhdGlvbnMgc2hvdWxkIGNvbXBsZXRlIHN1Y2Nlc3NmdWxseVxuICAgICAgZXhwZWN0KHJlc3VsdHMpLnRvSGF2ZUxlbmd0aCgzKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImNvbnRhaW5lciIsInN0b3JhZ2VTZXJ2aWNlIiwibW9ja1N0b3JhZ2UiLCJiZWZvcmVFYWNoIiwiY3JlYXRlVGVzdENvbnRhaW5lciIsInJlc29sdmUiLCJyZXNvbHZlQ3VzdG9tIiwidGVzdCIsImV4cGVjdCIsInRvQmVEZWZpbmVkIiwic2F2ZSIsInRvQmUiLCJsb2FkIiwicmVtb3ZlIiwiY2xlYXIiLCJnZXRBbGxLZXlzIiwiamVzdCIsImlzTW9ja0Z1bmN0aW9uIiwic2V0SXRlbSIsImdldEl0ZW0iLCJyZW1vdmVJdGVtIiwidGVzdEtleSIsInRlc3REYXRhIiwidmFsaWRhdGlvbiIsImNvdW50IiwiVGVzdEFzc2VydGlvbnMiLCJleHBlY3RTdG9yYWdlQ2FsbCIsIlNUT1JBR0UiLCJQUkVGSVgiLCJKU09OIiwic3RyaW5naWZ5IiwibG9hZGVkIiwibW9ja1JldHVyblZhbHVlIiwicmVzdWx0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ0b0VxdWFsIiwidG9CZU51bGwiLCJjb250YWluZXIxIiwic3RvcmFnZTEiLCJjb250YWluZXIyIiwic3RvcmFnZTIiLCJUZXN0U2NlbmFyaW9zIiwib2ZmbGluZSIsImRldmljZVNlcnZpY2UiLCJuZXR3b3JrU3RhdHVzIiwiZ2V0TmV0d29ya1N0YXR1cyIsImlzT25saW5lIiwidHlwZSIsIndpdGhTdG9yYWdlRGF0YSIsInByZXNldCIsImxvd01lbW9yeSIsIm1lbW9yeUluZm8iLCJnZXRNZW1vcnlJbmZvIiwidG90YWxNZW1vcnkiLCJ0b0JlTGVzc1RoYW4iLCJmYWlsaW5nU3RvcmFnZSIsImZuIiwibW9ja0ltcGxlbWVudGF0aW9uIiwiRXJyb3IiLCJrZXkiLCJsZW5ndGgiLCJsb2NhbFN0b3JhZ2UiLCJyZWplY3RzIiwidG9UaHJvdyIsImNvcnJ1cHRlZFN0b3JhZ2UiLCJzdGFydCIsInBlcmZvcm1hbmNlIiwibm93IiwiaSIsImVuZCIsImR1cmF0aW9uIiwiRGF0ZSIsInN0b3JhZ2UiLCJkZXZpY2UiLCJub3RpZmljYXRpb25zIiwicGVyZm9ybWFuY2VTZXJ2aWNlIiwiY2xpcGJvYXJkIiwic2hhcmUiLCJhbmFseXRpY3MiLCJ3aW5kb3ciLCJtb2NrMSIsIm1vY2syIiwibm90IiwiUHJvbWlzZSIsImFsbCIsInJlc3VsdHMiLCJ0b0hhdmVMZW5ndGgiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQzs7Ozt1QkFFa0U7dUJBRTNDO0FBRXhCQSxTQUFTLG1EQUFtRDtJQUMxREEsU0FBUyxpQ0FBaUM7UUFDeEMsSUFBSUM7UUFD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