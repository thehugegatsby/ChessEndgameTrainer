{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/orchestrators/loadTrainingContext.ts"],"sourcesContent":["/**\n * @file Load training context orchestrator\n * @module store/orchestrators/loadTrainingContext\n *\n * @description\n * Orchestrates loading a training position across game, training, and UI slices.\n * Sets up the complete training environment for a new endgame position.\n *\n * @remarks\n * This orchestrator is the main entry point for starting a training session.\n * It coordinates multiple slices to ensure proper initialization:\n * - Resets previous state to avoid conflicts\n * - Initializes chess.js with the position\n * - Configures training parameters\n * - Sets up initial turn order\n * - Requests initial analysis\n * - Tracks position progress\n *\n * The orchestrator handles both player-first and opponent-first scenarios,\n * automatically triggering the appropriate initial move or analysis.\n *\n * @example\n * ```typescript\n * // In a component\n * const loadContext = useStore(state => state.loadTrainingContext);\n *\n * await loadContext(endgamePosition);\n * ```\n */\n\nimport type { StoreApi } from \"./types\";\nimport type { EndgamePosition } from \"@shared/types/endgame\";\nimport type { TrainingPosition } from \"../slices/trainingSlice\";\nimport { getLogger } from \"@shared/services/logging\";\nimport { chessService } from \"@shared/services/ChessService\";\nimport { Chess } from \"chess.js\";\nimport { getServerPositionService } from \"@shared/services/database/serverPositionService\";\n\nconst logger = getLogger().setContext(\"loadTrainingContext\");\n\n/**\n * Loads training context for a position\n *\n * @param {StoreApi} api - Store API for accessing state and actions\n * @param {EndgamePosition} position - The endgame position to load\n * @returns {Promise<void>}\n *\n * @fires stateChange - Updates game, training, tablebase, progress, and UI slices\n * @fires tablebaseRequest - May trigger initial opponent move or position evaluation\n *\n * @description\n * Main orchestrator for initializing a complete training session.\n * Ensures all state is properly reset and configured for the new position.\n *\n * @remarks\n * This orchestrator performs the following steps:\n * 1. Resets training state to clean slate\n * 2. Initializes chess game with position FEN\n * 3. Sets up training position with metadata\n * 4. Determines initial turn based on position\n * 5. Clears any previous tablebase data\n * 6. Resets UI state for new session\n * 7. Initializes progress tracking\n * 8. Triggers initial move/analysis as needed\n *\n * The orchestrator gracefully handles errors by resetting to a clean state\n * and showing user-friendly error messages.\n *\n * TrainingPosition extends EndgamePosition with:\n * - colorToTrain: Which color the user is playing\n * - targetOutcome: Expected result (\"1-0\", \"0-1\", \"1/2-1/2\")\n * - timeLimit: Optional time constraint\n * - chapterId: If part of a training chapter\n *\n * @example\n * ```typescript\n * const position: EndgamePosition = {\n *   id: 1,\n *   title: \"King and Rook vs King\",\n *   fen: \"8/8/8/8/8/8/R7/K3k3 w - - 0 1\",\n *   category: \"basic-checkmates\",\n *   difficulty: \"beginner\",\n *   sideToMove: \"white\",\n *   goal: \"win\"\n * };\n *\n * await loadTrainingContext(api, position);\n * // Game is now ready for training\n * ```\n */\nexport const loadTrainingContext = async (\n  api: StoreApi,\n  position: EndgamePosition,\n): Promise<void> => {\n  const { setState } = api;\n\n  try {\n    // Set loading state via setState\n    setState((draft) => {\n      draft.ui.loading.position = true;\n    });\n\n    // Step 1: Reset all relevant state via setState using initial states\n    setState((draft) => {\n      // Reset slices to their initial states - PROPERLY preserving action methods\n      // CRITICAL: Reset only data properties, never overwrite the slice objects themselves\n\n      // Game slice - manual property reset\n      draft.game.moveHistory = [];\n      draft.game.currentMoveIndex = -1; // FIXED: -1 means starting position (no moves played)\n      draft.game.isGameFinished = false;\n\n      // Training slice - DO NOT RESET - Let the position loading handle training state\n\n      // Tablebase slice - manual property reset\n      draft.tablebase.tablebaseMove = null;\n      draft.tablebase.analysisStatus = \"idle\";\n      draft.tablebase.evaluations = [];\n      draft.tablebase.currentEvaluation = undefined;\n\n      // Close any open modals\n      if (draft.ui.currentModal) {\n        draft.ui.currentModal = null;\n      }\n    });\n\n    // Step 2: Validate FEN and initialize game state\n    // Defer ChessService initialization to avoid setState during render\n    // First just validate the FEN\n    const chess = new Chess();\n    let isValidFen = false;\n    try {\n      chess.load(position.fen);\n      isValidFen = true;\n    } catch {\n      isValidFen = false;\n    }\n\n    if (!isValidFen) {\n      throw new Error(\"UngÃ¼ltige FEN-Position\");\n    }\n\n    // Initialize ChessService synchronously - orchestrators can safely handle state updates\n    chessService.initialize(position.fen);\n\n    // Game state will be automatically synced via ChessService event subscription in rootStore\n\n    // Step 3: Create TrainingPosition from EndgamePosition\n    const trainingPosition: TrainingPosition = {\n      ...position,\n      // Add training-specific fields with sensible defaults if not already present\n      colorToTrain:\n        (position as any).colorToTrain || position.sideToMove || \"white\",\n      targetOutcome:\n        (position as any).targetOutcome ||\n        (position.goal === \"win\"\n          ? position.sideToMove === \"white\"\n            ? \"1-0\"\n            : \"0-1\"\n          : position.goal === \"draw\"\n            ? \"1/2-1/2\"\n            : \"1-0\"), // Default to win for white\n      timeLimit: (position as any).timeLimit || undefined, // No time limit by default\n      chapterId: (position as any).chapterId || undefined, // Will be set if part of a chapter\n    };\n\n    // Step 4: Set the training position and player turn\n    // Get turn from ChessService\n    const currentTurn = chessService.turn();\n    const isPlayerTurn =\n      currentTurn === trainingPosition.colorToTrain.charAt(0);\n\n    setState((draft) => {\n      draft.training.currentPosition = trainingPosition;\n      draft.training.isPlayerTurn = isPlayerTurn;\n    });\n\n    // Step 5: Load navigation positions (next/previous)\n    // This happens in the background to not block the main loading\n    const positionService = getServerPositionService();\n\n    // Set loading state for navigation\n    setState((draft) => {\n      draft.training.isLoadingNavigation = true;\n    });\n\n    try {\n      // Load navigation positions in parallel\n      const [nextPos, prevPos] = await Promise.all([\n        positionService.getNextPosition(position.id, position.category),\n        positionService.getPreviousPosition(position.id, position.category),\n      ]);\n\n      // Convert EndgamePosition to TrainingPosition for navigation positions\n      const nextTrainingPos = nextPos\n        ? ({\n            ...nextPos,\n            colorToTrain:\n              (nextPos as any).colorToTrain || nextPos.sideToMove || \"white\",\n            targetOutcome:\n              (nextPos as any).targetOutcome ||\n              (nextPos.goal === \"win\"\n                ? nextPos.sideToMove === \"white\"\n                  ? \"1-0\"\n                  : \"0-1\"\n                : nextPos.goal === \"draw\"\n                  ? \"1/2-1/2\"\n                  : \"1-0\"),\n            timeLimit: (nextPos as any).timeLimit || undefined,\n            chapterId: (nextPos as any).chapterId || undefined,\n          } as TrainingPosition)\n        : null;\n\n      const prevTrainingPos = prevPos\n        ? ({\n            ...prevPos,\n            colorToTrain:\n              (prevPos as any).colorToTrain || prevPos.sideToMove || \"white\",\n            targetOutcome:\n              (prevPos as any).targetOutcome ||\n              (prevPos.goal === \"win\"\n                ? prevPos.sideToMove === \"white\"\n                  ? \"1-0\"\n                  : \"0-1\"\n                : prevPos.goal === \"draw\"\n                  ? \"1/2-1/2\"\n                  : \"1-0\"),\n            timeLimit: (prevPos as any).timeLimit || undefined,\n            chapterId: (prevPos as any).chapterId || undefined,\n          } as TrainingPosition)\n        : null;\n\n      // Update navigation positions\n      setState((draft) => {\n        draft.training.nextPosition = nextTrainingPos;\n        draft.training.previousPosition = prevTrainingPos;\n        draft.training.isLoadingNavigation = false;\n      });\n\n      logger.debug(\"Navigation positions loaded\", {\n        nextId: nextPos?.id,\n        prevId: prevPos?.id,\n      });\n    } catch (navError) {\n      // Navigation loading is non-critical, just log and continue\n      logger.warn(\"Failed to load navigation positions\", { error: navError });\n      setState((draft) => {\n        draft.training.nextPosition = null;\n        draft.training.previousPosition = null;\n        draft.training.isLoadingNavigation = false;\n      });\n    }\n\n    // Step 6: Request initial tablebase analysis if it's not player's turn\n    if (!isPlayerTurn) {\n      // Tablebase needs to make the first move\n      // This is now handled by the training components\n      logger.debug(\"Opponent's turn - should be handled by component\");\n    } else {\n      // Position evaluation now handled by components using chessService\n      logger.debug(\"Player's turn - evaluation handled by component\");\n    }\n\n    // Step 7: Position progress tracking removed (was unused in UI)\n\n    // Step 8: Show success message\n    setState((draft) => {\n      draft.ui.toasts.push({\n        id: Date.now().toString(),\n        message: `Position geladen: ${position.title}`,\n        type: \"success\",\n        duration: 2000,\n      });\n    });\n  } catch (error) {\n    // Handle errors\n    const errorMessage =\n      error instanceof Error ? error.message : \"Fehler beim Laden der Position\";\n\n    // Show error and reset state\n    setState((draft) => {\n      // Show error toast\n      draft.ui.toasts.push({\n        id: Date.now().toString(),\n        message: errorMessage,\n        type: \"error\",\n        duration: 5000,\n      });\n\n      // Reset slices to initial states on error - PROPERLY preserving action methods\n      // Game slice - manual property reset\n      draft.game.moveHistory = [];\n      draft.game.currentMoveIndex = -1; // FIXED: -1 means starting position (no moves played)\n      draft.game.isGameFinished = false;\n\n      // Training slice - DO NOT RESET - Let the position loading handle training state\n    });\n  } finally {\n    // Clear loading state\n    setState((draft) => {\n      draft.ui.loading.position = false;\n    });\n  }\n};\n"],"names":["loadTrainingContext","logger","getLogger","setContext","api","position","setState","draft","ui","loading","game","moveHistory","currentMoveIndex","isGameFinished","tablebase","tablebaseMove","analysisStatus","evaluations","currentEvaluation","undefined","currentModal","chess","Chess","isValidFen","load","fen","Error","chessService","initialize","trainingPosition","colorToTrain","sideToMove","targetOutcome","goal","timeLimit","chapterId","currentTurn","turn","isPlayerTurn","charAt","training","currentPosition","positionService","getServerPositionService","isLoadingNavigation","nextPos","prevPos","Promise","all","getNextPosition","id","category","getPreviousPosition","nextTrainingPos","prevTrainingPos","nextPosition","previousPosition","debug","nextId","prevId","navError","warn","error","toasts","push","Date","now","toString","message","title","type","duration","errorMessage"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4BC;;;;+BA8DYA;;;eAAAA;;;yBAzDa;8BACG;uBACP;uCACmB;AAEzC,MAAMC,SAASC,IAAAA,kBAAS,IAAGC,UAAU,CAAC;AAoD/B,MAAMH,sBAAsB,OACjCI,KACAC;IAEA,MAAM,EAAEC,QAAQ,EAAE,GAAGF;IAErB,IAAI;QACF,iCAAiC;QACjCE,SAAS,CAACC;YACRA,MAAMC,EAAE,CAACC,OAAO,CAACJ,QAAQ,GAAG;QAC9B;QAEA,qEAAqE;QACrEC,SAAS,CAACC;YACR,4EAA4E;YAC5E,qFAAqF;YAErF,qCAAqC;YACrCA,MAAMG,IAAI,CAACC,WAAW,GAAG,EAAE;YAC3BJ,MAAMG,IAAI,CAACE,gBAAgB,GAAG,CAAC,GAAG,sDAAsD;YACxFL,MAAMG,IAAI,CAACG,cAAc,GAAG;YAE5B,iFAAiF;YAEjF,0CAA0C;YAC1CN,MAAMO,SAAS,CAACC,aAAa,GAAG;YAChCR,MAAMO,SAAS,CAACE,cAAc,GAAG;YACjCT,MAAMO,SAAS,CAACG,WAAW,GAAG,EAAE;YAChCV,MAAMO,SAAS,CAACI,iBAAiB,GAAGC;YAEpC,wBAAwB;YACxB,IAAIZ,MAAMC,EAAE,CAACY,YAAY,EAAE;gBACzBb,MAAMC,EAAE,CAACY,YAAY,GAAG;YAC1B;QACF;QAEA,iDAAiD;QACjD,oEAAoE;QACpE,8BAA8B;QAC9B,MAAMC,QAAQ,IAAIC,YAAK;QACvB,IAAIC,aAAa;QACjB,IAAI;YACFF,MAAMG,IAAI,CAACnB,SAASoB,GAAG;YACvBF,aAAa;QACf,EAAE,OAAM;YACNA,aAAa;QACf;QAEA,IAAI,CAACA,YAAY;YACf,MAAM,IAAIG,MAAM;QAClB;QAEA,wFAAwF;QACxFC,0BAAY,CAACC,UAAU,CAACvB,SAASoB,GAAG;QAEpC,2FAA2F;QAE3F,uDAAuD;QACvD,MAAMI,mBAAqC;YACzC,GAAGxB,QAAQ;YACX,6EAA6E;YAC7EyB,cACE,AAACzB,SAAiByB,YAAY,IAAIzB,SAAS0B,UAAU,IAAI;YAC3DC,eACE,AAAC3B,SAAiB2B,aAAa,IAC9B3B,CAAAA,SAAS4B,IAAI,KAAK,QACf5B,SAAS0B,UAAU,KAAK,UACtB,QACA,QACF1B,SAAS4B,IAAI,KAAK,SAChB,YACA,KAAI;YACZC,WAAW,AAAC7B,SAAiB6B,SAAS,IAAIf;YAC1CgB,WAAW,AAAC9B,SAAiB8B,SAAS,IAAIhB;QAC5C;QAEA,oDAAoD;QACpD,6BAA6B;QAC7B,MAAMiB,cAAcT,0BAAY,CAACU,IAAI;QACrC,MAAMC,eACJF,gBAAgBP,iBAAiBC,YAAY,CAACS,MAAM,CAAC;QAEvDjC,SAAS,CAACC;YACRA,MAAMiC,QAAQ,CAACC,eAAe,GAAGZ;YACjCtB,MAAMiC,QAAQ,CAACF,YAAY,GAAGA;QAChC;QAEA,oDAAoD;QACpD,+DAA+D;QAC/D,MAAMI,kBAAkBC,IAAAA,+CAAwB;QAEhD,mCAAmC;QACnCrC,SAAS,CAACC;YACRA,MAAMiC,QAAQ,CAACI,mBAAmB,GAAG;QACvC;QAEA,IAAI;YACF,wCAAwC;YACxC,MAAM,CAACC,SAASC,QAAQ,GAAG,MAAMC,QAAQC,GAAG,CAAC;gBAC3CN,gBAAgBO,eAAe,CAAC5C,SAAS6C,EAAE,EAAE7C,SAAS8C,QAAQ;gBAC9DT,gBAAgBU,mBAAmB,CAAC/C,SAAS6C,EAAE,EAAE7C,SAAS8C,QAAQ;aACnE;YAED,uEAAuE;YACvE,MAAME,kBAAkBR,UACnB;gBACC,GAAGA,OAAO;gBACVf,cACE,AAACe,QAAgBf,YAAY,IAAIe,QAAQd,UAAU,IAAI;gBACzDC,eACE,AAACa,QAAgBb,aAAa,IAC7Ba,CAAAA,QAAQZ,IAAI,KAAK,QACdY,QAAQd,UAAU,KAAK,UACrB,QACA,QACFc,QAAQZ,IAAI,KAAK,SACf,YACA,KAAI;gBACZC,WAAW,AAACW,QAAgBX,SAAS,IAAIf;gBACzCgB,WAAW,AAACU,QAAgBV,SAAS,IAAIhB;YAC3C,IACA;YAEJ,MAAMmC,kBAAkBR,UACnB;gBACC,GAAGA,OAAO;gBACVhB,cACE,AAACgB,QAAgBhB,YAAY,IAAIgB,QAAQf,UAAU,IAAI;gBACzDC,eACE,AAACc,QAAgBd,aAAa,IAC7Bc,CAAAA,QAAQb,IAAI,KAAK,QACda,QAAQf,UAAU,KAAK,UACrB,QACA,QACFe,QAAQb,IAAI,KAAK,SACf,YACA,KAAI;gBACZC,WAAW,AAACY,QAAgBZ,SAAS,IAAIf;gBACzCgB,WAAW,AAACW,QAAgBX,SAAS,IAAIhB;YAC3C,IACA;YAEJ,8BAA8B;YAC9Bb,SAAS,CAACC;gBACRA,MAAMiC,QAAQ,CAACe,YAAY,GAAGF;gBAC9B9C,MAAMiC,QAAQ,CAACgB,gBAAgB,GAAGF;gBAClC/C,MAAMiC,QAAQ,CAACI,mBAAmB,GAAG;YACvC;YAEA3C,OAAOwD,KAAK,CAAC,+BAA+B;gBAC1CC,MAAM,EAAEb,oBAAAA,8BAAAA,QAASK,EAAE;gBACnBS,MAAM,EAAEb,oBAAAA,8BAAAA,QAASI,EAAE;YACrB;QACF,EAAE,OAAOU,UAAU;YACjB,4DAA4D;YAC5D3D,OAAO4D,IAAI,CAAC,uCAAuC;gBAAEC,OAAOF;YAAS;YACrEtD,SAAS,CAACC;gBACRA,MAAMiC,QAAQ,CAACe,YAAY,GAAG;gBAC9BhD,MAAMiC,QAAQ,CAACgB,gBAAgB,GAAG;gBAClCjD,MAAMiC,QAAQ,CAACI,mBAAmB,GAAG;YACvC;QACF;QAEA,uEAAuE;QACvE,IAAI,CAACN,cAAc;YACjB,yCAAyC;YACzC,iDAAiD;YACjDrC,OAAOwD,KAAK,CAAC;QACf,OAAO;YACL,mEAAmE;YACnExD,OAAOwD,KAAK,CAAC;QACf;QAEA,gEAAgE;QAEhE,+BAA+B;QAC/BnD,SAAS,CAACC;YACRA,MAAMC,EAAE,CAACuD,MAAM,CAACC,IAAI,CAAC;gBACnBd,IAAIe,KAAKC,GAAG,GAAGC,QAAQ;gBACvBC,SAAS,CAAC,kBAAkB,EAAE/D,SAASgE,KAAK,EAAE;gBAC9CC,MAAM;gBACNC,UAAU;YACZ;QACF;IACF,EAAE,OAAOT,OAAO;QACd,gBAAgB;QAChB,MAAMU,eACJV,iBAAiBpC,QAAQoC,MAAMM,OAAO,GAAG;QAE3C,6BAA6B;QAC7B9D,SAAS,CAACC;YACR,mBAAmB;YACnBA,MAAMC,EAAE,CAACuD,MAAM,CAACC,IAAI,CAAC;gBACnBd,IAAIe,KAAKC,GAAG,GAAGC,QAAQ;gBACvBC,SAASI;gBACTF,MAAM;gBACNC,UAAU;YACZ;YAEA,+EAA+E;YAC/E,qCAAqC;YACrChE,MAAMG,IAAI,CAACC,WAAW,GAAG,EAAE;YAC3BJ,MAAMG,IAAI,CAACE,gBAAgB,GAAG,CAAC,GAAG,sDAAsD;YACxFL,MAAMG,IAAI,CAACG,cAAc,GAAG;QAE5B,iFAAiF;QACnF;IACF,SAAU;QACR,sBAAsB;QACtBP,SAAS,CAACC;YACRA,MAAMC,EAAE,CAACC,OAAO,CAACJ,QAAQ,GAAG;QAC9B;IACF;AACF"}