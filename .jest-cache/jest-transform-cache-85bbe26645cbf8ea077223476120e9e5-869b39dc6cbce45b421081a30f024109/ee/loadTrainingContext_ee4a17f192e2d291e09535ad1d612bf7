61e1889f6e247214d1d2b386c5fe1de0
/**
 * @file Load training context orchestrator
 * @module store/orchestrators/loadTrainingContext
 *
 * @description
 * Orchestrates loading a training position across game, training, and UI slices.
 * Sets up the complete training environment for a new endgame position.
 *
 * @remarks
 * This orchestrator is the main entry point for starting a training session.
 * It coordinates multiple slices to ensure proper initialization:
 * - Resets previous state to avoid conflicts
 * - Initializes chess.js with the position
 * - Configures training parameters
 * - Sets up initial turn order
 * - Requests initial analysis
 * - Tracks position progress
 *
 * The orchestrator handles both player-first and opponent-first scenarios,
 * automatically triggering the appropriate initial move or analysis.
 *
 * @example
 * ```typescript
 * // In a component
 * const loadContext = useStore(state => state.loadTrainingContext);
 *
 * await loadContext(endgamePosition);
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "loadTrainingContext", {
    enumerable: true,
    get: function() {
        return loadTrainingContext;
    }
});
const _logging = require("../../services/logging");
const _ChessService = require("../../services/ChessService");
const _chess = require("chess.js");
const _serverPositionService = require("../../services/database/serverPositionService");
const logger = (0, _logging.getLogger)().setContext("loadTrainingContext");
const loadTrainingContext = async (api, position)=>{
    const { setState } = api;
    try {
        // Set loading state via setState
        setState((draft)=>{
            draft.ui.loading.position = true;
        });
        // Step 1: Reset all relevant state via setState using initial states
        setState((draft)=>{
            // Reset slices to their initial states - PROPERLY preserving action methods
            // CRITICAL: Reset only data properties, never overwrite the slice objects themselves
            // Game slice - manual property reset
            draft.game.moveHistory = [];
            draft.game.currentMoveIndex = -1; // FIXED: -1 means starting position (no moves played)
            draft.game.isGameFinished = false;
            // Training slice - DO NOT RESET - Let the position loading handle training state
            // Tablebase slice - manual property reset
            draft.tablebase.tablebaseMove = null;
            draft.tablebase.analysisStatus = "idle";
            draft.tablebase.evaluations = [];
            draft.tablebase.currentEvaluation = undefined;
            // Close any open modals
            if (draft.ui.currentModal) {
                draft.ui.currentModal = null;
            }
        });
        // Step 2: Validate FEN and initialize game state
        // Defer ChessService initialization to avoid setState during render
        // First just validate the FEN
        const chess = new _chess.Chess();
        let isValidFen = false;
        try {
            chess.load(position.fen);
            isValidFen = true;
        } catch  {
            isValidFen = false;
        }
        if (!isValidFen) {
            throw new Error("UngÃ¼ltige FEN-Position");
        }
        // Initialize ChessService synchronously - orchestrators can safely handle state updates
        _ChessService.chessService.initialize(position.fen);
        // Game state will be automatically synced via ChessService event subscription in rootStore
        // Step 3: Create TrainingPosition from EndgamePosition
        const trainingPosition = {
            ...position,
            // Add training-specific fields with sensible defaults if not already present
            colorToTrain: position.colorToTrain || position.sideToMove || "white",
            targetOutcome: position.targetOutcome || (position.goal === "win" ? position.sideToMove === "white" ? "1-0" : "0-1" : position.goal === "draw" ? "1/2-1/2" : "1-0"),
            timeLimit: position.timeLimit || undefined,
            chapterId: position.chapterId || undefined
        };
        // Step 4: Set the training position and player turn
        // Get turn from ChessService
        const currentTurn = _ChessService.chessService.turn();
        const isPlayerTurn = currentTurn === trainingPosition.colorToTrain.charAt(0);
        setState((draft)=>{
            draft.training.currentPosition = trainingPosition;
            draft.training.isPlayerTurn = isPlayerTurn;
        });
        // Step 5: Load navigation positions (next/previous)
        // This happens in the background to not block the main loading
        const positionService = (0, _serverPositionService.getServerPositionService)();
        // Set loading state for navigation
        setState((draft)=>{
            draft.training.isLoadingNavigation = true;
        });
        try {
            // Load navigation positions in parallel
            const [nextPos, prevPos] = await Promise.all([
                positionService.getNextPosition(position.id, position.category),
                positionService.getPreviousPosition(position.id, position.category)
            ]);
            // Convert EndgamePosition to TrainingPosition for navigation positions
            const nextTrainingPos = nextPos ? {
                ...nextPos,
                colorToTrain: nextPos.colorToTrain || nextPos.sideToMove || "white",
                targetOutcome: nextPos.targetOutcome || (nextPos.goal === "win" ? nextPos.sideToMove === "white" ? "1-0" : "0-1" : nextPos.goal === "draw" ? "1/2-1/2" : "1-0"),
                timeLimit: nextPos.timeLimit || undefined,
                chapterId: nextPos.chapterId || undefined
            } : null;
            const prevTrainingPos = prevPos ? {
                ...prevPos,
                colorToTrain: prevPos.colorToTrain || prevPos.sideToMove || "white",
                targetOutcome: prevPos.targetOutcome || (prevPos.goal === "win" ? prevPos.sideToMove === "white" ? "1-0" : "0-1" : prevPos.goal === "draw" ? "1/2-1/2" : "1-0"),
                timeLimit: prevPos.timeLimit || undefined,
                chapterId: prevPos.chapterId || undefined
            } : null;
            // Update navigation positions
            setState((draft)=>{
                draft.training.nextPosition = nextTrainingPos;
                draft.training.previousPosition = prevTrainingPos;
                draft.training.isLoadingNavigation = false;
            });
            logger.debug("Navigation positions loaded", {
                nextId: nextPos === null || nextPos === void 0 ? void 0 : nextPos.id,
                prevId: prevPos === null || prevPos === void 0 ? void 0 : prevPos.id
            });
        } catch (navError) {
            // Navigation loading is non-critical, just log and continue
            logger.warn("Failed to load navigation positions", {
                error: navError
            });
            setState((draft)=>{
                draft.training.nextPosition = null;
                draft.training.previousPosition = null;
                draft.training.isLoadingNavigation = false;
            });
        }
        // Step 6: Request initial tablebase analysis if it's not player's turn
        if (!isPlayerTurn) {
            // Tablebase needs to make the first move
            // This is now handled by the training components
            logger.debug("Opponent's turn - should be handled by component");
        } else {
            // Position evaluation now handled by components using chessService
            logger.debug("Player's turn - evaluation handled by component");
        }
        // Step 7: Position progress tracking removed (was unused in UI)
        // Step 8: Show success message
        setState((draft)=>{
            draft.ui.toasts.push({
                id: Date.now().toString(),
                message: `Position geladen: ${position.title}`,
                type: "success",
                duration: 2000
            });
        });
    } catch (error) {
        // Handle errors
        const errorMessage = error instanceof Error ? error.message : "Fehler beim Laden der Position";
        // Show error and reset state
        setState((draft)=>{
            // Show error toast
            draft.ui.toasts.push({
                id: Date.now().toString(),
                message: errorMessage,
                type: "error",
                duration: 5000
            });
            // Reset slices to initial states on error - PROPERLY preserving action methods
            // Game slice - manual property reset
            draft.game.moveHistory = [];
            draft.game.currentMoveIndex = -1; // FIXED: -1 means starting position (no moves played)
            draft.game.isGameFinished = false;
        // Training slice - DO NOT RESET - Let the position loading handle training state
        });
    } finally{
        // Clear loading state
        setState((draft)=>{
            draft.ui.loading.position = false;
        });
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL29yY2hlc3RyYXRvcnMvbG9hZFRyYWluaW5nQ29udGV4dC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIExvYWQgdHJhaW5pbmcgY29udGV4dCBvcmNoZXN0cmF0b3JcbiAqIEBtb2R1bGUgc3RvcmUvb3JjaGVzdHJhdG9ycy9sb2FkVHJhaW5pbmdDb250ZXh0XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBPcmNoZXN0cmF0ZXMgbG9hZGluZyBhIHRyYWluaW5nIHBvc2l0aW9uIGFjcm9zcyBnYW1lLCB0cmFpbmluZywgYW5kIFVJIHNsaWNlcy5cbiAqIFNldHMgdXAgdGhlIGNvbXBsZXRlIHRyYWluaW5nIGVudmlyb25tZW50IGZvciBhIG5ldyBlbmRnYW1lIHBvc2l0aW9uLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIG9yY2hlc3RyYXRvciBpcyB0aGUgbWFpbiBlbnRyeSBwb2ludCBmb3Igc3RhcnRpbmcgYSB0cmFpbmluZyBzZXNzaW9uLlxuICogSXQgY29vcmRpbmF0ZXMgbXVsdGlwbGUgc2xpY2VzIHRvIGVuc3VyZSBwcm9wZXIgaW5pdGlhbGl6YXRpb246XG4gKiAtIFJlc2V0cyBwcmV2aW91cyBzdGF0ZSB0byBhdm9pZCBjb25mbGljdHNcbiAqIC0gSW5pdGlhbGl6ZXMgY2hlc3MuanMgd2l0aCB0aGUgcG9zaXRpb25cbiAqIC0gQ29uZmlndXJlcyB0cmFpbmluZyBwYXJhbWV0ZXJzXG4gKiAtIFNldHMgdXAgaW5pdGlhbCB0dXJuIG9yZGVyXG4gKiAtIFJlcXVlc3RzIGluaXRpYWwgYW5hbHlzaXNcbiAqIC0gVHJhY2tzIHBvc2l0aW9uIHByb2dyZXNzXG4gKlxuICogVGhlIG9yY2hlc3RyYXRvciBoYW5kbGVzIGJvdGggcGxheWVyLWZpcnN0IGFuZCBvcHBvbmVudC1maXJzdCBzY2VuYXJpb3MsXG4gKiBhdXRvbWF0aWNhbGx5IHRyaWdnZXJpbmcgdGhlIGFwcHJvcHJpYXRlIGluaXRpYWwgbW92ZSBvciBhbmFseXNpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gSW4gYSBjb21wb25lbnRcbiAqIGNvbnN0IGxvYWRDb250ZXh0ID0gdXNlU3RvcmUoc3RhdGUgPT4gc3RhdGUubG9hZFRyYWluaW5nQ29udGV4dCk7XG4gKlxuICogYXdhaXQgbG9hZENvbnRleHQoZW5kZ2FtZVBvc2l0aW9uKTtcbiAqIGBgYFxuICovXG5cbmltcG9ydCB0eXBlIHsgU3RvcmVBcGkgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBFbmRnYW1lUG9zaXRpb24gfSBmcm9tIFwiQHNoYXJlZC90eXBlcy9lbmRnYW1lXCI7XG5pbXBvcnQgdHlwZSB7IFRyYWluaW5nUG9zaXRpb24gfSBmcm9tIFwiLi4vc2xpY2VzL3RyYWluaW5nU2xpY2VcIjtcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmdcIjtcbmltcG9ydCB7IGNoZXNzU2VydmljZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL0NoZXNzU2VydmljZVwiO1xuaW1wb3J0IHsgQ2hlc3MgfSBmcm9tIFwiY2hlc3MuanNcIjtcbmltcG9ydCB7IGdldFNlcnZlclBvc2l0aW9uU2VydmljZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL2RhdGFiYXNlL3NlcnZlclBvc2l0aW9uU2VydmljZVwiO1xuXG5jb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KFwibG9hZFRyYWluaW5nQ29udGV4dFwiKTtcblxuLyoqXG4gKiBMb2FkcyB0cmFpbmluZyBjb250ZXh0IGZvciBhIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtIHtTdG9yZUFwaX0gYXBpIC0gU3RvcmUgQVBJIGZvciBhY2Nlc3Npbmcgc3RhdGUgYW5kIGFjdGlvbnNcbiAqIEBwYXJhbSB7RW5kZ2FtZVBvc2l0aW9ufSBwb3NpdGlvbiAtIFRoZSBlbmRnYW1lIHBvc2l0aW9uIHRvIGxvYWRcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICpcbiAqIEBmaXJlcyBzdGF0ZUNoYW5nZSAtIFVwZGF0ZXMgZ2FtZSwgdHJhaW5pbmcsIHRhYmxlYmFzZSwgcHJvZ3Jlc3MsIGFuZCBVSSBzbGljZXNcbiAqIEBmaXJlcyB0YWJsZWJhc2VSZXF1ZXN0IC0gTWF5IHRyaWdnZXIgaW5pdGlhbCBvcHBvbmVudCBtb3ZlIG9yIHBvc2l0aW9uIGV2YWx1YXRpb25cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIE1haW4gb3JjaGVzdHJhdG9yIGZvciBpbml0aWFsaXppbmcgYSBjb21wbGV0ZSB0cmFpbmluZyBzZXNzaW9uLlxuICogRW5zdXJlcyBhbGwgc3RhdGUgaXMgcHJvcGVybHkgcmVzZXQgYW5kIGNvbmZpZ3VyZWQgZm9yIHRoZSBuZXcgcG9zaXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgb3JjaGVzdHJhdG9yIHBlcmZvcm1zIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gKiAxLiBSZXNldHMgdHJhaW5pbmcgc3RhdGUgdG8gY2xlYW4gc2xhdGVcbiAqIDIuIEluaXRpYWxpemVzIGNoZXNzIGdhbWUgd2l0aCBwb3NpdGlvbiBGRU5cbiAqIDMuIFNldHMgdXAgdHJhaW5pbmcgcG9zaXRpb24gd2l0aCBtZXRhZGF0YVxuICogNC4gRGV0ZXJtaW5lcyBpbml0aWFsIHR1cm4gYmFzZWQgb24gcG9zaXRpb25cbiAqIDUuIENsZWFycyBhbnkgcHJldmlvdXMgdGFibGViYXNlIGRhdGFcbiAqIDYuIFJlc2V0cyBVSSBzdGF0ZSBmb3IgbmV3IHNlc3Npb25cbiAqIDcuIEluaXRpYWxpemVzIHByb2dyZXNzIHRyYWNraW5nXG4gKiA4LiBUcmlnZ2VycyBpbml0aWFsIG1vdmUvYW5hbHlzaXMgYXMgbmVlZGVkXG4gKlxuICogVGhlIG9yY2hlc3RyYXRvciBncmFjZWZ1bGx5IGhhbmRsZXMgZXJyb3JzIGJ5IHJlc2V0dGluZyB0byBhIGNsZWFuIHN0YXRlXG4gKiBhbmQgc2hvd2luZyB1c2VyLWZyaWVuZGx5IGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFRyYWluaW5nUG9zaXRpb24gZXh0ZW5kcyBFbmRnYW1lUG9zaXRpb24gd2l0aDpcbiAqIC0gY29sb3JUb1RyYWluOiBXaGljaCBjb2xvciB0aGUgdXNlciBpcyBwbGF5aW5nXG4gKiAtIHRhcmdldE91dGNvbWU6IEV4cGVjdGVkIHJlc3VsdCAoXCIxLTBcIiwgXCIwLTFcIiwgXCIxLzItMS8yXCIpXG4gKiAtIHRpbWVMaW1pdDogT3B0aW9uYWwgdGltZSBjb25zdHJhaW50XG4gKiAtIGNoYXB0ZXJJZDogSWYgcGFydCBvZiBhIHRyYWluaW5nIGNoYXB0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcG9zaXRpb246IEVuZGdhbWVQb3NpdGlvbiA9IHtcbiAqICAgaWQ6IDEsXG4gKiAgIHRpdGxlOiBcIktpbmcgYW5kIFJvb2sgdnMgS2luZ1wiLFxuICogICBmZW46IFwiOC84LzgvOC84LzgvUjcvSzNrMyB3IC0gLSAwIDFcIixcbiAqICAgY2F0ZWdvcnk6IFwiYmFzaWMtY2hlY2ttYXRlc1wiLFxuICogICBkaWZmaWN1bHR5OiBcImJlZ2lubmVyXCIsXG4gKiAgIHNpZGVUb01vdmU6IFwid2hpdGVcIixcbiAqICAgZ29hbDogXCJ3aW5cIlxuICogfTtcbiAqXG4gKiBhd2FpdCBsb2FkVHJhaW5pbmdDb250ZXh0KGFwaSwgcG9zaXRpb24pO1xuICogLy8gR2FtZSBpcyBub3cgcmVhZHkgZm9yIHRyYWluaW5nXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGxvYWRUcmFpbmluZ0NvbnRleHQgPSBhc3luYyAoXG4gIGFwaTogU3RvcmVBcGksXG4gIHBvc2l0aW9uOiBFbmRnYW1lUG9zaXRpb24sXG4pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgY29uc3QgeyBzZXRTdGF0ZSB9ID0gYXBpO1xuXG4gIHRyeSB7XG4gICAgLy8gU2V0IGxvYWRpbmcgc3RhdGUgdmlhIHNldFN0YXRlXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XG4gICAgICBkcmFmdC51aS5sb2FkaW5nLnBvc2l0aW9uID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIC8vIFN0ZXAgMTogUmVzZXQgYWxsIHJlbGV2YW50IHN0YXRlIHZpYSBzZXRTdGF0ZSB1c2luZyBpbml0aWFsIHN0YXRlc1xuICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgLy8gUmVzZXQgc2xpY2VzIHRvIHRoZWlyIGluaXRpYWwgc3RhdGVzIC0gUFJPUEVSTFkgcHJlc2VydmluZyBhY3Rpb24gbWV0aG9kc1xuICAgICAgLy8gQ1JJVElDQUw6IFJlc2V0IG9ubHkgZGF0YSBwcm9wZXJ0aWVzLCBuZXZlciBvdmVyd3JpdGUgdGhlIHNsaWNlIG9iamVjdHMgdGhlbXNlbHZlc1xuXG4gICAgICAvLyBHYW1lIHNsaWNlIC0gbWFudWFsIHByb3BlcnR5IHJlc2V0XG4gICAgICBkcmFmdC5nYW1lLm1vdmVIaXN0b3J5ID0gW107XG4gICAgICBkcmFmdC5nYW1lLmN1cnJlbnRNb3ZlSW5kZXggPSAtMTsgLy8gRklYRUQ6IC0xIG1lYW5zIHN0YXJ0aW5nIHBvc2l0aW9uIChubyBtb3ZlcyBwbGF5ZWQpXG4gICAgICBkcmFmdC5nYW1lLmlzR2FtZUZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFRyYWluaW5nIHNsaWNlIC0gRE8gTk9UIFJFU0VUIC0gTGV0IHRoZSBwb3NpdGlvbiBsb2FkaW5nIGhhbmRsZSB0cmFpbmluZyBzdGF0ZVxuXG4gICAgICAvLyBUYWJsZWJhc2Ugc2xpY2UgLSBtYW51YWwgcHJvcGVydHkgcmVzZXRcbiAgICAgIGRyYWZ0LnRhYmxlYmFzZS50YWJsZWJhc2VNb3ZlID0gbnVsbDtcbiAgICAgIGRyYWZ0LnRhYmxlYmFzZS5hbmFseXNpc1N0YXR1cyA9IFwiaWRsZVwiO1xuICAgICAgZHJhZnQudGFibGViYXNlLmV2YWx1YXRpb25zID0gW107XG4gICAgICBkcmFmdC50YWJsZWJhc2UuY3VycmVudEV2YWx1YXRpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIC8vIENsb3NlIGFueSBvcGVuIG1vZGFsc1xuICAgICAgaWYgKGRyYWZ0LnVpLmN1cnJlbnRNb2RhbCkge1xuICAgICAgICBkcmFmdC51aS5jdXJyZW50TW9kYWwgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU3RlcCAyOiBWYWxpZGF0ZSBGRU4gYW5kIGluaXRpYWxpemUgZ2FtZSBzdGF0ZVxuICAgIC8vIERlZmVyIENoZXNzU2VydmljZSBpbml0aWFsaXphdGlvbiB0byBhdm9pZCBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyXG4gICAgLy8gRmlyc3QganVzdCB2YWxpZGF0ZSB0aGUgRkVOXG4gICAgY29uc3QgY2hlc3MgPSBuZXcgQ2hlc3MoKTtcbiAgICBsZXQgaXNWYWxpZEZlbiA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjaGVzcy5sb2FkKHBvc2l0aW9uLmZlbik7XG4gICAgICBpc1ZhbGlkRmVuID0gdHJ1ZTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGlzVmFsaWRGZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzVmFsaWRGZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZ8O8bHRpZ2UgRkVOLVBvc2l0aW9uXCIpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgQ2hlc3NTZXJ2aWNlIHN5bmNocm9ub3VzbHkgLSBvcmNoZXN0cmF0b3JzIGNhbiBzYWZlbHkgaGFuZGxlIHN0YXRlIHVwZGF0ZXNcbiAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShwb3NpdGlvbi5mZW4pO1xuXG4gICAgLy8gR2FtZSBzdGF0ZSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc3luY2VkIHZpYSBDaGVzc1NlcnZpY2UgZXZlbnQgc3Vic2NyaXB0aW9uIGluIHJvb3RTdG9yZVxuXG4gICAgLy8gU3RlcCAzOiBDcmVhdGUgVHJhaW5pbmdQb3NpdGlvbiBmcm9tIEVuZGdhbWVQb3NpdGlvblxuICAgIGNvbnN0IHRyYWluaW5nUG9zaXRpb246IFRyYWluaW5nUG9zaXRpb24gPSB7XG4gICAgICAuLi5wb3NpdGlvbixcbiAgICAgIC8vIEFkZCB0cmFpbmluZy1zcGVjaWZpYyBmaWVsZHMgd2l0aCBzZW5zaWJsZSBkZWZhdWx0cyBpZiBub3QgYWxyZWFkeSBwcmVzZW50XG4gICAgICBjb2xvclRvVHJhaW46XG4gICAgICAgIChwb3NpdGlvbiBhcyBhbnkpLmNvbG9yVG9UcmFpbiB8fCBwb3NpdGlvbi5zaWRlVG9Nb3ZlIHx8IFwid2hpdGVcIixcbiAgICAgIHRhcmdldE91dGNvbWU6XG4gICAgICAgIChwb3NpdGlvbiBhcyBhbnkpLnRhcmdldE91dGNvbWUgfHxcbiAgICAgICAgKHBvc2l0aW9uLmdvYWwgPT09IFwid2luXCJcbiAgICAgICAgICA/IHBvc2l0aW9uLnNpZGVUb01vdmUgPT09IFwid2hpdGVcIlxuICAgICAgICAgICAgPyBcIjEtMFwiXG4gICAgICAgICAgICA6IFwiMC0xXCJcbiAgICAgICAgICA6IHBvc2l0aW9uLmdvYWwgPT09IFwiZHJhd1wiXG4gICAgICAgICAgICA/IFwiMS8yLTEvMlwiXG4gICAgICAgICAgICA6IFwiMS0wXCIpLCAvLyBEZWZhdWx0IHRvIHdpbiBmb3Igd2hpdGVcbiAgICAgIHRpbWVMaW1pdDogKHBvc2l0aW9uIGFzIGFueSkudGltZUxpbWl0IHx8IHVuZGVmaW5lZCwgLy8gTm8gdGltZSBsaW1pdCBieSBkZWZhdWx0XG4gICAgICBjaGFwdGVySWQ6IChwb3NpdGlvbiBhcyBhbnkpLmNoYXB0ZXJJZCB8fCB1bmRlZmluZWQsIC8vIFdpbGwgYmUgc2V0IGlmIHBhcnQgb2YgYSBjaGFwdGVyXG4gICAgfTtcblxuICAgIC8vIFN0ZXAgNDogU2V0IHRoZSB0cmFpbmluZyBwb3NpdGlvbiBhbmQgcGxheWVyIHR1cm5cbiAgICAvLyBHZXQgdHVybiBmcm9tIENoZXNzU2VydmljZVxuICAgIGNvbnN0IGN1cnJlbnRUdXJuID0gY2hlc3NTZXJ2aWNlLnR1cm4oKTtcbiAgICBjb25zdCBpc1BsYXllclR1cm4gPVxuICAgICAgY3VycmVudFR1cm4gPT09IHRyYWluaW5nUG9zaXRpb24uY29sb3JUb1RyYWluLmNoYXJBdCgwKTtcblxuICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgZHJhZnQudHJhaW5pbmcuY3VycmVudFBvc2l0aW9uID0gdHJhaW5pbmdQb3NpdGlvbjtcbiAgICAgIGRyYWZ0LnRyYWluaW5nLmlzUGxheWVyVHVybiA9IGlzUGxheWVyVHVybjtcbiAgICB9KTtcblxuICAgIC8vIFN0ZXAgNTogTG9hZCBuYXZpZ2F0aW9uIHBvc2l0aW9ucyAobmV4dC9wcmV2aW91cylcbiAgICAvLyBUaGlzIGhhcHBlbnMgaW4gdGhlIGJhY2tncm91bmQgdG8gbm90IGJsb2NrIHRoZSBtYWluIGxvYWRpbmdcbiAgICBjb25zdCBwb3NpdGlvblNlcnZpY2UgPSBnZXRTZXJ2ZXJQb3NpdGlvblNlcnZpY2UoKTtcblxuICAgIC8vIFNldCBsb2FkaW5nIHN0YXRlIGZvciBuYXZpZ2F0aW9uXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XG4gICAgICBkcmFmdC50cmFpbmluZy5pc0xvYWRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBMb2FkIG5hdmlnYXRpb24gcG9zaXRpb25zIGluIHBhcmFsbGVsXG4gICAgICBjb25zdCBbbmV4dFBvcywgcHJldlBvc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHBvc2l0aW9uU2VydmljZS5nZXROZXh0UG9zaXRpb24ocG9zaXRpb24uaWQsIHBvc2l0aW9uLmNhdGVnb3J5KSxcbiAgICAgICAgcG9zaXRpb25TZXJ2aWNlLmdldFByZXZpb3VzUG9zaXRpb24ocG9zaXRpb24uaWQsIHBvc2l0aW9uLmNhdGVnb3J5KSxcbiAgICAgIF0pO1xuXG4gICAgICAvLyBDb252ZXJ0IEVuZGdhbWVQb3NpdGlvbiB0byBUcmFpbmluZ1Bvc2l0aW9uIGZvciBuYXZpZ2F0aW9uIHBvc2l0aW9uc1xuICAgICAgY29uc3QgbmV4dFRyYWluaW5nUG9zID0gbmV4dFBvc1xuICAgICAgICA/ICh7XG4gICAgICAgICAgICAuLi5uZXh0UG9zLFxuICAgICAgICAgICAgY29sb3JUb1RyYWluOlxuICAgICAgICAgICAgICAobmV4dFBvcyBhcyBhbnkpLmNvbG9yVG9UcmFpbiB8fCBuZXh0UG9zLnNpZGVUb01vdmUgfHwgXCJ3aGl0ZVwiLFxuICAgICAgICAgICAgdGFyZ2V0T3V0Y29tZTpcbiAgICAgICAgICAgICAgKG5leHRQb3MgYXMgYW55KS50YXJnZXRPdXRjb21lIHx8XG4gICAgICAgICAgICAgIChuZXh0UG9zLmdvYWwgPT09IFwid2luXCJcbiAgICAgICAgICAgICAgICA/IG5leHRQb3Muc2lkZVRvTW92ZSA9PT0gXCJ3aGl0ZVwiXG4gICAgICAgICAgICAgICAgICA/IFwiMS0wXCJcbiAgICAgICAgICAgICAgICAgIDogXCIwLTFcIlxuICAgICAgICAgICAgICAgIDogbmV4dFBvcy5nb2FsID09PSBcImRyYXdcIlxuICAgICAgICAgICAgICAgICAgPyBcIjEvMi0xLzJcIlxuICAgICAgICAgICAgICAgICAgOiBcIjEtMFwiKSxcbiAgICAgICAgICAgIHRpbWVMaW1pdDogKG5leHRQb3MgYXMgYW55KS50aW1lTGltaXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hhcHRlcklkOiAobmV4dFBvcyBhcyBhbnkpLmNoYXB0ZXJJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgfSBhcyBUcmFpbmluZ1Bvc2l0aW9uKVxuICAgICAgICA6IG51bGw7XG5cbiAgICAgIGNvbnN0IHByZXZUcmFpbmluZ1BvcyA9IHByZXZQb3NcbiAgICAgICAgPyAoe1xuICAgICAgICAgICAgLi4ucHJldlBvcyxcbiAgICAgICAgICAgIGNvbG9yVG9UcmFpbjpcbiAgICAgICAgICAgICAgKHByZXZQb3MgYXMgYW55KS5jb2xvclRvVHJhaW4gfHwgcHJldlBvcy5zaWRlVG9Nb3ZlIHx8IFwid2hpdGVcIixcbiAgICAgICAgICAgIHRhcmdldE91dGNvbWU6XG4gICAgICAgICAgICAgIChwcmV2UG9zIGFzIGFueSkudGFyZ2V0T3V0Y29tZSB8fFxuICAgICAgICAgICAgICAocHJldlBvcy5nb2FsID09PSBcIndpblwiXG4gICAgICAgICAgICAgICAgPyBwcmV2UG9zLnNpZGVUb01vdmUgPT09IFwid2hpdGVcIlxuICAgICAgICAgICAgICAgICAgPyBcIjEtMFwiXG4gICAgICAgICAgICAgICAgICA6IFwiMC0xXCJcbiAgICAgICAgICAgICAgICA6IHByZXZQb3MuZ29hbCA9PT0gXCJkcmF3XCJcbiAgICAgICAgICAgICAgICAgID8gXCIxLzItMS8yXCJcbiAgICAgICAgICAgICAgICAgIDogXCIxLTBcIiksXG4gICAgICAgICAgICB0aW1lTGltaXQ6IChwcmV2UG9zIGFzIGFueSkudGltZUxpbWl0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYXB0ZXJJZDogKHByZXZQb3MgYXMgYW55KS5jaGFwdGVySWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIH0gYXMgVHJhaW5pbmdQb3NpdGlvbilcbiAgICAgICAgOiBudWxsO1xuXG4gICAgICAvLyBVcGRhdGUgbmF2aWdhdGlvbiBwb3NpdGlvbnNcbiAgICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgICBkcmFmdC50cmFpbmluZy5uZXh0UG9zaXRpb24gPSBuZXh0VHJhaW5pbmdQb3M7XG4gICAgICAgIGRyYWZ0LnRyYWluaW5nLnByZXZpb3VzUG9zaXRpb24gPSBwcmV2VHJhaW5pbmdQb3M7XG4gICAgICAgIGRyYWZ0LnRyYWluaW5nLmlzTG9hZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJOYXZpZ2F0aW9uIHBvc2l0aW9ucyBsb2FkZWRcIiwge1xuICAgICAgICBuZXh0SWQ6IG5leHRQb3M/LmlkLFxuICAgICAgICBwcmV2SWQ6IHByZXZQb3M/LmlkLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAobmF2RXJyb3IpIHtcbiAgICAgIC8vIE5hdmlnYXRpb24gbG9hZGluZyBpcyBub24tY3JpdGljYWwsIGp1c3QgbG9nIGFuZCBjb250aW51ZVxuICAgICAgbG9nZ2VyLndhcm4oXCJGYWlsZWQgdG8gbG9hZCBuYXZpZ2F0aW9uIHBvc2l0aW9uc1wiLCB7IGVycm9yOiBuYXZFcnJvciB9KTtcbiAgICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgICBkcmFmdC50cmFpbmluZy5uZXh0UG9zaXRpb24gPSBudWxsO1xuICAgICAgICBkcmFmdC50cmFpbmluZy5wcmV2aW91c1Bvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgZHJhZnQudHJhaW5pbmcuaXNMb2FkaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCA2OiBSZXF1ZXN0IGluaXRpYWwgdGFibGViYXNlIGFuYWx5c2lzIGlmIGl0J3Mgbm90IHBsYXllcidzIHR1cm5cbiAgICBpZiAoIWlzUGxheWVyVHVybikge1xuICAgICAgLy8gVGFibGViYXNlIG5lZWRzIHRvIG1ha2UgdGhlIGZpcnN0IG1vdmVcbiAgICAgIC8vIFRoaXMgaXMgbm93IGhhbmRsZWQgYnkgdGhlIHRyYWluaW5nIGNvbXBvbmVudHNcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIk9wcG9uZW50J3MgdHVybiAtIHNob3VsZCBiZSBoYW5kbGVkIGJ5IGNvbXBvbmVudFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUG9zaXRpb24gZXZhbHVhdGlvbiBub3cgaGFuZGxlZCBieSBjb21wb25lbnRzIHVzaW5nIGNoZXNzU2VydmljZVxuICAgICAgbG9nZ2VyLmRlYnVnKFwiUGxheWVyJ3MgdHVybiAtIGV2YWx1YXRpb24gaGFuZGxlZCBieSBjb21wb25lbnRcIik7XG4gICAgfVxuXG4gICAgLy8gU3RlcCA3OiBQb3NpdGlvbiBwcm9ncmVzcyB0cmFja2luZyByZW1vdmVkICh3YXMgdW51c2VkIGluIFVJKVxuXG4gICAgLy8gU3RlcCA4OiBTaG93IHN1Y2Nlc3MgbWVzc2FnZVxuICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgZHJhZnQudWkudG9hc3RzLnB1c2goe1xuICAgICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxuICAgICAgICBtZXNzYWdlOiBgUG9zaXRpb24gZ2VsYWRlbjogJHtwb3NpdGlvbi50aXRsZX1gLFxuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgZHVyYXRpb246IDIwMDAsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBIYW5kbGUgZXJyb3JzXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogXCJGZWhsZXIgYmVpbSBMYWRlbiBkZXIgUG9zaXRpb25cIjtcblxuICAgIC8vIFNob3cgZXJyb3IgYW5kIHJlc2V0IHN0YXRlXG4gICAgc2V0U3RhdGUoKGRyYWZ0KSA9PiB7XG4gICAgICAvLyBTaG93IGVycm9yIHRvYXN0XG4gICAgICBkcmFmdC51aS50b2FzdHMucHVzaCh7XG4gICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICBkdXJhdGlvbjogNTAwMCxcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZXNldCBzbGljZXMgdG8gaW5pdGlhbCBzdGF0ZXMgb24gZXJyb3IgLSBQUk9QRVJMWSBwcmVzZXJ2aW5nIGFjdGlvbiBtZXRob2RzXG4gICAgICAvLyBHYW1lIHNsaWNlIC0gbWFudWFsIHByb3BlcnR5IHJlc2V0XG4gICAgICBkcmFmdC5nYW1lLm1vdmVIaXN0b3J5ID0gW107XG4gICAgICBkcmFmdC5nYW1lLmN1cnJlbnRNb3ZlSW5kZXggPSAtMTsgLy8gRklYRUQ6IC0xIG1lYW5zIHN0YXJ0aW5nIHBvc2l0aW9uIChubyBtb3ZlcyBwbGF5ZWQpXG4gICAgICBkcmFmdC5nYW1lLmlzR2FtZUZpbmlzaGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIFRyYWluaW5nIHNsaWNlIC0gRE8gTk9UIFJFU0VUIC0gTGV0IHRoZSBwb3NpdGlvbiBsb2FkaW5nIGhhbmRsZSB0cmFpbmluZyBzdGF0ZVxuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIENsZWFyIGxvYWRpbmcgc3RhdGVcbiAgICBzZXRTdGF0ZSgoZHJhZnQpID0+IHtcbiAgICAgIGRyYWZ0LnVpLmxvYWRpbmcucG9zaXRpb24gPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJsb2FkVHJhaW5pbmdDb250ZXh0IiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImFwaSIsInBvc2l0aW9uIiwic2V0U3RhdGUiLCJkcmFmdCIsInVpIiwibG9hZGluZyIsImdhbWUiLCJtb3ZlSGlzdG9yeSIsImN1cnJlbnRNb3ZlSW5kZXgiLCJpc0dhbWVGaW5pc2hlZCIsInRhYmxlYmFzZSIsInRhYmxlYmFzZU1vdmUiLCJhbmFseXNpc1N0YXR1cyIsImV2YWx1YXRpb25zIiwiY3VycmVudEV2YWx1YXRpb24iLCJ1bmRlZmluZWQiLCJjdXJyZW50TW9kYWwiLCJjaGVzcyIsIkNoZXNzIiwiaXNWYWxpZEZlbiIsImxvYWQiLCJmZW4iLCJFcnJvciIsImNoZXNzU2VydmljZSIsImluaXRpYWxpemUiLCJ0cmFpbmluZ1Bvc2l0aW9uIiwiY29sb3JUb1RyYWluIiwic2lkZVRvTW92ZSIsInRhcmdldE91dGNvbWUiLCJnb2FsIiwidGltZUxpbWl0IiwiY2hhcHRlcklkIiwiY3VycmVudFR1cm4iLCJ0dXJuIiwiaXNQbGF5ZXJUdXJuIiwiY2hhckF0IiwidHJhaW5pbmciLCJjdXJyZW50UG9zaXRpb24iLCJwb3NpdGlvblNlcnZpY2UiLCJnZXRTZXJ2ZXJQb3NpdGlvblNlcnZpY2UiLCJpc0xvYWRpbmdOYXZpZ2F0aW9uIiwibmV4dFBvcyIsInByZXZQb3MiLCJQcm9taXNlIiwiYWxsIiwiZ2V0TmV4dFBvc2l0aW9uIiwiaWQiLCJjYXRlZ29yeSIsImdldFByZXZpb3VzUG9zaXRpb24iLCJuZXh0VHJhaW5pbmdQb3MiLCJwcmV2VHJhaW5pbmdQb3MiLCJuZXh0UG9zaXRpb24iLCJwcmV2aW91c1Bvc2l0aW9uIiwiZGVidWciLCJuZXh0SWQiLCJwcmV2SWQiLCJuYXZFcnJvciIsIndhcm4iLCJlcnJvciIsInRvYXN0cyIsInB1c2giLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJtZXNzYWdlIiwidGl0bGUiLCJ0eXBlIiwiZHVyYXRpb24iLCJlcnJvck1lc3NhZ2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBNEJDOzs7OytCQThEWUE7OztlQUFBQTs7O3lCQXpEYTs4QkFDRzt1QkFDUDt1Q0FDbUI7QUFFekMsTUFBTUMsU0FBU0MsSUFBQUEsa0JBQVMsSUFBR0MsVUFBVSxDQUFDO0FBb0QvQixNQUFNSCxzQkFBc0IsT0FDakNJLEtBQ0FDO0lBRUEsTUFBTSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFFckIsSUFBSTtRQUNGLGlDQUFpQztRQUNqQ0UsU0FBUyxDQUFDQztZQUNSQSxNQUFNQyxFQUFFLENBQUNDLE9BQU8sQ0FBQ0osUUFBUSxHQUFHO1FBQzlCO1FBRUEscUVBQXFFO1FBQ3JFQyxTQUFTLENBQUNDO1lBQ1IsNEVBQTRFO1lBQzVFLHFGQUFxRjtZQUVyRixxQ0FBcUM7WUFDckNBLE1BQU1HLElBQUksQ0FBQ0MsV0FBVyxHQUFHLEVBQUU7WUFDM0JKLE1BQU1HLElBQUksQ0FBQ0UsZ0JBQWdCLEdBQUcsQ0FBQyxHQUFHLHNEQUFzRDtZQUN4RkwsTUFBTUcsSUFBSSxDQUFDRyxjQUFjLEdBQUc7WUFFNUIsaUZBQWlGO1lBRWpGLDBDQUEwQztZQUMxQ04sTUFBTU8sU0FBUyxDQUFDQyxhQUFhLEdBQUc7WUFDaENSLE1BQU1PLFNBQVMsQ0FBQ0UsY0FBYyxH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