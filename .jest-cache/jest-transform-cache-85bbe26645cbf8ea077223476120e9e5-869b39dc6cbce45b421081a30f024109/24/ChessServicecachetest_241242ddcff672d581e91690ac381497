9ece2809b7f21da6edcc743d6bcce50a
/**
 * @file ChessService Cache & Performance Tests
 * @description Coverage tests for cache management (Line 528) and performance optimization
 * Target: Complete 100% coverage for ChessService
 */ "use strict";
// Mock chess.js following existing pattern
jest.mock("chess.js");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ChessService = require("../../../shared/services/ChessService");
const _chess = require("chess.js");
const MockedChess = _chess.Chess;
describe("ChessService Cache & Performance Tests", ()=>{
    let chessService;
    let mockChessInstance;
    beforeEach(()=>{
        MockedChess.mockClear();
        // Create comprehensive mock Chess instance
        mockChessInstance = {
            move: jest.fn(),
            fen: jest.fn().mockReturnValue("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"),
            pgn: jest.fn().mockReturnValue(""),
            history: jest.fn().mockReturnValue([]),
            load: jest.fn(),
            loadPgn: jest.fn(),
            isGameOver: jest.fn().mockReturnValue(false),
            turn: jest.fn().mockReturnValue("w"),
            moves: jest.fn().mockReturnValue([
                "e4",
                "e3",
                "Nf3"
            ]),
            isCheck: jest.fn().mockReturnValue(false),
            isCheckmate: jest.fn().mockReturnValue(false),
            isStalemate: jest.fn().mockReturnValue(false),
            isDraw: jest.fn().mockReturnValue(false)
        };
        MockedChess.mockImplementation(()=>mockChessInstance);
        chessService = new _ChessService.ChessService();
    });
    describe("Cache Key Update - Line 528", ()=>{
        it("should delete existing cache key before re-adding (Line 528)", ()=>{
            // Create a scenario where updateCache is called with an existing key
            // This can happen when the input FEN is different from the normalized FEN from chess.js
            const inputFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 5 10"; // With move counters
            const normalizedFen = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"; // Normalized by chess.js
            // First initialization - this will populate cache: inputFen -> normalizedFen 
            mockChessInstance.fen.mockReturnValue(normalizedFen);
            chessService.initialize(inputFen);
            // Now simulate a case where we need to access the cache internal state
            // We'll use reflection to manipulate the cache directly to force the condition
            const cacheAccess = chessService.fenCache;
            // Manually add an entry that will collide with updateCache
            const collisionKey = "collision-test-fen";
            cacheAccess.set(collisionKey, normalizedFen);
            // Now force updateCache to be called with the collision key by making initialize
            // bypass the cache check through a different path
            // Mock Chess constructor to simulate what would happen
            MockedChess.mockImplementationOnce(()=>{
                const mockInstance = {
                    ...mockChessInstance,
                    fen: jest.fn().mockReturnValue(normalizedFen)
                };
                return mockInstance;
            });
            // This should trigger updateCache with a key that already exists (collision-test-fen)
            // by calling the private updateCache method with an existing key
            const updateCacheMethod = chessService.updateCache;
            updateCacheMethod.call(chessService, collisionKey, normalizedFen);
            // Verify the cache still works after the key deletion and re-addition
            expect(cacheAccess.has(collisionKey)).toBe(true);
        });
        it("should handle cache key move-to-end behavior correctly", ()=>{
            // Fill cache with multiple positions
            const fens = [];
            for(let i = 0; i < 50; i++){
                const fen = `test-${i}-8/8/8/8/8/8/8/k6K w - - 0 1`;
                fens.push(fen);
                mockChessInstance.fen.mockReturnValue(fen);
                chessService.initialize(fen);
            }
            // Access an early FEN again - should move it to end of cache (Line 528)
            const earlyFen = fens[5];
            mockChessInstance.fen.mockReturnValue(earlyFen);
            chessService.initialize(earlyFen);
            // Add more FENs to test that the recently accessed one isn't evicted
            for(let i = 50; i < 80; i++){
                const fen = `new-${i}-8/8/8/8/8/8/8/k6K w - - 0 1`;
                mockChessInstance.fen.mockReturnValue(fen);
                chessService.initialize(fen);
            }
            // Should still work without errors
            expect(()=>chessService.initialize(earlyFen)).not.toThrow();
        });
        it("should handle multiple cache key updates in sequence", ()=>{
            const testFens = [
                "pos1-8/8/8/8/8/8/8/k6K w - - 0 1",
                "pos2-8/8/8/8/8/8/8/k6K w - - 0 1",
                "pos3-8/8/8/8/8/8/8/k6K w - - 0 1"
            ];
            // Initialize each position twice to trigger cache key updates
            testFens.forEach((fen)=>{
                mockChessInstance.fen.mockReturnValue(fen);
                chessService.initialize(fen); // First time - add to cache
                chessService.initialize(fen); // Second time - update cache (Line 528)
            });
            // All operations should complete successfully
            testFens.forEach((fen)=>{
                expect(()=>chessService.initialize(fen)).not.toThrow();
            });
        });
    });
    describe("Performance - Cache Efficiency", ()=>{
        it("should minimize Chess instance creations through caching", ()=>{
            const testFen = "8/8/8/8/8/5k2/8/5K2 w - - 0 1";
            mockChessInstance.fen.mockReturnValue(testFen);
            // Clear mock call count
            MockedChess.mockClear();
            // First call - should create Chess instance
            chessService.initialize(testFen);
            const firstCallCount = MockedChess.mock.calls.length;
            // Subsequent calls - should use cached normalized FEN
            chessService.initialize(testFen);
            chessService.initialize(testFen);
            const subsequentCallCount = MockedChess.mock.calls.length;
            // Should create new instances each time but use cached FEN for normalization
            expect(subsequentCallCount).toBeGreaterThan(firstCallCount);
        });
        it("should handle rapid consecutive initializations efficiently", ()=>{
            const positions = [
                "8/8/8/8/8/8/8/k6K w - - 0 1",
                "8/8/8/8/8/k7/8/6K1 w - - 0 1",
                "8/8/8/8/k7/8/8/6K1 w - - 0 1"
            ];
            // Rapid consecutive calls should not throw errors
            expect(()=>{
                positions.forEach((fen)=>{
                    mockChessInstance.fen.mockReturnValue(fen);
                    // Initialize each position multiple times rapidly
                    for(let i = 0; i < 10; i++){
                        chessService.initialize(fen);
                    }
                });
            }).not.toThrow();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2UuY2FjaGUudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIENoZXNzU2VydmljZSBDYWNoZSAmIFBlcmZvcm1hbmNlIFRlc3RzXG4gKiBAZGVzY3JpcHRpb24gQ292ZXJhZ2UgdGVzdHMgZm9yIGNhY2hlIG1hbmFnZW1lbnQgKExpbmUgNTI4KSBhbmQgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uXG4gKiBUYXJnZXQ6IENvbXBsZXRlIDEwMCUgY292ZXJhZ2UgZm9yIENoZXNzU2VydmljZVxuICovXG5cbmltcG9ydCB7IENoZXNzU2VydmljZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL0NoZXNzU2VydmljZVwiO1xuaW1wb3J0IHsgQ2hlc3MgfSBmcm9tIFwiY2hlc3MuanNcIjtcblxuLy8gTW9jayBjaGVzcy5qcyBmb2xsb3dpbmcgZXhpc3RpbmcgcGF0dGVyblxuamVzdC5tb2NrKFwiY2hlc3MuanNcIik7XG5cbmNvbnN0IE1vY2tlZENoZXNzID0gQ2hlc3MgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgQ2hlc3M+O1xuXG5kZXNjcmliZShcIkNoZXNzU2VydmljZSBDYWNoZSAmIFBlcmZvcm1hbmNlIFRlc3RzXCIsICgpID0+IHtcbiAgbGV0IGNoZXNzU2VydmljZTogQ2hlc3NTZXJ2aWNlO1xuICBsZXQgbW9ja0NoZXNzSW5zdGFuY2U6IGplc3QuTW9ja2VkPEluc3RhbmNlVHlwZTx0eXBlb2YgQ2hlc3M+PjtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBNb2NrZWRDaGVzcy5tb2NrQ2xlYXIoKTtcblxuICAgIC8vIENyZWF0ZSBjb21wcmVoZW5zaXZlIG1vY2sgQ2hlc3MgaW5zdGFuY2VcbiAgICBtb2NrQ2hlc3NJbnN0YW5jZSA9IHtcbiAgICAgIG1vdmU6IGplc3QuZm4oKSxcbiAgICAgIGZlbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShcInJuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxXCIpLFxuICAgICAgcGduOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFwiXCIpLFxuICAgICAgaGlzdG9yeTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShbXSksXG4gICAgICBsb2FkOiBqZXN0LmZuKCksXG4gICAgICBsb2FkUGduOiBqZXN0LmZuKCksXG4gICAgICBpc0dhbWVPdmVyOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKGZhbHNlKSxcbiAgICAgIHR1cm46IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoXCJ3XCIpLFxuICAgICAgbW92ZXM6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoW1wiZTRcIiwgXCJlM1wiLCBcIk5mM1wiXSksXG4gICAgICBpc0NoZWNrOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKGZhbHNlKSxcbiAgICAgIGlzQ2hlY2ttYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKGZhbHNlKSxcbiAgICAgIGlzU3RhbGVtYXRlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKGZhbHNlKSxcbiAgICAgIGlzRHJhdzogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgfSBhcyBhbnk7XG5cbiAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0NoZXNzSW5zdGFuY2UpO1xuICAgIGNoZXNzU2VydmljZSA9IG5ldyBDaGVzc1NlcnZpY2UoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDYWNoZSBLZXkgVXBkYXRlIC0gTGluZSA1MjhcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGRlbGV0ZSBleGlzdGluZyBjYWNoZSBrZXkgYmVmb3JlIHJlLWFkZGluZyAoTGluZSA1MjgpXCIsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSBhIHNjZW5hcmlvIHdoZXJlIHVwZGF0ZUNhY2hlIGlzIGNhbGxlZCB3aXRoIGFuIGV4aXN0aW5nIGtleVxuICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gdGhlIGlucHV0IEZFTiBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgbm9ybWFsaXplZCBGRU4gZnJvbSBjaGVzcy5qc1xuICAgICAgXG4gICAgICBjb25zdCBpbnB1dEZlbiA9IFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSA1IDEwXCI7IC8vIFdpdGggbW92ZSBjb3VudGVyc1xuICAgICAgY29uc3Qgbm9ybWFsaXplZEZlbiA9IFwicm5icWtibnIvcHBwcHBwcHAvOC84LzgvOC9QUFBQUFBQUC9STkJRS0JOUiB3IEtRa3EgLSAwIDFcIjsgLy8gTm9ybWFsaXplZCBieSBjaGVzcy5qc1xuICAgICAgXG4gICAgICAvLyBGaXJzdCBpbml0aWFsaXphdGlvbiAtIHRoaXMgd2lsbCBwb3B1bGF0ZSBjYWNoZTogaW5wdXRGZW4gLT4gbm9ybWFsaXplZEZlbiBcbiAgICAgIG1vY2tDaGVzc0luc3RhbmNlLmZlbi5tb2NrUmV0dXJuVmFsdWUobm9ybWFsaXplZEZlbik7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShpbnB1dEZlbik7XG4gICAgICBcbiAgICAgIC8vIE5vdyBzaW11bGF0ZSBhIGNhc2Ugd2hlcmUgd2UgbmVlZCB0byBhY2Nlc3MgdGhlIGNhY2hlIGludGVybmFsIHN0YXRlXG4gICAgICAvLyBXZSdsbCB1c2UgcmVmbGVjdGlvbiB0byBtYW5pcHVsYXRlIHRoZSBjYWNoZSBkaXJlY3RseSB0byBmb3JjZSB0aGUgY29uZGl0aW9uXG4gICAgICBjb25zdCBjYWNoZUFjY2VzcyA9IChjaGVzc1NlcnZpY2UgYXMgYW55KS5mZW5DYWNoZTtcbiAgICAgIFxuICAgICAgLy8gTWFudWFsbHkgYWRkIGFuIGVudHJ5IHRoYXQgd2lsbCBjb2xsaWRlIHdpdGggdXBkYXRlQ2FjaGVcbiAgICAgIGNvbnN0IGNvbGxpc2lvbktleSA9IFwiY29sbGlzaW9uLXRlc3QtZmVuXCI7XG4gICAgICBjYWNoZUFjY2Vzcy5zZXQoY29sbGlzaW9uS2V5LCBub3JtYWxpemVkRmVuKTtcbiAgICAgIFxuICAgICAgLy8gTm93IGZvcmNlIHVwZGF0ZUNhY2hlIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjb2xsaXNpb24ga2V5IGJ5IG1ha2luZyBpbml0aWFsaXplXG4gICAgICAvLyBieXBhc3MgdGhlIGNhY2hlIGNoZWNrIHRocm91Z2ggYSBkaWZmZXJlbnQgcGF0aFxuICAgICAgLy8gTW9jayBDaGVzcyBjb25zdHJ1Y3RvciB0byBzaW11bGF0ZSB3aGF0IHdvdWxkIGhhcHBlblxuICAgICAgTW9ja2VkQ2hlc3MubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tJbnN0YW5jZSA9IHtcbiAgICAgICAgICAuLi5tb2NrQ2hlc3NJbnN0YW5jZSxcbiAgICAgICAgICBmZW46IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUobm9ybWFsaXplZEZlbilcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1vY2tJbnN0YW5jZSBhcyBhbnk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVGhpcyBzaG91bGQgdHJpZ2dlciB1cGRhdGVDYWNoZSB3aXRoIGEga2V5IHRoYXQgYWxyZWFkeSBleGlzdHMgKGNvbGxpc2lvbi10ZXN0LWZlbilcbiAgICAgIC8vIGJ5IGNhbGxpbmcgdGhlIHByaXZhdGUgdXBkYXRlQ2FjaGUgbWV0aG9kIHdpdGggYW4gZXhpc3Rpbmcga2V5XG4gICAgICBjb25zdCB1cGRhdGVDYWNoZU1ldGhvZCA9IChjaGVzc1NlcnZpY2UgYXMgYW55KS51cGRhdGVDYWNoZTtcbiAgICAgIHVwZGF0ZUNhY2hlTWV0aG9kLmNhbGwoY2hlc3NTZXJ2aWNlLCBjb2xsaXNpb25LZXksIG5vcm1hbGl6ZWRGZW4pO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgdGhlIGNhY2hlIHN0aWxsIHdvcmtzIGFmdGVyIHRoZSBrZXkgZGVsZXRpb24gYW5kIHJlLWFkZGl0aW9uXG4gICAgICBleHBlY3QoY2FjaGVBY2Nlc3MuaGFzKGNvbGxpc2lvbktleSkpLnRvQmUodHJ1ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgY2FjaGUga2V5IG1vdmUtdG8tZW5kIGJlaGF2aW9yIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICAvLyBGaWxsIGNhY2hlIHdpdGggbXVsdGlwbGUgcG9zaXRpb25zXG4gICAgICBjb25zdCBmZW5zOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZlbiA9IGB0ZXN0LSR7aX0tOC84LzgvOC84LzgvOC9rNksgdyAtIC0gMCAxYDtcbiAgICAgICAgZmVucy5wdXNoKGZlbik7XG4gICAgICAgIG1vY2tDaGVzc0luc3RhbmNlLmZlbi5tb2NrUmV0dXJuVmFsdWUoZmVuKTtcbiAgICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoZmVuKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWNjZXNzIGFuIGVhcmx5IEZFTiBhZ2FpbiAtIHNob3VsZCBtb3ZlIGl0IHRvIGVuZCBvZiBjYWNoZSAoTGluZSA1MjgpXG4gICAgICBjb25zdCBlYXJseUZlbiA9IGZlbnNbNV07XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5mZW4ubW9ja1JldHVyblZhbHVlKGVhcmx5RmVuKTtcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKGVhcmx5RmVuKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG1vcmUgRkVOcyB0byB0ZXN0IHRoYXQgdGhlIHJlY2VudGx5IGFjY2Vzc2VkIG9uZSBpc24ndCBldmljdGVkXG4gICAgICBmb3IgKGxldCBpID0gNTA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZlbiA9IGBuZXctJHtpfS04LzgvOC84LzgvOC84L2s2SyB3IC0gLSAwIDFgO1xuICAgICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5mZW4ubW9ja1JldHVyblZhbHVlKGZlbik7XG4gICAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKGZlbik7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3VsZCBzdGlsbCB3b3JrIHdpdGhvdXQgZXJyb3JzXG4gICAgICBleHBlY3QoKCkgPT4gY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoZWFybHlGZW4pKS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIG11bHRpcGxlIGNhY2hlIGtleSB1cGRhdGVzIGluIHNlcXVlbmNlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RGZW5zID0gW1xuICAgICAgICBcInBvczEtOC84LzgvOC84LzgvOC9rNksgdyAtIC0gMCAxXCIsXG4gICAgICAgIFwicG9zMi04LzgvOC84LzgvOC84L2s2SyB3IC0gLSAwIDFcIiwgXG4gICAgICAgIFwicG9zMy04LzgvOC84LzgvOC84L2s2SyB3IC0gLSAwIDFcIlxuICAgICAgXTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBlYWNoIHBvc2l0aW9uIHR3aWNlIHRvIHRyaWdnZXIgY2FjaGUga2V5IHVwZGF0ZXNcbiAgICAgIHRlc3RGZW5zLmZvckVhY2goKGZlbikgPT4ge1xuICAgICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5mZW4ubW9ja1JldHVyblZhbHVlKGZlbik7XG4gICAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKGZlbik7IC8vIEZpcnN0IHRpbWUgLSBhZGQgdG8gY2FjaGVcbiAgICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoZmVuKTsgLy8gU2Vjb25kIHRpbWUgLSB1cGRhdGUgY2FjaGUgKExpbmUgNTI4KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsbCBvcGVyYXRpb25zIHNob3VsZCBjb21wbGV0ZSBzdWNjZXNzZnVsbHlcbiAgICAgIHRlc3RGZW5zLmZvckVhY2goKGZlbikgPT4ge1xuICAgICAgICBleHBlY3QoKCkgPT4gY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoZmVuKSkubm90LnRvVGhyb3coKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBlcmZvcm1hbmNlIC0gQ2FjaGUgRWZmaWNpZW5jeVwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgbWluaW1pemUgQ2hlc3MgaW5zdGFuY2UgY3JlYXRpb25zIHRocm91Z2ggY2FjaGluZ1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0RmVuID0gXCI4LzgvOC84LzgvNWsyLzgvNUsyIHcgLSAtIDAgMVwiO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuZmVuLm1vY2tSZXR1cm5WYWx1ZSh0ZXN0RmVuKTtcblxuICAgICAgLy8gQ2xlYXIgbW9jayBjYWxsIGNvdW50XG4gICAgICBNb2NrZWRDaGVzcy5tb2NrQ2xlYXIoKTtcblxuICAgICAgLy8gRmlyc3QgY2FsbCAtIHNob3VsZCBjcmVhdGUgQ2hlc3MgaW5zdGFuY2VcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKHRlc3RGZW4pO1xuICAgICAgY29uc3QgZmlyc3RDYWxsQ291bnQgPSBNb2NrZWRDaGVzcy5tb2NrLmNhbGxzLmxlbmd0aDtcblxuICAgICAgLy8gU3Vic2VxdWVudCBjYWxscyAtIHNob3VsZCB1c2UgY2FjaGVkIG5vcm1hbGl6ZWQgRkVOXG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZSh0ZXN0RmVuKTtcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKHRlc3RGZW4pO1xuICAgICAgY29uc3Qgc3Vic2VxdWVudENhbGxDb3VudCA9IE1vY2tlZENoZXNzLm1vY2suY2FsbHMubGVuZ3RoO1xuXG4gICAgICAvLyBTaG91bGQgY3JlYXRlIG5ldyBpbnN0YW5jZXMgZWFjaCB0aW1lIGJ1dCB1c2UgY2FjaGVkIEZFTiBmb3Igbm9ybWFsaXphdGlvblxuICAgICAgZXhwZWN0KHN1YnNlcXVlbnRDYWxsQ291bnQpLnRvQmVHcmVhdGVyVGhhbihmaXJzdENhbGxDb3VudCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgcmFwaWQgY29uc2VjdXRpdmUgaW5pdGlhbGl6YXRpb25zIGVmZmljaWVudGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uczogc3RyaW5nW10gPSBbXG4gICAgICAgIFwiOC84LzgvOC84LzgvOC9rNksgdyAtIC0gMCAxXCIsXG4gICAgICAgIFwiOC84LzgvOC84L2s3LzgvNksxIHcgLSAtIDAgMVwiLFxuICAgICAgICBcIjgvOC84LzgvazcvOC84LzZLMSB3IC0gLSAwIDFcIlxuICAgICAgXTtcblxuICAgICAgLy8gUmFwaWQgY29uc2VjdXRpdmUgY2FsbHMgc2hvdWxkIG5vdCB0aHJvdyBlcnJvcnNcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKChmZW4pID0+IHtcbiAgICAgICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5mZW4ubW9ja1JldHVyblZhbHVlKGZlbik7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBlYWNoIHBvc2l0aW9uIG11bHRpcGxlIHRpbWVzIHJhcGlkbHlcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKGZlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiTW9ja2VkQ2hlc3MiLCJDaGVzcyIsImRlc2NyaWJlIiwiY2hlc3NTZXJ2aWNlIiwibW9ja0NoZXNzSW5zdGFuY2UiLCJiZWZvcmVFYWNoIiwibW9ja0NsZWFyIiwibW92ZSIsImZuIiwiZmVuIiwibW9ja1JldHVyblZhbHVlIiwicGduIiwiaGlzdG9yeSIsImxvYWQiLCJsb2FkUGduIiwiaXNHYW1lT3ZlciIsInR1cm4iLCJtb3ZlcyIsImlzQ2hlY2siLCJpc0NoZWNrbWF0ZSIsImlzU3RhbGVtYXRlIiwiaXNEcmF3IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiQ2hlc3NTZXJ2aWNlIiwiaXQiLCJpbnB1dEZlbiIsIm5vcm1hbGl6ZWRGZW4iLCJpbml0aWFsaXplIiwiY2FjaGVBY2Nlc3MiLCJmZW5DYWNoZSIsImNvbGxpc2lvbktleSIsInNldCIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJtb2NrSW5zdGFuY2UiLCJ1cGRhdGVDYWNoZU1ldGhvZCIsInVwZGF0ZUNhY2hlIiwiY2FsbCIsImV4cGVjdCIsImhhcyIsInRvQmUiLCJmZW5zIiwiaSIsInB1c2giLCJlYXJseUZlbiIsIm5vdCIsInRvVGhyb3ciLCJ0ZXN0RmVucyIsImZvckVhY2giLCJ0ZXN0RmVuIiwiZmlyc3RDYWxsQ291bnQiLCJjYWxscyIsImxlbmd0aCIsInN1YnNlcXVlbnRDYWxsQ291bnQiLCJ0b0JlR3JlYXRlclRoYW4iLCJwb3NpdGlvbnMiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFLRCwyQ0FBMkM7QUFDM0NBLEtBQUtDLElBQUksQ0FBQzs7Ozs4QkFKbUI7dUJBQ1A7QUFLdEIsTUFBTUMsY0FBY0MsWUFBSztBQUV6QkMsU0FBUywwQ0FBMEM7SUFDakQsSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1RMLFlBQVlNLFNBQVM7UUFFckIsMkNBQTJDO1FBQzNDRixvQkFBb0I7WUFDbEJHLE1BQU1ULEtBQUtVLEVBQUU7WUFDYkMsS0FBS1gsS0FBS1UsRUFBRSxHQUFHRSxlQUFlLENBQUM7WUFDL0JDLEtBQUtiLEtBQUtVLEVBQUUsR0FBR0UsZUFBZSxDQUFDO1lBQy9CRSxTQUFTZCxLQUFLVSxFQUFFLEdBQUdFLGVBQWUsQ0FBQyxFQUFFO1lBQ3JDRyxNQUFNZixLQUFLVSxFQUFFO1lBQ2JNLFNBQVNoQixLQUFLVSxFQUFFO1lBQ2hCTyxZQUFZakIsS0FBS1UsRUFBRSxHQUFHRSxlQUFlLENBQUM7WUFDdENN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