caaac77de54bbfa3f961105702b59ff6
/**
 * Tests for core Logger functionality
 *
 * Tests cover:
 * - Log level methods (debug, info, warn, error, fatal)
 * - minLevel filtering
 * - Context management (setContext, clearContext)
 * - ConsoleTransport
 * - Log formatting
 * - Configuration management
 * - withFields functionality
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _Logger = require("../../../../shared/services/logging/Logger");
const _types = require("../../../../shared/services/logging/types");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
// Mock transport for testing
class MockTransport {
    /**
   * Log entry to mock storage
   * @param entry Log entry to store
   */ log(entry) {
        this.logs.push(entry);
    }
    /**
   *
   */ async flush() {
    // No-op for mock
    }
    constructor(){
        _define_property(this, "logs", []);
    }
}
describe("Logger", ()=>{
    let mockTransport;
    let consoleSpies;
    beforeEach(()=>{
        // Reset global logger instance
        (0, _Logger.resetLogger)();
        // Create fresh mock transport
        mockTransport = new MockTransport();
        // Spy on console methods
        consoleSpies = {
            debug: jest.spyOn(console, "debug").mockImplementation(),
            info: jest.spyOn(console, "info").mockImplementation(),
            warn: jest.spyOn(console, "warn").mockImplementation(),
            error: jest.spyOn(console, "error").mockImplementation()
        };
    });
    afterEach(()=>{
        // Restore console methods
        Object.values(consoleSpies).forEach((spy)=>spy.mockRestore());
    });
    describe("Method-to-Level Mapping", ()=>{
        it("should call transport with DEBUG level for debug()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.debug("Debug message");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.DEBUG);
            expect(mockTransport.logs[0].message).toBe("Debug message");
        });
        it("should call transport with INFO level for info()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.info("Info message");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.INFO);
            expect(mockTransport.logs[0].message).toBe("Info message");
        });
        it("should call transport with WARN level for warn()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.warn("Warning message");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.WARN);
            expect(mockTransport.logs[0].message).toBe("Warning message");
        });
        it("should call transport with ERROR level for error()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.error("Error message");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.ERROR);
            expect(mockTransport.logs[0].message).toBe("Error message");
        });
        it("should call transport with FATAL level for fatal()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.fatal("Fatal message");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.FATAL);
            expect(mockTransport.logs[0].message).toBe("Fatal message");
        });
    });
    describe("minLevel Filtering", ()=>{
        it("should filter out DEBUG messages when minLevel is INFO", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.INFO,
                transports: [
                    mockTransport
                ]
            });
            logger.debug("Should be ignored");
            logger.info("Should be logged");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].message).toBe("Should be logged");
        });
        it("should filter out DEBUG and INFO messages when minLevel is WARN", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.WARN,
                transports: [
                    mockTransport
                ]
            });
            logger.debug("Should be ignored");
            logger.info("Should be ignored");
            logger.warn("Should be logged");
            logger.error("Should be logged");
            expect(mockTransport.logs).toHaveLength(2);
            expect(mockTransport.logs[0].message).toBe("Should be logged");
            expect(mockTransport.logs[1].message).toBe("Should be logged");
        });
        it("should log all levels when minLevel is DEBUG", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.debug("Debug");
            logger.info("Info");
            logger.warn("Warn");
            logger.error("Error");
            logger.fatal("Fatal");
            expect(mockTransport.logs).toHaveLength(5);
        });
    });
    describe("Context Management", ()=>{
        it("should add context to log entries with setContext()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const contextLogger = logger.setContext("UserService");
            contextLogger.info("User action");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].context).toBe("UserService");
        });
        it("should clear context with clearContext()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const contextLogger = logger.setContext("UserService");
            contextLogger.info("With context");
            contextLogger.clearContext();
            contextLogger.info("Without context");
            expect(mockTransport.logs).toHaveLength(2);
            expect(mockTransport.logs[0].context).toBe("UserService");
            expect(mockTransport.logs[1].context).toBeUndefined();
        });
        it("should preserve context across multiple log calls", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const contextLogger = logger.setContext("PaymentService");
            contextLogger.info("Processing payment");
            contextLogger.warn("Payment delayed");
            contextLogger.error("Payment failed");
            expect(mockTransport.logs).toHaveLength(3);
            expect(mockTransport.logs.every((log)=>log.context === "PaymentService")).toBe(true);
        });
    });
    describe("Data and Error Handling", ()=>{
        it("should include data object in log entry", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const data = {
                userId: 123,
                action: "login"
            };
            logger.info("User logged in", data);
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].data).toEqual(data);
        });
        it("should include error details in log entry", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const error = new Error("Connection failed");
            logger.error("Database error", error);
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].error).toEqual(error);
            expect(mockTransport.logs[0].stack).toBeDefined();
        });
        it("should handle error passed as data", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const error = new Error("Connection failed");
            logger.error("Database error", error, {
                retries: 3
            });
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].error).toEqual(error);
            expect(mockTransport.logs[0].data).toEqual({
                retries: 3
            });
        });
    });
    describe("ConsoleTransport", ()=>{
        it("should log to console.info for INFO level", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.INFO,
                enableConsole: true,
                enableRemote: false
            });
            logger.info("Console info message");
            expect(consoleSpies.info).toHaveBeenCalled();
            const call = consoleSpies.info.mock.calls[0];
            expect(call[0]).toContain("INFO");
            expect(call[0]).toContain("Console info message");
        });
        it("should log to console.debug for DEBUG level", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                enableConsole: true,
                enableRemote: false
            });
            logger.debug("Console debug message");
            expect(consoleSpies.debug).toHaveBeenCalled();
            const call = consoleSpies.debug.mock.calls[0];
            expect(call[0]).toContain("DEBUG");
            expect(call[0]).toContain("Console debug message");
        });
        it("should log to console.warn for WARN level", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                enableConsole: true,
                enableRemote: false
            });
            logger.warn("Console warning");
            expect(consoleSpies.warn).toHaveBeenCalled();
            const call = consoleSpies.warn.mock.calls[0];
            expect(call[0]).toContain("WARN");
            expect(call[0]).toContain("Console warning");
        });
        it("should log to console.error for ERROR and FATAL levels", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                enableConsole: true,
                enableRemote: false
            });
            logger.error("Console error");
            logger.fatal("Console fatal");
            expect(consoleSpies.error).toHaveBeenCalledTimes(2);
            expect(consoleSpies.error.mock.calls[0][0]).toContain("ERROR");
            expect(consoleSpies.error.mock.calls[1][0]).toContain("FATAL");
        });
        it("should include context in console output", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                enableConsole: true,
                enableRemote: false
            });
            const contextLogger = logger.setContext("TestContext");
            contextLogger.info("Message with context");
            expect(consoleSpies.info).toHaveBeenCalled();
            const call = consoleSpies.info.mock.calls[0];
            expect(call[0]).toContain("[TestContext]");
        });
    });
    describe("Configuration", ()=>{
        it("should return current configuration with getConfig()", ()=>{
            const config = {
                minLevel: _types.LogLevel.WARN,
                enableConsole: false,
                enableRemote: true,
                remoteEndpoint: "https://logs.example.com"
            };
            const logger = (0, _Logger.createLogger)(config);
            const returnedConfig = logger.getConfig();
            expect(returnedConfig.minLevel).toBe(config.minLevel);
            expect(returnedConfig.enableConsole).toBe(config.enableConsole);
            expect(returnedConfig.enableRemote).toBe(config.enableRemote);
        });
        it("should update configuration with updateConfig()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.INFO,
                transports: [
                    mockTransport
                ]
            });
            // Log should be filtered
            logger.debug("Should be filtered");
            expect(mockTransport.logs).toHaveLength(0);
            // Update config to allow DEBUG and keep the same transport
            logger.updateConfig({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            // Now debug should work
            logger.debug("Should be logged");
            expect(mockTransport.logs).toHaveLength(1);
        });
    });
    describe("withFields", ()=>{
        it("should create a child logger with additional fields", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const childLogger = logger.withFields({
                requestId: "abc123"
            });
            childLogger.info("Request processed");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].data).toEqual({
                requestId: "abc123"
            });
        });
        it("should merge fields with log-specific data", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            const childLogger = logger.withFields({
                service: "api"
            });
            childLogger.info("Request received", {
                path: "/users"
            });
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].data).toEqual({
                service: "api",
                path: "/users"
            });
        });
    });
    describe("Log Storage", ()=>{
        it("should store logs in memory", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.info("First log");
            logger.warn("Second log");
            const logs = logger.getLogs();
            expect(logs).toHaveLength(2);
            expect(logs[0].message).toBe("First log");
            expect(logs[1].message).toBe("Second log");
        });
        it("should respect maxLogSize configuration", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                maxLogSize: 2,
                transports: [
                    mockTransport
                ]
            });
            logger.info("Log 1");
            logger.info("Log 2");
            logger.info("Log 3");
            const logs = logger.getLogs();
            expect(logs).toHaveLength(2);
            expect(logs[0].message).toBe("Log 2");
            expect(logs[1].message).toBe("Log 3");
        });
        it("should filter logs with getLogs(filter)", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.debug("Debug message");
            logger.info("Info message");
            logger.error("Error message");
            const errorLogs = logger.getLogs({
                minLevel: _types.LogLevel.ERROR
            });
            expect(errorLogs).toHaveLength(1);
            expect(errorLogs[0].message).toBe("Error message");
        });
        it("should clear logs with clearLogs()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.info("Test log");
            expect(logger.getLogs()).toHaveLength(1);
            logger.clearLogs();
            expect(logger.getLogs()).toHaveLength(0);
        });
    });
    describe("Performance Timing", ()=>{
        it("should measure time with time() and timeEnd()", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.time("operation");
            // Simulate some delay
            const start = Date.now();
            while(Date.now() - start < 10){
            // Wait
            }
            logger.timeEnd("operation");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.DEBUG);
            expect(mockTransport.logs[0].message).toContain("operation:");
            expect(mockTransport.logs[0].data.duration).toBeGreaterThan(0);
        });
        it("should warn if timer does not exist", ()=>{
            const logger = (0, _Logger.createLogger)({
                minLevel: _types.LogLevel.DEBUG,
                transports: [
                    mockTransport
                ]
            });
            logger.timeEnd("nonexistent");
            expect(mockTransport.logs).toHaveLength(1);
            expect(mockTransport.logs[0].level).toBe(_types.LogLevel.WARN);
            expect(mockTransport.logs[0].message).toContain("Timer 'nonexistent' does not exist");
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9sb2dnaW5nL0xvZ2dlci50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgZm9yIGNvcmUgTG9nZ2VyIGZ1bmN0aW9uYWxpdHlcbiAqXG4gKiBUZXN0cyBjb3ZlcjpcbiAqIC0gTG9nIGxldmVsIG1ldGhvZHMgKGRlYnVnLCBpbmZvLCB3YXJuLCBlcnJvciwgZmF0YWwpXG4gKiAtIG1pbkxldmVsIGZpbHRlcmluZ1xuICogLSBDb250ZXh0IG1hbmFnZW1lbnQgKHNldENvbnRleHQsIGNsZWFyQ29udGV4dClcbiAqIC0gQ29uc29sZVRyYW5zcG9ydFxuICogLSBMb2cgZm9ybWF0dGluZ1xuICogLSBDb25maWd1cmF0aW9uIG1hbmFnZW1lbnRcbiAqIC0gd2l0aEZpZWxkcyBmdW5jdGlvbmFsaXR5XG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlTG9nZ2VyLCByZXNldExvZ2dlciB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyXCI7XG5pbXBvcnQge1xuICBMb2dMZXZlbCxcbiAgTG9nRW50cnksXG4gIElMb2dUcmFuc3BvcnQsXG59IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvdHlwZXNcIjtcblxuLy8gTW9jayB0cmFuc3BvcnQgZm9yIHRlc3RpbmdcbmNsYXNzIE1vY2tUcmFuc3BvcnQgaW1wbGVtZW50cyBJTG9nVHJhbnNwb3J0IHtcbiAgcHVibGljIGxvZ3M6IExvZ0VudHJ5W10gPSBbXTtcblxuICAvKipcbiAgICogTG9nIGVudHJ5IHRvIG1vY2sgc3RvcmFnZVxuICAgKiBAcGFyYW0gZW50cnkgTG9nIGVudHJ5IHRvIHN0b3JlXG4gICAqL1xuICBsb2coZW50cnk6IExvZ0VudHJ5KTogdm9pZCB7XG4gICAgdGhpcy5sb2dzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqL1xuICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBOby1vcCBmb3IgbW9ja1xuICB9XG59XG5cbmRlc2NyaWJlKFwiTG9nZ2VyXCIsICgpID0+IHtcbiAgbGV0IG1vY2tUcmFuc3BvcnQ6IE1vY2tUcmFuc3BvcnQ7XG4gIGxldCBjb25zb2xlU3BpZXM6IHtcbiAgICBkZWJ1ZzogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBpbmZvOiBqZXN0LlNweUluc3RhbmNlO1xuICAgIHdhcm46IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgZXJyb3I6IGplc3QuU3B5SW5zdGFuY2U7XG4gIH07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gUmVzZXQgZ2xvYmFsIGxvZ2dlciBpbnN0YW5jZVxuICAgIHJlc2V0TG9nZ2VyKCk7XG5cbiAgICAvLyBDcmVhdGUgZnJlc2ggbW9jayB0cmFuc3BvcnRcbiAgICBtb2NrVHJhbnNwb3J0ID0gbmV3IE1vY2tUcmFuc3BvcnQoKTtcblxuICAgIC8vIFNweSBvbiBjb25zb2xlIG1ldGhvZHNcbiAgICBjb25zb2xlU3BpZXMgPSB7XG4gICAgICBkZWJ1ZzogamVzdC5zcHlPbihjb25zb2xlLCBcImRlYnVnXCIpLm1vY2tJbXBsZW1lbnRhdGlvbigpLFxuICAgICAgaW5mbzogamVzdC5zcHlPbihjb25zb2xlLCBcImluZm9cIikubW9ja0ltcGxlbWVudGF0aW9uKCksXG4gICAgICB3YXJuOiBqZXN0LnNweU9uKGNvbnNvbGUsIFwid2FyblwiKS5tb2NrSW1wbGVtZW50YXRpb24oKSxcbiAgICAgIGVycm9yOiBqZXN0LnNweU9uKGNvbnNvbGUsIFwiZXJyb3JcIikubW9ja0ltcGxlbWVudGF0aW9uKCksXG4gICAgfTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAvLyBSZXN0b3JlIGNvbnNvbGUgbWV0aG9kc1xuICAgIE9iamVjdC52YWx1ZXMoY29uc29sZVNwaWVzKS5mb3JFYWNoKChzcHkpID0+IHNweS5tb2NrUmVzdG9yZSgpKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJNZXRob2QtdG8tTGV2ZWwgTWFwcGluZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgY2FsbCB0cmFuc3BvcnQgd2l0aCBERUJVRyBsZXZlbCBmb3IgZGVidWcoKVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJEZWJ1ZyBtZXNzYWdlXCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmxldmVsKS50b0JlKExvZ0xldmVsLkRFQlVHKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIkRlYnVnIG1lc3NhZ2VcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjYWxsIHRyYW5zcG9ydCB3aXRoIElORk8gbGV2ZWwgZm9yIGluZm8oKVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuaW5mbyhcIkluZm8gbWVzc2FnZVwiKTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9ncykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5sZXZlbCkudG9CZShMb2dMZXZlbC5JTkZPKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIkluZm8gbWVzc2FnZVwiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNhbGwgdHJhbnNwb3J0IHdpdGggV0FSTiBsZXZlbCBmb3Igd2FybigpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlci53YXJuKFwiV2FybmluZyBtZXNzYWdlXCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmxldmVsKS50b0JlKExvZ0xldmVsLldBUk4pO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5tZXNzYWdlKS50b0JlKFwiV2FybmluZyBtZXNzYWdlXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgY2FsbCB0cmFuc3BvcnQgd2l0aCBFUlJPUiBsZXZlbCBmb3IgZXJyb3IoKVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBtZXNzYWdlXCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmxldmVsKS50b0JlKExvZ0xldmVsLkVSUk9SKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIkVycm9yIG1lc3NhZ2VcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjYWxsIHRyYW5zcG9ydCB3aXRoIEZBVEFMIGxldmVsIGZvciBmYXRhbCgpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlci5mYXRhbChcIkZhdGFsIG1lc3NhZ2VcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubGV2ZWwpLnRvQmUoTG9nTGV2ZWwuRkFUQUwpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5tZXNzYWdlKS50b0JlKFwiRmF0YWwgbWVzc2FnZVwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJtaW5MZXZlbCBGaWx0ZXJpbmdcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGZpbHRlciBvdXQgREVCVUcgbWVzc2FnZXMgd2hlbiBtaW5MZXZlbCBpcyBJTkZPXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICAgICAgICB0cmFuc3BvcnRzOiBbbW9ja1RyYW5zcG9ydF0sXG4gICAgICB9KTtcblxuICAgICAgbG9nZ2VyLmRlYnVnKFwiU2hvdWxkIGJlIGlnbm9yZWRcIik7XG4gICAgICBsb2dnZXIuaW5mbyhcIlNob3VsZCBiZSBsb2dnZWRcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIlNob3VsZCBiZSBsb2dnZWRcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBmaWx0ZXIgb3V0IERFQlVHIGFuZCBJTkZPIG1lc3NhZ2VzIHdoZW4gbWluTGV2ZWwgaXMgV0FSTlwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuV0FSTixcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIlNob3VsZCBiZSBpZ25vcmVkXCIpO1xuICAgICAgbG9nZ2VyLmluZm8oXCJTaG91bGQgYmUgaWdub3JlZFwiKTtcbiAgICAgIGxvZ2dlci53YXJuKFwiU2hvdWxkIGJlIGxvZ2dlZFwiKTtcbiAgICAgIGxvZ2dlci5lcnJvcihcIlNob3VsZCBiZSBsb2dnZWRcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgyKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIlNob3VsZCBiZSBsb2dnZWRcIik7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzFdLm1lc3NhZ2UpLnRvQmUoXCJTaG91bGQgYmUgbG9nZ2VkXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbG9nIGFsbCBsZXZlbHMgd2hlbiBtaW5MZXZlbCBpcyBERUJVR1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJEZWJ1Z1wiKTtcbiAgICAgIGxvZ2dlci5pbmZvKFwiSW5mb1wiKTtcbiAgICAgIGxvZ2dlci53YXJuKFwiV2FyblwiKTtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yXCIpO1xuICAgICAgbG9nZ2VyLmZhdGFsKFwiRmF0YWxcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCg1KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb250ZXh0IE1hbmFnZW1lbnRcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGFkZCBjb250ZXh0IHRvIGxvZyBlbnRyaWVzIHdpdGggc2V0Q29udGV4dCgpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRleHRMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dChcIlVzZXJTZXJ2aWNlXCIpO1xuICAgICAgY29udGV4dExvZ2dlci5pbmZvKFwiVXNlciBhY3Rpb25cIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0uY29udGV4dCkudG9CZShcIlVzZXJTZXJ2aWNlXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgY2xlYXIgY29udGV4dCB3aXRoIGNsZWFyQ29udGV4dCgpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRleHRMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dChcIlVzZXJTZXJ2aWNlXCIpO1xuICAgICAgY29udGV4dExvZ2dlci5pbmZvKFwiV2l0aCBjb250ZXh0XCIpO1xuXG4gICAgICBjb250ZXh0TG9nZ2VyLmNsZWFyQ29udGV4dCgpO1xuICAgICAgY29udGV4dExvZ2dlci5pbmZvKFwiV2l0aG91dCBjb250ZXh0XCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmNvbnRleHQpLnRvQmUoXCJVc2VyU2VydmljZVwiKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMV0uY29udGV4dCkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcHJlc2VydmUgY29udGV4dCBhY3Jvc3MgbXVsdGlwbGUgbG9nIGNhbGxzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRleHRMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dChcIlBheW1lbnRTZXJ2aWNlXCIpO1xuICAgICAgY29udGV4dExvZ2dlci5pbmZvKFwiUHJvY2Vzc2luZyBwYXltZW50XCIpO1xuICAgICAgY29udGV4dExvZ2dlci53YXJuKFwiUGF5bWVudCBkZWxheWVkXCIpO1xuICAgICAgY29udGV4dExvZ2dlci5lcnJvcihcIlBheW1lbnQgZmFpbGVkXCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMyk7XG4gICAgICBleHBlY3QoXG4gICAgICAgIG1vY2tUcmFuc3BvcnQubG9ncy5ldmVyeSgobG9nKSA9PiBsb2cuY29udGV4dCA9PT0gXCJQYXltZW50U2VydmljZVwiKSxcbiAgICAgICkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJEYXRhIGFuZCBFcnJvciBIYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgaW5jbHVkZSBkYXRhIG9iamVjdCBpbiBsb2cgZW50cnlcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbWluTGV2ZWw6IExvZ0xldmVsLkRFQlVHLFxuICAgICAgICB0cmFuc3BvcnRzOiBbbW9ja1RyYW5zcG9ydF0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgZGF0YSA9IHsgdXNlcklkOiAxMjMsIGFjdGlvbjogXCJsb2dpblwiIH07XG4gICAgICBsb2dnZXIuaW5mbyhcIlVzZXIgbG9nZ2VkIGluXCIsIGRhdGEpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmRhdGEpLnRvRXF1YWwoZGF0YSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBpbmNsdWRlIGVycm9yIGRldGFpbHMgaW4gbG9nIGVudHJ5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiQ29ubmVjdGlvbiBmYWlsZWRcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJEYXRhYmFzZSBlcnJvclwiLCBlcnJvcik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0uZXJyb3IpLnRvRXF1YWwoZXJyb3IpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5zdGFjaykudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBlcnJvciBwYXNzZWQgYXMgZGF0YVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkNvbm5lY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRGF0YWJhc2UgZXJyb3JcIiwgZXJyb3IsIHsgcmV0cmllczogMyB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9ncykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5lcnJvcikudG9FcXVhbChlcnJvcik7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmRhdGEpLnRvRXF1YWwoeyByZXRyaWVzOiAzIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkNvbnNvbGVUcmFuc3BvcnRcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGxvZyB0byBjb25zb2xlLmluZm8gZm9yIElORk8gbGV2ZWxcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbWluTGV2ZWw6IExvZ0xldmVsLklORk8sXG4gICAgICAgIGVuYWJsZUNvbnNvbGU6IHRydWUsXG4gICAgICAgIGVuYWJsZVJlbW90ZTogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgbG9nZ2VyLmluZm8oXCJDb25zb2xlIGluZm8gbWVzc2FnZVwiKTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVTcGllcy5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBjb25zdCBjYWxsID0gY29uc29sZVNwaWVzLmluZm8ubW9jay5jYWxsc1swXTtcbiAgICAgIGV4cGVjdChjYWxsWzBdKS50b0NvbnRhaW4oXCJJTkZPXCIpO1xuICAgICAgZXhwZWN0KGNhbGxbMF0pLnRvQ29udGFpbihcIkNvbnNvbGUgaW5mbyBtZXNzYWdlXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgbG9nIHRvIGNvbnNvbGUuZGVidWcgZm9yIERFQlVHIGxldmVsXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgZW5hYmxlQ29uc29sZTogdHJ1ZSxcbiAgICAgICAgZW5hYmxlUmVtb3RlOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJDb25zb2xlIGRlYnVnIG1lc3NhZ2VcIik7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlU3BpZXMuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGNvbnN0IGNhbGwgPSBjb25zb2xlU3BpZXMuZGVidWcubW9jay5jYWxsc1swXTtcbiAgICAgIGV4cGVjdChjYWxsWzBdKS50b0NvbnRhaW4oXCJERUJVR1wiKTtcbiAgICAgIGV4cGVjdChjYWxsWzBdKS50b0NvbnRhaW4oXCJDb25zb2xlIGRlYnVnIG1lc3NhZ2VcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBsb2cgdG8gY29uc29sZS53YXJuIGZvciBXQVJOIGxldmVsXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgZW5hYmxlQ29uc29sZTogdHJ1ZSxcbiAgICAgICAgZW5hYmxlUmVtb3RlOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIud2FybihcIkNvbnNvbGUgd2FybmluZ1wiKTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVTcGllcy53YXJuKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBjb25zdCBjYWxsID0gY29uc29sZVNwaWVzLndhcm4ubW9jay5jYWxsc1swXTtcbiAgICAgIGV4cGVjdChjYWxsWzBdKS50b0NvbnRhaW4oXCJXQVJOXCIpO1xuICAgICAgZXhwZWN0KGNhbGxbMF0pLnRvQ29udGFpbihcIkNvbnNvbGUgd2FybmluZ1wiKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGxvZyB0byBjb25zb2xlLmVycm9yIGZvciBFUlJPUiBhbmQgRkFUQUwgbGV2ZWxzXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgZW5hYmxlQ29uc29sZTogdHJ1ZSxcbiAgICAgICAgZW5hYmxlUmVtb3RlOiBmYWxzZSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZXJyb3IoXCJDb25zb2xlIGVycm9yXCIpO1xuICAgICAgbG9nZ2VyLmZhdGFsKFwiQ29uc29sZSBmYXRhbFwiKTtcblxuICAgICAgZXhwZWN0KGNvbnNvbGVTcGllcy5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVTcGllcy5lcnJvci5tb2NrLmNhbGxzWzBdWzBdKS50b0NvbnRhaW4oXCJFUlJPUlwiKTtcbiAgICAgIGV4cGVjdChjb25zb2xlU3BpZXMuZXJyb3IubW9jay5jYWxsc1sxXVswXSkudG9Db250YWluKFwiRkFUQUxcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBpbmNsdWRlIGNvbnRleHQgaW4gY29uc29sZSBvdXRwdXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbWluTGV2ZWw6IExvZ0xldmVsLkRFQlVHLFxuICAgICAgICBlbmFibGVDb25zb2xlOiB0cnVlLFxuICAgICAgICBlbmFibGVSZW1vdGU6IGZhbHNlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRleHRMb2dnZXIgPSBsb2dnZXIuc2V0Q29udGV4dChcIlRlc3RDb250ZXh0XCIpO1xuICAgICAgY29udGV4dExvZ2dlci5pbmZvKFwiTWVzc2FnZSB3aXRoIGNvbnRleHRcIik7XG5cbiAgICAgIGV4cGVjdChjb25zb2xlU3BpZXMuaW5mbykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgY29uc3QgY2FsbCA9IGNvbnNvbGVTcGllcy5pbmZvLm1vY2suY2FsbHNbMF07XG4gICAgICBleHBlY3QoY2FsbFswXSkudG9Db250YWluKFwiW1Rlc3RDb250ZXh0XVwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb25maWd1cmF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCByZXR1cm4gY3VycmVudCBjb25maWd1cmF0aW9uIHdpdGggZ2V0Q29uZmlnKClcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuV0FSTixcbiAgICAgICAgZW5hYmxlQ29uc29sZTogZmFsc2UsXG4gICAgICAgIGVuYWJsZVJlbW90ZTogdHJ1ZSxcbiAgICAgICAgcmVtb3RlRW5kcG9pbnQ6IFwiaHR0cHM6Ly9sb2dzLmV4YW1wbGUuY29tXCIsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoY29uZmlnKTtcbiAgICAgIGNvbnN0IHJldHVybmVkQ29uZmlnID0gbG9nZ2VyLmdldENvbmZpZygpO1xuXG4gICAgICBleHBlY3QocmV0dXJuZWRDb25maWcubWluTGV2ZWwpLnRvQmUoY29uZmlnLm1pbkxldmVsKTtcbiAgICAgIGV4cGVjdChyZXR1cm5lZENvbmZpZy5lbmFibGVDb25zb2xlKS50b0JlKGNvbmZpZy5lbmFibGVDb25zb2xlKTtcbiAgICAgIGV4cGVjdChyZXR1cm5lZENvbmZpZy5lbmFibGVSZW1vdGUpLnRvQmUoY29uZmlnLmVuYWJsZVJlbW90ZSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB1cGRhdGUgY29uZmlndXJhdGlvbiB3aXRoIHVwZGF0ZUNvbmZpZygpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5JTkZPLFxuICAgICAgICB0cmFuc3BvcnRzOiBbbW9ja1RyYW5zcG9ydF0sXG4gICAgICB9KTtcblxuICAgICAgLy8gTG9nIHNob3VsZCBiZSBmaWx0ZXJlZFxuICAgICAgbG9nZ2VyLmRlYnVnKFwiU2hvdWxkIGJlIGZpbHRlcmVkXCIpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9ncykudG9IYXZlTGVuZ3RoKDApO1xuXG4gICAgICAvLyBVcGRhdGUgY29uZmlnIHRvIGFsbG93IERFQlVHIGFuZCBrZWVwIHRoZSBzYW1lIHRyYW5zcG9ydFxuICAgICAgbG9nZ2VyLnVwZGF0ZUNvbmZpZyh7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE5vdyBkZWJ1ZyBzaG91bGQgd29ya1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiU2hvdWxkIGJlIGxvZ2dlZFwiKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ3aXRoRmllbGRzXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBjcmVhdGUgYSBjaGlsZCBsb2dnZXIgd2l0aCBhZGRpdGlvbmFsIGZpZWxkc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjaGlsZExvZ2dlciA9IGxvZ2dlci53aXRoRmllbGRzKHsgcmVxdWVzdElkOiBcImFiYzEyM1wiIH0pO1xuICAgICAgY2hpbGRMb2dnZXIuaW5mbyhcIlJlcXVlc3QgcHJvY2Vzc2VkXCIpO1xuXG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLmRhdGEpLnRvRXF1YWwoeyByZXF1ZXN0SWQ6IFwiYWJjMTIzXCIgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBtZXJnZSBmaWVsZHMgd2l0aCBsb2ctc3BlY2lmaWMgZGF0YVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBjaGlsZExvZ2dlciA9IGxvZ2dlci53aXRoRmllbGRzKHsgc2VydmljZTogXCJhcGlcIiB9KTtcbiAgICAgIGNoaWxkTG9nZ2VyLmluZm8oXCJSZXF1ZXN0IHJlY2VpdmVkXCIsIHsgcGF0aDogXCIvdXNlcnNcIiB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9ncykudG9IYXZlTGVuZ3RoKDEpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5kYXRhKS50b0VxdWFsKHtcbiAgICAgICAgc2VydmljZTogXCJhcGlcIixcbiAgICAgICAgcGF0aDogXCIvdXNlcnNcIixcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkxvZyBTdG9yYWdlXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBzdG9yZSBsb2dzIGluIG1lbW9yeVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuaW5mbyhcIkZpcnN0IGxvZ1wiKTtcbiAgICAgIGxvZ2dlci53YXJuKFwiU2Vjb25kIGxvZ1wiKTtcblxuICAgICAgY29uc3QgbG9ncyA9IGxvZ2dlci5nZXRMb2dzKCk7XG4gICAgICBleHBlY3QobG9ncykudG9IYXZlTGVuZ3RoKDIpO1xuICAgICAgZXhwZWN0KGxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIkZpcnN0IGxvZ1wiKTtcbiAgICAgIGV4cGVjdChsb2dzWzFdLm1lc3NhZ2UpLnRvQmUoXCJTZWNvbmQgbG9nXCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVzcGVjdCBtYXhMb2dTaXplIGNvbmZpZ3VyYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbWluTGV2ZWw6IExvZ0xldmVsLkRFQlVHLFxuICAgICAgICBtYXhMb2dTaXplOiAyLFxuICAgICAgICB0cmFuc3BvcnRzOiBbbW9ja1RyYW5zcG9ydF0sXG4gICAgICB9KTtcblxuICAgICAgbG9nZ2VyLmluZm8oXCJMb2cgMVwiKTtcbiAgICAgIGxvZ2dlci5pbmZvKFwiTG9nIDJcIik7XG4gICAgICBsb2dnZXIuaW5mbyhcIkxvZyAzXCIpO1xuXG4gICAgICBjb25zdCBsb2dzID0gbG9nZ2VyLmdldExvZ3MoKTtcbiAgICAgIGV4cGVjdChsb2dzKS50b0hhdmVMZW5ndGgoMik7XG4gICAgICBleHBlY3QobG9nc1swXS5tZXNzYWdlKS50b0JlKFwiTG9nIDJcIik7XG4gICAgICBleHBlY3QobG9nc1sxXS5tZXNzYWdlKS50b0JlKFwiTG9nIDNcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBmaWx0ZXIgbG9ncyB3aXRoIGdldExvZ3MoZmlsdGVyKVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIuZGVidWcoXCJEZWJ1ZyBtZXNzYWdlXCIpO1xuICAgICAgbG9nZ2VyLmluZm8oXCJJbmZvIG1lc3NhZ2VcIik7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJFcnJvciBtZXNzYWdlXCIpO1xuXG4gICAgICBjb25zdCBlcnJvckxvZ3MgPSBsb2dnZXIuZ2V0TG9ncyh7IG1pbkxldmVsOiBMb2dMZXZlbC5FUlJPUiB9KTtcbiAgICAgIGV4cGVjdChlcnJvckxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChlcnJvckxvZ3NbMF0ubWVzc2FnZSkudG9CZShcIkVycm9yIG1lc3NhZ2VcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjbGVhciBsb2dzIHdpdGggY2xlYXJMb2dzKClcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKHtcbiAgICAgICAgbWluTGV2ZWw6IExvZ0xldmVsLkRFQlVHLFxuICAgICAgICB0cmFuc3BvcnRzOiBbbW9ja1RyYW5zcG9ydF0sXG4gICAgICB9KTtcblxuICAgICAgbG9nZ2VyLmluZm8oXCJUZXN0IGxvZ1wiKTtcbiAgICAgIGV4cGVjdChsb2dnZXIuZ2V0TG9ncygpKS50b0hhdmVMZW5ndGgoMSk7XG5cbiAgICAgIGxvZ2dlci5jbGVhckxvZ3MoKTtcbiAgICAgIGV4cGVjdChsb2dnZXIuZ2V0TG9ncygpKS50b0hhdmVMZW5ndGgoMCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiUGVyZm9ybWFuY2UgVGltaW5nXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBtZWFzdXJlIHRpbWUgd2l0aCB0aW1lKCkgYW5kIHRpbWVFbmQoKVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBsb2dnZXIgPSBjcmVhdGVMb2dnZXIoe1xuICAgICAgICBtaW5MZXZlbDogTG9nTGV2ZWwuREVCVUcsXG4gICAgICAgIHRyYW5zcG9ydHM6IFttb2NrVHJhbnNwb3J0XSxcbiAgICAgIH0pO1xuXG4gICAgICBsb2dnZXIudGltZShcIm9wZXJhdGlvblwiKTtcblxuICAgICAgLy8gU2ltdWxhdGUgc29tZSBkZWxheVxuICAgICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydCA8IDEwKSB7XG4gICAgICAgIC8vIFdhaXRcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyLnRpbWVFbmQoXCJvcGVyYXRpb25cIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubGV2ZWwpLnRvQmUoTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5tZXNzYWdlKS50b0NvbnRhaW4oXCJvcGVyYXRpb246XCIpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFuc3BvcnQubG9nc1swXS5kYXRhLmR1cmF0aW9uKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB3YXJuIGlmIHRpbWVyIGRvZXMgbm90IGV4aXN0XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGNyZWF0ZUxvZ2dlcih7XG4gICAgICAgIG1pbkxldmVsOiBMb2dMZXZlbC5ERUJVRyxcbiAgICAgICAgdHJhbnNwb3J0czogW21vY2tUcmFuc3BvcnRdLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ2dlci50aW1lRW5kKFwibm9uZXhpc3RlbnRcIik7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3MpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhbnNwb3J0LmxvZ3NbMF0ubGV2ZWwpLnRvQmUoTG9nTGV2ZWwuV0FSTik7XG4gICAgICBleHBlY3QobW9ja1RyYW5zcG9ydC5sb2dzWzBdLm1lc3NhZ2UpLnRvQ29udGFpbihcbiAgICAgICAgXCJUaW1lciAnbm9uZXhpc3RlbnQnIGRvZXMgbm90IGV4aXN0XCIsXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbIk1vY2tUcmFuc3BvcnQiLCJsb2ciLCJlbnRyeSIsImxvZ3MiLCJwdXNoIiwiZmx1c2giLCJkZXNjcmliZSIsIm1vY2tUcmFuc3BvcnQiLCJjb25zb2xlU3BpZXMiLCJiZWZvcmVFYWNoIiwicmVzZXRMb2dnZXIiLCJkZWJ1ZyIsImplc3QiLCJzcHlPbiIsImNvbnNvbGUiLCJtb2NrSW1wbGVtZW50YXRpb24iLCJpbmZvIiwid2FybiIsImVycm9yIiwiYWZ0ZXJFYWNoIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsInNweSIsIm1vY2tSZXN0b3JlIiwiaXQiLCJsb2dnZXIiLCJjcmVhdGVMb2dnZXIiLCJtaW5MZXZlbCIsIkxvZ0xldmVsIiwiREVCVUciLCJ0cmFuc3BvcnRzIiwiZXhwZWN0IiwidG9IYXZlTGVuZ3RoIiwibGV2ZWwiLCJ0b0JlIiwibWVzc2FnZSIsIklORk8iLCJXQVJOIiwiRVJST1IiLCJmYXRhbCIsIkZBVEFMIiwiY29udGV4dExvZ2dlciIsInNldENvbnRleHQiLCJjb250ZXh0IiwiY2xlYXJDb250ZXh0IiwidG9CZVVuZGVmaW5lZCIsImV2ZXJ5IiwiZGF0YSIsInVzZXJJZCIsImFjdGlvbiIsInRvRXF1YWwiLCJFcnJvciIsInN0YWNrIiwidG9CZURlZmluZWQiLCJyZXRyaWVzIiwiZW5hYmxlQ29uc29sZSIsImVuYWJsZVJlbW90ZSIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjYWxsIiwibW9jayIsImNhbGxzIiwidG9Db250YWluIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwiY29uZmlnIiwicmVtb3RlRW5kcG9pbnQiLCJyZXR1cm5lZENvbmZpZyIsImdldENvbmZpZyIsInVwZGF0ZUNvbmZpZyIsImNoaWxkTG9nZ2VyIiwid2l0aEZpZWxkcyIsInJlcXVlc3RJZCIsInNlcnZpY2UiLCJwYXRoIiwiZ2V0TG9ncyIsIm1heExvZ1NpemUiLCJlcnJvckxvZ3MiLCJjbGVhckxvZ3MiLCJ0aW1lIiwic3RhcnQiLCJEYXRlIiwibm93IiwidGltZUVuZCIsImR1cmF0aW9uIiwidG9CZUdyZWF0ZXJUaGFuIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Q0FXQzs7Ozt3QkFFeUM7dUJBS25DOzs7Ozs7Ozs7Ozs7OztBQUVQLDZCQUE2QjtBQUM3QixNQUFNQTtJQUdKOzs7R0FHQyxHQUNEQyxJQUFJQyxLQUFlLEVBQVE7UUFDekIsSUFBSSxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQ0Y7SUFDakI7SUFFQTs7R0FFQyxHQUNELE1BQU1HLFFBQXVCO0lBQzNCLGlCQUFpQjtJQUNuQjs7UUFmQSx1QkFBT0YsUUFBbUIsRUFBRTs7QUFnQjlCO0FBRUFHLFNBQVMsVUFBVTtJQUNqQixJQUFJQztJQUNKLElBQUlDO0lBT0pDLFdBQVc7UUFDVCwrQkFBK0I7UUFDL0JDLElBQUFBLG1CQUFXO1FBRVgsOEJBQThCO1FBQzlCSCxnQkFBZ0IsSUFBSVA7UUFFcEIseUJBQXlCO1FBQ3pCUSxlQUFlO1lBQ2JHLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxTQUFTQyxrQkFBa0I7WUFDdERDLE1BQU1KLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxRQUFRQyxrQkFBa0I7WUFDcERFLE1BQU1MLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxRQUFRQyxrQkFBa0I7WUFDcERHLE9BQU9OLEtBQUtDLEtBQUssQ0FBQ0MsU0FBUyxTQUFTQyxrQkFBa0I7UUFDeEQ7SUFDRjtJQUVBSSxVQUFVO1FBQ1IsMEJBQTBCO1FBQzFCQyxPQUFPQyxNQUFNLENBQUNiLGNBQWNjLE9BQU8sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxXQUFXO0lBQzlEO0lBRUFsQixTQUFTLDJCQUEyQjtRQUNsQ21CLEdBQUcsc0RB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