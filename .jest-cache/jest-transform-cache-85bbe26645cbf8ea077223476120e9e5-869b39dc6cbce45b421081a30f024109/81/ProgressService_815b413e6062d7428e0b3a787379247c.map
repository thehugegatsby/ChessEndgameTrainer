{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/ProgressService.ts"],"sourcesContent":["/**\n * @file ProgressService\n * @description Firebase Firestore service for user progress tracking and spaced repetition\n * \n * This service manages user progress data in Firestore using a subcollection architecture:\n * - users/{userId}/userProgress/stats - Single UserStats document\n * - users/{userId}/userProgress/{positionId} - Individual CardProgress documents\n * \n * @example\n * ```typescript\n * const service = new ProgressService(db);\n * \n * // Update user stats\n * await service.updateUserStats('user123', { totalPositionsCompleted: increment(1) });\n * \n * // Update card progress with spaced repetition\n * await service.upsertCardProgress('user123', 'pos456', cardProgress);\n * \n * // Batch update after training session\n * await service.updateProgressTransaction('user123', statsUpdate, cardUpdates);\n * ```\n */\n\nimport {\n  Firestore,\n  doc,\n  getDoc,\n  setDoc,\n  deleteDoc,\n  writeBatch,\n  collection,\n  getDocs,\n  WithFieldValue,\n  DocumentData,\n  serverTimestamp,\n  runTransaction,\n  Transaction,\n} from 'firebase/firestore';\n\nimport type { UserStats, CardProgress } from '@shared/store/slices/types';\nimport { getLogger } from '@shared/services/logging/Logger';\n\nconst logger = getLogger().setContext('ProgressService');\n\n/**\n * Error messages in German for user-facing errors\n */\nconst ERROR_MESSAGES = {\n  FIRESTORE_ERROR: 'Datenbankfehler. Bitte versuchen Sie es später erneut.',\n  VALIDATION_ERROR: 'Ungültige Fortschrittsdaten.',\n  USER_NOT_FOUND: 'Benutzerdaten nicht gefunden.',\n  CARD_NOT_FOUND: 'Kartenfortschritt nicht gefunden.',\n  BATCH_TOO_LARGE: 'Zu viele Änderungen auf einmal. Bitte in kleineren Mengen versuchen.',\n  INVALID_USER_ID: 'Ungültige Benutzer-ID.',\n  INVALID_POSITION_ID: 'Ungültige Positions-ID.',\n} as const;\n\n/**\n * Configuration interface for ProgressService\n */\nexport interface ProgressServiceConfig {\n  /** Maximum batch size for Firestore operations (default: 500) */\n  maxBatchSize?: number;\n  /** Enable detailed logging (default: false) */\n  enableVerboseLogging?: boolean;\n}\n\n/**\n * Firestore converter for UserStats with validation\n */\nconst userStatsConverter = {\n  toFirestore(stats: WithFieldValue<UserStats>): DocumentData {\n    // Validate before saving\n    if (typeof stats === 'object' && stats !== null && 'overallSuccessRate' in stats) {\n      const rate = stats.overallSuccessRate as number;\n      if (rate < 0 || rate > 1) {\n        throw new Error(ERROR_MESSAGES.VALIDATION_ERROR);\n      }\n    }\n    \n    return {\n      ...stats,\n      lastUpdated: serverTimestamp(), // Add server timestamp\n    };\n  },\n  \n  fromFirestore(snapshot: any): UserStats {\n    const data = snapshot.data();\n    return {\n      userId: data.userId,\n      totalPositionsCompleted: data.totalPositionsCompleted || 0,\n      overallSuccessRate: data.overallSuccessRate || 0,\n      totalTimeSpent: data.totalTimeSpent || 0,\n      totalHintsUsed: data.totalHintsUsed || 0,\n      lastActive: data.lastActive?.toMillis?.() || data.lastActive || Date.now(),\n    };\n  },\n};\n\n/**\n * Firestore converter for CardProgress with validation\n */\nconst cardProgressConverter = {\n  toFirestore(progress: WithFieldValue<CardProgress>): DocumentData {\n    // Exclude 'id' since it becomes the document ID\n    const { id, ...data } = progress as CardProgress;\n    \n    // Validate ease factor bounds (SuperMemo-2 standard)\n    if ('efactor' in data && (data.efactor < 1.3 || data.efactor > 2.5)) {\n      logger.warn('EFactor out of bounds, clamping', { \n        id, \n        efactor: data.efactor,\n        clamped: Math.max(1.3, Math.min(2.5, data.efactor))\n      });\n      data.efactor = Math.max(1.3, Math.min(2.5, data.efactor));\n    }\n    \n    return {\n      ...data,\n      lastUpdated: serverTimestamp(),\n    };\n  },\n  \n  fromFirestore(snapshot: any): CardProgress {\n    const data = snapshot.data();\n    return {\n      id: snapshot.id, // Use document ID as card ID\n      nextReviewAt: data.nextReviewAt || 0,\n      lastReviewedAt: data.lastReviewedAt || 0,\n      interval: data.interval || 0,\n      repetition: data.repetition || 0,\n      efactor: data.efactor || 2.5,\n      lapses: data.lapses || 0,\n    };\n  },\n};\n\n/**\n * Firebase service for user progress tracking and spaced repetition\n * \n * Handles CRUD operations for UserStats and CardProgress with proper\n * error handling, validation, and performance optimizations.\n */\nexport class ProgressService {\n  private config: Required<ProgressServiceConfig>;\n\n  constructor(\n    private db: Firestore,\n    config: ProgressServiceConfig = {}\n  ) {\n    this.config = {\n      maxBatchSize: 500,\n      enableVerboseLogging: false,\n      ...config,\n    };\n    \n    logger.info('ProgressService initialized', { config: this.config });\n  }\n\n  /**\n   * Creates a typed reference to the user stats document\n   */\n  private userStatsRef(userId: string) {\n    return doc(this.db, 'users', userId, 'userProgress', 'stats')\n      .withConverter(userStatsConverter);\n  }\n\n  /**\n   * Creates a typed reference to a card progress document\n   */\n  private cardProgressRef(userId: string, positionId: string) {\n    return doc(this.db, 'users', userId, 'userProgress', positionId)\n      .withConverter(cardProgressConverter);\n  }\n\n  /**\n   * Creates a reference to the userProgress subcollection\n   */\n  private userProgressCollection(userId: string) {\n    return collection(this.db, 'users', userId, 'userProgress');\n  }\n\n  /**\n   * Validates user ID parameter\n   */\n  private validateUserId(userId: string): void {\n    if (!userId || typeof userId !== 'string' || userId.trim() === '') {\n      throw new Error(ERROR_MESSAGES.INVALID_USER_ID);\n    }\n  }\n\n  /**\n   * Validates position ID parameter\n   */\n  private validatePositionId(positionId: string): void {\n    if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {\n      throw new Error(ERROR_MESSAGES.INVALID_POSITION_ID);\n    }\n  }\n\n  /**\n   * Wrapper for Firestore operations with standardized error handling\n   */\n  private async firestoreOp<T>(\n    operation: () => Promise<T>,\n    operationName: string\n  ): Promise<T> {\n    try {\n      const result = await operation();\n      if (this.config.enableVerboseLogging) {\n        logger.debug(`${operationName} completed successfully`);\n      }\n      return result;\n    } catch (error) {\n      logger.error(`${operationName} failed`, error as Error);\n      throw new Error(ERROR_MESSAGES.FIRESTORE_ERROR);\n    }\n  }\n\n  // ===== CORE CRUD OPERATIONS =====\n\n  /**\n   * Retrieves user statistics\n   * \n   * @param userId - User identifier\n   * @returns UserStats or null if not found\n   * \n   * @example\n   * ```typescript\n   * const stats = await service.getUserStats('user123');\n   * if (stats) {\n   *   console.log(`Completed: ${stats.totalPositionsCompleted}`);\n   * }\n   * ```\n   */\n  async getUserStats(userId: string): Promise<UserStats | null> {\n    this.validateUserId(userId);\n    \n    return this.firestoreOp(async () => {\n      const docRef = this.userStatsRef(userId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        return docSnap.data() as UserStats;\n      }\n      \n      logger.debug('User stats not found', { userId });\n      return null;\n    }, 'getUserStats');\n  }\n\n  /**\n   * Updates user statistics using atomic operations where possible\n   * \n   * @param userId - User identifier\n   * @param updates - Partial stats to update (supports increment, serverTimestamp, etc.)\n   * \n   * @example\n   * ```typescript\n   * // Atomic increment\n   * await service.updateUserStats('user123', {\n   *   totalPositionsCompleted: increment(1),\n   *   totalTimeSpent: increment(300),\n   *   lastActive: Date.now()\n   * });\n   * ```\n   */\n  async updateUserStats(\n    userId: string, \n    updates: Partial<WithFieldValue<UserStats>>\n  ): Promise<void> {\n    this.validateUserId(userId);\n    \n    return this.firestoreOp(async () => {\n      const docRef = this.userStatsRef(userId);\n      \n      // Use setDoc with merge to create document if it doesn't exist\n      await setDoc(docRef, {\n        userId, // Ensure userId is always set\n        ...updates,\n      }, { merge: true });\n      \n      logger.debug('User stats updated', { userId, updateKeys: Object.keys(updates) });\n    }, 'updateUserStats');\n  }\n\n  /**\n   * Retrieves card progress for a specific position\n   * \n   * @param userId - User identifier\n   * @param positionId - Position identifier\n   * @returns CardProgress or null if not found\n   */\n  async getCardProgress(\n    userId: string, \n    positionId: string\n  ): Promise<CardProgress | null> {\n    this.validateUserId(userId);\n    this.validatePositionId(positionId);\n    \n    return this.firestoreOp(async () => {\n      const docRef = this.cardProgressRef(userId, positionId);\n      const docSnap = await getDoc(docRef);\n      \n      if (docSnap.exists()) {\n        return docSnap.data() as CardProgress;\n      }\n      \n      return null;\n    }, 'getCardProgress');\n  }\n\n  /**\n   * Creates or updates card progress (upsert operation)\n   * \n   * @param userId - User identifier\n   * @param positionId - Position identifier  \n   * @param progress - Complete CardProgress object\n   * \n   * @example\n   * ```typescript\n   * const updatedCard = updateCardProgress(existingCard, quality, Date.now());\n   * await service.upsertCardProgress('user123', 'pos456', updatedCard);\n   * ```\n   */\n  async upsertCardProgress(\n    userId: string,\n    positionId: string,\n    progress: CardProgress\n  ): Promise<void> {\n    this.validateUserId(userId);\n    this.validatePositionId(positionId);\n    \n    return this.firestoreOp(async () => {\n      const docRef = this.cardProgressRef(userId, positionId);\n      \n      // Ensure the ID matches the position\n      const progressWithId = { ...progress, id: positionId };\n      \n      await setDoc(docRef, progressWithId);\n      \n      logger.debug('Card progress updated', { \n        userId, \n        positionId, \n        interval: progress.interval,\n        nextReview: new Date(progress.nextReviewAt).toISOString()\n      });\n    }, 'upsertCardProgress');\n  }\n\n  /**\n   * Deletes card progress for a specific position\n   * \n   * @param userId - User identifier\n   * @param positionId - Position identifier\n   * @returns True if deleted, false if not found\n   * \n   * @example\n   * ```typescript\n   * const deleted = await service.deleteCardProgress('user123', 'pos456');\n   * if (deleted) {\n   *   console.log('Card progress deleted successfully');\n   * }\n   * ```\n   */\n  async deleteCardProgress(\n    userId: string,\n    positionId: string\n  ): Promise<boolean> {\n    this.validateUserId(userId);\n    this.validatePositionId(positionId);\n    \n    return this.firestoreOp(async () => {\n      const docRef = this.cardProgressRef(userId, positionId);\n      \n      // Check if document exists before deleting\n      const docSnap = await getDoc(docRef);\n      if (!docSnap.exists()) {\n        logger.debug('Card progress not found for deletion', { userId, positionId });\n        return false;\n      }\n      \n      await deleteDoc(docRef);\n      \n      logger.debug('Card progress deleted', { userId, positionId });\n      return true;\n    }, 'deleteCardProgress');\n  }\n\n  // ===== BATCH OPERATIONS =====\n\n  /**\n   * Bulk updates multiple card progresses in a single batch\n   * \n   * @param userId - User identifier\n   * @param updates - Array of position ID and progress pairs\n   * \n   * @throws Error if batch size exceeds maximum\n   * \n   * @example\n   * ```typescript\n   * await service.bulkUpdateCardProgresses('user123', [\n   *   { positionId: 'pos1', progress: card1 },\n   *   { positionId: 'pos2', progress: card2 }\n   * ]);\n   * ```\n   */\n  async bulkUpdateCardProgresses(\n    userId: string,\n    updates: Array<{ positionId: string; progress: CardProgress }>\n  ): Promise<void> {\n    this.validateUserId(userId);\n    \n    if (updates.length > this.config.maxBatchSize) {\n      throw new Error(ERROR_MESSAGES.BATCH_TOO_LARGE);\n    }\n\n    // Validate all position IDs before processing\n    for (const { positionId } of updates) {\n      this.validatePositionId(positionId);\n    }\n\n    return this.firestoreOp(async () => {\n      const batch = writeBatch(this.db);\n      \n      for (const { positionId, progress } of updates) {\n        const docRef = this.cardProgressRef(userId, positionId);\n        const progressWithId = { ...progress, id: positionId };\n        batch.set(docRef, progressWithId);\n      }\n      \n      await batch.commit();\n      \n      logger.info('Bulk card progress update completed', { \n        userId, \n        count: updates.length \n      });\n    }, 'bulkUpdateCardProgresses');\n  }\n\n  /**\n   * Atomic transaction to update both user stats and card progresses\n   * \n   * This ensures consistency when updating both user-level statistics\n   * and individual card progress in a single training session.\n   * \n   * @param userId - User identifier\n   * @param statsUpdate - Partial user stats to update\n   * @param cardUpdates - Array of card progress updates\n   * \n   * @example\n   * ```typescript\n   * // After completing a training session\n   * await service.updateProgressTransaction('user123', \n   *   { \n   *     totalPositionsCompleted: increment(3),\n   *     totalTimeSpent: increment(600)  \n   *   },\n   *   [\n   *     { positionId: 'pos1', progress: updatedCard1 },\n   *     { positionId: 'pos2', progress: updatedCard2 }\n   *   ]\n   * );\n   * ```\n   */\n  async updateProgressTransaction(\n    userId: string,\n    statsUpdate: Partial<WithFieldValue<UserStats>>,\n    cardUpdates: Array<{ positionId: string; progress: CardProgress }>\n  ): Promise<void> {\n    this.validateUserId(userId);\n    \n    if (cardUpdates.length > this.config.maxBatchSize) {\n      throw new Error(ERROR_MESSAGES.BATCH_TOO_LARGE);\n    }\n\n    // Validate all position IDs before processing\n    for (const { positionId } of cardUpdates) {\n      this.validatePositionId(positionId);\n    }\n\n    return this.firestoreOp(async () => {\n      await runTransaction(this.db, async (transaction: Transaction) => {\n        // Update user stats\n        const userStatsDocRef = this.userStatsRef(userId);\n        transaction.set(userStatsDocRef, {\n          userId,\n          ...statsUpdate,\n        }, { merge: true });\n\n        // Update all card progresses\n        for (const { positionId, progress } of cardUpdates) {\n          const cardDocRef = this.cardProgressRef(userId, positionId);\n          const progressWithId = { ...progress, id: positionId };\n          transaction.set(cardDocRef, progressWithId);\n        }\n      });\n\n      logger.info('Progress transaction completed', {\n        userId,\n        statsKeys: Object.keys(statsUpdate),\n        cardCount: cardUpdates.length,\n      });\n    }, 'updateProgressTransaction');\n  }\n\n  // ===== UTILITY METHODS =====\n\n  /**\n   * Retrieves all card progresses for a user\n   * \n   * @param userId - User identifier\n   * @returns Array of all CardProgress objects\n   * \n   * @warning This can be expensive for users with many cards.\n   * Consider pagination for large datasets.\n   */\n  async getAllCardProgresses(userId: string): Promise<CardProgress[]> {\n    this.validateUserId(userId);\n    \n    return this.firestoreOp(async () => {\n      const collectionRef = this.userProgressCollection(userId)\n        .withConverter(cardProgressConverter);\n      \n      const snapshot = await getDocs(collectionRef);\n      const cardProgresses: CardProgress[] = [];\n      \n      snapshot.forEach((doc) => {\n        // Skip the 'stats' document\n        if (doc.id !== 'stats') {\n          cardProgresses.push(doc.data() as CardProgress);\n        }\n      });\n      \n      logger.debug('Retrieved all card progresses', { \n        userId, \n        count: cardProgresses.length \n      });\n      \n      return cardProgresses;\n    }, 'getAllCardProgresses');\n  }\n\n  /**\n   * Retrieves cards that are due for review\n   * \n   * @param userId - User identifier\n   * @param now - Current timestamp (defaults to Date.now())\n   * @returns Array of CardProgress objects due for review\n   * \n   * @example\n   * ```typescript\n   * const dueCards = await service.getDueCardProgresses('user123');\n   * console.log(`${dueCards.length} cards are due for review`);\n   * ```\n   */\n  async getDueCardProgresses(\n    userId: string,\n    now: number = Date.now()\n  ): Promise<CardProgress[]> {\n    this.validateUserId(userId);\n    \n    return this.firestoreOp(async () => {\n      // For now, we fetch all cards and filter client-side\n      // In a future optimization, we could use Firestore queries with where('nextReviewAt', '<=', now)\n      // but that would require a composite index on (userId, nextReviewAt)\n      const allCards = await this.getAllCardProgresses(userId);\n      const dueCards = allCards.filter(card => card.nextReviewAt <= now);\n      \n      logger.debug('Retrieved due card progresses', { \n        userId, \n        totalCards: allCards.length,\n        dueCards: dueCards.length \n      });\n      \n      return dueCards;\n    }, 'getDueCardProgresses');\n  }\n\n  /**\n   * Initializes a new user with default stats\n   * \n   * @param userId - User identifier\n   * @param initialStats - Optional initial stats (defaults to zeros)\n   * \n   * @example\n   * ```typescript\n   * // Initialize new user after signup\n   * await service.initializeUser('user123', {\n   *   lastActive: Date.now()\n   * });\n   * ```\n   */\n  async initializeUser(\n    userId: string,\n    initialStats?: Partial<UserStats>\n  ): Promise<void> {\n    this.validateUserId(userId);\n    \n    const defaultStats: UserStats = {\n      userId,\n      totalPositionsCompleted: 0,\n      overallSuccessRate: 0,\n      totalTimeSpent: 0,\n      totalHintsUsed: 0,\n      lastActive: Date.now(),\n      ...initialStats,\n    };\n\n    return this.updateUserStats(userId, defaultStats);\n  }\n\n  /**\n   * Deletes all progress data for a user\n   * \n   * @param userId - User identifier\n   * @returns Number of documents deleted\n   * \n   * @warning This operation cannot be undone\n   */\n  async deleteAllUserProgress(userId: string): Promise<number> {\n    this.validateUserId(userId);\n    \n    return this.firestoreOp(async () => {\n      const collectionRef = this.userProgressCollection(userId);\n      const snapshot = await getDocs(collectionRef);\n      \n      if (snapshot.empty) {\n        return 0;\n      }\n\n      const batch = writeBatch(this.db);\n      \n      snapshot.docs.forEach((doc) => {\n        batch.delete(doc.ref);\n      });\n      \n      await batch.commit();\n      \n      const deletedCount = snapshot.size;\n      logger.warn('Deleted all user progress', { userId, count: deletedCount });\n      \n      return deletedCount;\n    }, 'deleteAllUserProgress');\n  }\n}\n\n// Export factory function for easier testing and dependency injection\nexport function createProgressService(\n  firestore: Firestore,\n  config?: ProgressServiceConfig\n): ProgressService {\n  return new ProgressService(firestore, config);\n}"],"names":["ProgressService","createProgressService","logger","getLogger","setContext","ERROR_MESSAGES","FIRESTORE_ERROR","VALIDATION_ERROR","USER_NOT_FOUND","CARD_NOT_FOUND","BATCH_TOO_LARGE","INVALID_USER_ID","INVALID_POSITION_ID","userStatsConverter","toFirestore","stats","rate","overallSuccessRate","Error","lastUpdated","serverTimestamp","fromFirestore","snapshot","data","userId","totalPositionsCompleted","totalTimeSpent","totalHintsUsed","lastActive","toMillis","Date","now","cardProgressConverter","progress","id","efactor","warn","clamped","Math","max","min","nextReviewAt","lastReviewedAt","interval","repetition","lapses","userStatsRef","doc","db","withConverter","cardProgressRef","positionId","userProgressCollection","collection","validateUserId","trim","validatePositionId","firestoreOp","operation","operationName","result","config","enableVerboseLogging","debug","error","getUserStats","docRef","docSnap","getDoc","exists","updateUserStats","updates","setDoc","merge","updateKeys","Object","keys","getCardProgress","upsertCardProgress","progressWithId","nextReview","toISOString","deleteCardProgress","deleteDoc","bulkUpdateCardProgresses","length","maxBatchSize","batch","writeBatch","set","commit","info","count","updateProgressTransaction","statsUpdate","cardUpdates","runTransaction","transaction","userStatsDocRef","cardDocRef","statsKeys","cardCount","getAllCardProgresses","collectionRef","getDocs","cardProgresses","forEach","push","getDueCardProgresses","allCards","dueCards","filter","card","totalCards","initializeUser","initialStats","defaultStats","deleteAllUserProgress","empty","docs","delete","ref","deletedCount","size","firestore"],"mappings":"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"}