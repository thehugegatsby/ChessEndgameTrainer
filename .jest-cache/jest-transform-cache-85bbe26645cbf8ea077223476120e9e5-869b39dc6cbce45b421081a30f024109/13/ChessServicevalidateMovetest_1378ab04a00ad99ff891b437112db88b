73fe1aa1d310276bbca8714cf1642a73
/**
 * @file ChessService validateMove Edge Cases Tests
 * @description Coverage tests for validateMove edge cases (Lines 431-432, 439-440, 406)
 * Target: Remaining coverage gaps for 100% completion
 */ "use strict";
// Mock chess.js following existing pattern
jest.mock("chess.js");
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ChessService = require("../../../shared/services/ChessService");
const _chess = require("chess.js");
const MockedChess = _chess.Chess;
describe("ChessService validateMove Edge Cases", ()=>{
    let chessService;
    let mockChessInstance;
    beforeEach(()=>{
        MockedChess.mockClear();
        // Create comprehensive mock Chess instance
        mockChessInstance = {
            move: jest.fn(),
            fen: jest.fn().mockReturnValue("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"),
            pgn: jest.fn().mockReturnValue(""),
            history: jest.fn().mockReturnValue([]),
            load: jest.fn(),
            loadPgn: jest.fn(),
            isGameOver: jest.fn().mockReturnValue(false),
            turn: jest.fn().mockReturnValue("w"),
            moves: jest.fn().mockReturnValue([
                "e4",
                "e3",
                "Nf3"
            ]),
            isCheck: jest.fn().mockReturnValue(false),
            isCheckmate: jest.fn().mockReturnValue(false),
            isStalemate: jest.fn().mockReturnValue(false),
            isDraw: jest.fn().mockReturnValue(false),
            get: jest.fn()
        };
        MockedChess.mockImplementation(()=>mockChessInstance);
        chessService = new _ChessService.ChessService();
        chessService.initialize("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1");
    });
    describe("validateMove() Edge Cases - Lines 431-432, 439-440", ()=>{
        it("should handle invalid square format in move object - Line 431-432", ()=>{
            // Test invalid 'from' square format (Line 431)
            const invalidFromMove = {
                from: "z9",
                to: "e4"
            }; // Invalid square format
            const result = chessService.validateMove(invalidFromMove);
            expect(result).toBe(false);
        // Should not call temp chess instance since format validation fails first
        });
        it("should handle invalid 'to' square format in move object - Line 431-432", ()=>{
            // Test invalid 'to' square format (Line 431)
            const invalidToMove = {
                from: "e2",
                to: "x0"
            }; // Invalid square format
            const result = chessService.validateMove(invalidToMove);
            expect(result).toBe(false);
        });
        it("should handle both invalid square formats - Line 431-432", ()=>{
            // Test both invalid formats
            const invalidMove = {
                from: "zz",
                to: "yy"
            };
            const result = chessService.validateMove(invalidMove);
            expect(result).toBe(false);
        });
        it("should handle no piece on source square - Line 439-440", ()=>{
            // Create temp chess instance that returns null for get()
            const tempChessInstance = {
                get: jest.fn().mockReturnValue(null),
                move: jest.fn()
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const moveWithNoPiece = {
                from: "d4",
                to: "d5"
            }; // Valid format but no piece on d4
            const result = chessService.validateMove(moveWithNoPiece);
            expect(result).toBe(false);
            expect(tempChessInstance.get).toHaveBeenCalledWith("d4");
        });
        it("should handle valid square format with piece present", ()=>{
            // Mock get() to return a piece (this will be called on the temp instance)
            const tempChessInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e2",
                    to: "e4",
                    san: "e4"
                }),
                get: jest.fn().mockReturnValue({
                    type: "p",
                    color: "w"
                })
            };
            // Mock Chess constructor to return temp instance for validation
            MockedChess.mockImplementation(()=>tempChessInstance);
            const validMove = {
                from: "e2",
                to: "e4"
            };
            const result = chessService.validateMove(validMove);
            expect(result).toBe(true);
            expect(tempChessInstance.get).toHaveBeenCalledWith("e2");
            expect(tempChessInstance.move).toHaveBeenCalledWith(validMove);
        });
        it("should handle promotion move validation", ()=>{
            const tempChessInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e7",
                    to: "e8",
                    san: "e8=Q",
                    promotion: "q"
                }),
                get: jest.fn().mockReturnValue({
                    type: "p",
                    color: "w"
                })
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const promotionMove = {
                from: "e7",
                to: "e8",
                promotion: "q"
            };
            const result = chessService.validateMove(promotionMove);
            expect(result).toBe(true);
            expect(tempChessInstance.move).toHaveBeenCalledWith(promotionMove);
        });
        it("should handle string moves (not object format)", ()=>{
            const tempChessInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e2",
                    to: "e4",
                    san: "e4"
                })
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const stringMove = "e4";
            const result = chessService.validateMove(stringMove);
            expect(result).toBe(true);
            expect(tempChessInstance.move).toHaveBeenCalledWith(stringMove);
            // Should not call get() for string moves (different validation path)
            expect(mockChessInstance.get).not.toHaveBeenCalled();
        });
        it("should handle chess.js move objects", ()=>{
            const tempChessInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e2",
                    to: "e4",
                    san: "e4"
                }),
                get: jest.fn().mockReturnValue({
                    type: "p",
                    color: "w"
                })
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const chessJsMove = {
                from: "e2",
                to: "e4",
                san: "e4",
                piece: "p",
                color: "w"
            };
            const result = chessService.validateMove(chessJsMove);
            expect(result).toBe(true);
            expect(tempChessInstance.move).toHaveBeenCalledWith(chessJsMove);
        });
        it("should handle validation error exceptions", ()=>{
            // Mock exception during validation
            const tempChessInstance = {
                move: jest.fn().mockImplementation(()=>{
                    throw new Error("Validation failed");
                })
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const move = {
                from: "e2",
                to: "e4"
            };
            mockChessInstance.get.mockReturnValue({
                type: "p",
                color: "w"
            });
            const result = chessService.validateMove(move);
            expect(result).toBe(false);
        });
    });
    describe("moves() method - Line 406", ()=>{
        it("should call chess.js moves() method without options", ()=>{
            mockChessInstance.moves.mockReturnValue([
                "e4",
                "e3",
                "Nf3"
            ]);
            const result = chessService.moves();
            expect(result).toEqual([
                "e4",
                "e3",
                "Nf3"
            ]);
            expect(mockChessInstance.moves).toHaveBeenCalledWith(undefined);
        });
        it("should call chess.js moves() method with square option", ()=>{
            mockChessInstance.moves.mockReturnValue([
                "e3",
                "e4"
            ]);
            const result = chessService.moves({
                square: "e2"
            });
            expect(result).toEqual([
                "e3",
                "e4"
            ]);
            expect(mockChessInstance.moves).toHaveBeenCalledWith({
                square: "e2"
            });
        });
        it("should call chess.js moves() method with verbose option", ()=>{
            const verboseMoves = [
                {
                    from: "e2",
                    to: "e3",
                    san: "e3"
                },
                {
                    from: "e2",
                    to: "e4",
                    san: "e4"
                }
            ];
            mockChessInstance.moves.mockReturnValue(verboseMoves);
            const result = chessService.moves({
                verbose: true
            });
            expect(result).toEqual(verboseMoves);
            expect(mockChessInstance.moves).toHaveBeenCalledWith({
                verbose: true
            });
        });
        it("should call chess.js moves() method with both square and verbose options", ()=>{
            const verboseMoves = [
                {
                    from: "e2",
                    to: "e3",
                    san: "e3"
                },
                {
                    from: "e2",
                    to: "e4",
                    san: "e4"
                }
            ];
            mockChessInstance.moves.mockReturnValue(verboseMoves);
            const result = chessService.moves({
                square: "e2",
                verbose: true
            });
            expect(result).toEqual(verboseMoves);
            expect(mockChessInstance.moves).toHaveBeenCalledWith({
                square: "e2",
                verbose: true
            });
        });
    });
    describe("Integration with existing validation", ()=>{
        it("should maintain consistency with move() method validation", ()=>{
            // Setup valid move scenario
            mockChessInstance.get.mockReturnValue({
                type: "p",
                color: "w"
            });
            const tempChessInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e2",
                    to: "e4",
                    san: "e4"
                })
            };
            MockedChess.mockImplementation(()=>tempChessInstance);
            const move = {
                from: "e2",
                to: "e4"
            };
            // validateMove should return true  
            // Need to reset mock for validation call
            const tempValidationInstance = {
                move: jest.fn().mockReturnValue({
                    from: "e2",
                    to: "e4",
                    san: "e4"
                }),
                get: jest.fn().mockReturnValue({
                    type: "p",
                    color: "w"
                })
            };
            MockedChess.mockImplementation(()=>tempValidationInstance);
            expect(chessService.validateMove(move)).toBe(true);
            // Reset mocks for actual move
            MockedChess.mockImplementation(()=>mockChessInstance);
            mockChessInstance.move.mockReturnValue({
                from: "e2",
                to: "e4",
                san: "e4"
            });
            // Actual move should also succeed
            const moveResult = chessService.move(move);
            expect(moveResult).not.toBeNull();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2UudmFsaWRhdGVNb3ZlLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBDaGVzc1NlcnZpY2UgdmFsaWRhdGVNb3ZlIEVkZ2UgQ2FzZXMgVGVzdHNcbiAqIEBkZXNjcmlwdGlvbiBDb3ZlcmFnZSB0ZXN0cyBmb3IgdmFsaWRhdGVNb3ZlIGVkZ2UgY2FzZXMgKExpbmVzIDQzMS00MzIsIDQzOS00NDAsIDQwNilcbiAqIFRhcmdldDogUmVtYWluaW5nIGNvdmVyYWdlIGdhcHMgZm9yIDEwMCUgY29tcGxldGlvblxuICovXG5cbmltcG9ydCB7IENoZXNzU2VydmljZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL0NoZXNzU2VydmljZVwiO1xuaW1wb3J0IHsgQ2hlc3MgfSBmcm9tIFwiY2hlc3MuanNcIjtcblxuLy8gTW9jayBjaGVzcy5qcyBmb2xsb3dpbmcgZXhpc3RpbmcgcGF0dGVyblxuamVzdC5tb2NrKFwiY2hlc3MuanNcIik7XG5cbmNvbnN0IE1vY2tlZENoZXNzID0gQ2hlc3MgYXMgamVzdC5Nb2NrZWRDbGFzczx0eXBlb2YgQ2hlc3M+O1xuXG5kZXNjcmliZShcIkNoZXNzU2VydmljZSB2YWxpZGF0ZU1vdmUgRWRnZSBDYXNlc1wiLCAoKSA9PiB7XG4gIGxldCBjaGVzc1NlcnZpY2U6IENoZXNzU2VydmljZTtcbiAgbGV0IG1vY2tDaGVzc0luc3RhbmNlOiBqZXN0Lk1vY2tlZDxJbnN0YW5jZVR5cGU8dHlwZW9mIENoZXNzPj47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgTW9ja2VkQ2hlc3MubW9ja0NsZWFyKCk7XG5cbiAgICAvLyBDcmVhdGUgY29tcHJlaGVuc2l2ZSBtb2NrIENoZXNzIGluc3RhbmNlXG4gICAgbW9ja0NoZXNzSW5zdGFuY2UgPSB7XG4gICAgICBtb3ZlOiBqZXN0LmZuKCksXG4gICAgICBmZW46IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiKSxcbiAgICAgIHBnbjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShcIlwiKSxcbiAgICAgIGhpc3Rvcnk6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoW10pLFxuICAgICAgbG9hZDogamVzdC5mbigpLFxuICAgICAgbG9hZFBnbjogamVzdC5mbigpLFxuICAgICAgaXNHYW1lT3ZlcjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShmYWxzZSksXG4gICAgICB0dXJuOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFwid1wiKSxcbiAgICAgIG1vdmVzOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKFtcImU0XCIsIFwiZTNcIiwgXCJOZjNcIl0gYXMgYW55KSxcbiAgICAgIGlzQ2hlY2s6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpLFxuICAgICAgaXNDaGVja21hdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpLFxuICAgICAgaXNTdGFsZW1hdGU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpLFxuICAgICAgaXNEcmF3OiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKGZhbHNlKSxcbiAgICAgIGdldDogamVzdC5mbigpLCAvLyBGb3IgcGllY2UgY2hlY2tpbmcgaW4gdmFsaWRhdGVNb3ZlXG4gICAgfSBhcyBhbnk7XG5cbiAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0NoZXNzSW5zdGFuY2UpO1xuICAgIGNoZXNzU2VydmljZSA9IG5ldyBDaGVzc1NlcnZpY2UoKTtcbiAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShcInJuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlIgdyBLUWtxIC0gMCAxXCIpO1xuICB9KTtcblxuICBkZXNjcmliZShcInZhbGlkYXRlTW92ZSgpIEVkZ2UgQ2FzZXMgLSBMaW5lcyA0MzEtNDMyLCA0MzktNDQwXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBoYW5kbGUgaW52YWxpZCBzcXVhcmUgZm9ybWF0IGluIG1vdmUgb2JqZWN0IC0gTGluZSA0MzEtNDMyXCIsICgpID0+IHtcbiAgICAgIC8vIFRlc3QgaW52YWxpZCAnZnJvbScgc3F1YXJlIGZvcm1hdCAoTGluZSA0MzEpXG4gICAgICBjb25zdCBpbnZhbGlkRnJvbU1vdmUgPSB7IGZyb206IFwiejlcIiwgdG86IFwiZTRcIiB9OyAvLyBJbnZhbGlkIHNxdWFyZSBmb3JtYXRcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZShpbnZhbGlkRnJvbU1vdmUpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICAgIC8vIFNob3VsZCBub3QgY2FsbCB0ZW1wIGNoZXNzIGluc3RhbmNlIHNpbmNlIGZvcm1hdCB2YWxpZGF0aW9uIGZhaWxzIGZpcnN0XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgaW52YWxpZCAndG8nIHNxdWFyZSBmb3JtYXQgaW4gbW92ZSBvYmplY3QgLSBMaW5lIDQzMS00MzJcIiwgKCkgPT4ge1xuICAgICAgLy8gVGVzdCBpbnZhbGlkICd0bycgc3F1YXJlIGZvcm1hdCAoTGluZSA0MzEpXG4gICAgICBjb25zdCBpbnZhbGlkVG9Nb3ZlID0geyBmcm9tOiBcImUyXCIsIHRvOiBcIngwXCIgfTsgLy8gSW52YWxpZCBzcXVhcmUgZm9ybWF0XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUoaW52YWxpZFRvTW92ZSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIGJvdGggaW52YWxpZCBzcXVhcmUgZm9ybWF0cyAtIExpbmUgNDMxLTQzMlwiLCAoKSA9PiB7XG4gICAgICAvLyBUZXN0IGJvdGggaW52YWxpZCBmb3JtYXRzXG4gICAgICBjb25zdCBpbnZhbGlkTW92ZSA9IHsgZnJvbTogXCJ6elwiLCB0bzogXCJ5eVwiIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUoaW52YWxpZE1vdmUpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBubyBwaWVjZSBvbiBzb3VyY2Ugc3F1YXJlIC0gTGluZSA0MzktNDQwXCIsICgpID0+IHtcbiAgICAgIC8vIENyZWF0ZSB0ZW1wIGNoZXNzIGluc3RhbmNlIHRoYXQgcmV0dXJucyBudWxsIGZvciBnZXQoKVxuICAgICAgY29uc3QgdGVtcENoZXNzSW5zdGFuY2UgPSB7XG4gICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShudWxsKSxcbiAgICAgICAgbW92ZTogamVzdC5mbigpLFxuICAgICAgfTtcbiAgICAgIE1vY2tlZENoZXNzLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0ZW1wQ2hlc3NJbnN0YW5jZSBhcyBhbnkpO1xuICAgICAgXG4gICAgICBjb25zdCBtb3ZlV2l0aE5vUGllY2UgPSB7IGZyb206IFwiZDRcIiwgdG86IFwiZDVcIiB9OyAvLyBWYWxpZCBmb3JtYXQgYnV0IG5vIHBpZWNlIG9uIGQ0XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUobW92ZVdpdGhOb1BpZWNlKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QodGVtcENoZXNzSW5zdGFuY2UuZ2V0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcImQ0XCIpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHZhbGlkIHNxdWFyZSBmb3JtYXQgd2l0aCBwaWVjZSBwcmVzZW50XCIsICgpID0+IHtcbiAgICAgIC8vIE1vY2sgZ2V0KCkgdG8gcmV0dXJuIGEgcGllY2UgKHRoaXMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHRlbXAgaW5zdGFuY2UpXG4gICAgICBjb25zdCB0ZW1wQ2hlc3NJbnN0YW5jZSA9IHtcbiAgICAgICAgbW92ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiwgc2FuOiBcImU0XCIgfSksXG4gICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHR5cGU6IFwicFwiLCBjb2xvcjogXCJ3XCIgfSksXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBNb2NrIENoZXNzIGNvbnN0cnVjdG9yIHRvIHJldHVybiB0ZW1wIGluc3RhbmNlIGZvciB2YWxpZGF0aW9uXG4gICAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdGVtcENoZXNzSW5zdGFuY2UgYXMgYW55KTtcbiAgICAgIFxuICAgICAgY29uc3QgdmFsaWRNb3ZlID0geyBmcm9tOiBcImUyXCIsIHRvOiBcImU0XCIgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZSh2YWxpZE1vdmUpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHRlbXBDaGVzc0luc3RhbmNlLmdldCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXCJlMlwiKTtcbiAgICAgIGV4cGVjdCh0ZW1wQ2hlc3NJbnN0YW5jZS5tb3ZlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh2YWxpZE1vdmUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHByb21vdGlvbiBtb3ZlIHZhbGlkYXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGVtcENoZXNzSW5zdGFuY2UgPSB7XG4gICAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBmcm9tOiBcImU3XCIsIHRvOiBcImU4XCIsIHNhbjogXCJlOD1RXCIsIHByb21vdGlvbjogXCJxXCIgfSksXG4gICAgICAgIGdldDogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHR5cGU6IFwicFwiLCBjb2xvcjogXCJ3XCIgfSksXG4gICAgICB9O1xuICAgICAgTW9ja2VkQ2hlc3MubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHRlbXBDaGVzc0luc3RhbmNlIGFzIGFueSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHByb21vdGlvbk1vdmUgPSB7IGZyb206IFwiZTdcIiwgdG86IFwiZThcIiwgcHJvbW90aW9uOiBcInFcIiB9O1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UudmFsaWRhdGVNb3ZlKHByb21vdGlvbk1vdmUpO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHRlbXBDaGVzc0luc3RhbmNlLm1vdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHByb21vdGlvbk1vdmUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHN0cmluZyBtb3ZlcyAobm90IG9iamVjdCBmb3JtYXQpXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBDaGVzc0luc3RhbmNlID0ge1xuICAgICAgICBtb3ZlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiB9KSxcbiAgICAgIH07XG4gICAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdGVtcENoZXNzSW5zdGFuY2UgYXMgYW55KTtcbiAgICAgIFxuICAgICAgY29uc3Qgc3RyaW5nTW92ZSA9IFwiZTRcIjtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZShzdHJpbmdNb3ZlKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh0ZW1wQ2hlc3NJbnN0YW5jZS5tb3ZlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChzdHJpbmdNb3ZlKTtcbiAgICAgIC8vIFNob3VsZCBub3QgY2FsbCBnZXQoKSBmb3Igc3RyaW5nIG1vdmVzIChkaWZmZXJlbnQgdmFsaWRhdGlvbiBwYXRoKVxuICAgICAgZXhwZWN0KG1vY2tDaGVzc0luc3RhbmNlLmdldCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBjaGVzcy5qcyBtb3ZlIG9iamVjdHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdGVtcENoZXNzSW5zdGFuY2UgPSB7XG4gICAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBmcm9tOiBcImUyXCIsIHRvOiBcImU0XCIsIHNhbjogXCJlNFwiIH0pLFxuICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB0eXBlOiBcInBcIiwgY29sb3I6IFwid1wiIH0pLFxuICAgICAgfTtcbiAgICAgIE1vY2tlZENoZXNzLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0ZW1wQ2hlc3NJbnN0YW5jZSBhcyBhbnkpO1xuICAgICAgXG4gICAgICBjb25zdCBjaGVzc0pzTW92ZSA9IHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiwgcGllY2U6IFwicFwiLCBjb2xvcjogXCJ3XCIgfTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZShjaGVzc0pzTW92ZSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QodGVtcENoZXNzSW5zdGFuY2UubW92ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoY2hlc3NKc01vdmUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHZhbGlkYXRpb24gZXJyb3IgZXhjZXB0aW9uc1wiLCAoKSA9PiB7XG4gICAgICAvLyBNb2NrIGV4Y2VwdGlvbiBkdXJpbmcgdmFsaWRhdGlvblxuICAgICAgY29uc3QgdGVtcENoZXNzSW5zdGFuY2UgPSB7XG4gICAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkXCIpO1xuICAgICAgICB9KSxcbiAgICAgIH07XG4gICAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdGVtcENoZXNzSW5zdGFuY2UgYXMgYW55KTtcbiAgICAgIFxuICAgICAgY29uc3QgbW92ZSA9IHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiIH07XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5nZXQubW9ja1JldHVyblZhbHVlKHsgdHlwZTogXCJwXCIsIGNvbG9yOiBcIndcIiB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZShtb3ZlKTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShmYWxzZSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwibW92ZXMoKSBtZXRob2QgLSBMaW5lIDQwNlwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgY2FsbCBjaGVzcy5qcyBtb3ZlcygpIG1ldGhvZCB3aXRob3V0IG9wdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubW92ZXMubW9ja1JldHVyblZhbHVlKFtcImU0XCIsIFwiZTNcIiwgXCJOZjNcIl0gYXMgYW55KTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmVzKCkgYXMgc3RyaW5nW107XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1wiZTRcIiwgXCJlM1wiLCBcIk5mM1wiXSk7XG4gICAgICBleHBlY3QobW9ja0NoZXNzSW5zdGFuY2UubW92ZXMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBjYWxsIGNoZXNzLmpzIG1vdmVzKCkgbWV0aG9kIHdpdGggc3F1YXJlIG9wdGlvblwiLCAoKSA9PiB7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5tb3Zlcy5tb2NrUmV0dXJuVmFsdWUoW1wiZTNcIiwgXCJlNFwiXSBhcyBhbnkpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UubW92ZXMoeyBzcXVhcmU6IFwiZTJcIiB9KSBhcyBzdHJpbmdbXTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXCJlM1wiLCBcImU0XCJdKTtcbiAgICAgIGV4cGVjdChtb2NrQ2hlc3NJbnN0YW5jZS5tb3ZlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyBzcXVhcmU6IFwiZTJcIiB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGNhbGwgY2hlc3MuanMgbW92ZXMoKSBtZXRob2Qgd2l0aCB2ZXJib3NlIG9wdGlvblwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB2ZXJib3NlTW92ZXMgPSBbXG4gICAgICAgIHsgZnJvbTogXCJlMlwiLCB0bzogXCJlM1wiLCBzYW46IFwiZTNcIiB9LFxuICAgICAgICB7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiwgc2FuOiBcImU0XCIgfSxcbiAgICAgIF07XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5tb3Zlcy5tb2NrUmV0dXJuVmFsdWUodmVyYm9zZU1vdmVzIGFzIGFueSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5tb3Zlcyh7IHZlcmJvc2U6IHRydWUgfSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwodmVyYm9zZU1vdmVzKTtcbiAgICAgIGV4cGVjdChtb2NrQ2hlc3NJbnN0YW5jZS5tb3ZlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyB2ZXJib3NlOiB0cnVlIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgY2FsbCBjaGVzcy5qcyBtb3ZlcygpIG1ldGhvZCB3aXRoIGJvdGggc3F1YXJlIGFuZCB2ZXJib3NlIG9wdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgdmVyYm9zZU1vdmVzID0gW1xuICAgICAgICB7IGZyb206IFwiZTJcIiwgdG86IFwiZTNcIiwgc2FuOiBcImUzXCIgfSxcbiAgICAgICAgeyBmcm9tOiBcImUyXCIsIHRvOiBcImU0XCIsIHNhbjogXCJlNFwiIH0sXG4gICAgICBdO1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UubW92ZXMubW9ja1JldHVyblZhbHVlKHZlcmJvc2VNb3ZlcyBhcyBhbnkpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UubW92ZXMoeyBzcXVhcmU6IFwiZTJcIiwgdmVyYm9zZTogdHJ1ZSB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh2ZXJib3NlTW92ZXMpO1xuICAgICAgZXhwZWN0KG1vY2tDaGVzc0luc3RhbmNlLm1vdmVzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7IHNxdWFyZTogXCJlMlwiLCB2ZXJib3NlOiB0cnVlIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkludGVncmF0aW9uIHdpdGggZXhpc3RpbmcgdmFsaWRhdGlvblwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgbWFpbnRhaW4gY29uc2lzdGVuY3kgd2l0aCBtb3ZlKCkgbWV0aG9kIHZhbGlkYXRpb25cIiwgKCkgPT4ge1xuICAgICAgLy8gU2V0dXAgdmFsaWQgbW92ZSBzY2VuYXJpb1xuICAgICAgbW9ja0NoZXNzSW5zdGFuY2UuZ2V0Lm1vY2tSZXR1cm5WYWx1ZSh7IHR5cGU6IFwicFwiLCBjb2xvcjogXCJ3XCIgfSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlbXBDaGVzc0luc3RhbmNlID0ge1xuICAgICAgICBtb3ZlOiBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiB9KSxcbiAgICAgIH07XG4gICAgICBNb2NrZWRDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gdGVtcENoZXNzSW5zdGFuY2UgYXMgYW55KTtcbiAgICAgIFxuICAgICAgY29uc3QgbW92ZSA9IHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiIH07XG4gICAgICBcbiAgICAgIC8vIHZhbGlkYXRlTW92ZSBzaG91bGQgcmV0dXJuIHRydWUgIFxuICAgICAgLy8gTmVlZCB0byByZXNldCBtb2NrIGZvciB2YWxpZGF0aW9uIGNhbGxcbiAgICAgIGNvbnN0IHRlbXBWYWxpZGF0aW9uSW5zdGFuY2UgPSB7XG4gICAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBmcm9tOiBcImUyXCIsIHRvOiBcImU0XCIsIHNhbjogXCJlNFwiIH0pLFxuICAgICAgICBnZXQ6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyB0eXBlOiBcInBcIiwgY29sb3I6IFwid1wiIH0pLFxuICAgICAgfTtcbiAgICAgIE1vY2tlZENoZXNzLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB0ZW1wVmFsaWRhdGlvbkluc3RhbmNlIGFzIGFueSk7XG4gICAgICBcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UudmFsaWRhdGVNb3ZlKG1vdmUpKS50b0JlKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBSZXNldCBtb2NrcyBmb3IgYWN0dWFsIG1vdmVcbiAgICAgIE1vY2tlZENoZXNzLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrQ2hlc3NJbnN0YW5jZSk7XG4gICAgICBtb2NrQ2hlc3NJbnN0YW5jZS5tb3ZlLm1vY2tSZXR1cm5WYWx1ZSh7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiwgc2FuOiBcImU0XCIgfSBhcyBhbnkpO1xuICAgICAgXG4gICAgICAvLyBBY3R1YWwgbW92ZSBzaG91bGQgYWxzbyBzdWNjZWVkXG4gICAgICBjb25zdCBtb3ZlUmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmUobW92ZSk7XG4gICAgICBleHBlY3QobW92ZVJlc3VsdCkubm90LnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiTW9ja2VkQ2hlc3MiLCJDaGVzcyIsImRlc2NyaWJlIiwiY2hlc3NTZXJ2aWNlIiwibW9ja0NoZXNzSW5zdGFuY2UiLCJiZWZvcmVFYWNoIiwibW9ja0NsZWFyIiwibW92ZSIsImZuIiwiZmVuIiwibW9ja1JldHVyblZhbHVlIiwicGduIiwiaGlzdG9yeSIsImxvYWQiLCJsb2FkUGduIiwiaXNHYW1lT3ZlciIsInR1cm4iLCJtb3ZlcyIsImlzQ2hlY2siLCJpc0NoZWNrbWF0ZSIsImlzU3RhbGVtYXRlIiwiaXNEcmF3IiwiZ2V0IiwibW9ja0ltcGxlbWVudGF0aW9uIiwiQ2hlc3NTZXJ2aWNlIiwiaW5pdGlhbGl6ZSIsIml0IiwiaW52YWxpZEZyb21Nb3ZlIiwiZnJvbSIsInRvIiwicmVzdWx0IiwidmFsaWRhdGVNb3ZlIiwiZXhwZWN0IiwidG9CZSIsImludmFsaWRUb01vdmUiLCJpbnZhbGlkTW92ZSIsInRlbXBDaGVzc0luc3RhbmNlIiwibW92ZVdpdGhOb1BpZWNlIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJzYW4iLCJ0eXBlIiwiY29sb3IiLCJ2YWxpZE1vdmUiLCJwcm9tb3Rpb24iLCJwcm9tb3Rpb25Nb3ZlIiwic3RyaW5nTW92ZSIsIm5vdCIsInRvSGF2ZUJlZW5DYWxsZWQiLCJjaGVzc0pzTW92ZSIsInBpZWNlIiwiRXJyb3IiLCJ0b0VxdWFsIiwidW5kZWZpbmVkIiwic3F1YXJlIiwidmVyYm9zZU1vdmVzIiwidmVyYm9zZSIsInRlbXBWYWxpZGF0aW9uSW5zdGFuY2UiLCJtb3ZlUmVzdWx0IiwidG9CZU51bGwiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFLRCwyQ0FBMkM7QUFDM0NBLEtBQUtDLElBQUksQ0FBQzs7Ozs4QkFKbUI7dUJBQ1A7QUFLdEIsTUFBTUMsY0FBY0MsWUFBSztBQUV6QkMsU0FBUyx3Q0FBd0M7SUFDL0MsSUFBSUM7SUFDSixJQUFJQztJQUVKQyxXQUFXO1FBQ1RMLFlBQVlNLFNBQVM7UUFFckIsMkNBQTJDO1FBQzNDRixvQkFBb0I7WUFDbEJHLE1BQU1ULEtBQUtVLEVBQUU7WUFDYkMsS0FBS1gsS0FBS1UsRUFBRSxHQUFHRSxlQUFlLENBQUM7WUFDL0JDLEtBQUtiLEtBQUtVLEVBQUUsR0FBR0UsZUFBZSxDQUFDO1lBQy9CRSxTQUFTZCxLQUFLVSxFQUFFLEdBQUdFLGVBQWUsQ0FBQyxFQUFFO1lBQ3JDRyxNQUFNZixLQUFLVSxFQUFFO1lBQ2JNLFNBQVNoQixLQUFLVSxFQUFFO1lBQ2hCTyxZQUFZakIsS0FBS1UsRUFBRSxHQUFHRSxlQUFlLENBQUM7WUFDdENNLE1BQU1sQixLQUFLVSxFQUFFLEdBQUdFLGVBQWUsQ0FBQztZQUNoQ08sT0FBT25CLEtBQUtVLEVBQUUsR0FBR0UsZUFBZSxDQUFDO2dCQUFDO2dCQUFNO2dCQUFNO2FBQU07WUFDcERRLFNBQVNwQixLQUFLVSxFQUFFLEdBQUdFLGVBQWUsQ0FBQztZQUNuQ1MsYUFBYXJCLEtBQUtVLEVBQUUsR0FBR0UsZUFBZSxDQUFDO1lBQ3ZDVSxhQUFhdEIsS0FBS1UsRUFBRSxHQUFHRSxlQUFlLENBQUM7WUFDdkNXLFFBQVF2QixLQUFLVSxFQUFFLEdBQUdFLGVBQWUsQ0FBQztZQUNsQ1ksS0FBS3hCLEtBQUtVLEVBQUU7UUFDZDtRQUVBUixZQUFZdUIsa0JBQWtCLENBQUMsSUFBTW5CO1FBQ3JDRCxlQUFlLElBQUlxQiwwQkFBWTtRQUMvQnJCLGFB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