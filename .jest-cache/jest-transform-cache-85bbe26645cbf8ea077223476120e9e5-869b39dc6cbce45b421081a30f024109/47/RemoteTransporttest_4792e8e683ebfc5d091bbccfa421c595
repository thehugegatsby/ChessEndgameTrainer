d1a8bec15846ade1f08346cbd260b5ed
/**
 * Tests for RemoteTransport flush() method
 *
 * Tests cover:
 * - Successful flush with buffer clearing
 * - Network error with log restoration
 * - HTTP error handling
 * - Concurrent flush prevention
 * - Early return conditions
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _Logger = require("../../../../shared/services/logging/Logger");
const _types = require("../../../../shared/services/logging/types");
// Helper to create log entries for tests
/**
 *
 * @param message
 * @param level
 */ const createLogEntry = (message, level = _types.LogLevel.INFO)=>({
        timestamp: new Date(),
        level,
        message
    });
describe("RemoteTransport.flush", ()=>{
    const ENDPOINT = "https://api.logs.com/v1/ingest";
    // Mock console.error to verify it's called on failure and keep test output clean
    let consoleErrorSpy;
    beforeEach(()=>{
        // Mock the global fetch function before each test
        global.fetch = jest.fn();
        // Reset console.error spy for each test
        consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(()=>{});
    });
    afterEach(()=>{
        // Clear mock calls after each test
        consoleErrorSpy.mockClear();
    });
    afterAll(()=>{
        // Restore original console.error implementation after all tests
        consoleErrorSpy.mockRestore();
    });
    it("should send logs to the endpoint and clear the buffer on success", async ()=>{
        // Arrange
        const transport = new _Logger.RemoteTransport(ENDPOINT);
        const log1 = createLogEntry("first log");
        const log2 = createLogEntry("second log");
        // Access private buffer for testing
        transport.buffer.push(log1, log2);
        fetch.mockResolvedValueOnce({
            ok: true,
            /**
       *
       */ json: ()=>Promise.resolve({})
        });
        // Act
        await transport.flush();
        // Assert
        expect(fetch).toHaveBeenCalledTimes(1);
        expect(fetch).toHaveBeenCalledWith(ENDPOINT, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                logs: [
                    log1,
                    log2
                ]
            })
        });
        // The buffer should be empty after a successful flush
        expect(transport.buffer.length).toBe(0);
    });
    it("should restore logs to the buffer on a network error", async ()=>{
        // Arrange
        const transport = new _Logger.RemoteTransport(ENDPOINT);
        const log1 = createLogEntry("failed log 1");
        const log2 = createLogEntry("failed log 2");
        const originalLogs = [
            log1,
            log2
        ];
        transport.buffer.push(...originalLogs);
        const networkError = new Error("Network connection failed");
        fetch.mockRejectedValueOnce(networkError);
        // Act
        await transport.flush();
        // Assert
        // The logs should be put back into the buffer
        expect(transport.buffer).toEqual(originalLogs);
        // Verify fallback logging was called
        expect(consoleErrorSpy).toHaveBeenCalledWith("Failed to send logs to remote:", networkError);
    });
    it("should restore logs to the buffer on an HTTP error (e.g., 500)", async ()=>{
        // Arrange
        const transport = new _Logger.RemoteTransport(ENDPOINT);
        const log1 = createLogEntry("failed log 1");
        const originalLogs = [
            log1
        ];
        transport.buffer.push(...originalLogs);
        fetch.mockResolvedValueOnce({
            ok: false,
            status: 500
        });
        // Act
        await transport.flush();
        // Assert
        expect(transport.buffer).toEqual(originalLogs);
        expect(consoleErrorSpy).toHaveBeenCalledWith("Failed to send logs to remote:", new Error("Server responded with status 500"));
    });
    it("should preserve chronological order by unshifting failed logs back to the buffer", async ()=>{
        // Arrange: Initial logs that will fail
        const transport = new _Logger.RemoteTransport(ENDPOINT);
        const failedLog1 = createLogEntry("failed log 1");
        const failedLog2 = createLogEntry("failed log 2");
        transport.buffer.push(failedLog1, failedLog2);
        fetch.mockRejectedValueOnce(new Error("Network failure"));
        // Act 1: First flush fails
        await transport.flush();
        // Arrange 2: A new log is added after the failure
        const newLog = createLogEntry("new log after failure");
        transport.buffer.push(newLog);
        // The buffer should now be [failedLog1, failedLog2, newLog]
        // confirming chronological order preservation
        expect(transport.buffer).toEqual([
            failedLog1,
            failedLog2,
            newLog
        ]);
        // Act 2: Second flush succeeds
        fetch.mockResolvedValueOnce({
            ok: true
        });
        await transport.flush();
        // Assert 2: Fetch was called with all three logs in the correct order
        const sentBody = JSON.parse(fetch.mock.calls[1][1].body);
        expect(sentBody.logs).toHaveLength(3);
        expect(sentBody.logs[0].message).toBe("failed log 1");
        expect(sentBody.logs[1].message).toBe("failed log 2");
        expect(sentBody.logs[2].message).toBe("new log after failure");
        expect(transport.buffer.length).toBe(0);
    });
    it("should prevent concurrent flushes using the isFlushing flag", async ()=>{
        // Arrange
        const transport = new _Logger.RemoteTransport(ENDPOINT);
        transport.buffer.push(createLogEntry("some log"));
        // Create a promise that we can resolve manually to simulate a long-running fetch
        let resolveFetch;
        const fetchPromise = new Promise((resolve)=>{
            resolveFetch = resolve;
        });
        fetch.mockReturnValue(fetchPromise);
        // Act
        // Start the first flush, but don't wait for it to complete
        const firstFlushPromise = transport.flush();
        // While the first flush is "in-flight", call flush again
        // This should hit the guard clause and return early
        await transport.flush();
        // Assert
        // fetch should have only been called once by the first flush()
        expect(fetch).toHaveBeenCalledTimes(1);
        // Now, complete the first fetch call and wait for the promise to resolve
        resolveFetch({
            ok: true
        });
        await firstFlushPromise;
        // The buffer should now be empty, and the lock released
        expect(transport.buffer.length).toBe(0);
        expect(transport.isFlushing).toBe(false);
    });
    describe("Early return conditions", ()=>{
        it("should not call fetch if the buffer is empty", async ()=>{
            const transport = new _Logger.RemoteTransport(ENDPOINT);
            await transport.flush();
            expect(fetch).not.toHaveBeenCalled();
        });
        it("should not call fetch if the endpoint is not configured", async ()=>{
            // Pass an empty string for the endpoint
            const transport = new _Logger.RemoteTransport("");
            transport.buffer.push(createLogEntry("test log"));
            await transport.flush();
            expect(fetch).not.toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9zZXJ2aWNlcy9sb2dnaW5nL1JlbW90ZVRyYW5zcG9ydC50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGVzdHMgZm9yIFJlbW90ZVRyYW5zcG9ydCBmbHVzaCgpIG1ldGhvZFxuICpcbiAqIFRlc3RzIGNvdmVyOlxuICogLSBTdWNjZXNzZnVsIGZsdXNoIHdpdGggYnVmZmVyIGNsZWFyaW5nXG4gKiAtIE5ldHdvcmsgZXJyb3Igd2l0aCBsb2cgcmVzdG9yYXRpb25cbiAqIC0gSFRUUCBlcnJvciBoYW5kbGluZ1xuICogLSBDb25jdXJyZW50IGZsdXNoIHByZXZlbnRpb25cbiAqIC0gRWFybHkgcmV0dXJuIGNvbmRpdGlvbnNcbiAqL1xuXG5pbXBvcnQgeyBSZW1vdGVUcmFuc3BvcnQgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nL0xvZ2dlclwiO1xuaW1wb3J0IHsgTG9nTGV2ZWwsIExvZ0VudHJ5IH0gZnJvbSBcIkBzaGFyZWQvc2VydmljZXMvbG9nZ2luZy90eXBlc1wiO1xuXG4vLyBIZWxwZXIgdG8gY3JlYXRlIGxvZyBlbnRyaWVzIGZvciB0ZXN0c1xuLyoqXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEBwYXJhbSBsZXZlbFxuICovXG5jb25zdCBjcmVhdGVMb2dFbnRyeSA9IChcbiAgbWVzc2FnZTogc3RyaW5nLFxuICBsZXZlbDogTG9nTGV2ZWwgPSBMb2dMZXZlbC5JTkZPLFxuKTogTG9nRW50cnkgPT4gKHtcbiAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICBsZXZlbCxcbiAgbWVzc2FnZSxcbn0pO1xuXG5kZXNjcmliZShcIlJlbW90ZVRyYW5zcG9ydC5mbHVzaFwiLCAoKSA9PiB7XG4gIGNvbnN0IEVORFBPSU5UID0gXCJodHRwczovL2FwaS5sb2dzLmNvbS92MS9pbmdlc3RcIjtcblxuICAvLyBNb2NrIGNvbnNvbGUuZXJyb3IgdG8gdmVyaWZ5IGl0J3MgY2FsbGVkIG9uIGZhaWx1cmUgYW5kIGtlZXAgdGVzdCBvdXRwdXQgY2xlYW5cbiAgbGV0IGNvbnNvbGVFcnJvclNweTogamVzdC5TcHlJbnN0YW5jZTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBNb2NrIHRoZSBnbG9iYWwgZmV0Y2ggZnVuY3Rpb24gYmVmb3JlIGVhY2ggdGVzdFxuICAgIGdsb2JhbC5mZXRjaCA9IGplc3QuZm4oKTtcbiAgICAvLyBSZXNldCBjb25zb2xlLmVycm9yIHNweSBmb3IgZWFjaCB0ZXN0XG4gICAgY29uc29sZUVycm9yU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCBcImVycm9yXCIpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgLy8gQ2xlYXIgbW9jayBjYWxscyBhZnRlciBlYWNoIHRlc3RcbiAgICBjb25zb2xlRXJyb3JTcHkubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGFmdGVyQWxsKCgpID0+IHtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNvbnNvbGUuZXJyb3IgaW1wbGVtZW50YXRpb24gYWZ0ZXIgYWxsIHRlc3RzXG4gICAgY29uc29sZUVycm9yU3B5Lm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGl0KFwic2hvdWxkIHNlbmQgbG9ncyB0byB0aGUgZW5kcG9pbnQgYW5kIGNsZWFyIHRoZSBidWZmZXIgb24gc3VjY2Vzc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gQXJyYW5nZVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBSZW1vdGVUcmFuc3BvcnQoRU5EUE9JTlQpO1xuICAgIGNvbnN0IGxvZzEgPSBjcmVhdGVMb2dFbnRyeShcImZpcnN0IGxvZ1wiKTtcbiAgICBjb25zdCBsb2cyID0gY3JlYXRlTG9nRW50cnkoXCJzZWNvbmQgbG9nXCIpO1xuXG4gICAgLy8gQWNjZXNzIHByaXZhdGUgYnVmZmVyIGZvciB0ZXN0aW5nXG4gICAgKHRyYW5zcG9ydCBhcyBhbnkpLmJ1ZmZlci5wdXNoKGxvZzEsIGxvZzIpO1xuXG4gICAgKGZldGNoIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgIG9rOiB0cnVlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICBqc29uOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoe30pLFxuICAgIH0pO1xuXG4gICAgLy8gQWN0XG4gICAgYXdhaXQgdHJhbnNwb3J0LmZsdXNoKCk7XG5cbiAgICAvLyBBc3NlcnRcbiAgICBleHBlY3QoZmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICBleHBlY3QoZmV0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKEVORFBPSU5ULCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBsb2dzOiBbbG9nMSwgbG9nMl0gfSksXG4gICAgfSk7XG5cbiAgICAvLyBUaGUgYnVmZmVyIHNob3VsZCBiZSBlbXB0eSBhZnRlciBhIHN1Y2Nlc3NmdWwgZmx1c2hcbiAgICBleHBlY3QoKHRyYW5zcG9ydCBhcyBhbnkpLmJ1ZmZlci5sZW5ndGgpLnRvQmUoMCk7XG4gIH0pO1xuXG4gIGl0KFwic2hvdWxkIHJlc3RvcmUgbG9ncyB0byB0aGUgYnVmZmVyIG9uIGEgbmV0d29yayBlcnJvclwiLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gQXJyYW5nZVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBSZW1vdGVUcmFuc3BvcnQoRU5EUE9JTlQpO1xuICAgIGNvbnN0IGxvZzEgPSBjcmVhdGVMb2dFbnRyeShcImZhaWxlZCBsb2cgMVwiKTtcbiAgICBjb25zdCBsb2cyID0gY3JlYXRlTG9nRW50cnkoXCJmYWlsZWQgbG9nIDJcIik7XG4gICAgY29uc3Qgb3JpZ2luYWxMb2dzID0gW2xvZzEsIGxvZzJdO1xuICAgICh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIucHVzaCguLi5vcmlnaW5hbExvZ3MpO1xuXG4gICAgY29uc3QgbmV0d29ya0Vycm9yID0gbmV3IEVycm9yKFwiTmV0d29yayBjb25uZWN0aW9uIGZhaWxlZFwiKTtcbiAgICAoZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV0d29ya0Vycm9yKTtcblxuICAgIC8vIEFjdFxuICAgIGF3YWl0IHRyYW5zcG9ydC5mbHVzaCgpO1xuXG4gICAgLy8gQXNzZXJ0XG4gICAgLy8gVGhlIGxvZ3Mgc2hvdWxkIGJlIHB1dCBiYWNrIGludG8gdGhlIGJ1ZmZlclxuICAgIGV4cGVjdCgodHJhbnNwb3J0IGFzIGFueSkuYnVmZmVyKS50b0VxdWFsKG9yaWdpbmFsTG9ncyk7XG4gICAgLy8gVmVyaWZ5IGZhbGxiYWNrIGxvZ2dpbmcgd2FzIGNhbGxlZFxuICAgIGV4cGVjdChjb25zb2xlRXJyb3JTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgXCJGYWlsZWQgdG8gc2VuZCBsb2dzIHRvIHJlbW90ZTpcIixcbiAgICAgIG5ldHdvcmtFcnJvcixcbiAgICApO1xuICB9KTtcblxuICBpdChcInNob3VsZCByZXN0b3JlIGxvZ3MgdG8gdGhlIGJ1ZmZlciBvbiBhbiBIVFRQIGVycm9yIChlLmcuLCA1MDApXCIsIGFzeW5jICgpID0+IHtcbiAgICAvLyBBcnJhbmdlXG4gICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFJlbW90ZVRyYW5zcG9ydChFTkRQT0lOVCk7XG4gICAgY29uc3QgbG9nMSA9IGNyZWF0ZUxvZ0VudHJ5KFwiZmFpbGVkIGxvZyAxXCIpO1xuICAgIGNvbnN0IG9yaWdpbmFsTG9ncyA9IFtsb2cxXTtcbiAgICAodHJhbnNwb3J0IGFzIGFueSkuYnVmZmVyLnB1c2goLi4ub3JpZ2luYWxMb2dzKTtcblxuICAgIChmZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICBvazogZmFsc2UsXG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICB9KTtcblxuICAgIC8vIEFjdFxuICAgIGF3YWl0IHRyYW5zcG9ydC5mbHVzaCgpO1xuXG4gICAgLy8gQXNzZXJ0XG4gICAgZXhwZWN0KCh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIpLnRvRXF1YWwob3JpZ2luYWxMb2dzKTtcbiAgICBleHBlY3QoY29uc29sZUVycm9yU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIFwiRmFpbGVkIHRvIHNlbmQgbG9ncyB0byByZW1vdGU6XCIsXG4gICAgICBuZXcgRXJyb3IoXCJTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggc3RhdHVzIDUwMFwiKSxcbiAgICApO1xuICB9KTtcblxuICBpdChcInNob3VsZCBwcmVzZXJ2ZSBjaHJvbm9sb2dpY2FsIG9yZGVyIGJ5IHVuc2hpZnRpbmcgZmFpbGVkIGxvZ3MgYmFjayB0byB0aGUgYnVmZmVyXCIsIGFzeW5jICgpID0+IHtcbiAgICAvLyBBcnJhbmdlOiBJbml0aWFsIGxvZ3MgdGhhdCB3aWxsIGZhaWxcbiAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgUmVtb3RlVHJhbnNwb3J0KEVORFBPSU5UKTtcbiAgICBjb25zdCBmYWlsZWRMb2cxID0gY3JlYXRlTG9nRW50cnkoXCJmYWlsZWQgbG9nIDFcIik7XG4gICAgY29uc3QgZmFpbGVkTG9nMiA9IGNyZWF0ZUxvZ0VudHJ5KFwiZmFpbGVkIGxvZyAyXCIpO1xuICAgICh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIucHVzaChmYWlsZWRMb2cxLCBmYWlsZWRMb2cyKTtcblxuICAgIChmZXRjaCBhcyBqZXN0Lk1vY2spLm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoXCJOZXR3b3JrIGZhaWx1cmVcIikpO1xuXG4gICAgLy8gQWN0IDE6IEZpcnN0IGZsdXNoIGZhaWxzXG4gICAgYXdhaXQgdHJhbnNwb3J0LmZsdXNoKCk7XG5cbiAgICAvLyBBcnJhbmdlIDI6IEEgbmV3IGxvZyBpcyBhZGRlZCBhZnRlciB0aGUgZmFpbHVyZVxuICAgIGNvbnN0IG5ld0xvZyA9IGNyZWF0ZUxvZ0VudHJ5KFwibmV3IGxvZyBhZnRlciBmYWlsdXJlXCIpO1xuICAgICh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIucHVzaChuZXdMb2cpO1xuXG4gICAgLy8gVGhlIGJ1ZmZlciBzaG91bGQgbm93IGJlIFtmYWlsZWRMb2cxLCBmYWlsZWRMb2cyLCBuZXdMb2ddXG4gICAgLy8gY29uZmlybWluZyBjaHJvbm9sb2dpY2FsIG9yZGVyIHByZXNlcnZhdGlvblxuICAgIGV4cGVjdCgodHJhbnNwb3J0IGFzIGFueSkuYnVmZmVyKS50b0VxdWFsKFtmYWlsZWRMb2cxLCBmYWlsZWRMb2cyLCBuZXdMb2ddKTtcblxuICAgIC8vIEFjdCAyOiBTZWNvbmQgZmx1c2ggc3VjY2VlZHNcbiAgICAoZmV0Y2ggYXMgamVzdC5Nb2NrKS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBvazogdHJ1ZSB9KTtcbiAgICBhd2FpdCB0cmFuc3BvcnQuZmx1c2goKTtcblxuICAgIC8vIEFzc2VydCAyOiBGZXRjaCB3YXMgY2FsbGVkIHdpdGggYWxsIHRocmVlIGxvZ3MgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcbiAgICBjb25zdCBzZW50Qm9keSA9IEpTT04ucGFyc2UoKGZldGNoIGFzIGplc3QuTW9jaykubW9jay5jYWxsc1sxXVsxXS5ib2R5KTtcbiAgICBleHBlY3Qoc2VudEJvZHkubG9ncykudG9IYXZlTGVuZ3RoKDMpO1xuICAgIGV4cGVjdChzZW50Qm9keS5sb2dzWzBdLm1lc3NhZ2UpLnRvQmUoXCJmYWlsZWQgbG9nIDFcIik7XG4gICAgZXhwZWN0KHNlbnRCb2R5LmxvZ3NbMV0ubWVzc2FnZSkudG9CZShcImZhaWxlZCBsb2cgMlwiKTtcbiAgICBleHBlY3Qoc2VudEJvZHkubG9nc1syXS5tZXNzYWdlKS50b0JlKFwibmV3IGxvZyBhZnRlciBmYWlsdXJlXCIpO1xuICAgIGV4cGVjdCgodHJhbnNwb3J0IGFzIGFueSkuYnVmZmVyLmxlbmd0aCkudG9CZSgwKTtcbiAgfSk7XG5cbiAgaXQoXCJzaG91bGQgcHJldmVudCBjb25jdXJyZW50IGZsdXNoZXMgdXNpbmcgdGhlIGlzRmx1c2hpbmcgZmxhZ1wiLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gQXJyYW5nZVxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBSZW1vdGVUcmFuc3BvcnQoRU5EUE9JTlQpO1xuICAgICh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIucHVzaChjcmVhdGVMb2dFbnRyeShcInNvbWUgbG9nXCIpKTtcblxuICAgIC8vIENyZWF0ZSBhIHByb21pc2UgdGhhdCB3ZSBjYW4gcmVzb2x2ZSBtYW51YWxseSB0byBzaW11bGF0ZSBhIGxvbmctcnVubmluZyBmZXRjaFxuICAgIGxldCByZXNvbHZlRmV0Y2g6ICh2YWx1ZTogeyBvazogYm9vbGVhbiB9KSA9PiB2b2lkO1xuICAgIGNvbnN0IGZldGNoUHJvbWlzZSA9IG5ldyBQcm9taXNlPHsgb2s6IGJvb2xlYW4gfT4oKHJlc29sdmUpID0+IHtcbiAgICAgIHJlc29sdmVGZXRjaCA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgKGZldGNoIGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlKGZldGNoUHJvbWlzZSk7XG5cbiAgICAvLyBBY3RcbiAgICAvLyBTdGFydCB0aGUgZmlyc3QgZmx1c2gsIGJ1dCBkb24ndCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuICAgIGNvbnN0IGZpcnN0Rmx1c2hQcm9taXNlID0gdHJhbnNwb3J0LmZsdXNoKCk7XG5cbiAgICAvLyBXaGlsZSB0aGUgZmlyc3QgZmx1c2ggaXMgXCJpbi1mbGlnaHRcIiwgY2FsbCBmbHVzaCBhZ2FpblxuICAgIC8vIFRoaXMgc2hvdWxkIGhpdCB0aGUgZ3VhcmQgY2xhdXNlIGFuZCByZXR1cm4gZWFybHlcbiAgICBhd2FpdCB0cmFuc3BvcnQuZmx1c2goKTtcblxuICAgIC8vIEFzc2VydFxuICAgIC8vIGZldGNoIHNob3VsZCBoYXZlIG9ubHkgYmVlbiBjYWxsZWQgb25jZSBieSB0aGUgZmlyc3QgZmx1c2goKVxuICAgIGV4cGVjdChmZXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuXG4gICAgLy8gTm93LCBjb21wbGV0ZSB0aGUgZmlyc3QgZmV0Y2ggY2FsbCBhbmQgd2FpdCBmb3IgdGhlIHByb21pc2UgdG8gcmVzb2x2ZVxuICAgIHJlc29sdmVGZXRjaCEoeyBvazogdHJ1ZSB9KTtcbiAgICBhd2FpdCBmaXJzdEZsdXNoUHJvbWlzZTtcblxuICAgIC8vIFRoZSBidWZmZXIgc2hvdWxkIG5vdyBiZSBlbXB0eSwgYW5kIHRoZSBsb2NrIHJlbGVhc2VkXG4gICAgZXhwZWN0KCh0cmFuc3BvcnQgYXMgYW55KS5idWZmZXIubGVuZ3RoKS50b0JlKDApO1xuICAgIGV4cGVjdCgodHJhbnNwb3J0IGFzIGFueSkuaXNGbHVzaGluZykudG9CZShmYWxzZSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRWFybHkgcmV0dXJuIGNvbmRpdGlvbnNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIG5vdCBjYWxsIGZldGNoIGlmIHRoZSBidWZmZXIgaXMgZW1wdHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFJlbW90ZVRyYW5zcG9ydChFTkRQT0lOVCk7XG4gICAgICBhd2FpdCB0cmFuc3BvcnQuZmx1c2goKTtcbiAgICAgIGV4cGVjdChmZXRjaCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG5vdCBjYWxsIGZldGNoIGlmIHRoZSBlbmRwb2ludCBpcyBub3QgY29uZmlndXJlZFwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBQYXNzIGFuIGVtcHR5IHN0cmluZyBmb3IgdGhlIGVuZHBvaW50XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgUmVtb3RlVHJhbnNwb3J0KFwiXCIpO1xuICAgICAgKHRyYW5zcG9ydCBhcyBhbnkpLmJ1ZmZlci5wdXNoKGNyZWF0ZUxvZ0VudHJ5KFwidGVzdCBsb2dcIikpO1xuICAgICAgYXdhaXQgdHJhbnNwb3J0LmZsdXNoKCk7XG4gICAgICBleHBlY3QoZmV0Y2gpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiY3JlYXRlTG9nRW50cnkiLCJtZXNzYWdlIiwibGV2ZWwiLCJMb2dMZXZlbCIsIklORk8iLCJ0aW1lc3RhbXAiLCJEYXRlIiwiZGVzY3JpYmUiLCJFTkRQT0lOVCIsImNvbnNvbGVFcnJvclNweSIsImJlZm9yZUVhY2giLCJnbG9iYWwiLCJmZXRjaCIsImplc3QiLCJmbiIsInNweU9uIiwiY29uc29sZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsImFmdGVyRWFjaCIsIm1vY2tDbGVhciIsImFmdGVyQWxsIiwibW9ja1Jlc3RvcmUiLCJpdCIsInRyYW5zcG9ydCIsIlJlbW90ZVRyYW5zcG9ydCIsImxvZzEiLCJsb2cyIiwiYnVmZmVyIiwicHVzaCIsIm1vY2tSZXNvbHZlZFZhbHVlT25jZSIsIm9rIiwianNvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiZmx1c2giLCJleHBlY3QiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImxvZ3MiLCJsZW5ndGgiLCJ0b0JlIiwib3JpZ2luYWxMb2dzIiwibmV0d29ya0Vycm9yIiwiRXJyb3IiLCJtb2NrUmVqZWN0ZWRWYWx1ZU9uY2UiLCJ0b0VxdWFsIiwic3RhdHVzIiwiZmFpbGVkTG9nMSIsImZhaWxlZExvZzIiLCJuZXdMb2ciLCJzZW50Qm9keSIsInBhcnNlIiwibW9jayIsImNhbGxzIiwidG9IYXZlTGVuZ3RoIiwicmVzb2x2ZUZldGNoIiwiZmV0Y2hQcm9taXNlIiwibW9ja1JldHVyblZhbHVlIiwiZmlyc3RGbHVzaFByb21p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