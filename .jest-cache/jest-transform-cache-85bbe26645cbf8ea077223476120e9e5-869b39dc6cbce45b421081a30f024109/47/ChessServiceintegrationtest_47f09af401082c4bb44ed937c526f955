b1dd2729f5e1359503cb07aa65a47ca9
/**
 * ChessService Integration Tests - Issue #85 Phase 1
 *
 * Focus: Integration testing with real chess.js (30% of total test strategy)
 * Target: Verify real chess rules work correctly with ChessService
 * Strategy: Use real chess.js to test actual chess logic integration
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _ChessService = require("../../../shared/services/ChessService");
const _fenPositions = require("../../fixtures/fenPositions");
const _chessTestHelpers = require("../../helpers/chessTestHelpers");
// NO jest.mock('chess.js') here - we want the real chess.js
describe("ChessService Integration Tests", ()=>{
    let chessService;
    beforeEach(()=>{
        chessService = new _ChessService.ChessService(); // Uses real Chess.js
    });
    describe("Real Chess Rules", ()=>{
        it("should execute standard opening moves correctly", ()=>{
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e2", "e4"));
            expect(result).not.toBeNull();
            expect(result === null || result === void 0 ? void 0 : result.san).toBe("e4");
            // chess.js correctly returns - for en passant after e4 (no en passant possible)
            const currentFen = chessService.getFen();
            expect(currentFen).toContain("4P3"); // Pawn on e4
            expect(currentFen).toContain("b KQkq -"); // No en passant available
        });
        it("should handle castling moves correctly", ()=>{
            chessService.initialize(_fenPositions.StandardPositions.CASTLING_AVAILABLE);
            // Test kingside castling for white
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e1", "g1"));
            expect(result).not.toBeNull();
            expect(result === null || result === void 0 ? void 0 : result.san).toBe("O-O");
            expect(chessService.getFen()).toContain("R4RK1"); // King on g1, Rook on f1 after castling
        });
        it("should handle en passant captures correctly", ()=>{
            chessService.initialize(_fenPositions.StandardPositions.EN_PASSANT);
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e5", "d6"));
            expect(result).not.toBeNull();
            expect(result === null || result === void 0 ? void 0 : result.san).toBe("exd6");
            expect(result === null || result === void 0 ? void 0 : result.flags).toContain("e"); // en passant flag
            // The captured pawn should be gone from d5
            expect(chessService.getFen()).not.toContain("3pP3");
        });
        it("should handle pawn promotion correctly", ()=>{
            chessService.initialize(_fenPositions.SpecialPositions.PROMOTION);
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("f7", "f8", "q"));
            expect(result).not.toBeNull();
            expect(result === null || result === void 0 ? void 0 : result.promotion).toBe("q");
            expect(chessService.getFen()).toContain("Q"); // Queen on f8
        });
        it("should detect checkmate correctly", ()=>{
            chessService.initialize(_fenPositions.SpecialPositions.CHECKMATE);
            expect(chessService.isGameOver()).toBe(true);
        });
        it("should detect stalemate correctly", ()=>{
            chessService.initialize(_fenPositions.SpecialPositions.STALEMATE);
            expect(chessService.isGameOver()).toBe(true);
        // Note: The SpecialPositions.STALEMATE should be a real stalemate position
        });
        it("should reject illegal moves", ()=>{
            chessService.initialize(_fenPositions.StandardPositions.STARTING);
            const initialFen = chessService.getFen();
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e2", "e5")); // Illegal pawn jump
            expect(result).toBeNull();
            expect(chessService.getFen()).toBe(initialFen); // Position unchanged
        });
        it("should handle complex move sequences", ()=>{
            // Play a short opening sequence
            const moves = [
                (0, _chessTestHelpers.createTestMove)("e2", "e4"),
                (0, _chessTestHelpers.createTestMove)("e7", "e5"),
                (0, _chessTestHelpers.createTestMove)("g1", "f3"),
                (0, _chessTestHelpers.createTestMove)("b8", "c6")
            ];
            let expectedMoveCount = 0;
            moves.forEach((move)=>{
                const result = chessService.move(move);
                expect(result).not.toBeNull();
                expectedMoveCount++;
                expect(chessService.getMoveHistory()).toHaveLength(expectedMoveCount);
            });
            // Final position should be after Italian/Spanish opening setup
            expect(chessService.getFen()).toContain("r1bqkbnr/pppp1ppp/2n5/4p3/4P3/5N2/PPPP1PPP/RNBQKB1R");
        });
    });
    describe("Move Validation Integration", ()=>{
        it("should validate moves without changing state", ()=>{
            chessService.initialize(_fenPositions.StandardPositions.STARTING);
            const initialFen = chessService.getFen();
            const initialHistory = chessService.getMoveHistory();
            const validGood = chessService.validateMove((0, _chessTestHelpers.createTestMove)("e2", "e4"));
            const validBad = chessService.validateMove((0, _chessTestHelpers.createTestMove)("e2", "e5"));
            expect(validGood).toBe(true);
            expect(validBad).toBe(false);
            // State should be completely unchanged
            expect(chessService.getFen()).toBe(initialFen);
            expect(chessService.getMoveHistory()).toEqual(initialHistory);
        });
        it("should validate promotion moves correctly", ()=>{
            chessService.initialize(_fenPositions.SpecialPositions.PROMOTION);
            const validPromotion = chessService.validateMove((0, _chessTestHelpers.createTestMove)("f7", "f8", "q"));
            const invalidNoPromotion = chessService.validateMove((0, _chessTestHelpers.createTestMove)("f7", "f8")); // Missing promotion
            expect(validPromotion).toBe(true);
            expect(invalidNoPromotion).toBe(false);
        });
        it("should validate string moves in SAN notation", ()=>{
            chessService.initialize(_fenPositions.StandardPositions.STARTING);
            const validSAN = chessService.validateMove("e4");
            const invalidSAN = chessService.validateMove("e5"); // Illegal as opening move for white
            expect(validSAN).toBe(true);
            expect(invalidSAN).toBe(false);
        });
    });
    describe("Event System Integration", ()=>{
        it("should emit correct events for real moves", ()=>{
            const mockListener = (0, _chessTestHelpers.createMockListener)();
            chessService.subscribe(mockListener);
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e2", "e4"));
            expect(result).not.toBeNull();
            const event = (0, _chessTestHelpers.getLastEmittedEvent)(mockListener);
            expect(event).toBeDefined();
            expect(event.type).toBe("stateUpdate");
            expect((0, _chessTestHelpers.isValidStateUpdateEvent)(event)).toBe(true);
            if (event.type === "stateUpdate") {
                expect(event.payload.fen).toContain("4P3"); // Pawn on e4
                expect(event.payload.moveHistory).toHaveLength(1);
                expect(event.payload.currentMoveIndex).toBe(0);
                expect(event.payload.pgn).toContain("e4");
                expect(event.source).toBe("move");
            }
        });
        it("should emit error events for invalid moves", ()=>{
            const mockListener = (0, _chessTestHelpers.createMockListener)();
            chessService.subscribe(mockListener);
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("e1", "e2")); // Invalid move - king can't move into own pawn
            expect(result).toBeNull();
            const event = (0, _chessTestHelpers.getLastEmittedEvent)(mockListener);
            expect(event === null || event === void 0 ? void 0 : event.type).toBe("error");
            if ((event === null || event === void 0 ? void 0 : event.type) === "error") {
                expect(event.payload.message).toBe("Fehler beim AusfÃ¼hren des Zuges"); // ChessService returns this for exceptions
                expect(event.payload.error).toBeInstanceOf(Error);
            }
        });
        it("should emit state updates on initialization", ()=>{
            const mockListener = (0, _chessTestHelpers.createMockListener)();
            chessService.subscribe(mockListener);
            const result = chessService.initialize(_fenPositions.EndgamePositions.KPK_WIN);
            expect(result).toBe(true);
            const event = (0, _chessTestHelpers.getLastEmittedEvent)(mockListener);
            expect(event.type).toBe("stateUpdate");
            if (event.type === "stateUpdate") {
                expect(event.source).toBe("load");
                expect(event.payload.fen).toBe(_fenPositions.EndgamePositions.KPK_WIN);
                expect(event.payload.moveHistory).toHaveLength(0);
                expect(event.payload.currentMoveIndex).toBe(-1);
            }
        });
    });
    describe("Endgame Scenarios", ()=>{
        it("should handle KPK (King + Pawn vs King) endgame correctly", ()=>{
            chessService.initialize(_fenPositions.EndgamePositions.KPK_WIN);
            // Test a typical winning move in KPK
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("a8", "b8")); // King move
            expect(result).not.toBeNull();
            expect(result === null || result === void 0 ? void 0 : result.san).toBe("Kb8");
            expect(chessService.getFen()).toContain("1K6/P7/k7"); // King moved to b8
        });
        it("should handle KQK (King + Queen vs King) endgame correctly", ()=>{
            chessService.initialize(_fenPositions.EndgamePositions.KQK_WIN);
            // Queen should have many legal moves in this position
            const fenBefore = chessService.getFen();
            expect(fenBefore).toContain("Q"); // Queen present
            expect(chessService.isGameOver()).toBe(false); // Not mate yet
            // Make a queen move
            const result = chessService.move((0, _chessTestHelpers.createTestMove)("h1", "h8")); // Example queen move
            if (result) {
                expect(result.piece).toBe("q");
                expect(chessService.getFen()).toContain("Q"); // Queen still present
            }
        });
        it("should detect insufficient material correctly", ()=>{
            chessService.initialize(_fenPositions.SpecialPositions.INSUFFICIENT_MATERIAL.KK);
            expect(chessService.isGameOver()).toBe(true);
        });
    });
    describe("Position Validation", ()=>{
        it("should accept valid FEN positions", ()=>{
            const validPositions = [
                _fenPositions.StandardPositions.STARTING,
                _fenPositions.StandardPositions.AFTER_E4,
                _fenPositions.EndgamePositions.KPK_WIN,
                _fenPositions.EndgamePositions.KQK_WIN
            ];
            validPositions.forEach((fen)=>{
                const result = chessService.initialize(fen);
                expect(result).toBe(true);
                // For AFTER_E4, chess.js correctly shows no en passant
                if (fen === _fenPositions.StandardPositions.AFTER_E4) {
                    expect(chessService.getFen()).toContain("4P3");
                    expect(chessService.getFen()).toContain("b KQkq -");
                } else {
                    expect(chessService.getFen()).toBe(fen);
                }
            });
        });
        it("should reject invalid FEN positions", ()=>{
            const mockListener = (0, _chessTestHelpers.createMockListener)();
            chessService.subscribe(mockListener);
            const invalidFen = "invalid-fen-string";
            const result = chessService.initialize(invalidFen);
            expect(result).toBe(false);
            const event = (0, _chessTestHelpers.getLastEmittedEvent)(mockListener);
            expect(event === null || event === void 0 ? void 0 : event.type).toBe("error");
        });
    });
    describe("Real Chess Logic Edge Cases", ()=>{
        it("should handle castling restrictions correctly", ()=>{
            // Start with castling available position
            chessService.initialize(_fenPositions.StandardPositions.CASTLING_AVAILABLE);
            // Move the king first
            chessService.move((0, _chessTestHelpers.createTestMove)("e1", "f1")); // King move
            chessService.move((0, _chessTestHelpers.createTestMove)("e8", "d8")); // Black king move
            chessService.move((0, _chessTestHelpers.createTestMove)("f1", "e1")); // King back
            // Now castling should be invalid (king has moved)
            const castlingResult = chessService.move((0, _chessTestHelpers.createTestMove)("e1", "g1"));
            expect(castlingResult).toBeNull(); // Should be invalid
        });
        it("should handle check restrictions correctly", ()=>{
            // Set up a position where black king is in check from white queen on g5
            chessService.initialize(_fenPositions.SpecialPositions.BLACK_IN_CHECK);
            // Black king is in check from white queen on g5
            // Should only allow moves that get out of check
            const illegalMove = chessService.move((0, _chessTestHelpers.createTestMove)("a7", "a6")); // Doesn't address check
            expect(illegalMove).toBeNull();
            // Legal move that blocks check
            const legalMove = chessService.move((0, _chessTestHelpers.createTestMove)("f7", "f6")); // Block with pawn on f6
            if (legalMove) {
                expect(legalMove.san).toBe("f6");
            }
        });
    });
    describe("Navigation Integration - Issue #86", ()=>{
        it("should handle real navigation with actual chess moves", ()=>{
            // Make a real opening sequence
            chessService.move({
                from: "e2",
                to: "e4"
            });
            chessService.move({
                from: "e7",
                to: "e5"
            });
            chessService.move({
                from: "g1",
                to: "f3"
            });
            expect(chessService.getCurrentMoveIndex()).toBe(2);
            expect(chessService.getMoveHistory()).toHaveLength(3);
            // Undo to middle of sequence
            expect(chessService.undo()).toBe(true);
            expect(chessService.getCurrentMoveIndex()).toBe(1);
            // Make different move (history truncation) - it's white's turn after undoing Nf3
            const differentMove = chessService.move({
                from: "f1",
                to: "c4"
            }); // Bc4 instead of Nf3
            expect(differentMove).not.toBeNull();
            expect(chessService.getCurrentMoveIndex()).toBe(2);
            expect(chessService.getMoveHistory()).toHaveLength(3); // e4, e5, Bc4
            // Navigate to start
            expect(chessService.goToMove(-1)).toBe(true);
            expect(chessService.getCurrentMoveIndex()).toBe(-1);
            expect(chessService.getFen()).toBe(_fenPositions.StandardPositions.STARTING);
            // Navigate to middle
            expect(chessService.goToMove(1)).toBe(true);
            expect(chessService.getCurrentMoveIndex()).toBe(1);
            expect(chessService.getFen()).toBe(_fenPositions.StandardPositions.AFTER_E4_E5);
        });
        it("should maintain FEN accuracy throughout navigation", ()=>{
            // Create a specific position sequence
            const moves = [
                {
                    from: "e2",
                    to: "e4"
                },
                {
                    from: "e7",
                    to: "e5"
                },
                {
                    from: "g1",
                    to: "f3"
                },
                {
                    from: "b8",
                    to: "c6"
                }
            ];
            // Capture FENs at each step
            const fenHistory = [
                chessService.getFen()
            ]; // Starting position
            moves.forEach((move)=>{
                chessService.move(move);
                fenHistory.push(chessService.getFen());
            });
            // Navigate backwards and verify each FEN matches
            for(let i = moves.length - 1; i >= -1; i--){
                expect(chessService.goToMove(i)).toBe(true);
                expect(chessService.getCurrentMoveIndex()).toBe(i);
                expect(chessService.getFen()).toBe(fenHistory[i + 1]); // +1 because fenHistory includes starting pos
            }
            // Navigate forwards and verify again
            for(let i = 0; i < moves.length; i++){
                expect(chessService.goToMove(i)).toBe(true);
                expect(chessService.getCurrentMoveIndex()).toBe(i);
                expect(chessService.getFen()).toBe(fenHistory[i + 1]);
            }
        });
        it("should handle reset to custom starting position", ()=>{
            // Initialize with KPK endgame
            chessService.initialize(_fenPositions.EndgamePositions.KPK_WIN);
            const initialFen = chessService.getFen();
            // Make some moves
            chessService.move({
                from: "a8",
                to: "b8"
            });
            chessService.move({
                from: "a6",
                to: "a5"
            });
            expect(chessService.getCurrentMoveIndex()).toBe(1);
            expect(chessService.getMoveHistory()).toHaveLength(2);
            // Reset should go back to KPK position, not default starting position
            chessService.reset();
            expect(chessService.getCurrentMoveIndex()).toBe(-1);
            expect(chessService.getMoveHistory()).toHaveLength(0);
            expect(chessService.getFen()).toBe(initialFen);
        });
        it("should handle navigation error boundaries with real positions", ()=>{
            // Make 2 moves
            chessService.move({
                from: "e2",
                to: "e4"
            });
            chessService.move({
                from: "e7",
                to: "e5"
            });
            // Test invalid indices
            expect(chessService.goToMove(-2)).toBe(false);
            expect(chessService.goToMove(5)).toBe(false);
            // Valid indices should still work
            expect(chessService.goToMove(0)).toBe(true);
            expect(chessService.getCurrentMoveIndex()).toBe(0);
            expect(chessService.goToMove(-1)).toBe(true);
            expect(chessService.getCurrentMoveIndex()).toBe(-1);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvaW50ZWdyYXRpb24vc2VydmljZXMvQ2hlc3NTZXJ2aWNlLmludGVncmF0aW9uLnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGVzc1NlcnZpY2UgSW50ZWdyYXRpb24gVGVzdHMgLSBJc3N1ZSAjODUgUGhhc2UgMVxuICpcbiAqIEZvY3VzOiBJbnRlZ3JhdGlvbiB0ZXN0aW5nIHdpdGggcmVhbCBjaGVzcy5qcyAoMzAlIG9mIHRvdGFsIHRlc3Qgc3RyYXRlZ3kpXG4gKiBUYXJnZXQ6IFZlcmlmeSByZWFsIGNoZXNzIHJ1bGVzIHdvcmsgY29ycmVjdGx5IHdpdGggQ2hlc3NTZXJ2aWNlXG4gKiBTdHJhdGVneTogVXNlIHJlYWwgY2hlc3MuanMgdG8gdGVzdCBhY3R1YWwgY2hlc3MgbG9naWMgaW50ZWdyYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBDaGVzc1NlcnZpY2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2VcIjtcbmltcG9ydCB7XG4gIFN0YW5kYXJkUG9zaXRpb25zLFxuICBFbmRnYW1lUG9zaXRpb25zLFxuICBTcGVjaWFsUG9zaXRpb25zLFxufSBmcm9tIFwiLi4vLi4vZml4dHVyZXMvZmVuUG9zaXRpb25zXCI7XG5pbXBvcnQge1xuICBjcmVhdGVNb2NrTGlzdGVuZXIsXG4gIGdldExhc3RFbWl0dGVkRXZlbnQsXG4gIGlzVmFsaWRTdGF0ZVVwZGF0ZUV2ZW50LFxuICBjcmVhdGVUZXN0TW92ZSxcbiAgZXhwZWN0RmVuVG9FcXVhbCxcbn0gZnJvbSBcIi4uLy4uL2hlbHBlcnMvY2hlc3NUZXN0SGVscGVyc1wiO1xuXG4vLyBOTyBqZXN0Lm1vY2soJ2NoZXNzLmpzJykgaGVyZSAtIHdlIHdhbnQgdGhlIHJlYWwgY2hlc3MuanNcblxuZGVzY3JpYmUoXCJDaGVzc1NlcnZpY2UgSW50ZWdyYXRpb24gVGVzdHNcIiwgKCkgPT4ge1xuICBsZXQgY2hlc3NTZXJ2aWNlOiBDaGVzc1NlcnZpY2U7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgY2hlc3NTZXJ2aWNlID0gbmV3IENoZXNzU2VydmljZSgpOyAvLyBVc2VzIHJlYWwgQ2hlc3MuanNcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJSZWFsIENoZXNzIFJ1bGVzXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBleGVjdXRlIHN0YW5kYXJkIG9wZW5pbmcgbW92ZXMgY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5tb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZTJcIiwgXCJlNFwiKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8uc2FuKS50b0JlKFwiZTRcIik7XG4gICAgICAvLyBjaGVzcy5qcyBjb3JyZWN0bHkgcmV0dXJucyAtIGZvciBlbiBwYXNzYW50IGFmdGVyIGU0IChubyBlbiBwYXNzYW50IHBvc3NpYmxlKVxuICAgICAgY29uc3QgY3VycmVudEZlbiA9IGNoZXNzU2VydmljZS5nZXRGZW4oKTtcbiAgICAgIGV4cGVjdChjdXJyZW50RmVuKS50b0NvbnRhaW4oXCI0UDNcIik7IC8vIFBhd24gb24gZTRcbiAgICAgIGV4cGVjdChjdXJyZW50RmVuKS50b0NvbnRhaW4oXCJiIEtRa3EgLVwiKTsgLy8gTm8gZW4gcGFzc2FudCBhdmFpbGFibGVcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBjYXN0bGluZyBtb3ZlcyBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoU3RhbmRhcmRQb3NpdGlvbnMuQ0FTVExJTkdfQVZBSUxBQkxFKTtcblxuICAgICAgLy8gVGVzdCBraW5nc2lkZSBjYXN0bGluZyBmb3Igd2hpdGVcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5tb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZTFcIiwgXCJnMVwiKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8uc2FuKS50b0JlKFwiTy1PXCIpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9Db250YWluKFwiUjRSSzFcIik7IC8vIEtpbmcgb24gZzEsIFJvb2sgb24gZjEgYWZ0ZXIgY2FzdGxpbmdcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBlbiBwYXNzYW50IGNhcHR1cmVzIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShTdGFuZGFyZFBvc2l0aW9ucy5FTl9QQVNTQU5UKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJlNVwiLCBcImQ2XCIpKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0Py5zYW4pLnRvQmUoXCJleGQ2XCIpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8uZmxhZ3MpLnRvQ29udGFpbihcImVcIik7IC8vIGVuIHBhc3NhbnQgZmxhZ1xuICAgICAgLy8gVGhlIGNhcHR1cmVkIHBhd24gc2hvdWxkIGJlIGdvbmUgZnJvbSBkNVxuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkubm90LnRvQ29udGFpbihcIjNwUDNcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgcGF3biBwcm9tb3Rpb24gY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKFNwZWNpYWxQb3NpdGlvbnMuUFJPTU9USU9OKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJmN1wiLCBcImY4XCIsIFwicVwiKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8ucHJvbW90aW9uKS50b0JlKFwicVwiKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0RmVuKCkpLnRvQ29udGFpbihcIlFcIik7IC8vIFF1ZWVuIG9uIGY4XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBkZXRlY3QgY2hlY2ttYXRlIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShTcGVjaWFsUG9zaXRpb25zLkNIRUNLTUFURSk7XG5cbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuaXNHYW1lT3ZlcigpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZGV0ZWN0IHN0YWxlbWF0ZSBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoU3BlY2lhbFBvc2l0aW9ucy5TVEFMRU1BVEUpO1xuXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmlzR2FtZU92ZXIoKSkudG9CZSh0cnVlKTtcbiAgICAgIC8vIE5vdGU6IFRoZSBTcGVjaWFsUG9zaXRpb25zLlNUQUxFTUFURSBzaG91bGQgYmUgYSByZWFsIHN0YWxlbWF0ZSBwb3NpdGlvblxuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcmVqZWN0IGlsbGVnYWwgbW92ZXNcIiwgKCkgPT4ge1xuICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoU3RhbmRhcmRQb3NpdGlvbnMuU1RBUlRJTkcpO1xuICAgICAgY29uc3QgaW5pdGlhbEZlbiA9IGNoZXNzU2VydmljZS5nZXRGZW4oKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJlMlwiLCBcImU1XCIpKTsgLy8gSWxsZWdhbCBwYXduIGp1bXBcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0RmVuKCkpLnRvQmUoaW5pdGlhbEZlbik7IC8vIFBvc2l0aW9uIHVuY2hhbmdlZFxuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIGNvbXBsZXggbW92ZSBzZXF1ZW5jZXNcIiwgKCkgPT4ge1xuICAgICAgLy8gUGxheSBhIHNob3J0IG9wZW5pbmcgc2VxdWVuY2VcbiAgICAgIGNvbnN0IG1vdmVzID0gW1xuICAgICAgICBjcmVhdGVUZXN0TW92ZShcImUyXCIsIFwiZTRcIiksIC8vIDEuIGU0XG4gICAgICAgIGNyZWF0ZVRlc3RNb3ZlKFwiZTdcIiwgXCJlNVwiKSwgLy8gMS4uLiBlNVxuICAgICAgICBjcmVhdGVUZXN0TW92ZShcImcxXCIsIFwiZjNcIiksIC8vIDIuIE5mM1xuICAgICAgICBjcmVhdGVUZXN0TW92ZShcImI4XCIsIFwiYzZcIiksIC8vIDIuLi4gTmM2XG4gICAgICBdO1xuXG4gICAgICBsZXQgZXhwZWN0ZWRNb3ZlQ291bnQgPSAwO1xuICAgICAgbW92ZXMuZm9yRWFjaCgobW92ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UubW92ZShtb3ZlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdGVkTW92ZUNvdW50Kys7XG4gICAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKGV4cGVjdGVkTW92ZUNvdW50KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaW5hbCBwb3NpdGlvbiBzaG91bGQgYmUgYWZ0ZXIgSXRhbGlhbi9TcGFuaXNoIG9wZW5pbmcgc2V0dXBcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0RmVuKCkpLnRvQ29udGFpbihcbiAgICAgICAgXCJyMWJxa2Juci9wcHBwMXBwcC8ybjUvNHAzLzRQMy81TjIvUFBQUDFQUFAvUk5CUUtCMVJcIixcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiTW92ZSBWYWxpZGF0aW9uIEludGVncmF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCB2YWxpZGF0ZSBtb3ZlcyB3aXRob3V0IGNoYW5naW5nIHN0YXRlXCIsICgpID0+IHtcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKFN0YW5kYXJkUG9zaXRpb25zLlNUQVJUSU5HKTtcbiAgICAgIGNvbnN0IGluaXRpYWxGZW4gPSBjaGVzc1NlcnZpY2UuZ2V0RmVuKCk7XG4gICAgICBjb25zdCBpbml0aWFsSGlzdG9yeSA9IGNoZXNzU2VydmljZS5nZXRNb3ZlSGlzdG9yeSgpO1xuXG4gICAgICBjb25zdCB2YWxpZEdvb2QgPSBjaGVzc1NlcnZpY2UudmFsaWRhdGVNb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZTJcIiwgXCJlNFwiKSk7XG4gICAgICBjb25zdCB2YWxpZEJhZCA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUoY3JlYXRlVGVzdE1vdmUoXCJlMlwiLCBcImU1XCIpKTtcblxuICAgICAgZXhwZWN0KHZhbGlkR29vZCkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdCh2YWxpZEJhZCkudG9CZShmYWxzZSk7XG5cbiAgICAgIC8vIFN0YXRlIHNob3VsZCBiZSBjb21wbGV0ZWx5IHVuY2hhbmdlZFxuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9CZShpbml0aWFsRmVuKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9FcXVhbChpbml0aWFsSGlzdG9yeSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCB2YWxpZGF0ZSBwcm9tb3Rpb24gbW92ZXMgY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKFNwZWNpYWxQb3NpdGlvbnMuUFJPTU9USU9OKTtcblxuICAgICAgY29uc3QgdmFsaWRQcm9tb3Rpb24gPSBjaGVzc1NlcnZpY2UudmFsaWRhdGVNb3ZlKFxuICAgICAgICBjcmVhdGVUZXN0TW92ZShcImY3XCIsIFwiZjhcIiwgXCJxXCIpLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGludmFsaWROb1Byb21vdGlvbiA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUoXG4gICAgICAgIGNyZWF0ZVRlc3RNb3ZlKFwiZjdcIiwgXCJmOFwiKSxcbiAgICAgICk7IC8vIE1pc3NpbmcgcHJvbW90aW9uXG5cbiAgICAgIGV4cGVjdCh2YWxpZFByb21vdGlvbikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpbnZhbGlkTm9Qcm9tb3Rpb24pLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgdmFsaWRhdGUgc3RyaW5nIG1vdmVzIGluIFNBTiBub3RhdGlvblwiLCAoKSA9PiB7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShTdGFuZGFyZFBvc2l0aW9ucy5TVEFSVElORyk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU0FOID0gY2hlc3NTZXJ2aWNlLnZhbGlkYXRlTW92ZShcImU0XCIpO1xuICAgICAgY29uc3QgaW52YWxpZFNBTiA9IGNoZXNzU2VydmljZS52YWxpZGF0ZU1vdmUoXCJlNVwiKTsgLy8gSWxsZWdhbCBhcyBvcGVuaW5nIG1vdmUgZm9yIHdoaXRlXG5cbiAgICAgIGV4cGVjdCh2YWxpZFNBTikudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChpbnZhbGlkU0FOKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFdmVudCBTeXN0ZW0gSW50ZWdyYXRpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGVtaXQgY29ycmVjdCBldmVudHMgZm9yIHJlYWwgbW92ZXNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xpc3RlbmVyID0gY3JlYXRlTW9ja0xpc3RlbmVyKCk7XG4gICAgICBjaGVzc1NlcnZpY2Uuc3Vic2NyaWJlKG1vY2tMaXN0ZW5lcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5tb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZTJcIiwgXCJlNFwiKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLm5vdC50b0JlTnVsbCgpO1xuXG4gICAgICBjb25zdCBldmVudCA9IGdldExhc3RFbWl0dGVkRXZlbnQobW9ja0xpc3RlbmVyKTtcbiAgICAgIGV4cGVjdChldmVudCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChldmVudCEudHlwZSkudG9CZShcInN0YXRlVXBkYXRlXCIpO1xuICAgICAgZXhwZWN0KGlzVmFsaWRTdGF0ZVVwZGF0ZUV2ZW50KGV2ZW50ISkpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGlmIChldmVudCEudHlwZSA9PT0gXCJzdGF0ZVVwZGF0ZVwiKSB7XG4gICAgICAgIGV4cGVjdChldmVudCEucGF5bG9hZC5mZW4pLnRvQ29udGFpbihcIjRQM1wiKTsgLy8gUGF3biBvbiBlNFxuICAgICAgICBleHBlY3QoZXZlbnQhLnBheWxvYWQubW92ZUhpc3RvcnkpLnRvSGF2ZUxlbmd0aCgxKTtcbiAgICAgICAgZXhwZWN0KGV2ZW50IS5wYXlsb2FkLmN1cnJlbnRNb3ZlSW5kZXgpLnRvQmUoMCk7XG4gICAgICAgIGV4cGVjdChldmVudCEucGF5bG9hZC5wZ24pLnRvQ29udGFpbihcImU0XCIpO1xuICAgICAgICBleHBlY3QoZXZlbnQhLnNvdXJjZSkudG9CZShcIm1vdmVcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBlbWl0IGVycm9yIGV2ZW50cyBmb3IgaW52YWxpZCBtb3Zlc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrTGlzdGVuZXIgPSBjcmVhdGVNb2NrTGlzdGVuZXIoKTtcbiAgICAgIGNoZXNzU2VydmljZS5zdWJzY3JpYmUobW9ja0xpc3RlbmVyKTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJlMVwiLCBcImUyXCIpKTsgLy8gSW52YWxpZCBtb3ZlIC0ga2luZyBjYW4ndCBtb3ZlIGludG8gb3duIHBhd25cblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZU51bGwoKTtcblxuICAgICAgY29uc3QgZXZlbnQgPSBnZXRMYXN0RW1pdHRlZEV2ZW50KG1vY2tMaXN0ZW5lcik7XG4gICAgICBleHBlY3QoZXZlbnQ/LnR5cGUpLnRvQmUoXCJlcnJvclwiKTtcblxuICAgICAgaWYgKGV2ZW50Py50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgZXhwZWN0KGV2ZW50LnBheWxvYWQubWVzc2FnZSkudG9CZShcIkZlaGxlciBiZWltIEF1c2bDvGhyZW4gZGVzIFp1Z2VzXCIpOyAvLyBDaGVzc1NlcnZpY2UgcmV0dXJucyB0aGlzIGZvciBleGNlcHRpb25zXG4gICAgICAgIGV4cGVjdChldmVudC5wYXlsb2FkLmVycm9yKS50b0JlSW5zdGFuY2VPZihFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBlbWl0IHN0YXRlIHVwZGF0ZXMgb24gaW5pdGlhbGl6YXRpb25cIiwgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0xpc3RlbmVyID0gY3JlYXRlTW9ja0xpc3RlbmVyKCk7XG4gICAgICBjaGVzc1NlcnZpY2Uuc3Vic2NyaWJlKG1vY2tMaXN0ZW5lcik7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5pbml0aWFsaXplKEVuZGdhbWVQb3NpdGlvbnMuS1BLX1dJTik7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUodHJ1ZSk7XG5cbiAgICAgIGNvbnN0IGV2ZW50ID0gZ2V0TGFzdEVtaXR0ZWRFdmVudChtb2NrTGlzdGVuZXIpO1xuICAgICAgZXhwZWN0KGV2ZW50IS50eXBlKS50b0JlKFwic3RhdGVVcGRhdGVcIik7XG5cbiAgICAgIGlmIChldmVudCEudHlwZSA9PT0gXCJzdGF0ZVVwZGF0ZVwiKSB7XG4gICAgICAgIGV4cGVjdChldmVudCEuc291cmNlKS50b0JlKFwibG9hZFwiKTtcbiAgICAgICAgZXhwZWN0KGV2ZW50IS5wYXlsb2FkLmZlbikudG9CZShFbmRnYW1lUG9zaXRpb25zLktQS19XSU4pO1xuICAgICAgICBleHBlY3QoZXZlbnQhLnBheWxvYWQubW92ZUhpc3RvcnkpLnRvSGF2ZUxlbmd0aCgwKTtcbiAgICAgICAgZXhwZWN0KGV2ZW50IS5wYXlsb2FkLmN1cnJlbnRNb3ZlSW5kZXgpLnRvQmUoLTEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkVuZGdhbWUgU2NlbmFyaW9zXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBoYW5kbGUgS1BLIChLaW5nICsgUGF3biB2cyBLaW5nKSBlbmRnYW1lIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShFbmRnYW1lUG9zaXRpb25zLktQS19XSU4pO1xuXG4gICAgICAvLyBUZXN0IGEgdHlwaWNhbCB3aW5uaW5nIG1vdmUgaW4gS1BLXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UubW92ZShjcmVhdGVUZXN0TW92ZShcImE4XCIsIFwiYjhcIikpOyAvLyBLaW5nIG1vdmVcblxuICAgICAgZXhwZWN0KHJlc3VsdCkubm90LnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0Py5zYW4pLnRvQmUoXCJLYjhcIik7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEZlbigpKS50b0NvbnRhaW4oXCIxSzYvUDcvazdcIik7IC8vIEtpbmcgbW92ZWQgdG8gYjhcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBLUUsgKEtpbmcgKyBRdWVlbiB2cyBLaW5nKSBlbmRnYW1lIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShFbmRnYW1lUG9zaXRpb25zLktRS19XSU4pO1xuXG4gICAgICAvLyBRdWVlbiBzaG91bGQgaGF2ZSBtYW55IGxlZ2FsIG1vdmVzIGluIHRoaXMgcG9zaXRpb25cbiAgICAgIGNvbnN0IGZlbkJlZm9yZSA9IGNoZXNzU2VydmljZS5nZXRGZW4oKTtcbiAgICAgIGV4cGVjdChmZW5CZWZvcmUpLnRvQ29udGFpbihcIlFcIik7IC8vIFF1ZWVuIHByZXNlbnRcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuaXNHYW1lT3ZlcigpKS50b0JlKGZhbHNlKTsgLy8gTm90IG1hdGUgeWV0XG5cbiAgICAgIC8vIE1ha2UgYSBxdWVlbiBtb3ZlXG4gICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UubW92ZShjcmVhdGVUZXN0TW92ZShcImgxXCIsIFwiaDhcIikpOyAvLyBFeGFtcGxlIHF1ZWVuIG1vdmVcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBleHBlY3QocmVzdWx0LnBpZWNlKS50b0JlKFwicVwiKTtcbiAgICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9Db250YWluKFwiUVwiKTsgLy8gUXVlZW4gc3RpbGwgcHJlc2VudFxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgZGV0ZWN0IGluc3VmZmljaWVudCBtYXRlcmlhbCBjb3JyZWN0bHlcIiwgKCkgPT4ge1xuICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoU3BlY2lhbFBvc2l0aW9ucy5JTlNVRkZJQ0lFTlRfTUFURVJJQUwuS0spO1xuXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmlzR2FtZU92ZXIoKSkudG9CZSh0cnVlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJQb3NpdGlvbiBWYWxpZGF0aW9uXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBhY2NlcHQgdmFsaWQgRkVOIHBvc2l0aW9uc1wiLCAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZFBvc2l0aW9ucyA9IFtcbiAgICAgICAgU3RhbmRhcmRQb3NpdGlvbnMuU1RBUlRJTkcsXG4gICAgICAgIFN0YW5kYXJkUG9zaXRpb25zLkFGVEVSX0U0LFxuICAgICAgICBFbmRnYW1lUG9zaXRpb25zLktQS19XSU4sXG4gICAgICAgIEVuZGdhbWVQb3NpdGlvbnMuS1FLX1dJTixcbiAgICAgIF07XG5cbiAgICAgIHZhbGlkUG9zaXRpb25zLmZvckVhY2goKGZlbikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShmZW4pO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKHRydWUpO1xuICAgICAgICAvLyBGb3IgQUZURVJfRTQsIGNoZXNzLmpzIGNvcnJlY3RseSBzaG93cyBubyBlbiBwYXNzYW50XG4gICAgICAgIGlmIChmZW4gPT09IFN0YW5kYXJkUG9zaXRpb25zLkFGVEVSX0U0KSB7XG4gICAgICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9Db250YWluKFwiNFAzXCIpO1xuICAgICAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0RmVuKCkpLnRvQ29udGFpbihcImIgS1FrcSAtXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0RmVuKCkpLnRvQmUoZmVuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZWplY3QgaW52YWxpZCBGRU4gcG9zaXRpb25zXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tMaXN0ZW5lciA9IGNyZWF0ZU1vY2tMaXN0ZW5lcigpO1xuICAgICAgY2hlc3NTZXJ2aWNlLnN1YnNjcmliZShtb2NrTGlzdGVuZXIpO1xuXG4gICAgICBjb25zdCBpbnZhbGlkRmVuID0gXCJpbnZhbGlkLWZlbi1zdHJpbmdcIjtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZXNzU2VydmljZS5pbml0aWFsaXplKGludmFsaWRGZW4pO1xuXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKGZhbHNlKTtcblxuICAgICAgY29uc3QgZXZlbnQgPSBnZXRMYXN0RW1pdHRlZEV2ZW50KG1vY2tMaXN0ZW5lcik7XG4gICAgICBleHBlY3QoZXZlbnQ/LnR5cGUpLnRvQmUoXCJlcnJvclwiKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJSZWFsIENoZXNzIExvZ2ljIEVkZ2UgQ2FzZXNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBjYXN0bGluZyByZXN0cmljdGlvbnMgY29ycmVjdGx5XCIsICgpID0+IHtcbiAgICAgIC8vIFN0YXJ0IHdpdGggY2FzdGxpbmcgYXZhaWxhYmxlIHBvc2l0aW9uXG4gICAgICBjaGVzc1NlcnZpY2UuaW5pdGlhbGl6ZShTdGFuZGFyZFBvc2l0aW9ucy5DQVNUTElOR19BVkFJTEFCTEUpO1xuXG4gICAgICAvLyBNb3ZlIHRoZSBraW5nIGZpcnN0XG4gICAgICBjaGVzc1NlcnZpY2UubW92ZShjcmVhdGVUZXN0TW92ZShcImUxXCIsIFwiZjFcIikpOyAvLyBLaW5nIG1vdmVcbiAgICAgIGNoZXNzU2VydmljZS5tb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZThcIiwgXCJkOFwiKSk7IC8vIEJsYWNrIGtpbmcgbW92ZVxuICAgICAgY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJmMVwiLCBcImUxXCIpKTsgLy8gS2luZyBiYWNrXG5cbiAgICAgIC8vIE5vdyBjYXN0bGluZyBzaG91bGQgYmUgaW52YWxpZCAoa2luZyBoYXMgbW92ZWQpXG4gICAgICBjb25zdCBjYXN0bGluZ1Jlc3VsdCA9IGNoZXNzU2VydmljZS5tb3ZlKGNyZWF0ZVRlc3RNb3ZlKFwiZTFcIiwgXCJnMVwiKSk7XG4gICAgICBleHBlY3QoY2FzdGxpbmdSZXN1bHQpLnRvQmVOdWxsKCk7IC8vIFNob3VsZCBiZSBpbnZhbGlkXG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgY2hlY2sgcmVzdHJpY3Rpb25zIGNvcnJlY3RseVwiLCAoKSA9PiB7XG4gICAgICAvLyBTZXQgdXAgYSBwb3NpdGlvbiB3aGVyZSBibGFjayBraW5nIGlzIGluIGNoZWNrIGZyb20gd2hpdGUgcXVlZW4gb24gZzVcbiAgICAgIGNoZXNzU2VydmljZS5pbml0aWFsaXplKFNwZWNpYWxQb3NpdGlvbnMuQkxBQ0tfSU5fQ0hFQ0spO1xuXG4gICAgICAvLyBCbGFjayBraW5nIGlzIGluIGNoZWNrIGZyb20gd2hpdGUgcXVlZW4gb24gZzVcbiAgICAgIC8vIFNob3VsZCBvbmx5IGFsbG93IG1vdmVzIHRoYXQgZ2V0IG91dCBvZiBjaGVja1xuICAgICAgY29uc3QgaWxsZWdhbE1vdmUgPSBjaGVzc1NlcnZpY2UubW92ZShjcmVhdGVUZXN0TW92ZShcImE3XCIsIFwiYTZcIikpOyAvLyBEb2Vzbid0IGFkZHJlc3MgY2hlY2tcbiAgICAgIGV4cGVjdChpbGxlZ2FsTW92ZSkudG9CZU51bGwoKTtcblxuICAgICAgLy8gTGVnYWwgbW92ZSB0aGF0IGJsb2NrcyBjaGVja1xuICAgICAgY29uc3QgbGVnYWxNb3ZlID0gY2hlc3NTZXJ2aWNlLm1vdmUoY3JlYXRlVGVzdE1vdmUoXCJmN1wiLCBcImY2XCIpKTsgLy8gQmxvY2sgd2l0aCBwYXduIG9uIGY2XG4gICAgICBpZiAobGVnYWxNb3ZlKSB7XG4gICAgICAgIGV4cGVjdChsZWdhbE1vdmUuc2FuKS50b0JlKFwiZjZcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiTmF2aWdhdGlvbiBJbnRlZ3JhdGlvbiAtIElzc3VlICM4NlwiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgaGFuZGxlIHJlYWwgbmF2aWdhdGlvbiB3aXRoIGFjdHVhbCBjaGVzcyBtb3Zlc1wiLCAoKSA9PiB7XG4gICAgICAvLyBNYWtlIGEgcmVhbCBvcGVuaW5nIHNlcXVlbmNlXG4gICAgICBjaGVzc1NlcnZpY2UubW92ZSh7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiB9KTtcbiAgICAgIGNoZXNzU2VydmljZS5tb3ZlKHsgZnJvbTogXCJlN1wiLCB0bzogXCJlNVwiIH0pO1xuICAgICAgY2hlc3NTZXJ2aWNlLm1vdmUoeyBmcm9tOiBcImcxXCIsIHRvOiBcImYzXCIgfSk7XG5cbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKDIpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRNb3ZlSGlzdG9yeSgpKS50b0hhdmVMZW5ndGgoMyk7XG5cbiAgICAgIC8vIFVuZG8gdG8gbWlkZGxlIG9mIHNlcXVlbmNlXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLnVuZG8oKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKDEpO1xuXG4gICAgICAvLyBNYWtlIGRpZmZlcmVudCBtb3ZlIChoaXN0b3J5IHRydW5jYXRpb24pIC0gaXQncyB3aGl0ZSdzIHR1cm4gYWZ0ZXIgdW5kb2luZyBOZjNcbiAgICAgIGNvbnN0IGRpZmZlcmVudE1vdmUgPSBjaGVzc1NlcnZpY2UubW92ZSh7IGZyb206IFwiZjFcIiwgdG86IFwiYzRcIiB9KTsgLy8gQmM0IGluc3RlYWQgb2YgTmYzXG4gICAgICBleHBlY3QoZGlmZmVyZW50TW92ZSkubm90LnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEN1cnJlbnRNb3ZlSW5kZXgoKSkudG9CZSgyKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKDMpOyAvLyBlNCwgZTUsIEJjNFxuXG4gICAgICAvLyBOYXZpZ2F0ZSB0byBzdGFydFxuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nb1RvTW92ZSgtMSkpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEN1cnJlbnRNb3ZlSW5kZXgoKSkudG9CZSgtMSk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEZlbigpKS50b0JlKFN0YW5kYXJkUG9zaXRpb25zLlNUQVJUSU5HKTtcblxuICAgICAgLy8gTmF2aWdhdGUgdG8gbWlkZGxlXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKDEpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRDdXJyZW50TW92ZUluZGV4KCkpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEZlbigpKS50b0JlKFN0YW5kYXJkUG9zaXRpb25zLkFGVEVSX0U0X0U1KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIG1haW50YWluIEZFTiBhY2N1cmFjeSB0aHJvdWdob3V0IG5hdmlnYXRpb25cIiwgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIGEgc3BlY2lmaWMgcG9zaXRpb24gc2VxdWVuY2VcbiAgICAgIGNvbnN0IG1vdmVzID0gW1xuICAgICAgICB7IGZyb206IFwiZTJcIiwgdG86IFwiZTRcIiB9LFxuICAgICAgICB7IGZyb206IFwiZTdcIiwgdG86IFwiZTVcIiB9LFxuICAgICAgICB7IGZyb206IFwiZzFcIiwgdG86IFwiZjNcIiB9LFxuICAgICAgICB7IGZyb206IFwiYjhcIiwgdG86IFwiYzZcIiB9LFxuICAgICAgXTtcblxuICAgICAgLy8gQ2FwdHVyZSBGRU5zIGF0IGVhY2ggc3RlcFxuICAgICAgY29uc3QgZmVuSGlzdG9yeTogc3RyaW5nW10gPSBbY2hlc3NTZXJ2aWNlLmdldEZlbigpXTsgLy8gU3RhcnRpbmcgcG9zaXRpb25cblxuICAgICAgbW92ZXMuZm9yRWFjaCgobW92ZSkgPT4ge1xuICAgICAgICBjaGVzc1NlcnZpY2UubW92ZShtb3ZlKTtcbiAgICAgICAgZmVuSGlzdG9yeS5wdXNoKGNoZXNzU2VydmljZS5nZXRGZW4oKSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTmF2aWdhdGUgYmFja3dhcmRzIGFuZCB2ZXJpZnkgZWFjaCBGRU4gbWF0Y2hlc1xuICAgICAgZm9yIChsZXQgaSA9IG1vdmVzLmxlbmd0aCAtIDE7IGkgPj0gLTE7IGktLSkge1xuICAgICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKGkpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEN1cnJlbnRNb3ZlSW5kZXgoKSkudG9CZShpKTtcbiAgICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9CZShmZW5IaXN0b3J5W2kgKyAxXSk7IC8vICsxIGJlY2F1c2UgZmVuSGlzdG9yeSBpbmNsdWRlcyBzdGFydGluZyBwb3NcbiAgICAgIH1cblxuICAgICAgLy8gTmF2aWdhdGUgZm9yd2FyZHMgYW5kIHZlcmlmeSBhZ2FpblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKGkpKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldEN1cnJlbnRNb3ZlSW5kZXgoKSkudG9CZShpKTtcbiAgICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9CZShmZW5IaXN0b3J5W2kgKyAxXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBoYW5kbGUgcmVzZXQgdG8gY3VzdG9tIHN0YXJ0aW5nIHBvc2l0aW9uXCIsICgpID0+IHtcbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCBLUEsgZW5kZ2FtZVxuICAgICAgY2hlc3NTZXJ2aWNlLmluaXRpYWxpemUoRW5kZ2FtZVBvc2l0aW9ucy5LUEtfV0lOKTtcbiAgICAgIGNvbnN0IGluaXRpYWxGZW4gPSBjaGVzc1NlcnZpY2UuZ2V0RmVuKCk7XG5cbiAgICAgIC8vIE1ha2Ugc29tZSBtb3Zlc1xuICAgICAgY2hlc3NTZXJ2aWNlLm1vdmUoeyBmcm9tOiBcImE4XCIsIHRvOiBcImI4XCIgfSk7XG4gICAgICBjaGVzc1NlcnZpY2UubW92ZSh7IGZyb206IFwiYTZcIiwgdG86IFwiYTVcIiB9KTtcblxuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRDdXJyZW50TW92ZUluZGV4KCkpLnRvQmUoMSk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdldE1vdmVIaXN0b3J5KCkpLnRvSGF2ZUxlbmd0aCgyKTtcblxuICAgICAgLy8gUmVzZXQgc2hvdWxkIGdvIGJhY2sgdG8gS1BLIHBvc2l0aW9uLCBub3QgZGVmYXVsdCBzdGFydGluZyBwb3NpdGlvblxuICAgICAgY2hlc3NTZXJ2aWNlLnJlc2V0KCk7XG5cbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKC0xKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0TW92ZUhpc3RvcnkoKSkudG9IYXZlTGVuZ3RoKDApO1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nZXRGZW4oKSkudG9CZShpbml0aWFsRmVuKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBuYXZpZ2F0aW9uIGVycm9yIGJvdW5kYXJpZXMgd2l0aCByZWFsIHBvc2l0aW9uc1wiLCAoKSA9PiB7XG4gICAgICAvLyBNYWtlIDIgbW92ZXNcbiAgICAgIGNoZXNzU2VydmljZS5tb3ZlKHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiIH0pO1xuICAgICAgY2hlc3NTZXJ2aWNlLm1vdmUoeyBmcm9tOiBcImU3XCIsIHRvOiBcImU1XCIgfSk7XG5cbiAgICAgIC8vIFRlc3QgaW52YWxpZCBpbmRpY2VzXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKC0yKSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKDUpKS50b0JlKGZhbHNlKTtcblxuICAgICAgLy8gVmFsaWQgaW5kaWNlcyBzaG91bGQgc3RpbGwgd29ya1xuICAgICAgZXhwZWN0KGNoZXNzU2VydmljZS5nb1RvTW92ZSgwKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKDApO1xuXG4gICAgICBleHBlY3QoY2hlc3NTZXJ2aWNlLmdvVG9Nb3ZlKC0xKSkudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChjaGVzc1NlcnZpY2UuZ2V0Q3VycmVudE1vdmVJbmRleCgpKS50b0JlKC0xKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJkZXNjcmliZSIsImNoZXNzU2VydmljZSIsImJlZm9yZUVhY2giLCJDaGVzc1NlcnZpY2UiLCJpdCIsInJlc3VsdCIsIm1vdmUiLCJjcmVhdGVUZXN0TW92ZSIsImV4cGVjdCIsIm5vdCIsInRvQmVOdWxsIiwic2FuIiwidG9CZSIsImN1cnJlbnRGZW4iLCJnZXRGZW4iLCJ0b0NvbnRhaW4iLCJpbml0aWFsaXplIiwiU3RhbmRhcmRQb3NpdGlvbnMiLCJDQVNUTElOR19BVkFJTEFCTEUiLCJFTl9QQVNTQU5UIiwiZmxhZ3MiLCJTcGVjaWFsUG9zaXRpb25zIiwiUFJPTU9USU9OIiwicHJvbW90aW9uIiwiQ0hFQ0tNQVRFIiwiaXNHYW1lT3ZlciIsIlNUQUxFTUFURSIsIlNUQVJUSU5HIiwiaW5pdGlhbEZlbiIsIm1vdmVzIiwiZXhwZWN0ZWRNb3ZlQ291bnQiLCJmb3JFYWNoIiwiZ2V0TW92ZUhpc3RvcnkiLCJ0b0hhdmVMZW5ndGgiLCJpbml0aWFsSGlzdG9yeSIsInZhbGlkR29vZCIsInZhbGlkYXRlTW92ZSIsInZhbGlkQmFkIiwidG9FcXVhbCIsInZhbGlkUHJvbW90aW9uIiwiaW52YWxpZE5vUHJvbW90aW9uIiwidmFsaWRTQU4iLCJpbnZhbGlkU0FOIiwibW9ja0xpc3RlbmVyIiwiY3JlYXRlTW9ja0xpc3RlbmVyIiwic3Vic2NyaWJlIiwiZXZlbnQiLCJnZXRMYXN0RW1pdHRlZEV2ZW50IiwidG9CZURlZmluZWQiLCJ0eXBlIiwiaXNWYWxpZFN0YXRlVXBkYXRlRXZlbnQiLCJwYXlsb2FkIiwiZmVuIiwibW92ZUhpc3RvcnkiLCJjdXJyZW50TW92ZUluZGV4IiwicGduIiwic291cmNlIiwibWVzc2FnZSIsImVycm9yIiwidG9CZUluc3RhbmNlT2YiLCJFcnJvciIsIkVuZGdhbWVQb3NpdGlvbnMiLCJLUEtfV0lOIiwiS1FLX1dJTiIsImZlbkJlZm9yZSIsInBpZWNlIiwiSU5TVUZGSUNJRU5UX01BVEVSSUFMIiwiS0siLCJ2YWxpZFBvc2l0aW9ucyIsIkFGVEVSX0U0IiwiaW52YWxpZEZlbiIsImNhc3RsaW5nUmVzdWx0IiwiQkxBQ0tfSU5fQ0hFQ0siLCJpbGxlZ2FsTW92ZSIsImxlZ2FsTW92ZSIsImZyb20iLCJ0byIsImdldEN1cnJlbnRNb3ZlSW5kZXgiLCJ1bmRvIiwiZGlmZmVyZW50TW92ZSIsImdvVG9Nb3ZlIiwiQUZURVJfRTRfRTUiLCJmZW5IaXN0b3J5IiwicHVzaCIsImkiLCJsZW5ndGgiLCJyZXNldCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DOzs7OzhCQUU0Qjs4QkFLdEI7a0NBT0E7QUFFUCw0REFBNEQ7QUFFNURBLFNBQVMsa0NBQWtDO0lBQ3pDLElBQUlDO0lBRUpDLFdBQVc7UUFDVEQsZUFBZSxJQUFJRSwwQkFBWSxJQUFJLHFCQUFxQjtJQUMxRDtJQUVBSCxTQUFTLG9CQUFvQjtRQUMzQkksR0FBRyxtREFBbUQ7WUFDcEQsTUFBTUMsU0FBU0osYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU07WUFFdERDLE9BQU9ILFFBQVFJLEdBQUcsQ0FBQ0MsUUFBUTtZQUMzQkYsT0FBT0gsbUJBQUFBLDZCQUFBQSxPQUFRTSxHQUFHLEVBQUVDLElBQUksQ0FBQztZQUN6QixnRkFBZ0Y7WUFDaEYsTUFBTUMsYUFBYVosYUFBYWEsTUFBTTtZQUN0Q04sT0FBT0ssWUFBWUUsU0FBUyxDQUFDLFFBQVEsYUFBYTtZQUNsRFAsT0FBT0ssWUFBWUUsU0FBUyxDQUFDLGFBQWEsMEJBQTBCO1FBQ3RFO1FBRUFYLEdBQUcsMENBQTBDO1lBQzNDSCxhQUFhZSxVQUFVLENBQUNDLCtCQUFpQixDQUFDQyxrQkFBa0I7WUFFNUQsbUNBQW1DO1lBQ25DLE1BQU1iLFNBQVNKLGFBQWFLLElBQUksQ0FBQ0MsSUFBQUEsZ0NBQWMsRUFBQyxNQUFNO1lBRXREQyxPQUFPSCxRQUFRSSxHQUFHLENBQUNDLFFBQVE7WUFDM0JGLE9BQU9ILG1CQUFBQSw2QkFBQUEsT0FBUU0sR0FBRyxFQUFFQyxJQUFJLENBQUM7WUFDekJKLE9BQU9QLGFBQWFhLE1BQU0sSUFBSUMsU0FBUyxDQUFDLFVBQVUsd0NBQXdDO1FBQzVGO1FBRUFYLEdBQUcsK0NBQStDO1lBQ2hESCxhQUFhZSxVQUFVLENBQUNDLCtCQUFpQixDQUFDRSxVQUFVO1lBRXBELE1BQU1kLFNBQVNKLGFBQWFLLElBQUksQ0FBQ0MsSUFBQUEsZ0NBQWMsRUFBQyxNQUFNO1lBRXREQyxPQUFPSCxRQUFRSSxHQUFHLENBQUNDLFFBQVE7WUFDM0JGLE9BQU9ILG1CQUFBQSw2QkFBQUEsT0FBUU0sR0FBRyxFQUFFQyxJQUFJLENBQUM7WUFDekJKLE9BQU9ILG1CQUFBQSw2QkFBQUEsT0FBUWUsS0FBSyxFQUFFTCxTQUFTLENBQUMsTUFBTSxrQkFBa0I7WUFDeEQsMkNBQTJDO1lBQzNDUCxPQUFPUCxhQUFhYSxNQUFNLElBQUlMLEdBQUcsQ0FBQ00sU0FBUyxDQUFDO1FBQzlDO1FBRUFYLEdBQUcsMENBQTBDO1lBQzNDSCxhQUFhZSxVQUFVLENBQUNLLDhCQUFnQixDQUFDQyxTQUFTO1lBRWxELE1BQU1qQixTQUFTSixhQUFhSyxJQUFJLENBQUNDLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxNQUFNO1lBRTVEQyxPQUFPSCxRQUFRSSxHQUFHLENBQUNDLFFBQVE7WUFDM0JGLE9BQU9ILG1CQUFBQSw2QkFBQUEsT0FBUWtCLFNBQVMsRUFBRVgsSUFBSSxDQUFDO1lBQy9CSixPQUFPUCxhQUFhYSxNQUFNLElBQUlDLFNBQVMsQ0FBQyxNQUFNLGNBQWM7UUFDOUQ7UUFFQVgsR0FBRyxxQ0FBcUM7WUFDdENILGFBQWFlLFVBQVUsQ0FBQ0ssOEJBQWdCLENBQUNHLFNBQVM7WUFFbERoQixPQUFPUCxhQUFhd0IsVUFBVSxJQUFJYixJQUFJLENBQUM7UUFDekM7UUFFQVIsR0FBRyxxQ0FBcUM7WUFDdENILGFBQWFlLFVBQVUsQ0FBQ0ssOEJBQWdCLENBQUNLLFNBQVM7WUFFbERsQixPQUFPUCxhQUFhd0IsVUFBVSxJQUFJYixJQUFJLENBQUM7UUFDdkMsMkVBQTJFO1FBQzdFO1FBRUFSLEdBQUcsK0JBQStCO1lBQ2hDSCxhQUFhZSxVQUFVLENBQUNDLCtCQUFpQixDQUFDVSxRQUFRO1lBQ2xELE1BQU1DLGFBQWEzQixhQUFhYSxNQUFNO1lBRXRDLE1BQU1ULFNBQVNKLGFBQWFLLElBQUksQ0FBQ0MsSUFBQUEsZ0NBQWMsRUFBQyxNQUFNLFFBQVEsb0JBQW9CO1lBRWxGQyxPQUFPSCxRQUFRSyxRQUFRO1lBQ3ZCRixPQUFPUCxhQUFhYSxNQUFNLElBQUlGLElBQUksQ0FBQ2dCLGFBQWEscUJBQXFCO1FBQ3ZFO1FBRUF4QixHQUFHLHdDQUF3QztZQUN6QyxnQ0FBZ0M7WUFDaEMsTUFBTXlCLFFBQVE7Z0JBQ1p0QixJQUFBQSxnQ0FBYyxFQUFDLE1BQU07Z0JBQ3JCQSxJQUFBQSxnQ0FBYyxFQUFDLE1BQU07Z0JBQ3JCQSxJQUFBQSxnQ0FBYyxFQUFDLE1BQU07Z0JBQ3JCQSxJQUFBQSxnQ0FBYyxFQUFDLE1BQU07YUFDdEI7WUFFRCxJQUFJdUIsb0JBQW9CO1lBQ3hCRCxNQUFNRSxPQUFPLENBQUMsQ0FBQ3pCO2dCQUNiLE1BQU1ELFNBQVNKLGFBQWFLLElBQUksQ0FBQ0E7Z0JBQ2pDRSxPQUFPSCxRQUFRSSxHQUFHLENBQUNDLFFBQVE7Z0JBQzNCb0I7Z0JBQ0F0QixPQUFPUCxhQUFhK0IsY0FBYyxJQUFJQyxZQUFZLENBQUNIO1lBQ3JEO1lBRUEsK0RBQStEO1lBQy9EdEIsT0FBT1AsYUFBYWEsTUFBTSxJQUFJQyxTQUFTLENBQ3JDO1FBRUo7SUFDRjtJQUVBZixTQUFTLCtCQUErQjtRQUN0Q0ksR0FBRyxnREFBZ0Q7WUFDakRILGFBQWFlLFVBQVUsQ0FBQ0MsK0JBQWlCLENBQUNVLFFBQVE7WUFDbEQsTUFBTUMsYUFBYTNCLGFBQWFhLE1BQU07WUFDdEMsTUFBTW9CLGlCQUFpQmpDLGFBQWErQixjQUFjO1lBRWxELE1BQU1HLFlBQVlsQyxhQUFhbUMsWUFBWSxDQUFDN0IsSUFBQUEsZ0NBQWMsRUFBQyxNQUFNO1lBQ2pFLE1BQU04QixXQUFXcEMsYUFBYW1DLFlBQVksQ0FBQzdCLElBQUFBLGdDQUFjLEVBQUMsTUFBTTtZQUVoRUMsT0FBTzJCLFdBQVd2QixJQUFJLENBQUM7WUFDdkJKLE9BQU82QixVQUFVekIsSUFBSSxDQUFDO1lBRXRCLHVDQUF1QztZQUN2Q0osT0FBT1AsYUFBYWEsTUFBTSxJQUFJRixJQUFJLENBQUNnQjtZQUNuQ3BCLE9BQU9QLGFBQWErQixjQUFjLElBQUlNLE9BQU8sQ0FBQ0o7UUFDaEQ7UUFFQTlCLEdBQUcsNkNBQTZDO1lBQzlDSCxhQUFhZSxVQUFVLENBQUNLLDhCQUFnQixDQUFDQyxTQUFTO1lBRWxELE1BQU1pQixpQkFBaUJ0QyxhQUFhbUMsWUFBWSxDQUM5QzdCLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxNQUFNO1lBRTdCLE1BQU1pQyxxQkFBcUJ2QyxhQUFhbUMsWUFBWSxDQUNsRDdCLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxRQUNwQixvQkFBb0I7WUFFdkJDLE9BQU8rQixnQkFBZ0IzQixJQUFJLENBQUM7WUFDNUJKLE9BQU9nQyxvQkFBb0I1QixJQUFJLENBQUM7UUFDbEM7UUFFQVIsR0FBRyxnREFBZ0Q7WUFDakRILGFBQWFlLFVBQVUsQ0FBQ0MsK0JBQWlCLENBQUNVLFFBQVE7WUFFbEQsTUFBTWMsV0FBV3hDLGFBQWFtQyxZQUFZLENBQUM7WUFDM0MsTUFBTU0sYUFBYXpDLGFBQWFtQyxZQUFZLENBQUMsT0FBTyxvQ0FBb0M7WUFFeEY1QixPQUFPaUMsVUFBVTdCLElBQUksQ0FBQztZQUN0QkosT0FBT2tDLFlBQVk5QixJQUFJLENBQUM7UUFDMUI7SUFDRjtJQUVBWixTQUFTLDRCQUE0QjtRQUNuQ0ksR0FBRyw2Q0FBNkM7WUFDOUMsTUFBTXVDLGVBQWVDLElBQUFBLG9DQUFrQjtZQUN2QzNDLGFBQWE0QyxTQUFTLENBQUNGO1lBRXZCLE1BQU10QyxTQUFTSixhQUFhSyxJQUFJLENBQUNDLElBQUFBLGdDQUFjLEVBQUMsTUFBTTtZQUV0REMsT0FBT0gsUUFBUUksR0FBRyxDQUFDQyxRQUFRO1lBRTNCLE1BQU1vQyxRQUFRQyxJQUFBQSxxQ0FBbUIsRUFBQ0o7WUFDbENuQyxPQUFPc0MsT0FBT0UsV0FBVztZQUN6QnhDLE9BQU9zQyxNQUFPRyxJQUFJLEVBQUVyQyxJQUFJLENBQUM7WUFDekJKLE9BQU8wQyxJQUFBQSx5Q0FBdUIsRUFBQ0osUUFBU2xDLElBQUksQ0FBQztZQUU3QyxJQUFJa0MsTUFBT0csSUFBSSxLQUFLLGVBQWU7Z0JBQ2pDekMsT0FBT3NDLE1BQU9LLE9BQU8sQ0FBQ0MsR0FBRyxFQUFFckMsU0FBUyxDQUFDLFFBQVEsYUFBYTtnQkFDMURQLE9BQU9zQyxNQUFPSyxPQUFPLENBQUNFLFdBQVcsRUFBRXBCLFlBQVksQ0FBQztnQkFDaER6QixPQUFPc0MsTUFBT0ssT0FBTyxDQUFDRyxnQkFBZ0IsRUFBRTFDLElBQUksQ0FBQztnQkFDN0NKLE9BQU9zQyxNQUFPSyxPQUFPLENBQUNJLEdBQUcsRUFBRXhDLFNBQVMsQ0FBQztnQkFDckNQLE9BQU9zQyxNQUFPVSxNQUFNLEVBQUU1QyxJQUFJLENBQUM7WUFDN0I7UUFDRjtRQUVBUixHQUFHLDhDQUE4QztZQUMvQyxNQUFNdUMsZUFBZUMsSUFBQUEsb0NBQWtCO1lBQ3ZDM0MsYUFBYTRDLFNBQVMsQ0FBQ0Y7WUFFdkIsTUFBTXRDLFNBQVNKLGFBQWFLLElBQUksQ0FBQ0MsSUFBQUEsZ0NBQWMsRUFBQyxNQUFNLFFBQVEsK0NBQStDO1lBRTdHQyxPQUFPSCxRQUFRSyxRQUFRO1lBRXZCLE1BQU1vQyxRQUFRQyxJQUFBQSxxQ0FBbUIsRUFBQ0o7WUFDbENuQyxPQUFPc0Msa0JBQUFBLDRCQUFBQSxNQUFPRyxJQUFJLEVBQUVyQyxJQUFJLENBQUM7WUFFekIsSUFBSWtDLENBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT0csSUFBSSxNQUFLLFNBQVM7Z0JBQzNCekMsT0FBT3NDLE1BQU1LLE9BQU8sQ0FBQ00sT0FBTyxFQUFFN0MsSUFBSSxDQUFDLG9DQUFvQywyQ0FBMkM7Z0JBQ2xISixPQUFPc0MsTUFBTUssT0FBTyxDQUFDTyxLQUFLLEVBQUVDLGNBQWMsQ0FBQ0M7WUFDN0M7UUFDRjtRQUVBeEQsR0FBRywrQ0FBK0M7WUFDaEQsTUFBTXVDLGVBQWVDLElBQUFBLG9DQUFrQjtZQUN2QzNDLGFBQWE0QyxTQUFTLENBQUNGO1lBRXZCLE1BQU10QyxTQUFTSixhQUFhZSxVQUFVLENBQUM2Qyw4QkFBZ0IsQ0FBQ0MsT0FBTztZQUUvRHRELE9BQU9ILFFBQVFPLElBQUksQ0FBQztZQUVwQixNQUFNa0MsUUFBUUMsSUFBQUEscUNBQW1CLEVBQUNKO1lBQ2xDbkMsT0FBT3NDLE1BQU9HLElBQUksRUFBRXJDLElBQUksQ0FBQztZQUV6QixJQUFJa0MsTUFBT0csSUFBSSxLQUFLLGVBQWU7Z0JBQ2pDekMsT0FBT3NDLE1BQU9VLE1BQU0sRUFBRTVDLElBQUksQ0FBQztnQkFDM0JKLE9BQU9zQyxNQUFPSyxPQUFPLENBQUNDLEdBQUcsRUFBRXhDLElBQUksQ0FBQ2lELDhCQUFnQixDQUFDQyxPQUFPO2dCQUN4RHRELE9BQU9zQyxNQUFPSyxPQUFPLENBQUNFLFdBQVcsRUFBRXBCLFlBQVksQ0FBQztnQkFDaER6QixPQUFPc0MsTUFBT0ssT0FBTyxDQUFDRyxnQkFBZ0IsRUFBRTFDLElBQUksQ0FBQyxDQUFDO1lBQ2hEO1FBQ0Y7SUFDRjtJQUVBWixTQUFTLHFCQUFxQjtRQUM1QkksR0FBRyw2REFBNkQ7WUFDOURILGFBQWFlLFVBQVUsQ0FBQzZDLDhCQUFnQixDQUFDQyxPQUFPO1lBRWhELHFDQUFxQztZQUNyQyxNQUFNekQsU0FBU0osYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU0sUUFBUSxZQUFZO1lBRTFFQyxPQUFPSCxRQUFRSSxHQUFHLENBQUNDLFFBQVE7WUFDM0JGLE9BQU9ILG1CQUFBQSw2QkFBQUEsT0FBUU0sR0FBRyxFQUFFQyxJQUFJLENBQUM7WUFDekJKLE9BQU9QLGFBQWFhLE1BQU0sSUFBSUMsU0FBUyxDQUFDLGNBQWMsbUJBQW1CO1FBQzNFO1FBRUFYLEdBQUcsOERBQThEO1lBQy9ESCxhQUFhZSxVQUFVLENBQUM2Qyw4QkFBZ0IsQ0FBQ0UsT0FBTztZQUVoRCxzREFBc0Q7WUFDdEQsTUFBTUMsWUFBWS9ELGFBQWFhLE1BQU07WUFDckNOLE9BQU93RCxXQUFXakQsU0FBUyxDQUFDLE1BQU0sZ0JBQWdCO1lBQ2xEUCxPQUFPUCxhQUFhd0IsVUFBVSxJQUFJYixJQUFJLENBQUMsUUFBUSxlQUFlO1lBRTlELG9CQUFvQjtZQUNwQixNQUFNUCxTQUFTSixhQUFhSyxJQUFJLENBQUNDLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxRQUFRLHFCQUFxQjtZQUVuRixJQUFJRixRQUFRO2dCQUNWRyxPQUFPSCxPQUFPNEQsS0FBSyxFQUFFckQsSUFBSSxDQUFDO2dCQUMxQkosT0FBT1AsYUFBYWEsTUFBTSxJQUFJQyxTQUFTLENBQUMsTUFBTSxzQkFBc0I7WUFDdEU7UUFDRjtRQUVBWCxHQUFHLGlEQUFpRDtZQUNsREgsYUFBYWUsVUFBVSxDQUFDSyw4QkFBZ0IsQ0FBQzZDLHFCQUFxQixDQUFDQyxFQUFFO1lBRWpFM0QsT0FBT1AsYUFBYXdCLFVBQVUsSUFBSWIsSUFBSSxDQUFDO1FBQ3pDO0lBQ0Y7SUFFQVosU0FBUyx1QkFBdUI7UUFDOUJJLEdBQUcscUNBQXFDO1lBQ3RDLE1BQU1nRSxpQkFBaUI7Z0JBQ3JCbkQsK0JBQWlCLENBQUNVLFFBQVE7Z0JBQzFCViwrQkFBaUIsQ0FBQ29ELFFBQVE7Z0JBQzFCUiw4QkFBZ0IsQ0FBQ0MsT0FBTztnQkFDeEJELDhCQUFnQixDQUFDRSxPQUFPO2FBQ3pCO1lBRURLLGVBQWVyQyxPQUFPLENBQUMsQ0FBQ3FCO2dCQUN0QixNQUFNL0MsU0FBU0osYUFBYWUsVUFBVSxDQUFDb0M7Z0JBQ3ZDNUMsT0FBT0gsUUFBUU8sSUFBSSxDQUFDO2dCQUNwQix1REFBdUQ7Z0JBQ3ZELElBQUl3QyxRQUFRbkMsK0JBQWlCLENBQUNvRCxRQUFRLEVBQUU7b0JBQ3RDN0QsT0FBT1AsYUFBYWEsTUFBTSxJQUFJQyxTQUFTLENBQUM7b0JBQ3hDUCxPQUFPUCxhQUFhYSxNQUFNLElBQUlDLFNBQVMsQ0FBQztnQkFDMUMsT0FBTztvQkFDTFAsT0FBT1AsYUFBYWEsTUFBTSxJQUFJRixJQUFJLENBQUN3QztnQkFDckM7WUFDRjtRQUNGO1FBRUFoRCxHQUFHLHVDQUF1QztZQUN4QyxNQUFNdUMsZUFBZUMsSUFBQUEsb0NBQWtCO1lBQ3ZDM0MsYUFBYTRDLFNBQVMsQ0FBQ0Y7WUFFdkIsTUFBTTJCLGFBQWE7WUFDbkIsTUFBTWpFLFNBQVNKLGFBQWFlLFVBQVUsQ0FBQ3NEO1lBRXZDOUQsT0FBT0gsUUFBUU8sSUFBSSxDQUFDO1lBRXBCLE1BQU1rQyxRQUFRQyxJQUFBQSxxQ0FBbUIsRUFBQ0o7WUFDbENuQyxPQUFPc0Msa0JBQUFBLDRCQUFBQSxNQUFPRyxJQUFJLEVBQUVyQyxJQUFJLENBQUM7UUFDM0I7SUFDRjtJQUVBWixTQUFTLCtCQUErQjtRQUN0Q0ksR0FBRyxpREFBaUQ7WUFDbEQseUNBQXlDO1lBQ3pDSCxhQUFhZSxVQUFVLENBQUNDLCtCQUFpQixDQUFDQyxrQkFBa0I7WUFFNUQsc0JBQXNCO1lBQ3RCakIsYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU0sUUFBUSxZQUFZO1lBQzNETixhQUFhSyxJQUFJLENBQUNDLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxRQUFRLGtCQUFrQjtZQUNqRU4sYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU0sUUFBUSxZQUFZO1lBRTNELGtEQUFrRDtZQUNsRCxNQUFNZ0UsaUJBQWlCdEUsYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU07WUFDOURDLE9BQU8rRCxnQkFBZ0I3RCxRQUFRLElBQUksb0JBQW9CO1FBQ3pEO1FBRUFOLEdBQUcsOENBQThDO1lBQy9DLHdFQUF3RTtZQUN4RUgsYUFBYWUsVUFBVSxDQUFDSyw4QkFBZ0IsQ0FBQ21ELGNBQWM7WUFFdkQsZ0RBQWdEO1lBQ2hELGdEQUFnRDtZQUNoRCxNQUFNQyxjQUFjeEUsYUFBYUssSUFBSSxDQUFDQyxJQUFBQSxnQ0FBYyxFQUFDLE1BQU0sUUFBUSx3QkFBd0I7WUFDM0ZDLE9BQU9pRSxhQUFhL0QsUUFBUTtZQUU1QiwrQkFBK0I7WUFDL0IsTUFBTWdFLFlBQVl6RSxhQUFhSyxJQUFJLENBQUNDLElBQUFBLGdDQUFjLEVBQUMsTUFBTSxRQUFRLHdCQUF3QjtZQUN6RixJQUFJbUUsV0FBVztnQkFDYmxFLE9BQU9rRSxVQUFVL0QsR0FBRyxFQUFFQyxJQUFJLENBQUM7WUFDN0I7UUFDRjtJQUNGO0lBRUFaLFNBQVMsc0NBQXNDO1FBQzdDSSxHQUFHLHlEQUF5RDtZQUMxRCwrQkFBK0I7WUFDL0JILGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSztZQUN6QzNFLGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSztZQUN6QzNFLGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSztZQUV6Q3BFLE9BQU9QLGFBQWE0RSxtQkFBbUIsSUFBSWpFLElBQUksQ0FBQztZQUNoREosT0FBT1AsYUFBYStCLGNBQWMsSUFBSUMsWUFBWSxDQUFDO1lBRW5ELDZCQUE2QjtZQUM3QnpCLE9BQU9QLGFBQWE2RSxJQUFJLElBQUlsRSxJQUFJLENBQUM7WUFDakNKLE9BQU9QLGFBQWE0RSxtQkFBbUIsSUFBSWpFLElBQUksQ0FBQztZQUVoRCxpRkFBaUY7WUFDakYsTUFBTW1FLGdCQUFnQjlFLGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSyxJQUFJLHFCQUFxQjtZQUN4RnBFLE9BQU91RSxlQUFldEUsR0FBRyxDQUFDQyxRQUFRO1lBQ2xDRixPQUFPUCxhQUFhNEUsbUJBQW1CLElBQUlqRSxJQUFJLENBQUM7WUFDaERKLE9BQU9QLGFBQWErQixjQUFjLElBQUlDLFlBQVksQ0FBQyxJQUFJLGNBQWM7WUFFckUsb0JBQW9CO1lBQ3BCekIsT0FBT1AsYUFBYStFLFFBQVEsQ0FBQyxDQUFDLElBQUlwRSxJQUFJLENBQUM7WUFDdkNKLE9BQU9QLGFBQWE0RSxtQkFBbUIsSUFBSWpFLElBQUksQ0FBQyxDQUFDO1lBQ2pESixPQUFPUCxhQUFhYSxNQUFNLElBQUlGLElBQUksQ0FBQ0ssK0JBQWlCLENBQUNVLFFBQVE7WUFFN0QscUJBQXFCO1lBQ3JCbkIsT0FBT1AsYUFBYStFLFFBQVEsQ0FBQyxJQUFJcEUsSUFBSSxDQUFDO1lBQ3RDSixPQUFPUCxhQUFhNEUsbUJBQW1CLElBQUlqRSxJQUFJLENBQUM7WUFDaERKLE9BQU9QLGFBQWFhLE1BQU0sSUFBSUYsSUFBSSxDQUFDSywrQkFBaUIsQ0FBQ2dFLFdBQVc7UUFDbEU7UUFFQTdFLEdBQUcsc0RBQXNEO1lBQ3ZELHNDQUFzQztZQUN0QyxNQUFNeUIsUUFBUTtnQkFDWjtvQkFBRThDLE1BQU07b0JBQU1DLElBQUk7Z0JBQUs7Z0JBQ3ZCO29CQUFFRCxNQUFNO29CQUFNQyxJQUFJO2dCQUFLO2dCQUN2QjtvQkFBRUQsTUFBTTtvQkFBTUMsSUFBSTtnQkFBSztnQkFDdkI7b0JBQUVELE1BQU07b0JBQU1DLElBQUk7Z0JBQUs7YUFDeEI7WUFFRCw0QkFBNEI7WUFDNUIsTUFBTU0sYUFBdUI7Z0JBQUNqRixhQUFhYSxNQUFNO2FBQUcsRUFBRSxvQkFBb0I7WUFFMUVlLE1BQU1FLE9BQU8sQ0FBQyxDQUFDekI7Z0JBQ2JMLGFBQWFLLElBQUksQ0FBQ0E7Z0JBQ2xCNEUsV0FBV0MsSUFBSSxDQUFDbEYsYUFBYWEsTUFBTTtZQUNyQztZQUVBLGlEQUFpRDtZQUNqRCxJQUFLLElBQUlzRSxJQUFJdkQsTUFBTXdELE1BQU0sR0FBRyxHQUFHRCxLQUFLLENBQUMsR0FBR0EsSUFBSztnQkFDM0M1RSxPQUFPUCxhQUFhK0UsUUFBUSxDQUFDSSxJQUFJeEUsSUFBSSxDQUFDO2dCQUN0Q0osT0FBT1AsYUFBYTRFLG1CQUFtQixJQUFJakUsSUFBSSxDQUFDd0U7Z0JBQ2hENUUsT0FBT1AsYUFBYWEsTUFBTSxJQUFJRixJQUFJLENBQUNzRSxVQUFVLENBQUNFLElBQUksRUFBRSxHQUFHLDhDQUE4QztZQUN2RztZQUVBLHFDQUFxQztZQUNyQyxJQUFLLElBQUlBLElBQUksR0FBR0EsSUFBSXZELE1BQU13RCxNQUFNLEVBQUVELElBQUs7Z0JBQ3JDNUUsT0FBT1AsYUFBYStFLFFBQVEsQ0FBQ0ksSUFBSXhFLElBQUksQ0FBQztnQkFDdENKLE9BQU9QLGFBQWE0RSxtQkFBbUIsSUFBSWpFLElBQUksQ0FBQ3dFO2dCQUNoRDVFLE9BQU9QLGFBQWFhLE1BQU0sSUFBSUYsSUFBSSxDQUFDc0UsVUFBVSxDQUFDRSxJQUFJLEVBQUU7WUFDdEQ7UUFDRjtRQUVBaEYsR0FBRyxtREFBbUQ7WUFDcEQsOEJBQThCO1lBQzlCSCxhQUFhZSxVQUFVLENBQUM2Qyw4QkFBZ0IsQ0FBQ0MsT0FBTztZQUNoRCxNQUFNbEMsYUFBYTNCLGFBQWFhLE1BQU07WUFFdEMsa0JBQWtCO1lBQ2xCYixhQUFhSyxJQUFJLENBQUM7Z0JBQUVxRSxNQUFNO2dCQUFNQyxJQUFJO1lBQUs7WUFDekMzRSxhQUFhSyxJQUFJLENBQUM7Z0JBQUVxRSxNQUFNO2dCQUFNQyxJQUFJO1lBQUs7WUFFekNwRSxPQUFPUCxhQUFhNEUsbUJBQW1CLElBQUlqRSxJQUFJLENBQUM7WUFDaERKLE9BQU9QLGFBQWErQixjQUFjLElBQUlDLFlBQVksQ0FBQztZQUVuRCxzRUFBc0U7WUFDdEVoQyxhQUFhcUYsS0FBSztZQUVsQjlFLE9BQU9QLGFBQWE0RSxtQkFBbUIsSUFBSWpFLElBQUksQ0FBQyxDQUFDO1lBQ2pESixPQUFPUCxhQUFhK0IsY0FBYyxJQUFJQyxZQUFZLENBQUM7WUFDbkR6QixPQUFPUCxhQUFhYSxNQUFNLElBQUlGLElBQUksQ0FBQ2dCO1FBQ3JDO1FBRUF4QixHQUFHLGlFQUFpRTtZQUNsRSxlQUFlO1lBQ2ZILGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSztZQUN6QzNFLGFBQWFLLElBQUksQ0FBQztnQkFBRXFFLE1BQU07Z0JBQU1DLElBQUk7WUFBSztZQUV6Qyx1QkFBdUI7WUFDdkJwRSxPQUFPUCxhQUFhK0UsUUFBUSxDQUFDLENBQUMsSUFBSXBFLElBQUksQ0FBQztZQUN2Q0osT0FBT1AsYUFBYStFLFFBQVEsQ0FBQyxJQUFJcEUsSUFBSSxDQUFDO1lBRXRDLGtDQUFrQztZQUNsQ0osT0FBT1AsYUFBYStFLFFBQVEsQ0FBQyxJQUFJcEUsSUFBSSxDQUFDO1lBQ3RDSixPQUFPUCxhQUFhNEUsbUJBQW1CLElBQUlqRSxJQUFJLENBQUM7WUFFaERKLE9BQU9QLGFBQWErRSxRQUFRLENBQUMsQ0FBQyxJQUFJcEUsSUFBSSxDQUFDO1lBQ3ZDSixPQUFPUCxhQUFhNEUsbUJBQW1CLElBQUlqRSxJQUFJLENBQUMsQ0FBQztRQUNuRDtJQUNGO0FBQ0YifQ==