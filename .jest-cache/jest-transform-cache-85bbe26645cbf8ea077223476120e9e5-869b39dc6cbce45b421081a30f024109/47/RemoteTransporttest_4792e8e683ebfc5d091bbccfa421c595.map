{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/tests/unit/services/logging/RemoteTransport.test.ts"],"sourcesContent":["/**\n * Tests for RemoteTransport flush() method\n *\n * Tests cover:\n * - Successful flush with buffer clearing\n * - Network error with log restoration\n * - HTTP error handling\n * - Concurrent flush prevention\n * - Early return conditions\n */\n\nimport { RemoteTransport } from \"@shared/services/logging/Logger\";\nimport { LogLevel, LogEntry } from \"@shared/services/logging/types\";\n\n// Helper to create log entries for tests\n/**\n *\n * @param message\n * @param level\n */\nconst createLogEntry = (\n  message: string,\n  level: LogLevel = LogLevel.INFO,\n): LogEntry => ({\n  timestamp: new Date(),\n  level,\n  message,\n});\n\ndescribe(\"RemoteTransport.flush\", () => {\n  const ENDPOINT = \"https://api.logs.com/v1/ingest\";\n\n  // Mock console.error to verify it's called on failure and keep test output clean\n  let consoleErrorSpy: jest.SpyInstance;\n\n  beforeEach(() => {\n    // Mock the global fetch function before each test\n    global.fetch = jest.fn();\n    // Reset console.error spy for each test\n    consoleErrorSpy = jest.spyOn(console, \"error\").mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    // Clear mock calls after each test\n    consoleErrorSpy.mockClear();\n  });\n\n  afterAll(() => {\n    // Restore original console.error implementation after all tests\n    consoleErrorSpy.mockRestore();\n  });\n\n  it(\"should send logs to the endpoint and clear the buffer on success\", async () => {\n    // Arrange\n    const transport = new RemoteTransport(ENDPOINT);\n    const log1 = createLogEntry(\"first log\");\n    const log2 = createLogEntry(\"second log\");\n\n    // Access private buffer for testing\n    (transport as any).buffer.push(log1, log2);\n\n    (fetch as jest.Mock).mockResolvedValueOnce({\n      ok: true,\n      /**\n       *\n       */\n      json: () => Promise.resolve({}),\n    });\n\n    // Act\n    await transport.flush();\n\n    // Assert\n    expect(fetch).toHaveBeenCalledTimes(1);\n    expect(fetch).toHaveBeenCalledWith(ENDPOINT, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ logs: [log1, log2] }),\n    });\n\n    // The buffer should be empty after a successful flush\n    expect((transport as any).buffer.length).toBe(0);\n  });\n\n  it(\"should restore logs to the buffer on a network error\", async () => {\n    // Arrange\n    const transport = new RemoteTransport(ENDPOINT);\n    const log1 = createLogEntry(\"failed log 1\");\n    const log2 = createLogEntry(\"failed log 2\");\n    const originalLogs = [log1, log2];\n    (transport as any).buffer.push(...originalLogs);\n\n    const networkError = new Error(\"Network connection failed\");\n    (fetch as jest.Mock).mockRejectedValueOnce(networkError);\n\n    // Act\n    await transport.flush();\n\n    // Assert\n    // The logs should be put back into the buffer\n    expect((transport as any).buffer).toEqual(originalLogs);\n    // Verify fallback logging was called\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      \"Failed to send logs to remote:\",\n      networkError,\n    );\n  });\n\n  it(\"should restore logs to the buffer on an HTTP error (e.g., 500)\", async () => {\n    // Arrange\n    const transport = new RemoteTransport(ENDPOINT);\n    const log1 = createLogEntry(\"failed log 1\");\n    const originalLogs = [log1];\n    (transport as any).buffer.push(...originalLogs);\n\n    (fetch as jest.Mock).mockResolvedValueOnce({\n      ok: false,\n      status: 500,\n    });\n\n    // Act\n    await transport.flush();\n\n    // Assert\n    expect((transport as any).buffer).toEqual(originalLogs);\n    expect(consoleErrorSpy).toHaveBeenCalledWith(\n      \"Failed to send logs to remote:\",\n      new Error(\"Server responded with status 500\"),\n    );\n  });\n\n  it(\"should preserve chronological order by unshifting failed logs back to the buffer\", async () => {\n    // Arrange: Initial logs that will fail\n    const transport = new RemoteTransport(ENDPOINT);\n    const failedLog1 = createLogEntry(\"failed log 1\");\n    const failedLog2 = createLogEntry(\"failed log 2\");\n    (transport as any).buffer.push(failedLog1, failedLog2);\n\n    (fetch as jest.Mock).mockRejectedValueOnce(new Error(\"Network failure\"));\n\n    // Act 1: First flush fails\n    await transport.flush();\n\n    // Arrange 2: A new log is added after the failure\n    const newLog = createLogEntry(\"new log after failure\");\n    (transport as any).buffer.push(newLog);\n\n    // The buffer should now be [failedLog1, failedLog2, newLog]\n    // confirming chronological order preservation\n    expect((transport as any).buffer).toEqual([failedLog1, failedLog2, newLog]);\n\n    // Act 2: Second flush succeeds\n    (fetch as jest.Mock).mockResolvedValueOnce({ ok: true });\n    await transport.flush();\n\n    // Assert 2: Fetch was called with all three logs in the correct order\n    const sentBody = JSON.parse((fetch as jest.Mock).mock.calls[1][1].body);\n    expect(sentBody.logs).toHaveLength(3);\n    expect(sentBody.logs[0].message).toBe(\"failed log 1\");\n    expect(sentBody.logs[1].message).toBe(\"failed log 2\");\n    expect(sentBody.logs[2].message).toBe(\"new log after failure\");\n    expect((transport as any).buffer.length).toBe(0);\n  });\n\n  it(\"should prevent concurrent flushes using the isFlushing flag\", async () => {\n    // Arrange\n    const transport = new RemoteTransport(ENDPOINT);\n    (transport as any).buffer.push(createLogEntry(\"some log\"));\n\n    // Create a promise that we can resolve manually to simulate a long-running fetch\n    let resolveFetch: (value: { ok: boolean }) => void;\n    const fetchPromise = new Promise<{ ok: boolean }>((resolve) => {\n      resolveFetch = resolve;\n    });\n    (fetch as jest.Mock).mockReturnValue(fetchPromise);\n\n    // Act\n    // Start the first flush, but don't wait for it to complete\n    const firstFlushPromise = transport.flush();\n\n    // While the first flush is \"in-flight\", call flush again\n    // This should hit the guard clause and return early\n    await transport.flush();\n\n    // Assert\n    // fetch should have only been called once by the first flush()\n    expect(fetch).toHaveBeenCalledTimes(1);\n\n    // Now, complete the first fetch call and wait for the promise to resolve\n    resolveFetch!({ ok: true });\n    await firstFlushPromise;\n\n    // The buffer should now be empty, and the lock released\n    expect((transport as any).buffer.length).toBe(0);\n    expect((transport as any).isFlushing).toBe(false);\n  });\n\n  describe(\"Early return conditions\", () => {\n    it(\"should not call fetch if the buffer is empty\", async () => {\n      const transport = new RemoteTransport(ENDPOINT);\n      await transport.flush();\n      expect(fetch).not.toHaveBeenCalled();\n    });\n\n    it(\"should not call fetch if the endpoint is not configured\", async () => {\n      // Pass an empty string for the endpoint\n      const transport = new RemoteTransport(\"\");\n      (transport as any).buffer.push(createLogEntry(\"test log\"));\n      await transport.flush();\n      expect(fetch).not.toHaveBeenCalled();\n    });\n  });\n});\n"],"names":["createLogEntry","message","level","LogLevel","INFO","timestamp","Date","describe","ENDPOINT","consoleErrorSpy","beforeEach","global","fetch","jest","fn","spyOn","console","mockImplementation","afterEach","mockClear","afterAll","mockRestore","it","transport","RemoteTransport","log1","log2","buffer","push","mockResolvedValueOnce","ok","json","Promise","resolve","flush","expect","toHaveBeenCalledTimes","toHaveBeenCalledWith","method","headers","body","JSON","stringify","logs","length","toBe","originalLogs","networkError","Error","mockRejectedValueOnce","toEqual","status","failedLog1","failedLog2","newLog","sentBody","parse","mock","calls","toHaveLength","resolveFetch","fetchPromise","mockReturnValue","firstFlushPromise","isFlushing","not","toHaveBeenCalled"],"mappings":"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"}