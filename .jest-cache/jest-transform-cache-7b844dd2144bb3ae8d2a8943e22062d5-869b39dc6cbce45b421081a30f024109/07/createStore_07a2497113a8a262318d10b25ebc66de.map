{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/createStore.ts"],"sourcesContent":["/**\n * @file Store factory for SSR-safe Zustand store creation\n * @module store/createStore\n * @description Factory function that creates fresh store instances for each request/context.\n * This resolves SSR hydration issues by ensuring consistent store creation patterns.\n *\n * @remarks\n * This factory is used by the StoreProvider to create store instances:\n * - Server: Fresh instance per request\n * - Client: Consistent instance during hydration\n * - HMR: Stable instance during development\n *\n * The factory extracts the store creation logic from rootStore.ts to enable\n * per-request instantiation without singleton conflicts.\n */\n\nimport { create } from \"zustand\";\nimport { devtools, persist, createJSONStorage, StateStorage } from \"zustand/middleware\";\nimport { immer } from \"zustand/middleware/immer\";\n\n// Safe storage adapter that gracefully handles localStorage errors\nconst safeStorage: StateStorage = {\n  getItem: (name) => {\n    try {\n      if (typeof window === \"undefined\") return null;\n      return localStorage.getItem(name);\n    } catch {\n      return null;\n    }\n  },\n  setItem: (name, value) => {\n    try {\n      if (typeof window === \"undefined\") return;\n      localStorage.setItem(name, value);\n    } catch {\n      // Silently fail in restricted environments\n    }\n  },\n  removeItem: (name) => {\n    try {\n      if (typeof window === \"undefined\") return;\n      localStorage.removeItem(name);\n    } catch {\n      // Silently fail in restricted environments\n    }\n  },\n};\n\n// Import all slice creators\nimport { createGameSlice } from \"./slices/gameSlice\";\nimport {\n  createTablebaseState,\n  createTablebaseActions,\n} from \"./slices/tablebaseSlice\";\nimport {\n  createTrainingState,\n  createTrainingActions,\n} from \"./slices/trainingSlice\";\nimport { createProgressSlice } from \"./slices/progressSlice\";\nimport { createUISlice } from \"./slices/uiSlice\";\n\n// Import ChessService for event subscription\nimport {\n  chessService,\n  type ChessServiceEvent,\n} from \"@shared/services/ChessService\";\nimport { getLogger } from \"@shared/services/logging/Logger\";\n\n// Import orchestrators\nimport { loadTrainingContext as loadTrainingContextOrchestrator } from \"./orchestrators/loadTrainingContext\";\nimport { handlePlayerMove as handlePlayerMoveOrchestrator } from \"./orchestrators/handlePlayerMove/index\";\n\n// Import types\nimport type { RootState } from \"./slices/types\";\nimport type { Move as ChessJsMove } from \"chess.js\";\nimport type { EndgamePosition } from \"@shared/types/endgame\";\n\n/**\n * Creates a fresh store instance with all slices and middleware\n *\n * @param {Partial<RootState>} [initialState] - Optional initial state for hydration\n * @returns {ReturnType<typeof create<RootState>>} Fresh Zustand store instance\n *\n * @remarks\n * This factory creates a complete store with:\n * - All 4 domain-specific slices (Game, Tablebase, Training, UI)\n * - Cross-slice orchestrators for complex operations\n * - Middleware integration (DevTools, Persist, Immer)\n * - ChessService event subscription for state sync\n * - Global reset and hydration actions\n *\n * Each call creates a completely fresh store instance, preventing\n * SSR hydration mismatches and ensuring clean state isolation.\n *\n * @example\n * ```typescript\n * // Create fresh store\n * const store = createStore();\n *\n * // Create with initial state for SSR\n * const store = createStore({\n *   game: { currentFen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1' }\n * });\n *\n * // Use in context provider\n * const storeRef = useRef<ReturnType<typeof createStore>>();\n * if (!storeRef.current) {\n *   storeRef.current = createStore(initialState);\n * }\n * ```\n */\nexport const createStore = (initialState?: Partial<RootState>) => {\n  const store = create<RootState>()(\n    devtools(\n      persist(\n        immer((set, get, api) => {\n          // Create slices using Slice-in-Slice pattern (clean separation of state and actions)\n          const gameSlice = createGameSlice(set, get, api);\n          const progressSlice = createProgressSlice(set, get, api);\n          const uiSlice = createUISlice(set, get, api);\n          const rootState: RootState = {\n            // Clean Slice-in-Slice pattern: state and actions preserved at slice level\n            game: gameSlice,\n            training: {\n              ...createTrainingState(),\n              ...createTrainingActions(set, get),\n            },\n            tablebase: {\n              ...createTablebaseState(),\n              ...createTablebaseActions(set),\n            },\n            progress: progressSlice,\n            ui: uiSlice,\n\n            // Orchestrator actions - coordinate across multiple slices\n            handlePlayerMove: async (\n              move:\n                | ChessJsMove\n                | { from: string; to: string; promotion?: string }\n                | string,\n            ): Promise<boolean> => {\n              const logger = getLogger().setContext(\"CreateStore\");\n              logger.debug(\"handlePlayerMove called\", { move });\n              const storeApi = { getState: get, setState: set };\n              logger.debug(\"Calling handlePlayerMoveOrchestrator\");\n              const result = await handlePlayerMoveOrchestrator(storeApi, move);\n              logger.debug(\"handlePlayerMoveOrchestrator result\", { result });\n              return result;\n            },\n\n            loadTrainingContext: async (\n              position: EndgamePosition,\n            ): Promise<void> => {\n              const storeApi = { getState: get, setState: set };\n              return await loadTrainingContextOrchestrator(storeApi, position);\n            },\n\n            /**\n             * Resets entire store to initial state\n             */\n            reset: () => {\n              set((state) => {\n                // Reset only the state properties, not the actions - MANUAL PROPERTY RESET\n                // Game slice - explicit property reset\n                state.game.moveHistory = [];\n                state.game.currentMoveIndex = 0;\n                state.game.isGameFinished = false;\n\n                // Training slice - DO NOT RESET - Preserve all action methods\n\n                // Tablebase slice - explicit property reset\n                state.tablebase.tablebaseMove = null;\n                state.tablebase.analysisStatus = \"idle\";\n                state.tablebase.evaluations = [];\n                state.tablebase.currentEvaluation = undefined;\n\n                // UI slice - explicit property reset\n                state.ui.isSidebarOpen = false;\n                state.ui.currentModal = null;\n                state.ui.toasts = [];\n                state.ui.loading = {\n                  global: false,\n                  position: false,\n                  tablebase: false,\n                  analysis: false,\n                };\n                state.ui.analysisPanel = {\n                  isOpen: false,\n                  activeTab: \"evaluation\",\n                  showTablebase: false,\n                };\n              });\n            },\n\n            /**\n             * Hydrates store with partial state data\n             */\n            hydrate: (state: Partial<RootState>) => {\n              set((currentState) => ({\n                ...currentState,\n                ...state,\n              }));\n            },\n          };\n\n          // Apply initial state if provided - Deep merge to preserve slice functions\n          if (initialState) {\n            // Merge game state properties\n            if (initialState.game) {\n              Object.assign(rootState.game, initialState.game);\n\n              // CRITICAL: Sync ChessService with initial FEN after render\n              // Use setTimeout to avoid setState during render\n              if (initialState.game.currentFen) {\n                const fenToLoad = initialState.game.currentFen;\n                setTimeout(() => {\n                  try {\n                    chessService.initialize(fenToLoad);\n                  } catch (error) {\n                    getLogger().error(\n                      \"Failed to load initial FEN into ChessService\",\n                      {\n                        fen: fenToLoad,\n                        error,\n                      },\n                    );\n                  }\n                }, 0);\n              }\n            }\n\n            // Merge training state properties\n            if (initialState.training) {\n              Object.assign(rootState.training, initialState.training);\n            }\n\n            // Merge tablebase state properties\n            if (initialState.tablebase) {\n              Object.assign(rootState.tablebase, initialState.tablebase);\n            }\n\n            // Merge progress state properties\n            if (initialState.progress) {\n              Object.assign(rootState.progress, initialState.progress);\n            }\n\n            // Merge UI state properties\n            if (initialState.ui) {\n              Object.assign(rootState.ui, initialState.ui);\n            }\n          }\n\n          return rootState;\n        }),\n        {\n          name: \"endgame-trainer-store\",\n          version: 1,\n          storage: createJSONStorage(() => safeStorage), // Safe storage that handles errors gracefully\n          // Only persist training position for session continuity\n          partialize: (state) => ({\n            training: {\n              currentPosition: state.training.currentPosition,\n            },\n          }),\n          // Merge strategy to prevent overwriting the entire slice\n          merge: (persistedState, currentState) => {\n            // Deep merge to preserve slice structure and functions\n            const merged = { ...currentState };\n\n            if (persistedState && typeof persistedState === \"object\") {\n              const persisted = persistedState as any;\n\n              // Only merge the specific persisted properties, not the entire slice\n              if (persisted.training?.currentPosition) {\n                merged.training = {\n                  ...currentState.training,\n                  currentPosition: persisted.training.currentPosition,\n                };\n              }\n            }\n\n            return merged;\n          },\n        },\n      ),\n      {\n        name: \"EndgameTrainer Store\",\n        enabled: process.env.NODE_ENV === \"development\",\n      },\n    ),\n  );\n\n  // Subscribe to ChessService events for automatic state synchronization\n  const unsubscribeChessService = chessService.subscribe(\n    (event: ChessServiceEvent) => {\n      switch (event.type) {\n        case \"stateUpdate\":\n          // Use batched payload for atomic state update\n          store.setState((draft) => {\n            draft.game.currentFen = event.payload.fen;\n            draft.game.currentPgn = event.payload.pgn;\n            draft.game.moveHistory = event.payload.moveHistory;\n            draft.game.currentMoveIndex = event.payload.currentMoveIndex;\n            draft.game.isGameFinished = event.payload.isGameOver;\n            draft.game.gameResult = event.payload.gameResult;\n          });\n          break;\n\n        case \"error\":\n          // Handle errors from ChessService\n          store.setState((draft) => {\n            draft.ui.toasts.push({\n              id: crypto.randomUUID(),\n              message: event.payload.message,\n              type: \"error\",\n              duration: 5000,\n            });\n          });\n          break;\n      }\n    },\n  );\n\n  // Attach cleanup function to store instance\n  (store as any).__cleanup = unsubscribeChessService;\n\n  return store;\n};\n\n/**\n * Type export for the store instance\n */\nexport type StoreInstance = ReturnType<typeof createStore>;\n"],"names":["createStore","safeStorage","getItem","name","window","localStorage","setItem","value","removeItem","initialState","store","create","devtools","persist","immer","set","get","api","gameSlice","createGameSlice","progressSlice","createProgressSlice","uiSlice","createUISlice","rootState","game","training","createTrainingState","createTrainingActions","tablebase","createTablebaseState","createTablebaseActions","progress","ui","handlePlayerMove","move","logger","getLogger","setContext","debug","storeApi","getState","setState","result","handlePlayerMoveOrchestrator","loadTrainingContext","position","loadTrainingContextOrchestrator","reset","state","moveHistory","currentMoveIndex","isGameFinished","tablebaseMove","analysisStatus","evaluations","currentEvaluation","undefined","isSidebarOpen","currentModal","toasts","loading","global","analysis","analysisPanel","isOpen","activeTab","showTablebase","hydrate","currentState","Object","assign","currentFen","fenToLoad","setTimeout","chessService","initialize","error","fen","version","storage","createJSONStorage","partialize","currentPosition","merge","persistedState","merged","persisted","enabled","process","env","NODE_ENV","unsubscribeChessService","subscribe","event","type","draft","payload","currentPgn","pgn","isGameOver","gameResult","push","id","crypto","randomUUID","message","duration","__cleanup"],"mappings":"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"}