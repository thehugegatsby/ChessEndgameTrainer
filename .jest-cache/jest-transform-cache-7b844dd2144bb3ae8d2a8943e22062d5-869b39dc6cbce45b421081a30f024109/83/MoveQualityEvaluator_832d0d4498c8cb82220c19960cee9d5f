03dc986993d275479f5074fa03701616
/**
 * @file Move quality evaluation module
 * @module store/orchestrators/handlePlayerMove/MoveQualityEvaluator
 *
 * @description
 * Evaluates chess move quality using tablebase analysis.
 * Compares player moves against optimal tablebase recommendations to determine
 * if moves are suboptimal and warrant user feedback through error dialogs.
 *
 * @remarks
 * Key features:
 * - Parallel tablebase API calls for performance
 * - WDL (Win/Draw/Loss) perspective conversion for accurate evaluation
 * - Best move comparison against top 3 tablebase recommendations
 * - Outcome change detection (Win->Draw/Loss, Draw->Loss)
 * - Comprehensive logging for debugging move evaluation logic
 *
 * @example
 * ```typescript
 * const evaluator = new MoveQualityEvaluator();
 * const result = await evaluator.evaluateMoveQuality(
 *   "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",
 *   "rnbqkbnr/pppppppp/8/8/4P3/8/PPPP1PPP/RNBQKBNR b KQkq e3 0 1",
 *   { from: "e2", to: "e4", san: "e4", color: "w" }
 * );
 * if (result.shouldShowErrorDialog) {
 *   // Show error dialog to user
 * }
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "MoveQualityEvaluator", {
    enumerable: true,
    get: function() {
        return MoveQualityEvaluator;
    }
});
const _TablebaseService = require("../../../services/TablebaseService");
const _logging = require("../../../services/logging");
/** Number of top moves to fetch from tablebase for comparison */ const TOP_MOVES_LIMIT = 3;
class MoveQualityEvaluator {
    /**
   * Evaluates the quality of a played move against tablebase recommendations
   *
   * @param fenBefore - FEN position before the move
   * @param fenAfter - FEN position after the move
   * @param validatedMove - The move that was played
   * @param trainingBaseline - Optional evaluation baseline for training context
   * @returns Quality evaluation result
   */ async evaluateMoveQuality(fenBefore, fenAfter, validatedMove, trainingBaseline) {
        try {
            // Get evaluations before and after the move in parallel for better performance
            const [evalBefore, evalAfter] = await Promise.all([
                this.getEvaluation(fenBefore),
                this.getEvaluation(fenAfter)
            ]);
            // Check if both evaluations are available
            if (!this.areEvaluationsValid(evalBefore, evalAfter)) {
                (0, _logging.getLogger)().debug("[MoveQuality] Skipping evaluation - insufficient data:", {
                    evalBeforeAvailable: evalBefore === null || evalBefore === void 0 ? void 0 : evalBefore.isAvailable,
                    evalAfterAvailable: evalAfter === null || evalAfter === void 0 ? void 0 : evalAfter.isAvailable,
                    hasBeforeResult: evalBefore && "result" in evalBefore,
                    hasAfterResult: evalAfter && "result" in evalAfter
                });
                return {
                    shouldShowErrorDialog: false,
                    wasOptimal: false,
                    outcomeChanged: false
                };
            }
            const wdlBefore = evalBefore.result.wdl;
            const wdlAfter = evalAfter.result.wdl;
            (0, _logging.getLogger)().debug("[MoveQuality] Evaluating move quality:", {
                moveColor: validatedMove.color,
                moveSan: validatedMove.san,
                wdlBefore,
                wdlAfter,
                fenBefore: fenBefore.split(" ")[0],
                fenAfter: fenAfter.split(" ")[0]
            });
            // Convert WDL values to player perspective
            const { wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective } = this.convertToPlayerPerspective(wdlBefore, wdlAfter);
            // Determine effective baseline for comparison
            const effectiveWdlBefore = this.determineEffectiveBaseline(trainingBaseline, wdlBeforeFromPlayerPerspective);
            (0, _logging.getLogger)().debug("[MoveQuality] WDL evaluation context:", {
                wdlBeforeFromPlayerPerspective,
                wdlAfterFromPlayerPerspective,
                trainingBaselineWdl: trainingBaseline === null || trainingBaseline === void 0 ? void 0 : trainingBaseline.wdl,
                effectiveWdlBefore,
                usingBaseline: !!trainingBaseline
            });
            // Get best moves for comparison
            const topMoves = await _TablebaseService.tablebaseService.getTopMoves(fenBefore, TOP_MOVES_LIMIT).catch(()=>({
                    isAvailable: false,
                    moves: []
                }));
            // Check if the played move was one of the best moves
            const playedMoveWasBest = this.wasMoveBest(topMoves, validatedMove.san);
            this.logBestMovesComparison(topMoves, validatedMove.san, playedMoveWasBest);
            // Determine if outcome changed significantly - use baseline if available
            const outcomeChanged = this.didOutcomeChange(effectiveWdlBefore, wdlAfterFromPlayerPerspective);
            this.logDecisionValues(outcomeChanged, playedMoveWasBest, effectiveWdlBefore, wdlAfterFromPlayerPerspective);
            const shouldShowErrorDialog = this.shouldShowErrorDialog(playedMoveWasBest, outcomeChanged);
            const bestMove = this.getBestMove(topMoves);
            (0, _logging.getLogger)().info("[MoveQuality] Decision to show error dialog:", {
                shouldShowErrorDialog,
                playedMoveWasBest,
                outcomeChanged,
                effectiveWdlBefore,
                wdlAfterFromPlayerPerspective,
                usingBaseline: !!trainingBaseline,
                validatedMove: validatedMove.san,
                bestMove
            });
            if (shouldShowErrorDialog) {
                (0, _logging.getLogger)().info("[MoveQuality] Move quality issue detected - suggesting error dialog");
            }
            return {
                shouldShowErrorDialog,
                wdlBefore,
                wdlAfter,
                bestMove,
                wasOptimal: playedMoveWasBest,
                outcomeChanged
            };
        } catch (error) {
            (0, _logging.getLogger)().error("Move quality evaluation failed:", error);
            return {
                shouldShowErrorDialog: false,
                wasOptimal: false,
                outcomeChanged: false
            };
        }
    }
    /**
   * Gets tablebase evaluation for a position with error handling
   */ async getEvaluation(fen) {
        return await _TablebaseService.tablebaseService.getEvaluation(fen).catch(()=>({
                isAvailable: false
            }));
    }
    /**
   * Validates that both evaluations are available and have results
   */ areEvaluationsValid(evalBefore, evalAfter) {
        return this.hasValidResult(evalBefore) && this.hasValidResult(evalAfter);
    }
    /**
   * Checks if a single evaluation has a valid result
   */ hasValidResult(evaluation) {
        return evaluation.isAvailable && "result" in evaluation && !!evaluation.result;
    }
    /**
   * Converts WDL values from the Lichess Tablebase API to a consistent perspective
   * for the player who just moved.
   *
   * @remarks
   * The Lichess Tablebase API returns WDL from the perspective of the side whose turn it is
   * (the side-to-move perspective). This is standard behavior for chess tablebases and engines.
   *
   * - `wdlBefore`: The WDL score before the move was made. This is from the perspective
   *   of the player making the move (they were the side-to-move).
   * - `wdlAfter`: The WDL score after the move was made. The turn has now passed to the
   *   opponent, so this score is from the opponent's perspective.
   *
   * Therefore, to maintain the original player's perspective for comparison:
   * - `wdlBefore` needs no conversion (already from player's perspective)
   * - `wdlAfter` must be negated (convert from opponent's to player's perspective)
   *
   * @param wdlBefore The WDL score for the position before the move
   * @param wdlAfter The WDL score for the position after the move
   * @returns An object with both WDL values from the original player's perspective
   *
   * @example
   * // Black plays a losing move (Kd7 instead of drawing Ke7)
   * // wdlBefore = 0 (draw from Black's perspective as side-to-move)
   * // wdlAfter = 1000 (win from White's perspective as side-to-move)
   * // Returns: { wdlBeforeFromPlayerPerspective: 0, wdlAfterFromPlayerPerspective: -1000 }
   * // This correctly shows Black went from draw (0) to loss (-1000)
   */ convertToPlayerPerspective(wdlBefore, wdlAfter) {
        // wdlBefore is already from the moving player's perspective (side-to-move)
        const wdlBeforeFromPlayerPerspective = wdlBefore;
        // wdlAfter is from opponent's perspective (they are now side-to-move)
        // We need to negate it to get the moving player's perspective
        const wdlAfterFromPlayerPerspective = -wdlAfter;
        return {
            wdlBeforeFromPlayerPerspective,
            wdlAfterFromPlayerPerspective
        };
    }
    /**
   * Checks if the played move was among the best moves
   */ wasMoveBest(topMoves, playedMoveSan) {
        if (!this.hasAvailableMoves(topMoves)) {
            return false;
        }
        return topMoves.moves.some((m)=>m.san === playedMoveSan);
    }
    /**
   * Checks if tablebase moves are available
   */ hasAvailableMoves(topMoves) {
        return topMoves.isAvailable && !!topMoves.moves && topMoves.moves.length > 0;
    }
    /**
   * Determines if the move outcome changed significantly
   */ didOutcomeChange(wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective) {
        const winTurnedIntoDrawOrLoss = this.isWinToDrawOrLoss(wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective);
        const drawTurnedIntoLoss = this.isDrawToLoss(wdlBeforeFromPlayerPerspective, wdlAfterFromPlayerPerspective);
        return winTurnedIntoDrawOrLoss || drawTurnedIntoLoss;
    }
    /**
   * Checks if a winning position turned into a draw or loss
   */ isWinToDrawOrLoss(wdlBefore, wdlAfter) {
        return wdlBefore > 0 && wdlAfter <= 0;
    }
    /**
   * Checks if a drawn position turned into a loss
   */ isDrawToLoss(wdlBefore, wdlAfter) {
        return wdlBefore === 0 && wdlAfter < 0;
    }
    /**
   * Gets the best move from top moves result
   */ getBestMove(topMoves) {
        return topMoves.isAvailable && topMoves.moves && topMoves.moves.length > 0 ? topMoves.moves[0].san : undefined;
    }
    /**
   * Logs best moves comparison for debugging
   */ logBestMovesComparison(topMoves, playedMoveSan, playedMoveWasBest) {
        var _topMoves_moves;
        (0, _logging.getLogger)().info("[MoveQuality] Best moves check:");
        (0, _logging.getLogger)().info("  topMovesAvailable:", topMoves.isAvailable);
        (0, _logging.getLogger)().info("  bestMoves:", JSON.stringify((_topMoves_moves = topMoves.moves) === null || _topMoves_moves === void 0 ? void 0 : _topMoves_moves.map((m)=>m.san)));
        (0, _logging.getLogger)().info("  playedMove:", playedMoveSan);
        (0, _logging.getLogger)().info("  playedMoveWasBest:", playedMoveWasBest);
        // Debug each move comparison
        if (topMoves.moves) {
            (0, _logging.getLogger)().debug("  Comparing each move:");
            topMoves.moves.forEach((m, i)=>{
                (0, _logging.getLogger)().debug(`    Move ${i}: "${m.san}" === "${playedMoveSan}" ? ${m.san === playedMoveSan}`);
            });
        }
    }
    /**
   * Determines the effective baseline for comparison
   */ determineEffectiveBaseline(trainingBaseline, wdlBeforeFromPlayerPerspective) {
        var _trainingBaseline_wdl;
        return (_trainingBaseline_wdl = trainingBaseline === null || trainingBaseline === void 0 ? void 0 : trainingBaseline.wdl) !== null && _trainingBaseline_wdl !== void 0 ? _trainingBaseline_wdl : wdlBeforeFromPlayerPerspective;
    }
    /**
   * Determines if error dialog should be shown based on move quality
   */ shouldShowErrorDialog(playedMoveWasBest, outcomeChanged) {
        return !playedMoveWasBest && outcomeChanged;
    }
    /**
   * Logs decision values for debugging
   */ logDecisionValues(outcomeChanged, playedMoveWasBest, effectiveWdlBefore, wdlAfterFromPlayerPerspective) {
        (0, _logging.getLogger)().debug("[MoveQuality] DECISION VALUES:");
        (0, _logging.getLogger)().debug("  outcomeChanged:", outcomeChanged);
        (0, _logging.getLogger)().debug("  playedMoveWasBest:", playedMoveWasBest);
        (0, _logging.getLogger)().debug("  effectiveWdlBefore:", effectiveWdlBefore);
        (0, _logging.getLogger)().debug("  wdlAfterFromPlayerPerspective:", wdlAfterFromPlayerPerspective);
        (0, _logging.getLogger)().debug("  showDialog:", !playedMoveWasBest && outcomeChanged);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZS9Nb3ZlUXVhbGl0eUV2YWx1YXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIE1vdmUgcXVhbGl0eSBldmFsdWF0aW9uIG1vZHVsZVxuICogQG1vZHVsZSBzdG9yZS9vcmNoZXN0cmF0b3JzL2hhbmRsZVBsYXllck1vdmUvTW92ZVF1YWxpdHlFdmFsdWF0b3JcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEV2YWx1YXRlcyBjaGVzcyBtb3ZlIHF1YWxpdHkgdXNpbmcgdGFibGViYXNlIGFuYWx5c2lzLlxuICogQ29tcGFyZXMgcGxheWVyIG1vdmVzIGFnYWluc3Qgb3B0aW1hbCB0YWJsZWJhc2UgcmVjb21tZW5kYXRpb25zIHRvIGRldGVybWluZVxuICogaWYgbW92ZXMgYXJlIHN1Ym9wdGltYWwgYW5kIHdhcnJhbnQgdXNlciBmZWVkYmFjayB0aHJvdWdoIGVycm9yIGRpYWxvZ3MuXG4gKlxuICogQHJlbWFya3NcbiAqIEtleSBmZWF0dXJlczpcbiAqIC0gUGFyYWxsZWwgdGFibGViYXNlIEFQSSBjYWxscyBmb3IgcGVyZm9ybWFuY2VcbiAqIC0gV0RMIChXaW4vRHJhdy9Mb3NzKSBwZXJzcGVjdGl2ZSBjb252ZXJzaW9uIGZvciBhY2N1cmF0ZSBldmFsdWF0aW9uXG4gKiAtIEJlc3QgbW92ZSBjb21wYXJpc29uIGFnYWluc3QgdG9wIDMgdGFibGViYXNlIHJlY29tbWVuZGF0aW9uc1xuICogLSBPdXRjb21lIGNoYW5nZSBkZXRlY3Rpb24gKFdpbi0+RHJhdy9Mb3NzLCBEcmF3LT5Mb3NzKVxuICogLSBDb21wcmVoZW5zaXZlIGxvZ2dpbmcgZm9yIGRlYnVnZ2luZyBtb3ZlIGV2YWx1YXRpb24gbG9naWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZXZhbHVhdG9yID0gbmV3IE1vdmVRdWFsaXR5RXZhbHVhdG9yKCk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVNb3ZlUXVhbGl0eShcbiAqICAgXCJybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMVwiLFxuICogICBcInJuYnFrYm5yL3BwcHBwcHBwLzgvOC80UDMvOC9QUFBQMVBQUC9STkJRS0JOUiBiIEtRa3EgZTMgMCAxXCIsXG4gKiAgIHsgZnJvbTogXCJlMlwiLCB0bzogXCJlNFwiLCBzYW46IFwiZTRcIiwgY29sb3I6IFwid1wiIH1cbiAqICk7XG4gKiBpZiAocmVzdWx0LnNob3VsZFNob3dFcnJvckRpYWxvZykge1xuICogICAvLyBTaG93IGVycm9yIGRpYWxvZyB0byB1c2VyXG4gKiB9XG4gKiBgYGBcbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFZhbGlkYXRlZE1vdmUgfSBmcm9tIFwiQHNoYXJlZC90eXBlcy9jaGVzc1wiO1xuaW1wb3J0IHtcbiAgdGFibGViYXNlU2VydmljZSxcbiAgdHlwZSBUYWJsZWJhc2VFdmFsdWF0aW9uLFxuICB0eXBlIFRhYmxlYmFzZU1vdmVzUmVzdWx0LFxufSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9UYWJsZWJhc2VTZXJ2aWNlXCI7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nXCI7XG5cbi8qKlxuICogUmVzdWx0IG9mIG1vdmUgcXVhbGl0eSBldmFsdWF0aW9uIGNvbnRhaW5pbmcgcmVjb21tZW5kYXRpb24gZGF0YVxuICogQGludGVyZmFjZSBNb3ZlUXVhbGl0eVJlc3VsdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vdmVRdWFsaXR5UmVzdWx0IHtcbiAgLyoqIFdoZXRoZXIgdG8gZGlzcGxheSBhbiBlcnJvciBkaWFsb2cgdG8gdGhlIHVzZXIgKi9cbiAgc2hvdWxkU2hvd0Vycm9yRGlhbG9nOiBib29sZWFuO1xuICAvKiogV0RMIHZhbHVlIGJlZm9yZSB0aGUgbW92ZSAoZnJvbSB3aGl0ZSdzIHBlcnNwZWN0aXZlKSAqL1xuICB3ZGxCZWZvcmU/OiBudW1iZXI7XG4gIC8qKiBXREwgdmFsdWUgYWZ0ZXIgdGhlIG1vdmUgKGZyb20gd2hpdGUncyBwZXJzcGVjdGl2ZSkgKi9cbiAgd2RsQWZ0ZXI/OiBudW1iZXI7XG4gIC8qKiBCZXN0IHJlY29tbWVuZGVkIG1vdmUgaW4gYWxnZWJyYWljIG5vdGF0aW9uICovXG4gIGJlc3RNb3ZlPzogc3RyaW5nO1xuICAvKiogV2hldGhlciB0aGUgcGxheWVkIG1vdmUgd2FzIGFtb25nIHRoZSBvcHRpbWFsIG1vdmVzICovXG4gIHdhc09wdGltYWw6IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRoZSBtb3ZlIHNpZ25pZmljYW50bHkgY2hhbmdlZCB0aGUgZ2FtZSBvdXRjb21lICovXG4gIG91dGNvbWVDaGFuZ2VkOiBib29sZWFuO1xufVxuXG4vKiogTnVtYmVyIG9mIHRvcCBtb3ZlcyB0byBmZXRjaCBmcm9tIHRhYmxlYmFzZSBmb3IgY29tcGFyaXNvbiAqL1xuY29uc3QgVE9QX01PVkVTX0xJTUlUID0gMztcblxuLyoqXG4gKiBFdmFsdWF0ZXMgY2hlc3MgbW92ZSBxdWFsaXR5IHVzaW5nIGFkdmFuY2VkIHRhYmxlYmFzZSBhbmFseXNpc1xuICogQGNsYXNzIE1vdmVRdWFsaXR5RXZhbHVhdG9yXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlcyBjb21wcmVoZW5zaXZlIG1vdmUgcXVhbGl0eSBhc3Nlc3NtZW50IGluY2x1ZGluZzpcbiAqIC0gVGFibGViYXNlIGV2YWx1YXRpb24gY29tcGFyaXNvbiAoYmVmb3JlL2FmdGVyIHBvc2l0aW9ucylcbiAqIC0gV0RMIHBlcnNwZWN0aXZlIGNvbnZlcnNpb24gZm9yIGFjY3VyYXRlIHBsYXllci1jZW50cmljIGV2YWx1YXRpb25cbiAqIC0gQmVzdCBtb3ZlIGRldGVjdGlvbiB1c2luZyB0b3AgdGFibGViYXNlIHJlY29tbWVuZGF0aW9uc1xuICogLSBPdXRjb21lIGNoYW5nZSBhbmFseXNpcyAoV2luL0RyYXcvTG9zcyB0cmFuc2l0aW9ucylcbiAqIC0gUGVyZm9ybWFuY2Utb3B0aW1pemVkIHBhcmFsbGVsIEFQSSBjYWxsc1xuICogLSBEZXRhaWxlZCBsb2dnaW5nIGZvciBkZWJ1Z2dpbmcgZXZhbHVhdGlvbiBkZWNpc2lvbnNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGV2YWx1YXRvciB1c2VzIHNvcGhpc3RpY2F0ZWQgbG9naWMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gc2hvdyBlcnJvciBkaWFsb2dzOlxuICogMS4gTW92ZSBtdXN0IE5PVCBiZSBhbW9uZyB0aGUgdG9wIDMgdGFibGViYXNlIHJlY29tbWVuZGF0aW9uc1xuICogMi4gTW92ZSBtdXN0IGNhdXNlIGEgc2lnbmlmaWNhbnQgb3V0Y29tZSBjaGFuZ2UgKFdpbi0+RHJhdy9Mb3NzIG9yIERyYXctPkxvc3MpXG4gKlxuICogV0RMIChXaW4vRHJhdy9Mb3NzKSB2YWx1ZXMgYXJlIGhhbmRsZWQgY2FyZWZ1bGx5OlxuICogLSBUYWJsZWJhc2UgcmV0dXJucyB2YWx1ZXMgZnJvbSB3aGl0ZSdzIHBlcnNwZWN0aXZlXG4gKiAtIFZhbHVlcyBhcmUgY29udmVydGVkIHRvIG1vdmluZyBwbGF5ZXIncyBwZXJzcGVjdGl2ZVxuICogLSBBZnRlciBhIG1vdmUsIGV2YWx1YXRpb24gaXMgZnJvbSBvcHBvbmVudCdzIHBlcnNwZWN0aXZlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGV2YWx1YXRvciA9IG5ldyBNb3ZlUXVhbGl0eUV2YWx1YXRvcigpO1xuICpcbiAqIC8vIEV2YWx1YXRlIGEgcG90ZW50aWFsbHkgc3Vib3B0aW1hbCBtb3ZlXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBldmFsdWF0b3IuZXZhbHVhdGVNb3ZlUXVhbGl0eShcbiAqICAgZmVuQmVmb3JlLFxuICogICBmZW5BZnRlcixcbiAqICAgcGxheWVkTW92ZVxuICogKTtcbiAqXG4gKiBpZiAocmVzdWx0LnNob3VsZFNob3dFcnJvckRpYWxvZykge1xuICogICBjb25zb2xlLmxvZyhgU3Vib3B0aW1hbCBtb3ZlISBCZXN0IHdhczogJHtyZXN1bHQuYmVzdE1vdmV9YCk7XG4gKiAgIGNvbnNvbGUubG9nKGBXREwgY2hhbmdlOiAke3Jlc3VsdC53ZGxCZWZvcmV9IC0+ICR7cmVzdWx0LndkbEFmdGVyfWApO1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBNb3ZlUXVhbGl0eUV2YWx1YXRvciB7XG4gIC8qKlxuICAgKiBFdmFsdWF0ZXMgdGhlIHF1YWxpdHkgb2YgYSBwbGF5ZWQgbW92ZSBhZ2FpbnN0IHRhYmxlYmFzZSByZWNvbW1lbmRhdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIGZlbkJlZm9yZSAtIEZFTiBwb3NpdGlvbiBiZWZvcmUgdGhlIG1vdmVcbiAgICogQHBhcmFtIGZlbkFmdGVyIC0gRkVOIHBvc2l0aW9uIGFmdGVyIHRoZSBtb3ZlXG4gICAqIEBwYXJhbSB2YWxpZGF0ZWRNb3ZlIC0gVGhlIG1vdmUgdGhhdCB3YXMgcGxheWVkXG4gICAqIEBwYXJhbSB0cmFpbmluZ0Jhc2VsaW5lIC0gT3B0aW9uYWwgZXZhbHVhdGlvbiBiYXNlbGluZSBmb3IgdHJhaW5pbmcgY29udGV4dFxuICAgKiBAcmV0dXJucyBRdWFsaXR5IGV2YWx1YXRpb24gcmVzdWx0XG4gICAqL1xuICBhc3luYyBldmFsdWF0ZU1vdmVRdWFsaXR5KFxuICAgIGZlbkJlZm9yZTogc3RyaW5nLFxuICAgIGZlbkFmdGVyOiBzdHJpbmcsXG4gICAgdmFsaWRhdGVkTW92ZTogVmFsaWRhdGVkTW92ZSxcbiAgICB0cmFpbmluZ0Jhc2VsaW5lPzogeyB3ZGw6IG51bWJlcjsgZmVuOiBzdHJpbmcgfSB8IG51bGwsXG4gICk6IFByb21pc2U8TW92ZVF1YWxpdHlSZXN1bHQ+IHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGV2YWx1YXRpb25zIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIG1vdmUgaW4gcGFyYWxsZWwgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgY29uc3QgW2V2YWxCZWZvcmUsIGV2YWxBZnRlcl0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMuZ2V0RXZhbHVhdGlvbihmZW5CZWZvcmUpLFxuICAgICAgICB0aGlzLmdldEV2YWx1YXRpb24oZmVuQWZ0ZXIpLFxuICAgICAgXSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGJvdGggZXZhbHVhdGlvbnMgYXJlIGF2YWlsYWJsZVxuICAgICAgaWYgKCF0aGlzLmFyZUV2YWx1YXRpb25zVmFsaWQoZXZhbEJlZm9yZSwgZXZhbEFmdGVyKSkge1xuICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcbiAgICAgICAgICBcIltNb3ZlUXVhbGl0eV0gU2tpcHBpbmcgZXZhbHVhdGlvbiAtIGluc3VmZmljaWVudCBkYXRhOlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV2YWxCZWZvcmVBdmFpbGFibGU6IGV2YWxCZWZvcmU/LmlzQXZhaWxhYmxlLFxuICAgICAgICAgICAgZXZhbEFmdGVyQXZhaWxhYmxlOiBldmFsQWZ0ZXI/LmlzQXZhaWxhYmxlLFxuICAgICAgICAgICAgaGFzQmVmb3JlUmVzdWx0OiBldmFsQmVmb3JlICYmIFwicmVzdWx0XCIgaW4gZXZhbEJlZm9yZSxcbiAgICAgICAgICAgIGhhc0FmdGVyUmVzdWx0OiBldmFsQWZ0ZXIgJiYgXCJyZXN1bHRcIiBpbiBldmFsQWZ0ZXIsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNob3VsZFNob3dFcnJvckRpYWxvZzogZmFsc2UsXG4gICAgICAgICAgd2FzT3B0aW1hbDogZmFsc2UsIC8vIENvbnNlcnZhdGl2ZSAtIGlmIHdlIGNhbid0IGV2YWx1YXRlLCBkb24ndCBhc3N1bWUgb3B0aW1hbFxuICAgICAgICAgIG91dGNvbWVDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgd2RsQmVmb3JlID0gZXZhbEJlZm9yZS5yZXN1bHQhLndkbDtcbiAgICAgIGNvbnN0IHdkbEFmdGVyID0gZXZhbEFmdGVyLnJlc3VsdCEud2RsO1xuXG4gICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltNb3ZlUXVhbGl0eV0gRXZhbHVhdGluZyBtb3ZlIHF1YWxpdHk6XCIsIHtcbiAgICAgICAgbW92ZUNvbG9yOiB2YWxpZGF0ZWRNb3ZlLmNvbG9yLFxuICAgICAgICBtb3ZlU2FuOiB2YWxpZGF0ZWRNb3ZlLnNhbixcbiAgICAgICAgd2RsQmVmb3JlLFxuICAgICAgICB3ZGxBZnRlcixcbiAgICAgICAgZmVuQmVmb3JlOiBmZW5CZWZvcmUuc3BsaXQoXCIgXCIpWzBdLCAvLyBKdXN0IGJvYXJkIHBvc2l0aW9uXG4gICAgICAgIGZlbkFmdGVyOiBmZW5BZnRlci5zcGxpdChcIiBcIilbMF0sXG4gICAgICB9KTtcblxuICAgICAgLy8gQ29udmVydCBXREwgdmFsdWVzIHRvIHBsYXllciBwZXJzcGVjdGl2ZVxuICAgICAgY29uc3QgeyB3ZGxCZWZvcmVGcm9tUGxheWVyUGVyc3BlY3RpdmUsIHdkbEFmdGVyRnJvbVBsYXllclBlcnNwZWN0aXZlIH0gPVxuICAgICAgICB0aGlzLmNvbnZlcnRUb1BsYXllclBlcnNwZWN0aXZlKHdkbEJlZm9yZSwgd2RsQWZ0ZXIpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZWZmZWN0aXZlIGJhc2VsaW5lIGZvciBjb21wYXJpc29uXG4gICAgICBjb25zdCBlZmZlY3RpdmVXZGxCZWZvcmUgPSB0aGlzLmRldGVybWluZUVmZmVjdGl2ZUJhc2VsaW5lKFxuICAgICAgICB0cmFpbmluZ0Jhc2VsaW5lLFxuICAgICAgICB3ZGxCZWZvcmVGcm9tUGxheWVyUGVyc3BlY3RpdmVcbiAgICAgICk7XG5cbiAgICAgIGdldExvZ2dlcigpLmRlYnVnKFwiW01vdmVRdWFsaXR5XSBXREwgZXZhbHVhdGlvbiBjb250ZXh0OlwiLCB7XG4gICAgICAgIHdkbEJlZm9yZUZyb21QbGF5ZXJQZXJzcGVjdGl2ZSxcbiAgICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmUsXG4gICAgICAgIHRyYWluaW5nQmFzZWxpbmVXZGw6IHRyYWluaW5nQmFzZWxpbmU/LndkbCxcbiAgICAgICAgZWZmZWN0aXZlV2RsQmVmb3JlLFxuICAgICAgICB1c2luZ0Jhc2VsaW5lOiAhIXRyYWluaW5nQmFzZWxpbmUsXG4gICAgICB9KTtcblxuICAgICAgLy8gR2V0IGJlc3QgbW92ZXMgZm9yIGNvbXBhcmlzb25cbiAgICAgIGNvbnN0IHRvcE1vdmVzID0gYXdhaXQgdGFibGViYXNlU2VydmljZVxuICAgICAgICAuZ2V0VG9wTW92ZXMoZmVuQmVmb3JlLCBUT1BfTU9WRVNfTElNSVQpXG4gICAgICAgIC5jYXRjaCgoKSA9PiAoeyBpc0F2YWlsYWJsZTogZmFsc2UsIG1vdmVzOiBbXSB9KSk7XG5cbiAgICAgIC8vIENoZWNrIGlmIHRoZSBwbGF5ZWQgbW92ZSB3YXMgb25lIG9mIHRoZSBiZXN0IG1vdmVzXG4gICAgICBjb25zdCBwbGF5ZWRNb3ZlV2FzQmVzdCA9IHRoaXMud2FzTW92ZUJlc3QodG9wTW92ZXMsIHZhbGlkYXRlZE1vdmUuc2FuKTtcblxuICAgICAgdGhpcy5sb2dCZXN0TW92ZXNDb21wYXJpc29uKFxuICAgICAgICB0b3BNb3ZlcyxcbiAgICAgICAgdmFsaWRhdGVkTW92ZS5zYW4sXG4gICAgICAgIHBsYXllZE1vdmVXYXNCZXN0LFxuICAgICAgKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIG91dGNvbWUgY2hhbmdlZCBzaWduaWZpY2FudGx5IC0gdXNlIGJhc2VsaW5lIGlmIGF2YWlsYWJsZVxuICAgICAgY29uc3Qgb3V0Y29tZUNoYW5nZWQgPSB0aGlzLmRpZE91dGNvbWVDaGFuZ2UoXG4gICAgICAgIGVmZmVjdGl2ZVdkbEJlZm9yZSxcbiAgICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmUsXG4gICAgICApO1xuXG4gICAgICB0aGlzLmxvZ0RlY2lzaW9uVmFsdWVzKFxuICAgICAgICBvdXRjb21lQ2hhbmdlZCxcbiAgICAgICAgcGxheWVkTW92ZVdhc0Jlc3QsXG4gICAgICAgIGVmZmVjdGl2ZVdkbEJlZm9yZSxcbiAgICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmUsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzaG91bGRTaG93RXJyb3JEaWFsb2cgPSB0aGlzLnNob3VsZFNob3dFcnJvckRpYWxvZyhcbiAgICAgICAgcGxheWVkTW92ZVdhc0Jlc3QsXG4gICAgICAgIG91dGNvbWVDaGFuZ2VkXG4gICAgICApO1xuICAgICAgY29uc3QgYmVzdE1vdmUgPSB0aGlzLmdldEJlc3RNb3ZlKHRvcE1vdmVzKTtcblxuICAgICAgZ2V0TG9nZ2VyKCkuaW5mbyhcIltNb3ZlUXVhbGl0eV0gRGVjaXNpb24gdG8gc2hvdyBlcnJvciBkaWFsb2c6XCIsIHtcbiAgICAgICAgc2hvdWxkU2hvd0Vycm9yRGlhbG9nLFxuICAgICAgICBwbGF5ZWRNb3ZlV2FzQmVzdCxcbiAgICAgICAgb3V0Y29tZUNoYW5nZWQsXG4gICAgICAgIGVmZmVjdGl2ZVdkbEJlZm9yZSxcbiAgICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmUsXG4gICAgICAgIHVzaW5nQmFzZWxpbmU6ICEhdHJhaW5pbmdCYXNlbGluZSxcbiAgICAgICAgdmFsaWRhdGVkTW92ZTogdmFsaWRhdGVkTW92ZS5zYW4sXG4gICAgICAgIGJlc3RNb3ZlLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChzaG91bGRTaG93RXJyb3JEaWFsb2cpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKCkuaW5mbyhcbiAgICAgICAgICBcIltNb3ZlUXVhbGl0eV0gTW92ZSBxdWFsaXR5IGlzc3VlIGRldGVjdGVkIC0gc3VnZ2VzdGluZyBlcnJvciBkaWFsb2dcIixcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvdWxkU2hvd0Vycm9yRGlhbG9nLFxuICAgICAgICB3ZGxCZWZvcmUsXG4gICAgICAgIHdkbEFmdGVyLFxuICAgICAgICBiZXN0TW92ZSxcbiAgICAgICAgd2FzT3B0aW1hbDogcGxheWVkTW92ZVdhc0Jlc3QsXG4gICAgICAgIG91dGNvbWVDaGFuZ2VkLFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZ2V0TG9nZ2VyKCkuZXJyb3IoXCJNb3ZlIHF1YWxpdHkgZXZhbHVhdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3VsZFNob3dFcnJvckRpYWxvZzogZmFsc2UsXG4gICAgICAgIHdhc09wdGltYWw6IGZhbHNlLCAvLyBDb25zZXJ2YXRpdmUgLSBkb24ndCBhc3N1bWUgb3B0aW1hbCBvbiBldmFsdWF0aW9uIGZhaWx1cmVcbiAgICAgICAgb3V0Y29tZUNoYW5nZWQ6IGZhbHNlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0YWJsZWJhc2UgZXZhbHVhdGlvbiBmb3IgYSBwb3NpdGlvbiB3aXRoIGVycm9yIGhhbmRsaW5nXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldEV2YWx1YXRpb24oZmVuOiBzdHJpbmcpOiBQcm9taXNlPFRhYmxlYmFzZUV2YWx1YXRpb24+IHtcbiAgICByZXR1cm4gYXdhaXQgdGFibGViYXNlU2VydmljZVxuICAgICAgLmdldEV2YWx1YXRpb24oZmVuKVxuICAgICAgLmNhdGNoKCgpID0+ICh7IGlzQXZhaWxhYmxlOiBmYWxzZSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoYXQgYm90aCBldmFsdWF0aW9ucyBhcmUgYXZhaWxhYmxlIGFuZCBoYXZlIHJlc3VsdHNcbiAgICovXG4gIHByaXZhdGUgYXJlRXZhbHVhdGlvbnNWYWxpZChcbiAgICBldmFsQmVmb3JlOiBUYWJsZWJhc2VFdmFsdWF0aW9uLFxuICAgIGV2YWxBZnRlcjogVGFibGViYXNlRXZhbHVhdGlvbixcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuaGFzVmFsaWRSZXN1bHQoZXZhbEJlZm9yZSkgJiYgdGhpcy5oYXNWYWxpZFJlc3VsdChldmFsQWZ0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIHNpbmdsZSBldmFsdWF0aW9uIGhhcyBhIHZhbGlkIHJlc3VsdFxuICAgKi9cbiAgcHJpdmF0ZSBoYXNWYWxpZFJlc3VsdChldmFsdWF0aW9uOiBUYWJsZWJhc2VFdmFsdWF0aW9uKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIChcbiAgICAgIGV2YWx1YXRpb24uaXNBdmFpbGFibGUgJiZcbiAgICAgIFwicmVzdWx0XCIgaW4gZXZhbHVhdGlvbiAmJlxuICAgICAgISFldmFsdWF0aW9uLnJlc3VsdFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgV0RMIHZhbHVlcyBmcm9tIHRoZSBMaWNoZXNzIFRhYmxlYmFzZSBBUEkgdG8gYSBjb25zaXN0ZW50IHBlcnNwZWN0aXZlXG4gICAqIGZvciB0aGUgcGxheWVyIHdobyBqdXN0IG1vdmVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGUgTGljaGVzcyBUYWJsZWJhc2UgQVBJIHJldHVybnMgV0RMIGZyb20gdGhlIHBlcnNwZWN0aXZlIG9mIHRoZSBzaWRlIHdob3NlIHR1cm4gaXQgaXNcbiAgICogKHRoZSBzaWRlLXRvLW1vdmUgcGVyc3BlY3RpdmUpLiBUaGlzIGlzIHN0YW5kYXJkIGJlaGF2aW9yIGZvciBjaGVzcyB0YWJsZWJhc2VzIGFuZCBlbmdpbmVzLlxuICAgKlxuICAgKiAtIGB3ZGxCZWZvcmVgOiBUaGUgV0RMIHNjb3JlIGJlZm9yZSB0aGUgbW92ZSB3YXMgbWFkZS4gVGhpcyBpcyBmcm9tIHRoZSBwZXJzcGVjdGl2ZVxuICAgKiAgIG9mIHRoZSBwbGF5ZXIgbWFraW5nIHRoZSBtb3ZlICh0aGV5IHdlcmUgdGhlIHNpZGUtdG8tbW92ZSkuXG4gICAqIC0gYHdkbEFmdGVyYDogVGhlIFdETCBzY29yZSBhZnRlciB0aGUgbW92ZSB3YXMgbWFkZS4gVGhlIHR1cm4gaGFzIG5vdyBwYXNzZWQgdG8gdGhlXG4gICAqICAgb3Bwb25lbnQsIHNvIHRoaXMgc2NvcmUgaXMgZnJvbSB0aGUgb3Bwb25lbnQncyBwZXJzcGVjdGl2ZS5cbiAgICpcbiAgICogVGhlcmVmb3JlLCB0byBtYWludGFpbiB0aGUgb3JpZ2luYWwgcGxheWVyJ3MgcGVyc3BlY3RpdmUgZm9yIGNvbXBhcmlzb246XG4gICAqIC0gYHdkbEJlZm9yZWAgbmVlZHMgbm8gY29udmVyc2lvbiAoYWxyZWFkeSBmcm9tIHBsYXllcidzIHBlcnNwZWN0aXZlKVxuICAgKiAtIGB3ZGxBZnRlcmAgbXVzdCBiZSBuZWdhdGVkIChjb252ZXJ0IGZyb20gb3Bwb25lbnQncyB0byBwbGF5ZXIncyBwZXJzcGVjdGl2ZSlcbiAgICpcbiAgICogQHBhcmFtIHdkbEJlZm9yZSBUaGUgV0RMIHNjb3JlIGZvciB0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBtb3ZlXG4gICAqIEBwYXJhbSB3ZGxBZnRlciBUaGUgV0RMIHNjb3JlIGZvciB0aGUgcG9zaXRpb24gYWZ0ZXIgdGhlIG1vdmVcbiAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYm90aCBXREwgdmFsdWVzIGZyb20gdGhlIG9yaWdpbmFsIHBsYXllcidzIHBlcnNwZWN0aXZlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIEJsYWNrIHBsYXlzIGEgbG9zaW5nIG1vdmUgKEtkNyBpbnN0ZWFkIG9mIGRyYXdpbmcgS2U3KVxuICAgKiAvLyB3ZGxCZWZvcmUgPSAwIChkcmF3IGZyb20gQmxhY2sncyBwZXJzcGVjdGl2ZSBhcyBzaWRlLXRvLW1vdmUpXG4gICAqIC8vIHdkbEFmdGVyID0gMTAwMCAod2luIGZyb20gV2hpdGUncyBwZXJzcGVjdGl2ZSBhcyBzaWRlLXRvLW1vdmUpXG4gICAqIC8vIFJldHVybnM6IHsgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlOiAwLCB3ZGxBZnRlckZyb21QbGF5ZXJQZXJzcGVjdGl2ZTogLTEwMDAgfVxuICAgKiAvLyBUaGlzIGNvcnJlY3RseSBzaG93cyBCbGFjayB3ZW50IGZyb20gZHJhdyAoMCkgdG8gbG9zcyAoLTEwMDApXG4gICAqL1xuICBwcml2YXRlIGNvbnZlcnRUb1BsYXllclBlcnNwZWN0aXZlKHdkbEJlZm9yZTogbnVtYmVyLCB3ZGxBZnRlcjogbnVtYmVyKSB7XG4gICAgLy8gd2RsQmVmb3JlIGlzIGFscmVhZHkgZnJvbSB0aGUgbW92aW5nIHBsYXllcidzIHBlcnNwZWN0aXZlIChzaWRlLXRvLW1vdmUpXG4gICAgY29uc3Qgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlID0gd2RsQmVmb3JlO1xuXG4gICAgLy8gd2RsQWZ0ZXIgaXMgZnJvbSBvcHBvbmVudCdzIHBlcnNwZWN0aXZlICh0aGV5IGFyZSBub3cgc2lkZS10by1tb3ZlKVxuICAgIC8vIFdlIG5lZWQgdG8gbmVnYXRlIGl0IHRvIGdldCB0aGUgbW92aW5nIHBsYXllcidzIHBlcnNwZWN0aXZlXG4gICAgY29uc3Qgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmUgPSAtd2RsQWZ0ZXI7XG5cbiAgICByZXR1cm4geyB3ZGxCZWZvcmVGcm9tUGxheWVyUGVyc3BlY3RpdmUsIHdkbEFmdGVyRnJvbVBsYXllclBlcnNwZWN0aXZlIH07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBwbGF5ZWQgbW92ZSB3YXMgYW1vbmcgdGhlIGJlc3QgbW92ZXNcbiAgICovXG4gIHByaXZhdGUgd2FzTW92ZUJlc3QoXG4gICAgdG9wTW92ZXM6IFRhYmxlYmFzZU1vdmVzUmVzdWx0LFxuICAgIHBsYXllZE1vdmVTYW46IHN0cmluZyxcbiAgKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmhhc0F2YWlsYWJsZU1vdmVzKHRvcE1vdmVzKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdG9wTW92ZXMubW92ZXMhLnNvbWUoKG0pID0+IG0uc2FuID09PSBwbGF5ZWRNb3ZlU2FuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGFibGViYXNlIG1vdmVzIGFyZSBhdmFpbGFibGVcbiAgICovXG4gIHByaXZhdGUgaGFzQXZhaWxhYmxlTW92ZXModG9wTW92ZXM6IFRhYmxlYmFzZU1vdmVzUmVzdWx0KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRvcE1vdmVzLmlzQXZhaWxhYmxlICYmICEhdG9wTW92ZXMubW92ZXMgJiYgdG9wTW92ZXMubW92ZXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBtb3ZlIG91dGNvbWUgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gICAqL1xuICBwcml2YXRlIGRpZE91dGNvbWVDaGFuZ2UoXG4gICAgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlOiBudW1iZXIsXG4gICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmU6IG51bWJlcixcbiAgKTogYm9vbGVhbiB7XG4gICAgY29uc3Qgd2luVHVybmVkSW50b0RyYXdPckxvc3MgPSB0aGlzLmlzV2luVG9EcmF3T3JMb3NzKFxuICAgICAgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlLFxuICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmVcbiAgICApO1xuICAgIGNvbnN0IGRyYXdUdXJuZWRJbnRvTG9zcyA9IHRoaXMuaXNEcmF3VG9Mb3NzKFxuICAgICAgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlLFxuICAgICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmVcbiAgICApO1xuICAgIFxuICAgIHJldHVybiB3aW5UdXJuZWRJbnRvRHJhd09yTG9zcyB8fCBkcmF3VHVybmVkSW50b0xvc3M7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgd2lubmluZyBwb3NpdGlvbiB0dXJuZWQgaW50byBhIGRyYXcgb3IgbG9zc1xuICAgKi9cbiAgcHJpdmF0ZSBpc1dpblRvRHJhd09yTG9zcyh3ZGxCZWZvcmU6IG51bWJlciwgd2RsQWZ0ZXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB3ZGxCZWZvcmUgPiAwICYmIHdkbEFmdGVyIDw9IDA7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZHJhd24gcG9zaXRpb24gdHVybmVkIGludG8gYSBsb3NzXG4gICAqL1xuICBwcml2YXRlIGlzRHJhd1RvTG9zcyh3ZGxCZWZvcmU6IG51bWJlciwgd2RsQWZ0ZXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiB3ZGxCZWZvcmUgPT09IDAgJiYgd2RsQWZ0ZXIgPCAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGJlc3QgbW92ZSBmcm9tIHRvcCBtb3ZlcyByZXN1bHRcbiAgICovXG4gIHByaXZhdGUgZ2V0QmVzdE1vdmUodG9wTW92ZXM6IFRhYmxlYmFzZU1vdmVzUmVzdWx0KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdG9wTW92ZXMuaXNBdmFpbGFibGUgJiYgdG9wTW92ZXMubW92ZXMgJiYgdG9wTW92ZXMubW92ZXMubGVuZ3RoID4gMFxuICAgICAgPyB0b3BNb3Zlcy5tb3Zlc1swXS5zYW5cbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgYmVzdCBtb3ZlcyBjb21wYXJpc29uIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIHByaXZhdGUgbG9nQmVzdE1vdmVzQ29tcGFyaXNvbihcbiAgICB0b3BNb3ZlczogVGFibGViYXNlTW92ZXNSZXN1bHQsXG4gICAgcGxheWVkTW92ZVNhbjogc3RyaW5nLFxuICAgIHBsYXllZE1vdmVXYXNCZXN0OiBib29sZWFuLFxuICApOiB2b2lkIHtcbiAgICBnZXRMb2dnZXIoKS5pbmZvKFwiW01vdmVRdWFsaXR5XSBCZXN0IG1vdmVzIGNoZWNrOlwiKTtcbiAgICBnZXRMb2dnZXIoKS5pbmZvKFwiICB0b3BNb3Zlc0F2YWlsYWJsZTpcIiwgdG9wTW92ZXMuaXNBdmFpbGFibGUpO1xuICAgIGdldExvZ2dlcigpLmluZm8oXG4gICAgICBcIiAgYmVzdE1vdmVzOlwiLFxuICAgICAgSlNPTi5zdHJpbmdpZnkodG9wTW92ZXMubW92ZXM/Lm1hcCgobSkgPT4gbS5zYW4pKSxcbiAgICApO1xuICAgIGdldExvZ2dlcigpLmluZm8oXCIgIHBsYXllZE1vdmU6XCIsIHBsYXllZE1vdmVTYW4pO1xuICAgIGdldExvZ2dlcigpLmluZm8oXCIgIHBsYXllZE1vdmVXYXNCZXN0OlwiLCBwbGF5ZWRNb3ZlV2FzQmVzdCk7XG5cbiAgICAvLyBEZWJ1ZyBlYWNoIG1vdmUgY29tcGFyaXNvblxuICAgIGlmICh0b3BNb3Zlcy5tb3Zlcykge1xuICAgICAgZ2V0TG9nZ2VyKCkuZGVidWcoXCIgIENvbXBhcmluZyBlYWNoIG1vdmU6XCIpO1xuICAgICAgdG9wTW92ZXMubW92ZXMuZm9yRWFjaCgobSwgaSkgPT4ge1xuICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcbiAgICAgICAgICBgICAgIE1vdmUgJHtpfTogXCIke20uc2FufVwiID09PSBcIiR7cGxheWVkTW92ZVNhbn1cIiA/ICR7bS5zYW4gPT09IHBsYXllZE1vdmVTYW59YCxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBlZmZlY3RpdmUgYmFzZWxpbmUgZm9yIGNvbXBhcmlzb25cbiAgICovXG4gIHByaXZhdGUgZGV0ZXJtaW5lRWZmZWN0aXZlQmFzZWxpbmUoXG4gICAgdHJhaW5pbmdCYXNlbGluZTogeyB3ZGw6IG51bWJlcjsgZmVuOiBzdHJpbmcgfSB8IG51bGwgfCB1bmRlZmluZWQsXG4gICAgd2RsQmVmb3JlRnJvbVBsYXllclBlcnNwZWN0aXZlOiBudW1iZXJcbiAgKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdHJhaW5pbmdCYXNlbGluZT8ud2RsID8/IHdkbEJlZm9yZUZyb21QbGF5ZXJQZXJzcGVjdGl2ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGVycm9yIGRpYWxvZyBzaG91bGQgYmUgc2hvd24gYmFzZWQgb24gbW92ZSBxdWFsaXR5XG4gICAqL1xuICBwcml2YXRlIHNob3VsZFNob3dFcnJvckRpYWxvZyhcbiAgICBwbGF5ZWRNb3ZlV2FzQmVzdDogYm9vbGVhbixcbiAgICBvdXRjb21lQ2hhbmdlZDogYm9vbGVhblxuICApOiBib29sZWFuIHtcbiAgICByZXR1cm4gIXBsYXllZE1vdmVXYXNCZXN0ICYmIG91dGNvbWVDaGFuZ2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ3MgZGVjaXNpb24gdmFsdWVzIGZvciBkZWJ1Z2dpbmdcbiAgICovXG4gIHByaXZhdGUgbG9nRGVjaXNpb25WYWx1ZXMoXG4gICAgb3V0Y29tZUNoYW5nZWQ6IGJvb2xlYW4sXG4gICAgcGxheWVkTW92ZVdhc0Jlc3Q6IGJvb2xlYW4sXG4gICAgZWZmZWN0aXZlV2RsQmVmb3JlOiBudW1iZXIsXG4gICAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmU6IG51bWJlcixcbiAgKTogdm9pZCB7XG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXCJbTW92ZVF1YWxpdHldIERFQ0lTSU9OIFZBTFVFUzpcIik7XG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXCIgIG91dGNvbWVDaGFuZ2VkOlwiLCBvdXRjb21lQ2hhbmdlZCk7XG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXCIgIHBsYXllZE1vdmVXYXNCZXN0OlwiLCBwbGF5ZWRNb3ZlV2FzQmVzdCk7XG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXG4gICAgICBcIiAgZWZmZWN0aXZlV2RsQmVmb3JlOlwiLFxuICAgICAgZWZmZWN0aXZlV2RsQmVmb3JlLFxuICAgICk7XG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXG4gICAgICBcIiAgd2RsQWZ0ZXJGcm9tUGxheWVyUGVyc3BlY3RpdmU6XCIsXG4gICAgICB3ZGxBZnRlckZyb21QbGF5ZXJQZXJzcGVjdGl2ZSxcbiAgICApO1xuICAgIGdldExvZ2dlcigpLmRlYnVnKFwiICBzaG93RGlhbG9nOlwiLCAhcGxheWVkTW92ZVdhc0Jlc3QgJiYgb3V0Y29tZUNoYW5nZWQpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTW92ZVF1YWxpdHlFdmFsdWF0b3IiLCJUT1BfTU9WRVNfTElNSVQiLCJldmFsdWF0ZU1vdmVRdWFsaXR5IiwiZmVuQmVmb3JlIiwiZmVuQWZ0ZXIiLCJ2YWxpZGF0ZWRNb3ZlIiwidHJhaW5pbmdCYXNlbGluZSIsImV2YWxCZWZvcmUiLCJldmFsQWZ0ZXIiLCJQcm9taXNlIiwiYWxsIiwiZ2V0RXZhbHVhdGlvbiIsImFyZUV2YWx1YXRpb25zVmFsaWQiLCJnZXRMb2dnZXIiLCJkZWJ1ZyIsImV2YWxCZWZvcmVBdmFpbGFibGUiLCJpc0F2YWlsYWJsZSIsImV2YWxBZnRlckF2YWlsYWJsZSIsImhhc0JlZm9yZVJlc3VsdCIsImhhc0FmdGVyUmVzdWx0Iiwic2hvdWxkU2hvd0Vycm9yRGlhbG9nIiwid2FzT3B0aW1hbCIsIm91dGNvbWVDaGFuZ2VkIiwid2RsQmVmb3JlIiwicmVzdWx0Iiwid2RsIiwid2RsQWZ0ZXIiLCJtb3ZlQ29sb3IiLCJjb2xvciIsIm1vdmVTYW4iLCJzYW4iLCJzcGxpdCIsIndkbEJlZm9yZUZyb21QbGF5ZXJQZXJzcGVjdGl2ZSIsIndkbEFmdGVyRnJvbVBsYXllclBlcnNwZWN0aXZlIiwiY29udmVydFRvUGxheWVyUGVyc3BlY3RpdmUiLCJlZmZlY3RpdmVXZGxCZWZvcmUiLCJkZXRlcm1pbmVFZmZlY3RpdmVCYXNlbGluZSIsInRyYWluaW5nQmFzZWxpbmVXZGwiLCJ1c2luZ0Jhc2VsaW5lIiwidG9wTW92ZXMiLCJ0YWJsZWJhc2VTZXJ2aWNlIiwiZ2V0VG9wTW92ZXMiLCJjYXRjaCIsIm1vdmVzIiwicGxheWVkTW92ZVdhc0Jlc3QiLCJ3YXNNb3ZlQmVzdCIsImxvZ0Jlc3RNb3Zlc0NvbXBhcmlzb24iLCJkaWRPdXRjb21lQ2hhbmdlIiwibG9nRGVjaXNpb25WYWx1ZXMiLCJiZXN0TW92ZSIsImdldEJlc3RNb3ZlIiwiaW5mbyIsImVycm9yIiwiZmVuIiwiaGFzVmFsaWRSZXN1bHQiLCJldmFsdWF0aW9uIiwicGxheWVkTW92ZVNhbiIsImhhc0F2YWlsYWJsZU1vdmVzIiwic29tZSIsIm0iLCJsZW5ndGgiLCJ3aW5UdXJuZWRJbnRvRHJhd09yTG9zcyIsImlzV2luVG9EcmF3T3JMb3NzIiwiZHJhd1R1cm5lZEludG9Mb3NzIiwiaXNEcmF3VG9Mb3NzIiwidW5kZWZpbmVkIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsImZvckVhY2giLCJpIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2QkM7Ozs7K0JBd0VZQTs7O2VBQUFBOzs7a0NBakVOO3lCQUNtQjtBQXFCMUIsK0RBQStELEdBQy9ELE1BQU1DLGtCQUFrQjtBQTBDakIsTUFBTUQ7SUFDWDs7Ozs7Ozs7R0FRQyxHQUNELE1BQU1FLG9CQUNKQyxTQUFpQixFQUNqQkMsUUFBZ0IsRUFDaEJDLGFBQTRCLEVBQzVCQyxnQkFBc0QsRUFDMUI7UUFDNUIsSUFBSTtZQUNGLCtFQUErRTtZQUMvRSxNQUFNLENBQUNDLFlBQVlDLFVBQVUsR0FBRyxNQUFNQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2hELElBQUksQ0FBQ0MsYUFBYSxDQUFDUjtnQkFDbkIsSUFBSSxDQUFDUSxhQUFhLENBQUNQO2FBQ3BCO1lBRUQsMENBQTBDO1lBQzFDLElBQUksQ0FBQyxJQUFJLENBQUNRLG1CQUFtQixDQUFDTCxZQUFZQyxZQUFZO2dCQUNwREssSUFBQUEsa0JBQVMsSUFBR0MsS0FBSyxDQUNmLDBEQUNBO29CQUNFQyxtQkFBbUIsRUFBRVIsdUJBQUFBLGlDQUFBQSxXQUFZUyxXQUFXO29CQUM1Q0Msa0JBQWtCLEVBQUVULHNCQUFBQSxnQ0FBQUEsVUFBV1EsV0FBVztvQkFDMUNFLGlCQUFpQlgsY0FBYyxZQUFZQTtvQkFDM0NZLGdCQUFnQlgsYUFBYSxZQUFZQTtnQkFDM0M7Z0JBR0YsT0FBTztvQkFDTFksdUJBQXVCO29C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