e506f26e61e2ec2e3e96b91b46b5e8db
/**
 * @file Unit tests for useProgressSync hook
 * @description Tests debounced sync, optimistic updates, retry logic, and offline handling
 */ "use strict";
jest.mock("@shared/store/hooks/useProgressStore", ()=>({
        /**
   *
   */ useProgressActions: ()=>mockProgressActions
    }));
// Mock logger
jest.mock("@shared/services/logging/Logger", ()=>{
    const mockLogger = {
        debug: jest.fn(),
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn()
    };
    return {
        /**
     *
     */ getLogger: ()=>({
                /**
       *
       */ setContext: ()=>mockLogger
            })
    };
});
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useProgressSync = require("../../../shared/hooks/useProgressSync");
// Mock progress actions
const mockProgressActions = {
    batchUpdateProgress: jest.fn(),
    setCardProgress: jest.fn(),
    setLastSync: jest.fn(),
    setSyncError: jest.fn()
};
// Mock localStorage
const mockLocalStorage = (()=>{
    let store = {};
    return {
        /**
     *
     * @param key
     */ getItem: (key)=>store[key] || null,
        /**
     *
     * @param key
     * @param value
     */ setItem: (key, value)=>{
            store[key] = value;
        },
        /**
     *
     * @param key
     */ removeItem: (key)=>{
            delete store[key];
        },
        /**
     *
     */ clear: ()=>{
            store = {};
        }
    };
})();
Object.defineProperty(window, "localStorage", {
    value: mockLocalStorage
});
// Mock window online/offline events
const mockWindowEventListeners = {};
Object.defineProperty(window, "addEventListener", {
    /**
   *
   * @param event
   * @param listener
   */ value: (event, listener)=>{
        if (!mockWindowEventListeners[event]) {
            mockWindowEventListeners[event] = [];
        }
        mockWindowEventListeners[event].push(listener);
    }
});
Object.defineProperty(window, "removeEventListener", {
    /**
   *
   * @param event
   * @param listener
   */ value: (event, listener)=>{
        if (mockWindowEventListeners[event]) {
            const index = mockWindowEventListeners[event].indexOf(listener);
            if (index > -1) {
                mockWindowEventListeners[event].splice(index, 1);
            }
        }
    }
});
/**
 *
 */ const triggerOnlineEvent = ()=>{
    var _mockWindowEventListeners_online;
    // Mock navigator.onLine
    Object.defineProperty(navigator, "onLine", {
        writable: true,
        value: true
    });
    (_mockWindowEventListeners_online = mockWindowEventListeners["online"]) === null || _mockWindowEventListeners_online === void 0 ? void 0 : _mockWindowEventListeners_online.forEach((listener)=>listener(new Event("online")));
};
/**
 *
 */ const triggerOfflineEvent = ()=>{
    var _mockWindowEventListeners_offline;
    // Mock navigator.onLine
    Object.defineProperty(navigator, "onLine", {
        writable: true,
        value: false
    });
    (_mockWindowEventListeners_offline = mockWindowEventListeners["offline"]) === null || _mockWindowEventListeners_offline === void 0 ? void 0 : _mockWindowEventListeners_offline.forEach((listener)=>listener(new Event("offline")));
};
// Test helpers
/**
 *
 */ const createMockProgressService = ()=>({
        updateUserStats: jest.fn().mockResolvedValue(undefined),
        upsertCardProgress: jest.fn().mockResolvedValue(undefined),
        updateProgressTransaction: jest.fn().mockResolvedValue(undefined)
    });
/**
 *
 */ const createTestUserStats = ()=>({
        totalPositionsCompleted: 10,
        overallSuccessRate: 0.85
    });
/**
 *
 * @param id
 */ const createTestCardProgress = (id)=>({
        id,
        nextReviewAt: Date.now() + 86400000,
        lastReviewedAt: Date.now() - 3600000,
        interval: 1,
        repetition: 1,
        efactor: 2.5,
        lapses: 0
    });
describe("useProgressSync", ()=>{
    const userId = "test-user-123";
    let mockProgressService;
    beforeEach(()=>{
        mockProgressService = createMockProgressService();
        jest.clearAllMocks();
        mockLocalStorage.clear();
        // Clear all window event listeners
        Object.keys(mockWindowEventListeners).forEach((key)=>{
            mockWindowEventListeners[key] = [];
        });
        // Reset navigator.onLine to true
        Object.defineProperty(navigator, "onLine", {
            writable: true,
            value: true
        });
        // Reset timers
        jest.clearAllTimers();
        jest.useFakeTimers();
    });
    afterEach(async ()=>{
        // Properly clean up timers and wait for any pending state updates
        await (0, _react.act)(async ()=>{
            jest.runOnlyPendingTimers();
        });
        jest.clearAllTimers();
        jest.useRealTimers();
    });
    describe("Basic sync operations", ()=>{
        it("should sync user stats with optimistic updates", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            // Should perform optimistic update immediately
            expect(mockProgressActions.batchUpdateProgress).toHaveBeenCalledWith({
                userStats: statsUpdate
            });
            // Should queue operation
            expect(result.current.syncStatus.pendingCount).toBe(1);
            expect(result.current.syncStatus.isDebounced).toBe(true);
            // Fast-forward debounce timer and wait for async operations
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledWith(userId, statsUpdate);
            });
        });
        it("should sync card progress with optimistic updates", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            const cardProgress = createTestCardProgress("test-card-1");
            (0, _react.act)(()=>{
                result.current.syncCardProgress("test-card-1", cardProgress);
            });
            // Should perform optimistic update immediately
            expect(mockProgressActions.setCardProgress).toHaveBeenCalledWith("test-card-1", cardProgress);
            // Fast-forward debounce timer and wait for async operations
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.upsertCardProgress).toHaveBeenCalledWith(userId, "test-card-1", cardProgress);
            });
        });
        it("should handle batch sync operations", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            const statsUpdate = createTestUserStats();
            const cardUpdates = [
                {
                    positionId: "card-1",
                    progress: createTestCardProgress("card-1")
                },
                {
                    positionId: "card-2",
                    progress: createTestCardProgress("card-2")
                }
            ];
            (0, _react.act)(()=>{
                result.current.syncBatch(statsUpdate, cardUpdates);
            });
            // Should perform optimistic updates
            expect(mockProgressActions.batchUpdateProgress).toHaveBeenCalledWith({
                userStats: statsUpdate
            });
            expect(mockProgressActions.batchUpdateProgress).toHaveBeenCalledWith({
                cardProgress: {
                    "card-1": cardUpdates[0].progress,
                    "card-2": cardUpdates[1].progress
                }
            });
            // Fast-forward debounce timer and wait for async operations
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateProgressTransaction).toHaveBeenCalledWith(userId, statsUpdate, cardUpdates);
            });
        });
    });
    describe("Error handling and retry logic", ()=>{
        it.skip("should retry failed operations with exponential backoff", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService, {
                    maxRetries: 2
                }));
            // Make service fail initially
            mockProgressService.updateUserStats.mockRejectedValueOnce(new Error("Network error")).mockRejectedValueOnce(new Error("Network error")).mockResolvedValueOnce(undefined);
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            // Initial sync attempt
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(1);
                expect(result.current.syncStatus.status).toBe("error");
            });
            expect(result.current.syncStatus.pendingCount).toBe(1);
            // First retry (after 1s exponential backoff)
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(1000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(2);
            });
            // Second retry (after 2s exponential backoff)
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(3);
            });
            // Should eventually succeed
            expect(result.current.syncStatus.status).toBe("idle");
            expect(result.current.syncStatus.pendingCount).toBe(0);
        });
        it.skip("should give up after max retries", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService, {
                    maxRetries: 1
                }));
            // Make service always fail
            mockProgressService.updateUserStats.mockRejectedValue(new Error("Permanent error"));
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            // Initial attempt
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(1);
            });
            // Wait longer for retry attempt + debounce
            (0, _react.act)(()=>{
                jest.advanceTimersByTime(3000); // 1000ms retry delay + 2000ms debounce
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(2);
            }, {
                timeout: 3000
            });
            // Should give up and remove from queue
            expect(result.current.syncStatus.status).toBe("error");
            expect(result.current.syncStatus.pendingCount).toBe(0);
            expect(mockProgressActions.setSyncError).toHaveBeenCalledWith("Permanent error");
        });
    });
    describe("Offline/Online handling", ()=>{
        it("should queue operations while offline", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            // Trigger offline event
            (0, _react.act)(()=>{
                triggerOfflineEvent();
            });
            expect(result.current.syncStatus.status).toBe("offline");
            // Queue operations while offline
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            expect(result.current.syncStatus.pendingCount).toBe(1);
            // Service should not be called while offline
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            expect(mockProgressService.updateUserStats).not.toHaveBeenCalled();
        });
        it("should process queue when coming back online", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            // Go offline and queue operations
            (0, _react.act)(()=>{
                triggerOfflineEvent();
            });
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            expect(result.current.syncStatus.pendingCount).toBe(1);
            // Come back online
            (0, _react.act)(()=>{
                triggerOnlineEvent();
            });
            expect(result.current.syncStatus.status).toBe("idle");
            // Should process queued operations
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalledWith(userId, statsUpdate);
            });
        });
    });
    describe("Queue management", ()=>{
        it("should persist queue to localStorage", ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            const statsUpdate = createTestUserStats();
            (0, _react.act)(()=>{
                result.current.syncUserStats(statsUpdate);
            });
            // Should save to localStorage
            const savedQueue = mockLocalStorage.getItem(`syncQueue-${userId}`);
            expect(savedQueue).toBeTruthy();
            const parsedQueue = JSON.parse(savedQueue);
            expect(parsedQueue).toHaveLength(1);
            expect(parsedQueue[0].operation.type).toBe("userStats");
        });
        it("should restore queue from localStorage on mount", ()=>{
            // Pre-populate localStorage
            const queueData = [
                {
                    id: "test-id",
                    operation: {
                        type: "userStats",
                        userId,
                        updates: createTestUserStats()
                    },
                    timestamp: Date.now(),
                    retries: 0,
                    lastAttempt: null
                }
            ];
            mockLocalStorage.setItem(`syncQueue-${userId}`, JSON.stringify(queueData));
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            expect(result.current.syncStatus.pendingCount).toBe(1);
        });
        it("should enforce queue size limit", ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            // Fill queue beyond limit (MAX_QUEUE_SIZE = 100)
            (0, _react.act)(()=>{
                for(let i = 0; i < 105; i++){
                    result.current.syncUserStats({
                        totalPositionsCompleted: i
                    });
                }
            });
            // Should drop oldest operations and keep under limit
            expect(result.current.syncStatus.pendingCount).toBeLessThanOrEqual(100);
        });
        it("should clear queue on demand", ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            // Queue some operations
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
                result.current.syncCardProgress("test-card", createTestCardProgress("test-card"));
            });
            expect(result.current.syncStatus.pendingCount).toBe(2);
            // Clear queue
            (0, _react.act)(()=>{
                result.current.clearQueue();
            });
            expect(result.current.syncStatus.pendingCount).toBe(0);
            expect(result.current.syncStatus.status).toBe("idle");
        });
    });
    describe("Batch splitting", ()=>{
        it("should split large batches into chunks", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService, {
                    maxBatchSize: 2
                }));
            const statsUpdate = createTestUserStats();
            const cardUpdates = [
                {
                    positionId: "card-1",
                    progress: createTestCardProgress("card-1")
                },
                {
                    positionId: "card-2",
                    progress: createTestCardProgress("card-2")
                },
                {
                    positionId: "card-3",
                    progress: createTestCardProgress("card-3")
                },
                {
                    positionId: "card-4",
                    progress: createTestCardProgress("card-4")
                },
                {
                    positionId: "card-5",
                    progress: createTestCardProgress("card-5")
                }
            ];
            (0, _react.act)(()=>{
                result.current.syncBatch(statsUpdate, cardUpdates);
            });
            // Should split into 3 chunks: [2, 2, 1] cards
            expect(result.current.syncStatus.pendingCount).toBe(3);
            // Fast-forward debounce timer and wait for async operations
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateProgressTransaction).toHaveBeenCalledTimes(3);
            });
            // First chunk should include stats update
            expect(mockProgressService.updateProgressTransaction).toHaveBeenNthCalledWith(1, userId, statsUpdate, cardUpdates.slice(0, 2));
            // Other chunks should have empty stats update
            expect(mockProgressService.updateProgressTransaction).toHaveBeenNthCalledWith(2, userId, {}, cardUpdates.slice(2, 4));
            expect(mockProgressService.updateProgressTransaction).toHaveBeenNthCalledWith(3, userId, {}, cardUpdates.slice(4, 5));
        });
    });
    describe("Configuration options", ()=>{
        it("should respect custom debounce delay", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService, {
                    debounceMs: 5000
                }));
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            expect(result.current.syncStatus.isDebounced).toBe(true);
            // Should not sync before custom debounce time
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            expect(mockProgressService.updateUserStats).not.toHaveBeenCalled();
            // Should sync after custom debounce time
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(3000);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockProgressService.updateUserStats).toHaveBeenCalled();
            });
        });
        it("should disable optimistic updates when configured", ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService, {
                    enableOptimistic: false
                }));
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            // Should not perform optimistic updates
            expect(mockProgressActions.batchUpdateProgress).not.toHaveBeenCalled();
        });
    });
    describe("Force sync", ()=>{
        it("should bypass debounce and sync immediately", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            expect(result.current.syncStatus.isDebounced).toBe(true);
            // Force sync without waiting for debounce
            await (0, _react.act)(async ()=>{
                await result.current.forceSync();
            });
            expect(result.current.syncStatus.isDebounced).toBe(false);
            expect(mockProgressService.updateUserStats).toHaveBeenCalled();
        });
    });
    describe("Concurrency protection", ()=>{
        it("should prevent concurrent queue processing", async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            // Make the first sync take time (longer than debounce)
            let resolveFirst;
            mockProgressService.updateUserStats.mockImplementationOnce(()=>new Promise((resolve)=>{
                    resolveFirst = resolve;
                }));
            // Queue first operation
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            expect(result.current.syncStatus.pendingCount).toBe(1);
            // Start first sync
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            // First sync should have started
            expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(1);
            // Queue second operation while first is still processing
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            // Both operations should be in the queue
            expect(result.current.syncStatus.pendingCount).toBe(2);
            // Try to trigger processing again (should be blocked because first is still processing)
            await (0, _react.act)(async ()=>{
                jest.advanceTimersByTime(2000);
            });
            // Should still only have one sync call (concurrent processing prevented)
            expect(mockProgressService.updateUserStats).toHaveBeenCalledTimes(1);
            // Now resolve the first operation to allow the second to process
            await (0, _react.act)(async ()=>{
                resolveFirst();
            });
        });
    });
    describe("Edge cases", ()=>{
        it("should handle sync without userId gracefully", ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(null, mockProgressService));
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            // Operation should not be queued without userId
            expect(result.current.syncStatus.pendingCount).toBe(0);
        });
        it("should handle localStorage errors gracefully", ()=>{
            // Mock localStorage to throw error
            const originalSetItem = mockLocalStorage.setItem;
            mockLocalStorage.setItem = jest.fn(()=>{
                throw new Error("Storage quota exceeded");
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressSync.useProgressSync)(userId, mockProgressService));
            (0, _react.act)(()=>{
                result.current.syncUserStats(createTestUserStats());
            });
            // Test should not crash and operation should still be queued in memory
            expect(result.current.syncStatus.pendingCount).toBe(1);
            // Restore original method
            mockLocalStorage.setItem = originalSetItem;
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VQcm9ncmVzc1N5bmMudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFVuaXQgdGVzdHMgZm9yIHVzZVByb2dyZXNzU3luYyBob29rXG4gKiBAZGVzY3JpcHRpb24gVGVzdHMgZGVib3VuY2VkIHN5bmMsIG9wdGltaXN0aWMgdXBkYXRlcywgcmV0cnkgbG9naWMsIGFuZCBvZmZsaW5lIGhhbmRsaW5nXG4gKi9cblxuaW1wb3J0IHsgcmVuZGVySG9vaywgYWN0LCB3YWl0Rm9yIH0gZnJvbSBcIkB0ZXN0aW5nLWxpYnJhcnkvcmVhY3RcIjtcbmltcG9ydCB7IHVzZVByb2dyZXNzU3luYyB9IGZyb20gXCJAc2hhcmVkL2hvb2tzL3VzZVByb2dyZXNzU3luY1wiO1xuaW1wb3J0IHsgUHJvZ3Jlc3NTZXJ2aWNlIH0gZnJvbSBcIkBzaGFyZWQvc2VydmljZXMvUHJvZ3Jlc3NTZXJ2aWNlXCI7XG5pbXBvcnQgdHlwZSB7IFVzZXJTdGF0cywgQ2FyZFByb2dyZXNzIH0gZnJvbSBcIkBzaGFyZWQvc3RvcmUvc2xpY2VzL3R5cGVzXCI7XG5cbi8vIE1vY2sgcHJvZ3Jlc3MgYWN0aW9uc1xuY29uc3QgbW9ja1Byb2dyZXNzQWN0aW9ucyA9IHtcbiAgYmF0Y2hVcGRhdGVQcm9ncmVzczogamVzdC5mbigpLFxuICBzZXRDYXJkUHJvZ3Jlc3M6IGplc3QuZm4oKSxcbiAgc2V0TGFzdFN5bmM6IGplc3QuZm4oKSxcbiAgc2V0U3luY0Vycm9yOiBqZXN0LmZuKCksXG59O1xuXG5qZXN0Lm1vY2soXCJAc2hhcmVkL3N0b3JlL2hvb2tzL3VzZVByb2dyZXNzU3RvcmVcIiwgKCkgPT4gKHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICB1c2VQcm9ncmVzc0FjdGlvbnM6ICgpID0+IG1vY2tQcm9ncmVzc0FjdGlvbnMsXG59KSk7XG5cbi8vIE1vY2sgbG9nZ2VyXG5qZXN0Lm1vY2soXCJAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyXCIsICgpID0+IHtcbiAgY29uc3QgbW9ja0xvZ2dlciA9IHtcbiAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgIGluZm86IGplc3QuZm4oKSxcbiAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0TG9nZ2VyOiAoKSA9PiAoe1xuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICBzZXRDb250ZXh0OiAoKSA9PiBtb2NrTG9nZ2VyLFxuICAgIH0pLFxuICB9O1xufSk7XG5cbi8vIE1vY2sgbG9jYWxTdG9yYWdlXG5jb25zdCBtb2NrTG9jYWxTdG9yYWdlID0gKCgpID0+IHtcbiAgbGV0IHN0b3JlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKi9cbiAgICBnZXRJdGVtOiAoa2V5OiBzdHJpbmcpID0+IHN0b3JlW2tleV0gfHwgbnVsbCxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRJdGVtOiAoa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqL1xuICAgIHJlbW92ZUl0ZW06IChrZXk6IHN0cmluZykgPT4ge1xuICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNsZWFyOiAoKSA9PiB7XG4gICAgICBzdG9yZSA9IHt9O1xuICAgIH0sXG4gIH07XG59KSgpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcImxvY2FsU3RvcmFnZVwiLCB7XG4gIHZhbHVlOiBtb2NrTG9jYWxTdG9yYWdlLFxufSk7XG5cbi8vIE1vY2sgd2luZG93IG9ubGluZS9vZmZsaW5lIGV2ZW50c1xuY29uc3QgbW9ja1dpbmRvd0V2ZW50TGlzdGVuZXJzOiB7IFtrZXk6IHN0cmluZ106IEV2ZW50TGlzdGVuZXJbXSB9ID0ge307XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFwiYWRkRXZlbnRMaXN0ZW5lclwiLCB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnRcbiAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAqL1xuICB2YWx1ZTogKGV2ZW50OiBzdHJpbmcsIGxpc3RlbmVyOiBFdmVudExpc3RlbmVyKSA9PiB7XG4gICAgaWYgKCFtb2NrV2luZG93RXZlbnRMaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICBtb2NrV2luZG93RXZlbnRMaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuICAgIG1vY2tXaW5kb3dFdmVudExpc3RlbmVyc1tldmVudF0ucHVzaChsaXN0ZW5lcik7XG4gIH0sXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgXCJyZW1vdmVFdmVudExpc3RlbmVyXCIsIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBldmVudFxuICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICovXG4gIHZhbHVlOiAoZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6IEV2ZW50TGlzdGVuZXIpID0+IHtcbiAgICBpZiAobW9ja1dpbmRvd0V2ZW50TGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgY29uc3QgaW5kZXggPSBtb2NrV2luZG93RXZlbnRMaXN0ZW5lcnNbZXZlbnRdLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgbW9ja1dpbmRvd0V2ZW50TGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pO1xuXG4vKipcbiAqXG4gKi9cbmNvbnN0IHRyaWdnZXJPbmxpbmVFdmVudCA9ICgpID0+IHtcbiAgLy8gTW9jayBuYXZpZ2F0b3Iub25MaW5lXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsIFwib25MaW5lXCIsIHtcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdHJ1ZSxcbiAgfSk7XG5cbiAgbW9ja1dpbmRvd0V2ZW50TGlzdGVuZXJzW1wib25saW5lXCJdPy5mb3JFYWNoKChsaXN0ZW5lcikgPT5cbiAgICBsaXN0ZW5lcihuZXcgRXZlbnQoXCJvbmxpbmVcIikpLFxuICApO1xufTtcblxuLyoqXG4gKlxuICovXG5jb25zdCB0cmlnZ2VyT2ZmbGluZUV2ZW50ID0gKCkgPT4ge1xuICAvLyBNb2NrIG5hdmlnYXRvci5vbkxpbmVcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgXCJvbkxpbmVcIiwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmYWxzZSxcbiAgfSk7XG5cbiAgbW9ja1dpbmRvd0V2ZW50TGlzdGVuZXJzW1wib2ZmbGluZVwiXT8uZm9yRWFjaCgobGlzdGVuZXIpID0+XG4gICAgbGlzdGVuZXIobmV3IEV2ZW50KFwib2ZmbGluZVwiKSksXG4gICk7XG59O1xuXG4vLyBUZXN0IGhlbHBlcnNcbi8qKlxuICpcbiAqL1xuY29uc3QgY3JlYXRlTW9ja1Byb2dyZXNzU2VydmljZSA9ICgpOiBqZXN0Lk1vY2tlZDxQcm9ncmVzc1NlcnZpY2U+ID0+XG4gICh7XG4gICAgdXBkYXRlVXNlclN0YXRzOiBqZXN0LmZuKCkubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKSxcbiAgICB1cHNlcnRDYXJkUHJvZ3Jlc3M6IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpLFxuICAgIHVwZGF0ZVByb2dyZXNzVHJhbnNhY3Rpb246IGplc3QuZm4oKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpLFxuICB9KSBhcyBhbnk7XG5cbi8qKlxuICpcbiAqL1xuY29uc3QgY3JlYXRlVGVzdFVzZXJTdGF0cyA9ICgpOiBQYXJ0aWFsPFVzZXJTdGF0cz4gPT4gKHtcbiAgdG90YWxQb3NpdGlvbnNDb21wbGV0ZWQ6IDEwLFxuICBvdmVyYWxsU3VjY2Vzc1JhdGU6IDAuODUsXG59KTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGlkXG4gKi9cbmNvbnN0IGNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MgPSAoaWQ6IHN0cmluZyk6IENhcmRQcm9ncmVzcyA9PiAoe1xuICBpZCxcbiAgbmV4dFJldmlld0F0OiBEYXRlLm5vdygpICsgODY0MDAwMDAsIC8vIDI0IGhvdXJzIGZyb20gbm93XG4gIGxhc3RSZXZpZXdlZEF0OiBEYXRlLm5vdygpIC0gMzYwMDAwMCwgLy8gMSBob3VyIGFnb1xuICBpbnRlcnZhbDogMSxcbiAgcmVwZXRpdGlvbjogMSxcbiAgZWZhY3RvcjogMi41LFxuICBsYXBzZXM6IDAsXG59KTtcblxuZGVzY3JpYmUoXCJ1c2VQcm9ncmVzc1N5bmNcIiwgKCkgPT4ge1xuICBjb25zdCB1c2VySWQgPSBcInRlc3QtdXNlci0xMjNcIjtcbiAgbGV0IG1vY2tQcm9ncmVzc1NlcnZpY2U6IGplc3QuTW9ja2VkPFByb2dyZXNzU2VydmljZT47XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja1Byb2dyZXNzU2VydmljZSA9IGNyZWF0ZU1vY2tQcm9ncmVzc1NlcnZpY2UoKTtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBtb2NrTG9jYWxTdG9yYWdlLmNsZWFyKCk7XG5cbiAgICAvLyBDbGVhciBhbGwgd2luZG93IGV2ZW50IGxpc3RlbmVyc1xuICAgIE9iamVjdC5rZXlzKG1vY2tXaW5kb3dFdmVudExpc3RlbmVycykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBtb2NrV2luZG93RXZlbnRMaXN0ZW5lcnNba2V5XSA9IFtdO1xuICAgIH0pO1xuXG4gICAgLy8gUmVzZXQgbmF2aWdhdG9yLm9uTGluZSB0byB0cnVlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdmlnYXRvciwgXCJvbkxpbmVcIiwge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIFJlc2V0IHRpbWVyc1xuICAgIGplc3QuY2xlYXJBbGxUaW1lcnMoKTtcbiAgICBqZXN0LnVzZUZha2VUaW1lcnMoKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKGFzeW5jICgpID0+IHtcbiAgICAvLyBQcm9wZXJseSBjbGVhbiB1cCB0aW1lcnMgYW5kIHdhaXQgZm9yIGFueSBwZW5kaW5nIHN0YXRlIHVwZGF0ZXNcbiAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5ydW5Pbmx5UGVuZGluZ1RpbWVycygpO1xuICAgIH0pO1xuICAgIGplc3QuY2xlYXJBbGxUaW1lcnMoKTtcbiAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJCYXNpYyBzeW5jIG9wZXJhdGlvbnNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHN5bmMgdXNlciBzdGF0cyB3aXRoIG9wdGltaXN0aWMgdXBkYXRlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXRzVXBkYXRlID0gY3JlYXRlVGVzdFVzZXJTdGF0cygpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5zeW5jVXNlclN0YXRzKHN0YXRzVXBkYXRlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgcGVyZm9ybSBvcHRpbWlzdGljIHVwZGF0ZSBpbW1lZGlhdGVseVxuICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc0FjdGlvbnMuYmF0Y2hVcGRhdGVQcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB1c2VyU3RhdHM6IHN0YXRzVXBkYXRlLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBxdWV1ZSBvcGVyYXRpb25cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLmlzRGVib3VuY2VkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgZGVib3VuY2UgdGltZXIgYW5kIHdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgc3RhdHNVcGRhdGUsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIHN5bmMgY2FyZCBwcm9ncmVzcyB3aXRoIG9wdGltaXN0aWMgdXBkYXRlc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNhcmRQcm9ncmVzcyA9IGNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MoXCJ0ZXN0LWNhcmQtMVwiKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY0NhcmRQcm9ncmVzcyhcInRlc3QtY2FyZC0xXCIsIGNhcmRQcm9ncmVzcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHBlcmZvcm0gb3B0aW1pc3RpYyB1cGRhdGUgaW1tZWRpYXRlbHlcbiAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NBY3Rpb25zLnNldENhcmRQcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwidGVzdC1jYXJkLTFcIixcbiAgICAgICAgY2FyZFByb2dyZXNzLFxuICAgICAgKTtcblxuICAgICAgLy8gRmFzdC1mb3J3YXJkIGRlYm91bmNlIHRpbWVyIGFuZCB3YWl0IGZvciBhc3luYyBvcGVyYXRpb25zXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjAwMCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwc2VydENhcmRQcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIFwidGVzdC1jYXJkLTFcIixcbiAgICAgICAgICBjYXJkUHJvZ3Jlc3MsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBiYXRjaCBzeW5jIG9wZXJhdGlvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUHJvZ3Jlc3NTeW5jKHVzZXJJZCwgbW9ja1Byb2dyZXNzU2VydmljZSksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdGF0c1VwZGF0ZSA9IGNyZWF0ZVRlc3RVc2VyU3RhdHMoKTtcbiAgICAgIGNvbnN0IGNhcmRVcGRhdGVzID0gW1xuICAgICAgICB7IHBvc2l0aW9uSWQ6IFwiY2FyZC0xXCIsIHByb2dyZXNzOiBjcmVhdGVUZXN0Q2FyZFByb2dyZXNzKFwiY2FyZC0xXCIpIH0sXG4gICAgICAgIHsgcG9zaXRpb25JZDogXCJjYXJkLTJcIiwgcHJvZ3Jlc3M6IGNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MoXCJjYXJkLTJcIikgfSxcbiAgICAgIF07XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNCYXRjaChzdGF0c1VwZGF0ZSwgY2FyZFVwZGF0ZXMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBwZXJmb3JtIG9wdGltaXN0aWMgdXBkYXRlc1xuICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc0FjdGlvbnMuYmF0Y2hVcGRhdGVQcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB1c2VyU3RhdHM6IHN0YXRzVXBkYXRlLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja1Byb2dyZXNzQWN0aW9ucy5iYXRjaFVwZGF0ZVByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIGNhcmRQcm9ncmVzczoge1xuICAgICAgICAgIFwiY2FyZC0xXCI6IGNhcmRVcGRhdGVzWzBdLnByb2dyZXNzLFxuICAgICAgICAgIFwiY2FyZC0yXCI6IGNhcmRVcGRhdGVzWzFdLnByb2dyZXNzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIC8vIEZhc3QtZm9yd2FyZCBkZWJvdW5jZSB0aW1lciBhbmQgd2FpdCBmb3IgYXN5bmMgb3BlcmF0aW9uc1xuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDIwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QoXG4gICAgICAgICAgbW9ja1Byb2dyZXNzU2VydmljZS51cGRhdGVQcm9ncmVzc1RyYW5zYWN0aW9uLFxuICAgICAgICApLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVzZXJJZCwgc3RhdHNVcGRhdGUsIGNhcmRVcGRhdGVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkVycm9yIGhhbmRsaW5nIGFuZCByZXRyeSBsb2dpY1wiLCAoKSA9PiB7XG4gICAgaXQuc2tpcChcInNob3VsZCByZXRyeSBmYWlsZWQgb3BlcmF0aW9ucyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUHJvZ3Jlc3NTeW5jKHVzZXJJZCwgbW9ja1Byb2dyZXNzU2VydmljZSwgeyBtYXhSZXRyaWVzOiAyIH0pLFxuICAgICAgKTtcblxuICAgICAgLy8gTWFrZSBzZXJ2aWNlIGZhaWwgaW5pdGlhbGx5XG4gICAgICBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0c1xuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcihcIk5ldHdvcmsgZXJyb3JcIikpXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKFwiTmV0d29yayBlcnJvclwiKSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCBzdGF0c1VwZGF0ZSA9IGNyZWF0ZVRlc3RVc2VyU3RhdHMoKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhzdGF0c1VwZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbCBzeW5jIGF0dGVtcHRcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnN0YXR1cykudG9CZShcImVycm9yXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgxKTtcblxuICAgICAgLy8gRmlyc3QgcmV0cnkgKGFmdGVyIDFzIGV4cG9uZW50aWFsIGJhY2tvZmYpXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMTAwMCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNlY29uZCByZXRyeSAoYWZ0ZXIgMnMgZXhwb25lbnRpYWwgYmFja29mZilcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIGV2ZW50dWFsbHkgc3VjY2VlZFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMuc3RhdHVzKS50b0JlKFwiaWRsZVwiKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0LnNraXAoXCJzaG91bGQgZ2l2ZSB1cCBhZnRlciBtYXggcmV0cmllc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLCB7IG1heFJldHJpZXM6IDEgfSksXG4gICAgICApO1xuXG4gICAgICAvLyBNYWtlIHNlcnZpY2UgYWx3YXlzIGZhaWxcbiAgICAgIG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzLm1vY2tSZWplY3RlZFZhbHVlKFxuICAgICAgICBuZXcgRXJyb3IoXCJQZXJtYW5lbnQgZXJyb3JcIiksXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdGF0c1VwZGF0ZSA9IGNyZWF0ZVRlc3RVc2VyU3RhdHMoKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhzdGF0c1VwZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gSW5pdGlhbCBhdHRlbXB0XG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjAwMCk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdhaXQgbG9uZ2VyIGZvciByZXRyeSBhdHRlbXB0ICsgZGVib3VuY2VcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzMDAwKTsgLy8gMTAwMG1zIHJldHJ5IGRlbGF5ICsgMjAwMG1zIGRlYm91bmNlXG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgd2FpdEZvcihcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICB9LFxuICAgICAgICB7IHRpbWVvdXQ6IDMwMDAgfSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFNob3VsZCBnaXZlIHVwIGFuZCByZW1vdmUgZnJvbSBxdWV1ZVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMuc3RhdHVzKS50b0JlKFwiZXJyb3JcIik7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5wZW5kaW5nQ291bnQpLnRvQmUoMCk7XG4gICAgICBleHBlY3QobW9ja1Byb2dyZXNzQWN0aW9ucy5zZXRTeW5jRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBcIlBlcm1hbmVudCBlcnJvclwiLFxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJPZmZsaW5lL09ubGluZSBoYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgcXVldWUgb3BlcmF0aW9ucyB3aGlsZSBvZmZsaW5lXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UpLFxuICAgICAgKTtcblxuICAgICAgLy8gVHJpZ2dlciBvZmZsaW5lIGV2ZW50XG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICB0cmlnZ2VyT2ZmbGluZUV2ZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMuc3RhdHVzKS50b0JlKFwib2ZmbGluZVwiKTtcblxuICAgICAgLy8gUXVldWUgb3BlcmF0aW9ucyB3aGlsZSBvZmZsaW5lXG4gICAgICBjb25zdCBzdGF0c1VwZGF0ZSA9IGNyZWF0ZVRlc3RVc2VyU3RhdHMoKTtcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoc3RhdHNVcGRhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgxKTtcblxuICAgICAgLy8gU2VydmljZSBzaG91bGQgbm90IGJlIGNhbGxlZCB3aGlsZSBvZmZsaW5lXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjAwMCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgcHJvY2VzcyBxdWV1ZSB3aGVuIGNvbWluZyBiYWNrIG9ubGluZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlKSxcbiAgICAgICk7XG5cbiAgICAgIC8vIEdvIG9mZmxpbmUgYW5kIHF1ZXVlIG9wZXJhdGlvbnNcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHRyaWdnZXJPZmZsaW5lRXZlbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdGF0c1VwZGF0ZSA9IGNyZWF0ZVRlc3RVc2VyU3RhdHMoKTtcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoc3RhdHNVcGRhdGUpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgxKTtcblxuICAgICAgLy8gQ29tZSBiYWNrIG9ubGluZVxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgdHJpZ2dlck9ubGluZUV2ZW50KCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMuc3RhdHVzKS50b0JlKFwiaWRsZVwiKTtcblxuICAgICAgLy8gU2hvdWxkIHByb2Nlc3MgcXVldWVkIG9wZXJhdGlvbnNcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgc3RhdHNVcGRhdGUsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJRdWV1ZSBtYW5hZ2VtZW50XCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBwZXJzaXN0IHF1ZXVlIHRvIGxvY2FsU3RvcmFnZVwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXRzVXBkYXRlID0gY3JlYXRlVGVzdFVzZXJTdGF0cygpO1xuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhzdGF0c1VwZGF0ZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICBjb25zdCBzYXZlZFF1ZXVlID0gbW9ja0xvY2FsU3RvcmFnZS5nZXRJdGVtKGBzeW5jUXVldWUtJHt1c2VySWR9YCk7XG4gICAgICBleHBlY3Qoc2F2ZWRRdWV1ZSkudG9CZVRydXRoeSgpO1xuXG4gICAgICBjb25zdCBwYXJzZWRRdWV1ZSA9IEpTT04ucGFyc2Uoc2F2ZWRRdWV1ZSEpO1xuICAgICAgZXhwZWN0KHBhcnNlZFF1ZXVlKS50b0hhdmVMZW5ndGgoMSk7XG4gICAgICBleHBlY3QocGFyc2VkUXVldWVbMF0ub3BlcmF0aW9uLnR5cGUpLnRvQmUoXCJ1c2VyU3RhdHNcIik7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCByZXN0b3JlIHF1ZXVlIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XCIsICgpID0+IHtcbiAgICAgIC8vIFByZS1wb3B1bGF0ZSBsb2NhbFN0b3JhZ2VcbiAgICAgIGNvbnN0IHF1ZXVlRGF0YSA9IFtcbiAgICAgICAge1xuICAgICAgICAgIGlkOiBcInRlc3QtaWRcIixcbiAgICAgICAgICBvcGVyYXRpb246IHtcbiAgICAgICAgICAgIHR5cGU6IFwidXNlclN0YXRzXCIsXG4gICAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgICB1cGRhdGVzOiBjcmVhdGVUZXN0VXNlclN0YXRzKCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICAgICAgcmV0cmllczogMCxcbiAgICAgICAgICBsYXN0QXR0ZW1wdDogbnVsbCxcbiAgICAgICAgfSxcbiAgICAgIF07XG5cbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgICAgYHN5bmNRdWV1ZS0ke3VzZXJJZH1gLFxuICAgICAgICBKU09OLnN0cmluZ2lmeShxdWV1ZURhdGEpLFxuICAgICAgKTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUHJvZ3Jlc3NTeW5jKHVzZXJJZCwgbW9ja1Byb2dyZXNzU2VydmljZSksXG4gICAgICApO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5wZW5kaW5nQ291bnQpLnRvQmUoMSk7XG4gICAgfSk7XG5cbiAgICBpdChcInNob3VsZCBlbmZvcmNlIHF1ZXVlIHNpemUgbGltaXRcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgdXNlUHJvZ3Jlc3NTeW5jKHVzZXJJZCwgbW9ja1Byb2dyZXNzU2VydmljZSksXG4gICAgICApO1xuXG4gICAgICAvLyBGaWxsIHF1ZXVlIGJleW9uZCBsaW1pdCAoTUFYX1FVRVVFX1NJWkUgPSAxMDApXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwNTsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyh7IHRvdGFsUG9zaXRpb25zQ29tcGxldGVkOiBpIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIGRyb3Agb2xkZXN0IG9wZXJhdGlvbnMgYW5kIGtlZXAgdW5kZXIgbGltaXRcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZUxlc3NUaGFuT3JFcXVhbCgxMDApO1xuICAgIH0pO1xuXG4gICAgaXQoXCJzaG91bGQgY2xlYXIgcXVldWUgb24gZGVtYW5kXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UpLFxuICAgICAgKTtcblxuICAgICAgLy8gUXVldWUgc29tZSBvcGVyYXRpb25zXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5zeW5jVXNlclN0YXRzKGNyZWF0ZVRlc3RVc2VyU3RhdHMoKSk7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNDYXJkUHJvZ3Jlc3MoXG4gICAgICAgICAgXCJ0ZXN0LWNhcmRcIixcbiAgICAgICAgICBjcmVhdGVUZXN0Q2FyZFByb2dyZXNzKFwidGVzdC1jYXJkXCIpLFxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgyKTtcblxuICAgICAgLy8gQ2xlYXIgcXVldWVcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyUXVldWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5wZW5kaW5nQ291bnQpLnRvQmUoMCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5zdGF0dXMpLnRvQmUoXCJpZGxlXCIpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkJhdGNoIHNwbGl0dGluZ1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgc3BsaXQgbGFyZ2UgYmF0Y2hlcyBpbnRvIGNodW5rc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLCB7IG1heEJhdGNoU2l6ZTogMiB9KSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHN0YXRzVXBkYXRlID0gY3JlYXRlVGVzdFVzZXJTdGF0cygpO1xuICAgICAgY29uc3QgY2FyZFVwZGF0ZXMgPSBbXG4gICAgICAgIHsgcG9zaXRpb25JZDogXCJjYXJkLTFcIiwgcHJvZ3Jlc3M6IGNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MoXCJjYXJkLTFcIikgfSxcbiAgICAgICAgeyBwb3NpdGlvbklkOiBcImNhcmQtMlwiLCBwcm9ncmVzczogY3JlYXRlVGVzdENhcmRQcm9ncmVzcyhcImNhcmQtMlwiKSB9LFxuICAgICAgICB7IHBvc2l0aW9uSWQ6IFwiY2FyZC0zXCIsIHByb2dyZXNzOiBjcmVhdGVUZXN0Q2FyZFByb2dyZXNzKFwiY2FyZC0zXCIpIH0sXG4gICAgICAgIHsgcG9zaXRpb25JZDogXCJjYXJkLTRcIiwgcHJvZ3Jlc3M6IGNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MoXCJjYXJkLTRcIikgfSxcbiAgICAgICAgeyBwb3NpdGlvbklkOiBcImNhcmQtNVwiLCBwcm9ncmVzczogY3JlYXRlVGVzdENhcmRQcm9ncmVzcyhcImNhcmQtNVwiKSB9LFxuICAgICAgXTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY0JhdGNoKHN0YXRzVXBkYXRlLCBjYXJkVXBkYXRlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHNwbGl0IGludG8gMyBjaHVua3M6IFsyLCAyLCAxXSBjYXJkc1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMucGVuZGluZ0NvdW50KS50b0JlKDMpO1xuXG4gICAgICAvLyBGYXN0LWZvcndhcmQgZGVib3VuY2UgdGltZXIgYW5kIHdhaXQgZm9yIGFzeW5jIG9wZXJhdGlvbnNcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KFxuICAgICAgICAgIG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlUHJvZ3Jlc3NUcmFuc2FjdGlvbixcbiAgICAgICAgKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRmlyc3QgY2h1bmsgc2hvdWxkIGluY2x1ZGUgc3RhdHMgdXBkYXRlXG4gICAgICBleHBlY3QoXG4gICAgICAgIG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlUHJvZ3Jlc3NUcmFuc2FjdGlvbixcbiAgICAgICkudG9IYXZlQmVlbk50aENhbGxlZFdpdGgoXG4gICAgICAgIDEsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc3RhdHNVcGRhdGUsXG4gICAgICAgIGNhcmRVcGRhdGVzLnNsaWNlKDAsIDIpLFxuICAgICAgKTtcblxuICAgICAgLy8gT3RoZXIgY2h1bmtzIHNob3VsZCBoYXZlIGVtcHR5IHN0YXRzIHVwZGF0ZVxuICAgICAgZXhwZWN0KFxuICAgICAgICBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVByb2dyZXNzVHJhbnNhY3Rpb24sXG4gICAgICApLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKDIsIHVzZXJJZCwge30sIGNhcmRVcGRhdGVzLnNsaWNlKDIsIDQpKTtcblxuICAgICAgZXhwZWN0KFxuICAgICAgICBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVByb2dyZXNzVHJhbnNhY3Rpb24sXG4gICAgICApLnRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoKDMsIHVzZXJJZCwge30sIGNhcmRVcGRhdGVzLnNsaWNlKDQsIDUpKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJDb25maWd1cmF0aW9uIG9wdGlvbnNcIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHJlc3BlY3QgY3VzdG9tIGRlYm91bmNlIGRlbGF5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UsIHsgZGVib3VuY2VNczogNTAwMCB9KSxcbiAgICAgICk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoY3JlYXRlVGVzdFVzZXJTdGF0cygpKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5pc0RlYm91bmNlZCkudG9CZSh0cnVlKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBzeW5jIGJlZm9yZSBjdXN0b20gZGVib3VuY2UgdGltZVxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5hZHZhbmNlVGltZXJzQnlUaW1lKDIwMDApO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgICAgLy8gU2hvdWxkIHN5bmMgYWZ0ZXIgY3VzdG9tIGRlYm91bmNlIHRpbWVcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgzMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGRpc2FibGUgb3B0aW1pc3RpYyB1cGRhdGVzIHdoZW4gY29uZmlndXJlZFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VQcm9ncmVzc1N5bmModXNlcklkLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlLCB7XG4gICAgICAgICAgZW5hYmxlT3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhjcmVhdGVUZXN0VXNlclN0YXRzKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgcGVyZm9ybSBvcHRpbWlzdGljIHVwZGF0ZXNcbiAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NBY3Rpb25zLmJhdGNoVXBkYXRlUHJvZ3Jlc3MpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiRm9yY2Ugc3luY1wiLCAoKSA9PiB7XG4gICAgaXQoXCJzaG91bGQgYnlwYXNzIGRlYm91bmNlIGFuZCBzeW5jIGltbWVkaWF0ZWx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UpLFxuICAgICAgKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhjcmVhdGVUZXN0VXNlclN0YXRzKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLmlzRGVib3VuY2VkKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBGb3JjZSBzeW5jIHdpdGhvdXQgd2FpdGluZyBmb3IgZGVib3VuY2VcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmZvcmNlU3luYygpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLmlzRGVib3VuY2VkKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIkNvbmN1cnJlbmN5IHByb3RlY3Rpb25cIiwgKCkgPT4ge1xuICAgIGl0KFwic2hvdWxkIHByZXZlbnQgY29uY3VycmVudCBxdWV1ZSBwcm9jZXNzaW5nXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UpLFxuICAgICAgKTtcblxuICAgICAgLy8gTWFrZSB0aGUgZmlyc3Qgc3luYyB0YWtlIHRpbWUgKGxvbmdlciB0aGFuIGRlYm91bmNlKVxuICAgICAgbGV0IHJlc29sdmVGaXJzdDogKCkgPT4gdm9pZDtcbiAgICAgIG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoXG4gICAgICAgICgpID0+XG4gICAgICAgICAgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmVGaXJzdCA9IHJlc29sdmU7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgICAvLyBRdWV1ZSBmaXJzdCBvcGVyYXRpb25cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoY3JlYXRlVGVzdFVzZXJTdGF0cygpKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5wZW5kaW5nQ291bnQpLnRvQmUoMSk7XG5cbiAgICAgIC8vIFN0YXJ0IGZpcnN0IHN5bmNcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGplc3QuYWR2YW5jZVRpbWVyc0J5VGltZSgyMDAwKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaXJzdCBzeW5jIHNob3VsZCBoYXZlIHN0YXJ0ZWRcbiAgICAgIGV4cGVjdChtb2NrUHJvZ3Jlc3NTZXJ2aWNlLnVwZGF0ZVVzZXJTdGF0cykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuXG4gICAgICAvLyBRdWV1ZSBzZWNvbmQgb3BlcmF0aW9uIHdoaWxlIGZpcnN0IGlzIHN0aWxsIHByb2Nlc3NpbmdcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoY3JlYXRlVGVzdFVzZXJTdGF0cygpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBCb3RoIG9wZXJhdGlvbnMgc2hvdWxkIGJlIGluIHRoZSBxdWV1ZVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN5bmNTdGF0dXMucGVuZGluZ0NvdW50KS50b0JlKDIpO1xuXG4gICAgICAvLyBUcnkgdG8gdHJpZ2dlciBwcm9jZXNzaW5nIGFnYWluIChzaG91bGQgYmUgYmxvY2tlZCBiZWNhdXNlIGZpcnN0IGlzIHN0aWxsIHByb2Nlc3NpbmcpXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LmFkdmFuY2VUaW1lcnNCeVRpbWUoMjAwMCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIG9ubHkgaGF2ZSBvbmUgc3luYyBjYWxsIChjb25jdXJyZW50IHByb2Nlc3NpbmcgcHJldmVudGVkKVxuICAgICAgZXhwZWN0KG1vY2tQcm9ncmVzc1NlcnZpY2UudXBkYXRlVXNlclN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG5cbiAgICAgIC8vIE5vdyByZXNvbHZlIHRoZSBmaXJzdCBvcGVyYXRpb24gdG8gYWxsb3cgdGhlIHNlY29uZCB0byBwcm9jZXNzXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXNvbHZlRmlyc3QhKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJFZGdlIGNhc2VzXCIsICgpID0+IHtcbiAgICBpdChcInNob3VsZCBoYW5kbGUgc3luYyB3aXRob3V0IHVzZXJJZCBncmFjZWZ1bGx5XCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyhudWxsLCBtb2NrUHJvZ3Jlc3NTZXJ2aWNlKSxcbiAgICAgICk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LnN5bmNVc2VyU3RhdHMoY3JlYXRlVGVzdFVzZXJTdGF0cygpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBPcGVyYXRpb24gc2hvdWxkIG5vdCBiZSBxdWV1ZWQgd2l0aG91dCB1c2VySWRcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zeW5jU3RhdHVzLnBlbmRpbmdDb3VudCkudG9CZSgwKTtcbiAgICB9KTtcblxuICAgIGl0KFwic2hvdWxkIGhhbmRsZSBsb2NhbFN0b3JhZ2UgZXJyb3JzIGdyYWNlZnVsbHlcIiwgKCkgPT4ge1xuICAgICAgLy8gTW9jayBsb2NhbFN0b3JhZ2UgdG8gdGhyb3cgZXJyb3JcbiAgICAgIGNvbnN0IG9yaWdpbmFsU2V0SXRlbSA9IG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbTtcbiAgICAgIG1vY2tMb2NhbFN0b3JhZ2Uuc2V0SXRlbSA9IGplc3QuZm4oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdG9yYWdlIHF1b3RhIGV4Y2VlZGVkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZVByb2dyZXNzU3luYyh1c2VySWQsIG1vY2tQcm9ncmVzc1NlcnZpY2UpLFxuICAgICAgKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuc3luY1VzZXJTdGF0cyhjcmVhdGVUZXN0VXNlclN0YXRzKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRlc3Qgc2hvdWxkIG5vdCBjcmFzaCBhbmQgb3BlcmF0aW9uIHNob3VsZCBzdGlsbCBiZSBxdWV1ZWQgaW4gbWVtb3J5XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuc3luY1N0YXR1cy5wZW5kaW5nQ291bnQpLnRvQmUoMSk7XG5cbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgbWV0aG9kXG4gICAgICBtb2NrTG9jYWxTdG9yYWdlLnNldEl0ZW0gPSBvcmlnaW5hbFNldEl0ZW07XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwibmFtZXMiOlsiamVzdCIsIm1vY2siLCJ1c2VQcm9ncmVzc0FjdGlvbnMiLCJtb2NrUHJvZ3Jlc3NBY3Rpb25zIiwibW9ja0xvZ2dlciIsImRlYnVnIiwiZm4iLCJpbmZvIiwid2FybiIsImVycm9yIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImJhdGNoVXBkYXRlUHJvZ3Jlc3MiLCJzZXRDYXJkUHJvZ3Jlc3MiLCJzZXRMYXN0U3luYyIsInNldFN5bmNFcnJvciIsIm1vY2tMb2NhbFN0b3JhZ2UiLCJzdG9yZSIsImdldEl0ZW0iLCJrZXkiLCJzZXRJdGVtIiwidmFsdWUiLCJyZW1vdmVJdGVtIiwiY2xlYXIiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIndpbmRvdyIsIm1vY2tXaW5kb3dFdmVudExpc3RlbmVycyIsImV2ZW50IiwibGlzdGVuZXIiLCJwdXNoIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwidHJpZ2dlck9ubGluZUV2ZW50IiwibmF2aWdhdG9yIiwid3JpdGFibGUiLCJmb3JFYWNoIiwiRXZlbnQiLCJ0cmlnZ2VyT2ZmbGluZUV2ZW50IiwiY3JlYXRlTW9ja1Byb2dyZXNzU2VydmljZSIsInVwZGF0ZVVzZXJTdGF0cyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwidW5kZWZpbmVkIiwidXBzZXJ0Q2FyZFByb2dyZXNzIiwidXBkYXRlUHJvZ3Jlc3NUcmFuc2FjdGlvbiIsImNyZWF0ZVRlc3RVc2VyU3RhdHMiLCJ0b3RhbFBvc2l0aW9uc0NvbXBsZXRlZCIsIm92ZXJhbGxTdWNjZXNzUmF0ZSIsImNyZWF0ZVRlc3RDYXJkUHJvZ3Jlc3MiLCJpZCIsIm5leHRSZXZpZXdBdCIsIkRhdGUiLCJub3ciLCJsYXN0UmV2aWV3ZWRBdCIsImludGVydmFsIiwicmVwZXRpdGlvbiIsImVmYWN0b3IiLCJsYXBzZXMiLCJkZXNjcmliZSIsInVzZXJJZCIsIm1vY2tQcm9ncmVzc1NlcnZpY2UiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsImtleXMiLCJjbGVhckFsbFRpbWVycyIsInVzZUZha2VUaW1lcnMiLCJhZnRlckVhY2giLCJhY3QiLCJydW5Pbmx5UGVuZGluZ1RpbWVycyIsInVzZVJlYWxUaW1lcnMiLCJpdCIsInJlc3VsdCIsInJlbmRlckhvb2siLCJ1c2VQcm9ncmVzc1N5bmMiLCJzdGF0c1VwZGF0ZSIsImN1cnJlbnQiLCJzeW5jVXNlclN0YXRzIiwiZXhwZWN0IiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJ1c2VyU3RhdHMiLCJzeW5jU3RhdHVzIiwicGVuZGluZ0NvdW50IiwidG9CZSIsImlzRGVib3VuY2VkIiwiYWR2YW5jZVRpbWVyc0J5VGltZSIsIndhaXRGb3IiLCJjYXJkUHJvZ3Jlc3MiLCJzeW5jQ2FyZFByb2dyZXNzIiwiY2FyZFVwZGF0ZXMiLCJwb3NpdGlvbklkIiwicHJvZ3Jlc3MiLCJzeW5jQmF0Y2giLCJza2lwIiwibWF4UmV0cmllcyIsIm1vY2tSZWplY3RlZFZhbHVlT25jZSIsIkVycm9yIiwibW9ja1Jlc29sdmVkVmFsdWVPbmNlIiwidG9IYXZlQmVlbkNhbGxlZFRpbWVzIiwic3RhdHVzIiwibW9ja1JlamVjdGVkVmFsdWUiLCJ0aW1lb3V0Iiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsInNhdmVkUXVldWUiLCJ0b0JlVHJ1dGh5IiwicGFyc2VkUXVldWUiLCJKU09OIiwicGFyc2UiLCJ0b0hhdmVMZW5ndGgiLCJvcGVyYXRpb24iLCJ0eXBlIiwicXVldWVEYXRhIiwidXBkYXRlcyIsInRpbWVzdGFtcCIsInJldHJpZXMiLCJsYXN0QXR0ZW1wdCIsInN0cmluZ2lmeSIsImkiLCJ0b0JlTGVzc1RoYW5PckVxdWFsIiwiY2xlYXJRdWV1ZSIsIm1heEJhdGNoU2l6ZSIsInRvSGF2ZUJlZW5OdGhDYWxsZWRXaXRoIiwic2xpY2UiLCJkZWJvdW5jZU1zIiwiZW5hYmxlT3B0aW1pc3RpYyIsImZvcmNlU3luYyIsInJlc29sdmVGaXJzdCIsIm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsIm9yaWdpbmFsU2V0SXRlbSJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdD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