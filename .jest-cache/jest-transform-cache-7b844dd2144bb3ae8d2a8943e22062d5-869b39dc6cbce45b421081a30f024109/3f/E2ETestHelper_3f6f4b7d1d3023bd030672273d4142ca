37184fe8cb786c3117c14180b19e1faa
/**
 * @file E2E Test Helper for automated move execution
 * @module components/testing/E2ETestHelper
 * 
 * @description
 * Extracted from TrainingBoard to separate E2E testing concerns from business logic.
 * Handles automated move execution via URL parameters for E2E test scenarios.
 * 
 * @example
 * // URL: /train/position?moves=e2-e4,Nf3,d5
 * <E2ETestHelper 
 *   currentFen={fen} 
 *   isGameFinished={finished}
 *   onMove={handleMove}
 *   moveHistory={history}
 * />
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "E2ETestHelper", {
    enumerable: true,
    get: function() {
        return E2ETestHelper;
    }
});
const _react = require("react");
const _chess = require("chess.js");
const _ChessService = require("../../services/ChessService");
const _logging = require("../../services/logging");
const _constants = require("../../constants");
const E2ETestHelper = ({ currentFen, isGameFinished, onMove, moveHistory })=>{
    const [testMoveProcessed, setTestMoveProcessed] = (0, _react.useState)(false);
    (0, _react.useEffect)(()=>{
        if (typeof window !== "undefined" && !testMoveProcessed) {
            const urlParams = new URLSearchParams(window.location.search);
            const testMoves = urlParams.get("moves");
            // Debug logging
            const logger = (0, _logging.getLogger)().setContext("E2ETestHelper");
            logger.debug("URL check", {
                url: window.location.href,
                search: window.location.search,
                testMoves,
                gameReady: !!currentFen,
                isGameFinished,
                historyLength: moveHistory.length,
                testMoveProcessed
            });
            if (testMoves && currentFen && !isGameFinished) {
                setTestMoveProcessed(true);
                const moves = testMoves.split(",");
                let moveIndex = 0;
                logger.info("Starting automated moves", {
                    moves,
                    totalMoves: moves.length
                });
                /**
         * Recursively plays moves from URL parameter for automated testing
         *
         * @description
         * Internal function that processes a sequence of moves provided
         * via URL parameter. Supports multiple notation formats and
         * includes error recovery.
         *
         * @remarks
         * Moves are played with animation delays to simulate user interaction.
         * Failed moves are skipped and the sequence continues.
         */ const playNextMove = async ()=>{
                    if (moveIndex < moves.length) {
                        const moveNotation = moves[moveIndex];
                        logger.debug("Attempting move", {
                            moveIndex,
                            moveNotation,
                            currentHistoryLength: moveHistory.length
                        });
                        try {
                            // Parse move notation to standardized format
                            let move;
                            if (moveNotation.includes("-")) {
                                // Format: e2-e4
                                const [from, to] = moveNotation.split("-");
                                move = {
                                    from: from,
                                    to: to,
                                    promotion: "q"
                                };
                            } else {
                                // Format: e4 (SAN) - parse it properly
                                const tempGame = new _chess.Chess(_ChessService.chessService.getFen());
                                const parsedMove = tempGame.move(moveNotation);
                                if (parsedMove) {
                                    move = {
                                        from: parsedMove.from,
                                        to: parsedMove.to,
                                        promotion: parsedMove.promotion || "q"
                                    };
                                }
                            }
                            if (move) {
                                logger.debug("Move parsed successfully", {
                                    move
                                });
                                const result = await onMove(move);
                                if (result) {
                                    moveIndex++;
                                    logger.debug("Move executed successfully", {
                                        moveIndex,
                                        newHistoryLength: moveHistory.length
                                    });
                                    // Wait and then next move
                                    setTimeout(playNextMove, _constants.ANIMATION.MOVE_PLAY_DELAY_NORMAL);
                                } else {
                                    logger.warn("Move execution failed", {
                                        moveNotation
                                    });
                                    // Try next move
                                    moveIndex++;
                                    setTimeout(playNextMove, _constants.ANIMATION.MOVE_PLAY_DELAY_FAST);
                                }
                            } else {
                                logger.warn("Move parsing returned null", {
                                    moveNotation
                                });
                                // Try next move
                                moveIndex++;
                                setTimeout(playNextMove, _constants.ANIMATION.MOVE_PLAY_DELAY_FAST);
                            }
                        } catch (error) {
                            logger.error("Test move failed", error, {
                                moveNotation
                            });
                            // Try next move
                            moveIndex++;
                            setTimeout(playNextMove, _constants.ANIMATION.MOVE_PLAY_DELAY_FAST);
                        }
                    } else {
                        logger.info("Automated moves completed", {
                            finalMoveIndex: moveIndex,
                            finalHistoryLength: moveHistory.length
                        });
                    }
                };
                // Start after initial render
                setTimeout(playNextMove, _constants.ANIMATION.MOVE_PLAY_DELAY_SLOW);
            }
        }
    }, [
        currentFen,
        isGameFinished,
        onMove,
        testMoveProcessed,
        moveHistory
    ]);
    // Headless component - no rendering
    return null;
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL2NvbXBvbmVudHMvdGVzdGluZy9FMkVUZXN0SGVscGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIEUyRSBUZXN0IEhlbHBlciBmb3IgYXV0b21hdGVkIG1vdmUgZXhlY3V0aW9uXG4gKiBAbW9kdWxlIGNvbXBvbmVudHMvdGVzdGluZy9FMkVUZXN0SGVscGVyXG4gKiBcbiAqIEBkZXNjcmlwdGlvblxuICogRXh0cmFjdGVkIGZyb20gVHJhaW5pbmdCb2FyZCB0byBzZXBhcmF0ZSBFMkUgdGVzdGluZyBjb25jZXJucyBmcm9tIGJ1c2luZXNzIGxvZ2ljLlxuICogSGFuZGxlcyBhdXRvbWF0ZWQgbW92ZSBleGVjdXRpb24gdmlhIFVSTCBwYXJhbWV0ZXJzIGZvciBFMkUgdGVzdCBzY2VuYXJpb3MuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiAvLyBVUkw6IC90cmFpbi9wb3NpdGlvbj9tb3Zlcz1lMi1lNCxOZjMsZDVcbiAqIDxFMkVUZXN0SGVscGVyIFxuICogICBjdXJyZW50RmVuPXtmZW59IFxuICogICBpc0dhbWVGaW5pc2hlZD17ZmluaXNoZWR9XG4gKiAgIG9uTW92ZT17aGFuZGxlTW92ZX1cbiAqICAgbW92ZUhpc3Rvcnk9e2hpc3Rvcnl9XG4gKiAvPlxuICovXG5cbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDaGVzcyB9IGZyb20gJ2NoZXNzLmpzJztcbmltcG9ydCB7IGNoZXNzU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvQ2hlc3NTZXJ2aWNlJztcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2luZyc7XG5pbXBvcnQgeyBBTklNQVRJT04gfSBmcm9tICdAc2hhcmVkL2NvbnN0YW50cyc7XG5cbi8qKlxuICogUHJvcHMgZm9yIEUyRVRlc3RIZWxwZXIgY29tcG9uZW50XG4gKi9cbmludGVyZmFjZSBFMkVUZXN0SGVscGVyUHJvcHMge1xuICAvKiogQ3VycmVudCBwb3NpdGlvbiBpbiBGRU4gbm90YXRpb24gKi9cbiAgY3VycmVudEZlbjogc3RyaW5nO1xuICAvKiogV2hldGhlciB0aGUgZ2FtZSBoYXMgZmluaXNoZWQgKi9cbiAgaXNHYW1lRmluaXNoZWQ6IGJvb2xlYW47XG4gIC8qKiBDYWxsYmFjayB0byBleGVjdXRlIG1vdmVzIC0gc2hvdWxkIG1hdGNoIFRyYWluaW5nQm9hcmQncyBoYW5kbGVNb3ZlIHNpZ25hdHVyZSAqL1xuICBvbk1vdmU6IChtb3ZlOiBhbnkpID0+IFByb21pc2U8Ym9vbGVhbiB8IG51bGw+O1xuICAvKiogTW92ZSBoaXN0b3J5IGZvciBsb2dnaW5nL2RlYnVnZ2luZyAqL1xuICBtb3ZlSGlzdG9yeTogYW55W107XG59XG5cbi8qKlxuICogRTJFIFRlc3QgSGVscGVyIENvbXBvbmVudFxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGV4ZWN1dGVzIG1vdmVzIGZyb20gVVJMIHBhcmFtZXRlcnMgZm9yIEUyRSB0ZXN0aW5nLlxuICogT25seSBhY3RpdmF0ZXMgd2hlbiBcIm1vdmVzXCIgcGFyYW1ldGVyIGlzIHByZXNlbnQgaW4gVVJMLlxuICogXG4gKiBAcGFyYW0gcHJvcHMgQ29uZmlndXJhdGlvbiBmb3IgYXV0b21hdGVkIHRlc3QgZXhlY3V0aW9uXG4gKiBAcmV0dXJucyBudWxsIChoZWFkbGVzcyBjb21wb25lbnQgZm9yIHNpZGUgZWZmZWN0cyBvbmx5KVxuICogXG4gKiBAcmVtYXJrc1xuICogVGhpcyBjb21wb25lbnQ6XG4gKiAtIFBhcnNlcyBtb3ZlcyBmcm9tIFVSTCBwYXJhbWV0ZXIgXCJtb3Zlc1wiIChjb21tYS1zZXBhcmF0ZWQpXG4gKiAtIFN1cHBvcnRzIG11bHRpcGxlIG5vdGF0aW9uIGZvcm1hdHMgKGUyLWU0LCBlNCwgTmYzKVxuICogLSBJbmNsdWRlcyBlcnJvciByZWNvdmVyeSAoc2tpcHMgaW52YWxpZCBtb3ZlcylcbiAqIC0gVXNlcyBkZWxheXMgdG8gc2ltdWxhdGUgcmVhbGlzdGljIHVzZXIgaW50ZXJhY3Rpb25cbiAqIC0gUHJvdmlkZXMgY29tcHJlaGVuc2l2ZSBsb2dnaW5nIGZvciB0ZXN0IGRlYnVnZ2luZ1xuICogXG4gKiBVUkwgRm9ybWF0OiA/bW92ZXM9ZTItZTQsTmYzLGQ1XG4gKiBNb3ZlIEZvcm1hdHMgU3VwcG9ydGVkOlxuICogLSBDb29yZGluYXRlIG5vdGF0aW9uOiBlMi1lNCwgZzEtZjNcbiAqIC0gU0FOIG5vdGF0aW9uOiBlNCwgTmYzLCBPLU9cbiAqIC0gQXV0by1wcm9tb3Rpb24gdG8gUXVlZW4gZm9yIHBhd24gbW92ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IEUyRVRlc3RIZWxwZXI6IFJlYWN0LkZDPEUyRVRlc3RIZWxwZXJQcm9wcz4gPSAoe1xuICBjdXJyZW50RmVuLFxuICBpc0dhbWVGaW5pc2hlZCxcbiAgb25Nb3ZlLFxuICBtb3ZlSGlzdG9yeSxcbn0pID0+IHtcbiAgY29uc3QgW3Rlc3RNb3ZlUHJvY2Vzc2VkLCBzZXRUZXN0TW92ZVByb2Nlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhdGVzdE1vdmVQcm9jZXNzZWQpIHtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICBjb25zdCB0ZXN0TW92ZXMgPSB1cmxQYXJhbXMuZ2V0KFwibW92ZXNcIik7XG5cbiAgICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpLnNldENvbnRleHQoXCJFMkVUZXN0SGVscGVyXCIpO1xuICAgICAgbG9nZ2VyLmRlYnVnKFwiVVJMIGNoZWNrXCIsIHtcbiAgICAgICAgdXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgc2VhcmNoOiB3aW5kb3cubG9jYXRpb24uc2VhcmNoLFxuICAgICAgICB0ZXN0TW92ZXMsXG4gICAgICAgIGdhbWVSZWFkeTogISFjdXJyZW50RmVuLFxuICAgICAgICBpc0dhbWVGaW5pc2hlZCxcbiAgICAgICAgaGlzdG9yeUxlbmd0aDogbW92ZUhpc3RvcnkubGVuZ3RoLFxuICAgICAgICB0ZXN0TW92ZVByb2Nlc3NlZCxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGVzdE1vdmVzICYmIGN1cnJlbnRGZW4gJiYgIWlzR2FtZUZpbmlzaGVkKSB7XG4gICAgICAgIHNldFRlc3RNb3ZlUHJvY2Vzc2VkKHRydWUpO1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRlc3RNb3Zlcy5zcGxpdChcIixcIik7XG4gICAgICAgIGxldCBtb3ZlSW5kZXggPSAwO1xuXG4gICAgICAgIGxvZ2dlci5pbmZvKFwiU3RhcnRpbmcgYXV0b21hdGVkIG1vdmVzXCIsIHtcbiAgICAgICAgICBtb3ZlcyxcbiAgICAgICAgICB0b3RhbE1vdmVzOiBtb3Zlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWN1cnNpdmVseSBwbGF5cyBtb3ZlcyBmcm9tIFVSTCBwYXJhbWV0ZXIgZm9yIGF1dG9tYXRlZCB0ZXN0aW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IHByb2Nlc3NlcyBhIHNlcXVlbmNlIG9mIG1vdmVzIHByb3ZpZGVkXG4gICAgICAgICAqIHZpYSBVUkwgcGFyYW1ldGVyLiBTdXBwb3J0cyBtdWx0aXBsZSBub3RhdGlvbiBmb3JtYXRzIGFuZFxuICAgICAgICAgKiBpbmNsdWRlcyBlcnJvciByZWNvdmVyeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlbWFya3NcbiAgICAgICAgICogTW92ZXMgYXJlIHBsYXllZCB3aXRoIGFuaW1hdGlvbiBkZWxheXMgdG8gc2ltdWxhdGUgdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICogRmFpbGVkIG1vdmVzIGFyZSBza2lwcGVkIGFuZCB0aGUgc2VxdWVuY2UgY29udGludWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGxheU5leHRNb3ZlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChtb3ZlSW5kZXggPCBtb3Zlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVOb3RhdGlvbiA9IG1vdmVzW21vdmVJbmRleF07XG5cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkF0dGVtcHRpbmcgbW92ZVwiLCB7XG4gICAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgICAgbW92ZU5vdGF0aW9uLFxuICAgICAgICAgICAgICBjdXJyZW50SGlzdG9yeUxlbmd0aDogbW92ZUhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlIG1vdmUgbm90YXRpb24gdG8gc3RhbmRhcmRpemVkIGZvcm1hdFxuICAgICAgICAgICAgICBsZXQgbW92ZTtcbiAgICAgICAgICAgICAgaWYgKG1vdmVOb3RhdGlvbi5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3JtYXQ6IGUyLWU0XG4gICAgICAgICAgICAgICAgY29uc3QgW2Zyb20sIHRvXSA9IG1vdmVOb3RhdGlvbi5zcGxpdChcIi1cIik7XG4gICAgICAgICAgICAgICAgbW92ZSA9IHtcbiAgICAgICAgICAgICAgICAgIGZyb206IGZyb20sXG4gICAgICAgICAgICAgICAgICB0bzogdG8sXG4gICAgICAgICAgICAgICAgICBwcm9tb3Rpb246IFwicVwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9ybWF0OiBlNCAoU0FOKSAtIHBhcnNlIGl0IHByb3Blcmx5XG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcEdhbWUgPSBuZXcgQ2hlc3MoY2hlc3NTZXJ2aWNlLmdldEZlbigpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRNb3ZlID0gdGVtcEdhbWUubW92ZShtb3ZlTm90YXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRNb3ZlKSB7XG4gICAgICAgICAgICAgICAgICBtb3ZlID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBwYXJzZWRNb3ZlLmZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvOiBwYXJzZWRNb3ZlLnRvLFxuICAgICAgICAgICAgICAgICAgICBwcm9tb3Rpb246IHBhcnNlZE1vdmUucHJvbW90aW9uIHx8IFwicVwiLFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIk1vdmUgcGFyc2VkIHN1Y2Nlc3NmdWxseVwiLCB7IG1vdmUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb25Nb3ZlKG1vdmUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgbW92ZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJNb3ZlIGV4ZWN1dGVkIHN1Y2Nlc3NmdWxseVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmV3SGlzdG9yeUxlbmd0aDogbW92ZUhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFdhaXQgYW5kIHRoZW4gbmV4dCBtb3ZlXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHBsYXlOZXh0TW92ZSwgQU5JTUFUSU9OLk1PVkVfUExBWV9ERUxBWV9OT1JNQUwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcIk1vdmUgZXhlY3V0aW9uIGZhaWxlZFwiLCB7IG1vdmVOb3RhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICAgIC8vIFRyeSBuZXh0IG1vdmVcbiAgICAgICAgICAgICAgICAgIG1vdmVJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChwbGF5TmV4dE1vdmUsIEFOSU1BVElPTi5NT1ZFX1BMQVlfREVMQVlfRkFTVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTW92ZSBwYXJzaW5nIHJldHVybmVkIG51bGxcIiwgeyBtb3ZlTm90YXRpb24gfSk7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IG5leHQgbW92ZVxuICAgICAgICAgICAgICAgIG1vdmVJbmRleCsrO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocGxheU5leHRNb3ZlLCBBTklNQVRJT04uTU9WRV9QTEFZX0RFTEFZX0ZBU1QpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoXCJUZXN0IG1vdmUgZmFpbGVkXCIsIGVycm9yLCB7IG1vdmVOb3RhdGlvbiB9KTtcbiAgICAgICAgICAgICAgLy8gVHJ5IG5leHQgbW92ZVxuICAgICAgICAgICAgICBtb3ZlSW5kZXgrKztcbiAgICAgICAgICAgICAgc2V0VGltZW91dChwbGF5TmV4dE1vdmUsIEFOSU1BVElPTi5NT1ZFX1BMQVlfREVMQVlfRkFTVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5pbmZvKFwiQXV0b21hdGVkIG1vdmVzIGNvbXBsZXRlZFwiLCB7XG4gICAgICAgICAgICAgIGZpbmFsTW92ZUluZGV4OiBtb3ZlSW5kZXgsXG4gICAgICAgICAgICAgIGZpbmFsSGlzdG9yeUxlbmd0aDogbW92ZUhpc3RvcnkubGVuZ3RoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN0YXJ0IGFmdGVyIGluaXRpYWwgcmVuZGVyXG4gICAgICAgIHNldFRpbWVvdXQocGxheU5leHRNb3ZlLCBBTklNQVRJT04uTU9WRV9QTEFZX0RFTEFZX1NMT1cpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2N1cnJlbnRGZW4sIGlzR2FtZUZpbmlzaGVkLCBvbk1vdmUsIHRlc3RNb3ZlUHJvY2Vzc2VkLCBtb3ZlSGlzdG9yeV0pO1xuXG4gIC8vIEhlYWRsZXNzIGNvbXBvbmVudCAtIG5vIHJlbmRlcmluZ1xuICByZXR1cm4gbnVsbDtcbn07Il0sIm5hbWVzIjpbIkUyRVRlc3RIZWxwZXIiLCJjdXJyZW50RmVuIiwiaXNHYW1lRmluaXNoZWQiLCJvbk1vdmUiLCJtb3ZlSGlzdG9yeSIsInRlc3RNb3ZlUHJvY2Vzc2VkIiwic2V0VGVzdE1vdmVQcm9jZXNzZWQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIndpbmRvdyIsInVybFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImxvY2F0aW9uIiwic2VhcmNoIiwidGVzdE1vdmVzIiwiZ2V0IiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImRlYnVnIiwidXJsIiwiaHJlZiIsImdhbWVSZWFkeSIsImhpc3RvcnlMZW5ndGgiLCJsZW5ndGgiLCJtb3ZlcyIsInNwbGl0IiwibW92ZUluZGV4IiwiaW5mbyIsInRvdGFsTW92ZXMiLCJwbGF5TmV4dE1vdmUiLCJtb3ZlTm90YXRpb24iLCJjdXJyZW50SGlzdG9yeUxlbmd0aCIsIm1vdmUiLCJpbmNsdWRlcyIsImZyb20iLCJ0byIsInByb21vdGlvbiIsInRlbXBHYW1lIiwiQ2hlc3MiLCJjaGVzc1NlcnZpY2UiLCJnZXRGZW4iLCJwYXJzZWRNb3ZlIiwicmVzdWx0IiwibmV3SGlzdG9yeUxlbmd0aCIsInNldFRpbWVvdXQiLCJBTklNQVRJT04iLCJNT1ZFX1BMQVlfREVMQVlfTk9STUFMIiwid2FybiIsIk1PVkVfUExBWV9ERUxBWV9GQVNUIiwiZXJyb3IiLCJmaW5hbE1vdmVJbmRleCIsImZpbmFsSGlzdG9yeUxlbmd0aCIsIk1PVkVfUExBWV9ERUxBWV9TTE9XIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQzs7OzsrQkE2Q1lBOzs7ZUFBQUE7Ozt1QkEzQ3VCO3VCQUNkOzhCQUNPO3lCQUNIOzJCQUNBO0FBdUNuQixNQUFNQSxnQkFBOEMsQ0FBQyxFQUMxREMsVUFBVSxFQUNWQyxjQUFjLEVBQ2RDLE1BQU0sRUFDTkMsV0FBVyxFQUNaO0lBQ0MsTUFBTSxDQUFDQyxtQkFBbUJDLHFCQUFxQixHQUFHQyxJQUFBQSxlQUFRLEVBQUM7SUFFM0RDLElBQUFBLGdCQUFTLEVBQUM7UUFDUixJQUFJLE9BQU9DLFdBQVcsZUFBZSxDQUFDSixtQkFBbUI7WUFDdkQsTUFBTUssWUFBWSxJQUFJQyxnQkFBZ0JGLE9BQU9HLFFBQVEsQ0FBQ0MsTUFBTTtZQUM1RCxNQUFNQyxZQUFZSixVQUFVSyxHQUFHLENBQUM7WUFFaEMsZ0JBQWdCO1lBQ2hCLE1BQU1DLFNBQVNDLElBQUFBLGtCQUFTLElBQUdDLFVBQVUsQ0FBQztZQUN0Q0YsT0FBT0csS0FBSyxDQUFDLGFBQWE7Z0JBQ3hCQyxLQUFLWCxPQUFPRyxRQUFRLENBQUNTLElBQUk7Z0JBQ3pCUixRQUFRSixPQUFPRyxRQUFRLENBQUNDLE1BQU07Z0JBQzlCQztnQkFDQVEsV0FBVyxDQUFDLENBQUNyQjtnQkFDYkM7Z0JBQ0FxQixlQUFlbkIsWUFBWW9CLE1BQU07Z0JBQ2pDbkI7WUFDRjtZQUVBLElBQUlTLGFBQWFiLGNBQWMsQ0FBQ0MsZ0JBQWdCO2dCQUM5Q0kscUJBQXFCO2dCQUNyQixNQUFNbUIsUUFBUVgsVUFBVVksS0FBSyxDQUFDO2dC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