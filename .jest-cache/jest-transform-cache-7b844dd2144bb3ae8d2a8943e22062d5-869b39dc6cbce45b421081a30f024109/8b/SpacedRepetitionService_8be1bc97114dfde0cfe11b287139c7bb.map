{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/SpacedRepetitionService.ts"],"sourcesContent":["/**\n * @file SpacedRepetitionService\n * @description Pure computation service for spaced repetition using SuperMemo-2 algorithm\n * \n * This service provides stateless functions for managing spaced repetition scheduling.\n * It uses the supermemo npm package for algorithm implementation and provides\n * utility functions for chess training specific needs.\n * \n * @example\n * ```typescript\n * // Update card after review\n * const updatedCard = updateCardProgress(card, mapBinaryToQuality(true));\n * \n * // Get cards due for review\n * const dueCards = getDueCards(allCards);\n * \n * // Create new card\n * const newCard = createNewCard('position-123');\n * ```\n */\n\nimport { supermemo } from 'supermemo';\nimport type { CardProgress } from '@shared/store/slices/types';\nimport { getLogger } from '@shared/services/logging/Logger';\nimport { filterDueCards, type DueCard } from '@shared/types/progress';\n\nconst logger = getLogger().setContext('SpacedRepetitionService');\n\n/**\n * Maps binary correct/incorrect to SuperMemo quality scale (0-5)\n * \n * Quality scale:\n * - 0: Complete blackout, wrong response\n * - 1: Incorrect response, but remembered upon seeing answer\n * - 2: Incorrect, but close/easy to recall\n * - 3: Correct but with difficulty\n * - 4: Correct after hesitation\n * - 5: Perfect response\n * \n * For chess moves, we use conservative mapping:\n * - Incorrect → 0 (reset interval)\n * - Correct → 4 (good but not perfect, allows steady progress)\n * \n * @param correct - Whether the move was correct\n * @returns Quality value for SuperMemo algorithm\n */\nexport function mapBinaryToQuality(correct: boolean): number {\n  return correct ? 4 : 0;\n}\n\n/**\n * Maps move quality assessment to SuperMemo quality scale\n * Allows for more nuanced quality assessment in future\n * \n * @param quality - Move quality assessment\n * @returns Quality value for SuperMemo algorithm (0-5)\n */\nexport function mapMoveQualityToSM2(quality: 'fail' | 'hard' | 'good' | 'easy'): number {\n  switch (quality) {\n    case 'fail': return 0;\n    case 'hard': return 3;\n    case 'good': return 4;\n    case 'easy': return 5;\n    default: return 4; // Safe default\n  }\n}\n\n/**\n * Updates card progress using SuperMemo-2 algorithm\n * \n * @param card - Current card state\n * @param quality - Review quality (0-5)\n * @param now - Current timestamp (defaults to Date.now())\n * @returns Updated card with new scheduling\n * @throws Error if quality is out of bounds\n */\nexport function updateCardProgress(\n  card: CardProgress,\n  quality: number,\n  now: number = Date.now()\n): CardProgress {\n  // Validate quality parameter\n  if (quality < 0 || quality > 5) {\n    logger.error('Invalid quality value', { quality, cardId: card.id });\n    throw new Error(`Quality must be between 0 and 5, got ${quality}`);\n  }\n\n  logger.debug('Updating card progress', {\n    cardId: card.id,\n    quality,\n    oldInterval: card.interval,\n    oldEfactor: card.efactor,\n  });\n\n  // Call SuperMemo algorithm - expects item object and grade\n  const result = supermemo(\n    {\n      interval: card.interval,\n      repetition: card.repetition,\n      efactor: card.efactor,\n    },\n    quality as any // Type cast to avoid strict type checking issues\n  );\n  \n  // Handle potential NaN from supermemo library\n  const interval = isNaN(result.interval) ? 1 : result.interval;\n  const efactor = isNaN(result.efactor) ? 2.5 : result.efactor;\n  const repetition = isNaN(result.repetition) ? 0 : result.repetition;\n\n  // Calculate next review date (interval is in days)\n  const nextReviewAt = now + (interval * 86400000); // Convert days to milliseconds\n\n  const updatedCard: CardProgress = {\n    ...card,\n    interval,\n    repetition,\n    efactor,\n    lapses: quality === 0 ? card.lapses + 1 : card.lapses,\n    lastReviewedAt: now,\n    nextReviewAt,\n  };\n\n  logger.debug('Card progress updated', {\n    cardId: card.id,\n    newInterval: interval,\n    newEfactor: efactor,\n    nextReviewDate: new Date(nextReviewAt).toISOString(),\n  });\n\n  return updatedCard;\n}\n\n/**\n * Filters cards that are due for review\n * \n * @param cards - Array of card progress objects\n * @param now - Current timestamp (defaults to Date.now())\n * @returns Array of cards due for review\n */\nexport function getDueCards(\n  cards: CardProgress[],\n  now: number = Date.now()\n): CardProgress[] {\n  return cards.filter(card => card.nextReviewAt <= now);\n}\n\n/**\n * Gets cards due for review from a record/map structure\n * \n * @param cardMap - Record of card IDs to CardProgress\n * @param now - Current timestamp (defaults to Date.now())\n * @returns Array of cards due for review\n */\nexport function getDueCardsFromMap(\n  cardMap: Record<string, CardProgress>,\n  now: number = Date.now()\n): CardProgress[] {\n  return getDueCards(Object.values(cardMap), now);\n}\n\n/**\n * Gets cards due for review with branded types (NEW - Enhanced Version)\n * \n * Type-safe version that returns DueCard branded objects.\n * Provides better type safety and leverages optimized filterDueCards implementation.\n * \n * @param cardMap - Record of card IDs to CardProgress\n * @param now - Current timestamp (defaults to Date.now())\n * @returns Array of type-safe DueCard objects\n * \n * @example\n * ```typescript\n * const dueCards: DueCard[] = getDueCardsWithBranding(cardProgress);\n * // TypeScript knows these are validated due cards\n * dueCards.forEach(card => processCard(card));\n * ```\n */\nexport function getDueCardsWithBranding(\n  cardMap: Record<string, CardProgress>,\n  now: number = Date.now()\n): DueCard[] {\n  return filterDueCards(Object.values(cardMap), now);\n}\n\n/**\n * Creates a new card with initial spaced repetition values\n * \n * @param id - Unique identifier for the card\n * @param now - Current timestamp (defaults to Date.now())\n * @returns New card with default SM-2 values\n */\nexport function createNewCard(\n  id: string,\n  now: number = Date.now()\n): CardProgress {\n  return {\n    id,\n    nextReviewAt: now, // Immediately due for first review\n    lastReviewedAt: 0,\n    interval: 0,\n    repetition: 0,\n    efactor: 2.5, // SM-2 default ease factor\n    lapses: 0,\n  };\n}\n\n/**\n * Resets card progress to initial state\n * Preserves the card ID and optionally other fields\n * \n * @param base - Card with ID and optional fields to preserve\n * @returns Reset card with default SM-2 values\n */\nexport function resetCardProgress(\n  base: Pick<CardProgress, 'id'> & Partial<CardProgress>\n): CardProgress {\n  return {\n    nextReviewAt: 0,\n    lastReviewedAt: 0,\n    interval: 0,\n    repetition: 0,\n    efactor: 2.5,\n    lapses: 0,\n    ...base, // ID and any overrides\n  };\n}\n\n/**\n * Batch updates multiple cards\n * Useful for bulk operations and performance optimization\n * \n * @param cards - Array of cards to update\n * @param results - Map of card ID to review result (quality)\n * @param now - Current timestamp\n * @returns Updated cards array\n */\nexport function batchUpdateCards(\n  cards: CardProgress[],\n  results: Record<string, number>,\n  now: number = Date.now()\n): CardProgress[] {\n  return cards.map(card => {\n    const quality = results[card.id];\n    if (quality === undefined) {\n      return card; // No update for this card\n    }\n    return updateCardProgress(card, quality, now);\n  });\n}\n\n/**\n * Calculates statistics for a set of cards\n * \n * @param cards - Array of card progress objects\n * @param now - Current timestamp\n * @returns Statistics object\n */\nexport function calculateCardStatistics(\n  cards: CardProgress[],\n  now: number = Date.now()\n) {\n  const dueCards = getDueCards(cards, now);\n  const totalCards = cards.length;\n  const masteredCards = cards.filter(c => c.interval >= 21).length; // 3+ weeks\n  const learningCards = cards.filter(c => c.interval > 0 && c.interval < 21).length;\n  const newCards = cards.filter(c => c.repetition === 0).length;\n  const averageEfactor = cards.reduce((sum, c) => sum + c.efactor, 0) / totalCards || 2.5;\n  const totalLapses = cards.reduce((sum, c) => sum + c.lapses, 0);\n\n  return {\n    totalCards,\n    dueCards: dueCards.length,\n    masteredCards,\n    learningCards,\n    newCards,\n    averageEfactor,\n    totalLapses,\n    duePercentage: totalCards > 0 ? (dueCards.length / totalCards) * 100 : 0,\n  };\n}\n\n/**\n * Determines if a card should be considered \"difficult\"\n * Based on ease factor and lapse count\n * \n * @param card - Card to evaluate\n * @returns True if card is difficult\n */\nexport function isCardDifficult(card: CardProgress): boolean {\n  return card.efactor < 2.0 || card.lapses > 3;\n}\n\n/**\n * Sorts cards by review priority\n * Most overdue cards first\n * \n * @param cards - Array of cards to sort\n * @param now - Current timestamp\n * @returns Sorted array (most urgent first)\n */\nexport function sortByReviewPriority(\n  cards: CardProgress[],\n  now: number = Date.now()\n): CardProgress[] {\n  return [...cards].sort((a, b) => {\n    // Both overdue: most overdue first\n    if (a.nextReviewAt <= now && b.nextReviewAt <= now) {\n      return a.nextReviewAt - b.nextReviewAt;\n    }\n    // One overdue: overdue first\n    if (a.nextReviewAt <= now) return -1;\n    if (b.nextReviewAt <= now) return 1;\n    // Neither overdue: soonest first\n    return a.nextReviewAt - b.nextReviewAt;\n  });\n}"],"names":["batchUpdateCards","calculateCardStatistics","createNewCard","getDueCards","getDueCardsFromMap","getDueCardsWithBranding","isCardDifficult","mapBinaryToQuality","mapMoveQualityToSM2","resetCardProgress","sortByReviewPriority","updateCardProgress","logger","getLogger","setContext","correct","quality","card","now","Date","error","cardId","id","Error","debug","oldInterval","interval","oldEfactor","efactor","result","supermemo","repetition","isNaN","nextReviewAt","updatedCard","lapses","lastReviewedAt","newInterval","newEfactor","nextReviewDate","toISOString","cards","filter","cardMap","Object","values","filterDueCards","base","results","map","undefined","dueCards","totalCards","length","masteredCards","c","learningCards","newCards","averageEfactor","reduce","sum","totalLapses","duePercentage","sort","a","b"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;CAmBC;;;;;;;;;;;QAyNeA;eAAAA;;QAqBAC;eAAAA;;QAlEAC;eAAAA;;QApDAC;eAAAA;;QAcAC;eAAAA;;QAwBAC;eAAAA;;QA+GAC;eAAAA;;QAlPAC;eAAAA;;QAWAC;eAAAA;;QA4JAC;eAAAA;;QAuFAC;eAAAA;;QAhOAC;eAAAA;;;2BAvDU;wBAEA;0BACmB;AAE7C,MAAMC,SAASC,IAAAA,iBAAS,IAAGC,UAAU,CAAC;AAoB/B,SAASP,mBAAmBQ,OAAgB;IACjD,OAAOA,UAAU,IAAI;AACvB;AASO,SAASP,oBAAoBQ,OAA0C;IAC5E,OAAQA;QACN,KAAK;YAAQ,OAAO;QACpB,KAAK;YAAQ,OAAO;QACpB,KAAK;YAAQ,OAAO;QACpB,KAAK;YAAQ,OAAO;QACpB;YAAS,OAAO,GAAG,eAAe;IACpC;AACF;AAWO,SAASL,mBACdM,IAAkB,EAClBD,OAAe,EACfE,MAAcC,KAAKD,GAAG,EAAE;IAExB,6BAA6B;IAC7B,IAAIF,UAAU,KAAKA,UAAU,GAAG;QAC9BJ,OAAOQ,KAAK,CAAC,yBAAyB;YAAEJ;YAASK,QAAQJ,KAAKK,EAAE;QAAC;QACjE,MAAM,IAAIC,MAAM,CAAC,qCAAqC,EAAEP,SAAS;IACnE;IAEAJ,OAAOY,KAAK,CAAC,0BAA0B;QACrCH,QAAQJ,KAAKK,EAAE;QACfN;QACAS,aAAaR,KAAKS,QAAQ;QAC1BC,YAAYV,KAAKW,OAAO;IAC1B;IAEA,2DAA2D;IAC3D,MAAMC,SAASC,IAAAA,oBAAS,EACtB;QACEJ,UAAUT,KAAKS,QAAQ;QACvBK,YAAYd,KAAKc,UAAU;QAC3BH,SAASX,KAAKW,OAAO;IACvB,GACAZ;IAGF,8CAA8C;IAC9C,MAAMU,WAAWM,MAAMH,OAAOH,QAAQ,IAAI,IAAIG,OAAOH,QAAQ;IAC7D,MAAME,UAAUI,MAAMH,OAAOD,OAAO,IAAI,MAAMC,OAAOD,OAAO;IAC5D,MAAMG,aAAaC,MAAMH,OAAOE,UAAU,IAAI,IAAIF,OAAOE,UAAU;IAEnE,mDAAmD;IACnD,MAAME,eAAef,MAAOQ,WAAW,UAAW,+BAA+B;IAEjF,MAAMQ,cAA4B;QAChC,GAAGjB,IAAI;QACPS;QACAK;QACAH;QACAO,QAAQnB,YAAY,IAAIC,KAAKkB,MAAM,GAAG,IAAIlB,KAAKkB,MAAM;QACrDC,gBAAgBlB;QAChBe;IACF;IAEArB,OAAOY,KAAK,CAAC,yBAAyB;QACpCH,QAAQJ,KAAKK,EAAE;QACfe,aAAaX;QACbY,YAAYV;QACZW,gBAAgB,IAAIpB,KAAKc,cAAcO,WAAW;IACpD;IAEA,OAAON;AACT;AASO,SAAS/B,YACdsC,KAAqB,EACrBvB,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAOuB,MAAMC,MAAM,CAACzB,CAAAA,OAAQA,KAAKgB,YAAY,IAAIf;AACnD;AASO,SAASd,mBACduC,OAAqC,EACrCzB,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAOf,YAAYyC,OAAOC,MAAM,CAACF,UAAUzB;AAC7C;AAmBO,SAASb,wBACdsC,OAAqC,EACrCzB,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAO4B,IAAAA,wBAAc,EAACF,OAAOC,MAAM,CAACF,UAAUzB;AAChD;AASO,SAAShB,cACdoB,EAAU,EACVJ,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAO;QACLI;QACAW,cAAcf;QACdkB,gBAAgB;QAChBV,UAAU;QACVK,YAAY;QACZH,SAAS;QACTO,QAAQ;IACV;AACF;AASO,SAAS1B,kBACdsC,IAAsD;IAEtD,OAAO;QACLd,cAAc;QACdG,gBAAgB;QAChBV,UAAU;QACVK,YAAY;QACZH,SAAS;QACTO,QAAQ;QACR,GAAGY,IAAI;IACT;AACF;AAWO,SAAS/C,iBACdyC,KAAqB,EACrBO,OAA+B,EAC/B9B,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAOuB,MAAMQ,GAAG,CAAChC,CAAAA;QACf,MAAMD,UAAUgC,OAAO,CAAC/B,KAAKK,EAAE,CAAC;QAChC,IAAIN,YAAYkC,WAAW;YACzB,OAAOjC,MAAM,0BAA0B;QACzC;QACA,OAAON,mBAAmBM,MAAMD,SAASE;IAC3C;AACF;AASO,SAASjB,wBACdwC,KAAqB,EACrBvB,MAAcC,KAAKD,GAAG,EAAE;IAExB,MAAMiC,WAAWhD,YAAYsC,OAAOvB;IACpC,MAAMkC,aAAaX,MAAMY,MAAM;IAC/B,MAAMC,gBAAgBb,MAAMC,MAAM,CAACa,CAAAA,IAAKA,EAAE7B,QAAQ,IAAI,IAAI2B,MAAM,EAAE,WAAW;IAC7E,MAAMG,gBAAgBf,MAAMC,MAAM,CAACa,CAAAA,IAAKA,EAAE7B,QAAQ,GAAG,KAAK6B,EAAE7B,QAAQ,GAAG,IAAI2B,MAAM;IACjF,MAAMI,WAAWhB,MAAMC,MAAM,CAACa,CAAAA,IAAKA,EAAExB,UAAU,KAAK,GAAGsB,MAAM;IAC7D,MAAMK,iBAAiBjB,MAAMkB,MAAM,CAAC,CAACC,KAAKL,IAAMK,MAAML,EAAE3B,OAAO,EAAE,KAAKwB,cAAc;IACpF,MAAMS,cAAcpB,MAAMkB,MAAM,CAAC,CAACC,KAAKL,IAAMK,MAAML,EAAEpB,MAAM,EAAE;IAE7D,OAAO;QACLiB;QACAD,UAAUA,SAASE,MAAM;QACzBC;QACAE;QACAC;QACAC;QACAG;QACAC,eAAeV,aAAa,IAAI,AAACD,SAASE,MAAM,GAAGD,aAAc,MAAM;IACzE;AACF;AASO,SAAS9C,gBAAgBW,IAAkB;IAChD,OAAOA,KAAKW,OAAO,GAAG,OAAOX,KAAKkB,MAAM,GAAG;AAC7C;AAUO,SAASzB,qBACd+B,KAAqB,EACrBvB,MAAcC,KAAKD,GAAG,EAAE;IAExB,OAAO;WAAIuB;KAAM,CAACsB,IAAI,CAAC,CAACC,GAAGC;QACzB,mCAAmC;QACnC,IAAID,EAAE/B,YAAY,IAAIf,OAAO+C,EAAEhC,YAAY,IAAIf,KAAK;YAClD,OAAO8C,EAAE/B,YAAY,GAAGgC,EAAEhC,YAAY;QACxC;QACA,6BAA6B;QAC7B,IAAI+B,EAAE/B,YAAY,IAAIf,KAAK,OAAO,CAAC;QACnC,IAAI+C,EAAEhC,YAAY,IAAIf,KAAK,OAAO;QAClC,iCAAiC;QACjC,OAAO8C,EAAE/B,YAAY,GAAGgC,EAAEhC,YAAY;IACxC;AACF"}