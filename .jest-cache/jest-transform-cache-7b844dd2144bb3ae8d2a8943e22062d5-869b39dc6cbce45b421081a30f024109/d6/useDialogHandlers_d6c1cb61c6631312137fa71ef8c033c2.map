{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/hooks/useDialogHandlers.ts"],"sourcesContent":["/**\n * @file Dialog handlers hook for chess training board\n * @module hooks/useDialogHandlers\n * \n * @description\n * Custom hook that encapsulates all dialog handling logic for chess training.\n * Extracted from TrainingBoard to separate dialog business logic from UI coordination.\n * Handles error dialogs, success dialogs, and training workflow actions.\n * \n * @remarks\n * Key responsibilities:\n * - Move error dialog actions (take back, restart, continue, show best move)\n * - Move success dialog actions (close, continue)\n * - Training session reset coordination\n * - Complex opponent turn scheduling and cancellation\n * - Comprehensive logging and state coordination\n * \n * This hook maintains all the complex business logic while providing\n * a clean interface for dialog action coordination.\n * \n * @example\n * ```tsx\n * const dialogHandlers = useDialogHandlers({\n *   undoMove,\n *   resetGame,\n *   clearEvaluations,\n *   trainingActions,\n *   gameActions,\n *   uiActions,\n *   trainingState,\n *   storeApi,\n *   trainingUIState,\n * });\n * \n * <DialogManager\n *   errorDialog={trainingState.moveErrorDialog}\n *   successDialog={trainingState.moveSuccessDialog}\n *   onErrorTakeBack={dialogHandlers.handleMoveErrorTakeBack}\n *   onErrorRestart={dialogHandlers.handleMoveErrorRestart}\n *   onErrorContinue={dialogHandlers.handleMoveErrorContinue}\n *   onErrorShowBestMove={dialogHandlers.handleShowBestMove}\n *   onSuccessClose={dialogHandlers.handleMoveSuccessClose}\n *   onSuccessContinue={dialogHandlers.handleMoveSuccessContinue}\n * />\n * ```\n */\n\nimport { useCallback } from 'react';\nimport { getLogger } from '@shared/services/logging/Logger';\nimport {\n  cancelScheduledOpponentTurn,\n  scheduleOpponentTurn,\n} from '@shared/store/orchestrators/handlePlayerMove';\nimport { chessService } from '@shared/services/ChessService';\nimport { tablebaseService } from '@shared/services/TablebaseService';\nimport type { StoreApi } from '@shared/store/StoreContext';\n\n/**\n * Training actions interface (subset needed for dialog handling)\n */\ninterface TrainingActionsSubset {\n  setPlayerTurn: (isPlayerTurn: boolean) => void;\n  clearOpponentThinking: () => void;\n  setMoveErrorDialog: (dialog: any) => void;\n  setMoveSuccessDialog: (dialog: any) => void;\n  setEvaluationBaseline: (wdl: number, fen: string) => void;\n  clearEvaluationBaseline: () => void;\n}\n\n/**\n * Game actions interface (subset needed for dialog handling)\n */\ninterface GameActionsSubset {\n  resetGame: () => void;\n}\n\n/**\n * UI actions interface (subset needed for dialog handling)\n */\ninterface UIActionsSubset {\n  showToast: (message: string, type: string) => void;\n}\n\n/**\n * Training state interface (subset needed for dialog handling)\n */\ninterface TrainingStateSubset {\n  isPlayerTurn: boolean;\n  isOpponentThinking: boolean;\n  currentPosition?: {\n    id: number;\n    colorToTrain?: string;\n  } | null;\n  moveErrorDialog?: {\n    bestMove?: string;\n  } | null;\n}\n\n\n/**\n * Training UI state interface (subset needed for dialog handling)\n */\ninterface TrainingUIStateSubset {\n  handleReset: () => void;\n}\n\n/**\n * Props for useDialogHandlers hook\n */\ninterface UseDialogHandlersProps {\n  /** Training session function to undo moves */\n  undoMove: () => boolean;\n  /** Training session function to reset game */\n  resetGame: () => void;\n  /** Training session function to clear evaluations */\n  clearEvaluations: () => void;\n  \n  /** Training store actions */\n  trainingActions: TrainingActionsSubset;\n  /** Game store actions */\n  gameActions: GameActionsSubset;\n  /** UI store actions */\n  uiActions: UIActionsSubset;\n  \n  /** Training state */\n  trainingState: TrainingStateSubset;\n  \n  /** Store API for direct state access */\n  storeApi: StoreApi;\n  \n  /** Training UI state management */\n  trainingUIState: TrainingUIStateSubset;\n}\n\n/**\n * Return value from useDialogHandlers hook\n */\ninterface UseDialogHandlersReturn {\n  /** Handler for move error dialog - take back move (undo) */\n  handleMoveErrorTakeBack: () => void;\n  /** Handler for move error dialog - restart game */\n  handleMoveErrorRestart: () => void;\n  /** Handler for move error dialog - continue playing */\n  handleMoveErrorContinue: () => void;\n  /** Handler for move error dialog - show best move */\n  handleShowBestMove: () => void;\n  \n  /** Handler for move success dialog - close dialog */\n  handleMoveSuccessClose: () => void;\n  /** Handler for move success dialog - continue to next */\n  handleMoveSuccessContinue: () => void;\n  \n  /** Handler for general game reset */\n  handleReset: () => void;\n}\n\n/**\n * Custom hook for chess dialog handling logic\n * \n * @description\n * Encapsulates all dialog handling logic including:\n * - Move error dialog actions with complex undo and opponent turn logic\n * - Move success dialog actions for training flow continuation\n * - Training session reset coordination across multiple services\n * - State management for opponent turns and player interactions\n * - Comprehensive logging and error handling\n * \n * @remarks\n * This hook maintains all the complex business logic that was previously\n * embedded in TrainingBoard. It coordinates between multiple services:\n * - TrainingSession hooks for game state management\n * - Store actions for state updates\n * - Opponent turn orchestrators for training flow\n * - Logging service for debugging and monitoring\n * \n * The hook preserves all original functionality while providing a clean\n * interface that separates concerns between dialog actions and UI coordination.\n * \n * @param props Configuration object with session functions, store actions, and state\n * @returns Object with all dialog handler functions\n */\nexport const useDialogHandlers = ({\n  undoMove,\n  resetGame,\n  clearEvaluations,\n  trainingActions,\n  gameActions,\n  uiActions,\n  trainingState,\n  storeApi,\n  trainingUIState,\n}: UseDialogHandlersProps): UseDialogHandlersReturn => {\n\n  /**\n   * Resets the training board to initial state\n   *\n   * @description\n   * Performs comprehensive cleanup including:\n   * - Resetting chess game to starting position\n   * - Clearing all position evaluations\n   * - Resetting UI state and dialogs\n   * - Clearing training session data\n   *\n   * @remarks\n   * This handler is called when:\n   * - User clicks reset button\n   * - Training session needs restart\n   * - Parent component triggers reset\n   */\n  const handleReset = useCallback(() => {\n    resetGame();\n    clearEvaluations();\n    trainingUIState.handleReset();\n    gameActions.resetGame();\n    // Clear evaluation baseline when resetting\n    trainingActions.clearEvaluationBaseline();\n  }, [resetGame, clearEvaluations, gameActions, trainingUIState, trainingActions]);\n\n  /**\n   * Handles move error dialog dismissal with undo\n   *\n   * @description\n   * Closes the move error dialog and undoes the suboptimal move,\n   * allowing the user to try a different move.\n   *\n   * @remarks\n   * When a suboptimal move is detected, it has already been executed\n   * on the board and added to the move history. This function removes\n   * the move from history and reverts the board position.\n   */\n  const handleMoveErrorTakeBack = useCallback(() => {\n    const logger = getLogger().setContext(\"useDialogHandlers-MoveError\");\n    logger.info(\"Undoing suboptimal move using useTrainingSession undoMove\");\n\n    // CRITICAL: Cancel any scheduled opponent turn BEFORE undoing\n    // This prevents the opponent from playing after we undo\n    cancelScheduledOpponentTurn();\n    logger.info(\"Cancelled any scheduled opponent turn\");\n\n    // Use the undoMove function from useTrainingSession which properly handles ChessService\n    const undoResult = undoMove();\n\n    if (undoResult) {\n      logger.info(\"Move successfully undone\");\n\n      // CRITICAL: Set player turn to true after undoing a suboptimal move\n      // This prevents the opponent from playing immediately after undo\n      logger.debug(\"Before setPlayerTurn - current state\", {\n        isPlayerTurn: trainingState.isPlayerTurn,\n        isOpponentThinking: trainingState.isOpponentThinking,\n      });\n      trainingActions.setPlayerTurn(true);\n      trainingActions.clearOpponentThinking(); // Clear opponent thinking flag\n      trainingActions.clearEvaluationBaseline(); // Clear baseline since we're back to original position\n      logger.info(\n        \"Set player turn to true, cleared opponent thinking, and cleared evaluation baseline\",\n      );\n      logger.debug(\"After setPlayerTurn call\");\n    } else {\n      logger.error(\"Failed to undo move - no moves in history\");\n    }\n\n    // Close the dialog using the trainingActions hook which properly accesses the action\n    // The hook extracts the action from the slice creator, not from the nested store state\n    if (trainingActions && trainingActions.setMoveErrorDialog) {\n      trainingActions.setMoveErrorDialog(null);\n      logger.info(\n        \"Successfully closed move error dialog via trainingActions hook\",\n      );\n    } else {\n      logger.error(\"setMoveErrorDialog not available in trainingActions\");\n    }\n  }, [undoMove, trainingActions, trainingState]);\n\n  /**\n   * Restarts the entire training session after move error\n   *\n   * @description\n   * Completely resets the game and closes the error dialog when\n   * the user chooses to restart after making a critical mistake.\n   *\n   * @remarks\n   * This is typically used when the user has made a game-losing\n   * mistake and wants to start the position from the beginning.\n   */\n  const handleMoveErrorRestart = useCallback(() => {\n    const logger = getLogger().setContext(\"useDialogHandlers-MoveError\");\n    logger.info(\"Restarting game due to move error\");\n    handleReset();\n    trainingActions.setMoveErrorDialog(null);\n  }, [handleReset, trainingActions]);\n\n  /**\n   * Handles \"Weiterspielen\" (continue playing) action from error dialog\n   *\n   * @description\n   * Closes the error dialog and schedules the opponent's turn.\n   * This allows the game to continue even after a suboptimal move,\n   * letting the opponent respond to the player's move.\n   *\n   * @remarks\n   * This provides a smoother training experience by allowing players\n   * to continue playing and learning from their mistakes rather than\n   * always having to take back moves.\n   */\n  const handleMoveErrorContinue = useCallback(() => {\n    const logger = getLogger().setContext(\"useDialogHandlers-MoveError\");\n    \n    // Get current state for debugging\n    const currentState = storeApi.getState();\n    logger.info(\n      \"ðŸŽ¯ WEITERSPIELEN clicked - Current state BEFORE action:\",\n      {\n        isPlayerTurn: currentState.training.isPlayerTurn,\n        isOpponentThinking: currentState.training.isOpponentThinking,\n        currentFen: chessService.getFen(),\n        currentTurn: chessService.turn(),\n        colorToTrain: currentState.training.currentPosition?.colorToTrain,\n        moveCount: currentState.game.moveHistory.length,\n      }\n    );\n\n    // CRITICAL FIX: Set turn state before scheduling opponent turn\n    // This ensures the opponent can actually execute their move\n    const currentTurn = chessService.turn();\n    const trainingColor = currentState.training.currentPosition?.colorToTrain?.charAt(0);\n    \n    if (currentTurn !== trainingColor) {\n      logger.info(\"ðŸ”§ FIXING BUG: Setting isPlayerTurn=false for opponent to move\");\n      trainingActions.setPlayerTurn(false);\n    }\n\n    // Close the error dialog\n    trainingActions.setMoveErrorDialog(null);\n    logger.info(\"âœ… Error dialog closed\");\n\n    // Schedule opponent turn to respond to player's move\n    logger.info(\"ðŸ“… Calling scheduleOpponentTurn with evaluation baseline callback...\");\n    scheduleOpponentTurn(storeApi, 500, {\n      onOpponentMoveComplete: async () => {\n        logger.info(\"ðŸŽ¯ Opponent move completed - updating evaluation baseline\");\n        \n        try {\n          // Get current position evaluation\n          const currentFen = chessService.getFen();\n          const currentEval = await tablebaseService.getEvaluation(currentFen);\n          \n          if (currentEval.isAvailable && currentEval.result) {\n            // Update baseline to current position's evaluation using the actions provided to this hook\n            trainingActions.setEvaluationBaseline(currentEval.result.wdl, currentFen);\n            logger.info(\"âœ… Evaluation baseline updated successfully\", {\n              newBaseline: currentEval.result.wdl,\n              fen: currentFen,\n            });\n          } else {\n            logger.warn(\"âš ï¸ Could not get evaluation for baseline update - tablebase unavailable\");\n          }\n        } catch (error) {\n          logger.error(\"âŒ Failed to update evaluation baseline:\", error);\n        }\n      }\n    });\n\n    // Check state after scheduling\n    const stateAfter = storeApi.getState();\n    logger.info(\"ðŸ“Š State AFTER scheduling opponent turn:\", {\n      isPlayerTurn: stateAfter.training.isPlayerTurn,\n      isOpponentThinking: stateAfter.training.isOpponentThinking,\n    });\n  }, [trainingActions, storeApi]);\n\n  /**\n   * Displays the best move as a toast notification\n   *\n   * @description\n   * Shows the optimal move in a toast message when the user\n   * requests to see the best move after making a mistake.\n   *\n   * @remarks\n   * The best move is determined by tablebase analysis and\n   * represents the objectively best continuation from the\n   * position before the user's suboptimal move.\n   */\n  const handleShowBestMove = useCallback(() => {\n    if (trainingState.moveErrorDialog?.bestMove) {\n      const logger = getLogger().setContext(\"useDialogHandlers-MoveError\");\n      logger.info(\"Showing best move\", { bestMove: trainingState.moveErrorDialog.bestMove });\n      uiActions.showToast(\n        `Der beste Zug war: ${trainingState.moveErrorDialog.bestMove}`,\n        \"info\",\n      );\n    }\n    trainingActions.setMoveErrorDialog(null);\n  }, [trainingState.moveErrorDialog, uiActions, trainingActions]);\n\n  /**\n   * Handles success dialog close\n   *\n   * @description\n   * Closes the move success dialog when user dismisses it.\n   */\n  const handleMoveSuccessClose = useCallback(() => {\n    trainingActions.setMoveSuccessDialog(null);\n  }, [trainingActions]);\n\n  /**\n   * Handles continuing to next position after success\n   *\n   * @description\n   * Closes the success dialog and allows training to continue.\n   * Training completion logic is handled elsewhere in the system.\n   */\n  const handleMoveSuccessContinue = useCallback(() => {\n    trainingActions.setMoveSuccessDialog(null);\n    // Training completion logic is already handled by PawnPromotionHandler\n  }, [trainingActions]);\n\n  return {\n    handleMoveErrorTakeBack,\n    handleMoveErrorRestart,\n    handleMoveErrorContinue,\n    handleShowBestMove,\n    handleMoveSuccessClose,\n    handleMoveSuccessContinue,\n    handleReset,\n  };\n};"],"names":["useDialogHandlers","undoMove","resetGame","clearEvaluations","trainingActions","gameActions","uiActions","trainingState","storeApi","trainingUIState","handleReset","useCallback","clearEvaluationBaseline","handleMoveErrorTakeBack","logger","getLogger","setContext","info","cancelScheduledOpponentTurn","undoResult","debug","isPlayerTurn","isOpponentThinking","setPlayerTurn","clearOpponentThinking","error","setMoveErrorDialog","handleMoveErrorRestart","handleMoveErrorContinue","currentState","getState","training","currentFen","chessService","getFen","currentTurn","turn","colorToTrain","currentPosition","moveCount","game","moveHistory","length","trainingColor","charAt","scheduleOpponentTurn","onOpponentMoveComplete","currentEval","tablebaseService","getEvaluation","isAvailable","result","setEvaluationBaseline","wdl","newBaseline","fen","warn","stateAfter","handleShowBestMove","moveErrorDialog","bestMove","showToast","handleMoveSuccessClose","setMoveSuccessDialog","handleMoveSuccessContinue"],"mappings":"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"}