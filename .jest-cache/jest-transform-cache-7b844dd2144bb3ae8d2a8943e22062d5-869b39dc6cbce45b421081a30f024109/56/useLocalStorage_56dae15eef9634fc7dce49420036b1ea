cefe4a949f2ca2521be6fcd4b87a76d8
/**
 * @file localStorage hooks with React state management
 * @module hooks/useLocalStorage
 *
 * @description
 * Provides cross-platform localStorage functionality with async support.
 * Uses the PlatformService abstraction to work across web, mobile, and desktop.
 *
 * Three APIs are provided:
 * - useLocalStorage: Backward-compatible API that hides async complexity
 * - useLocalStorageWithState: Full-featured API with loading/error states
 * - useLocalStorageSync: Deprecated sync wrapper
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get useLocalStorage () {
        return useLocalStorage;
    },
    get useLocalStorageWithState () {
        return useLocalStorageWithState;
    }
});
const _react = require("react");
const _platform = require("../services/platform");
const _logging = require("../services/logging");
const logger = (0, _logging.getLogger)().setContext("useLocalStorage");
/**
 * INTERNAL: Full-featured async hook with loading state and error handling
 * Private implementation used by both legacy and new APIs
 *
 * @private
 * @template T - Type of the stored value
 * @param {string} key - Storage key
 * @param {T | (() => T)} initialValue - Initial value or factory function
 * @returns {[T | undefined, Function, boolean, Error | null]} Tuple of [value, setter, isLoading, error]
 */ function useLocalStorageInternal(key, initialValue) {
    const resolvedInitialValue = (0, _react.useMemo)(()=>{
        return typeof initialValue === "function" ? initialValue() : initialValue;
    }, [
        initialValue
    ]);
    const [storedValue, setStoredValue] = (0, _react.useState)(undefined);
    const [isLoading, setIsLoading] = (0, _react.useState)(true);
    const [saveError, setSaveError] = (0, _react.useState)(null);
    // Effect for initial loading from storage
    (0, _react.useEffect)(()=>{
        let isMounted = true;
        setIsLoading(true);
        (0, _platform.getPlatformService)().storage.load(key).then((item)=>{
            if (isMounted) {
                setStoredValue(item !== null ? item : resolvedInitialValue);
            }
        }).catch((loadError)=>{
            logger.warn(`Error loading storage key "${key}": ${loadError}`);
            if (isMounted) {
                setStoredValue(resolvedInitialValue);
            }
        }).finally(()=>{
            if (isMounted) {
                setIsLoading(false);
            }
        });
        return ()=>{
            isMounted = false;
        };
    }, [
        key,
        resolvedInitialValue
    ]);
    // Ref to prevent saving the value that was just loaded from storage
    const isInitialMountAfterLoad = (0, _react.useRef)(true);
    // Effect for saving to storage on value change
    (0, _react.useEffect)(()=>{
        if (isLoading) {
            isInitialMountAfterLoad.current = true; // Reset on re-load
            return;
        }
        if (isInitialMountAfterLoad.current) {
            // This is the first render after loading. Don't save the initial value.
            isInitialMountAfterLoad.current = false;
            return;
        }
        let isMounted = true;
        (0, _platform.getPlatformService)().storage.save(key, storedValue).then(()=>{
            // On success, clear any previous error
            if (isMounted && saveError !== null) {
                setSaveError(null);
            }
        }).catch((err)=>{
            logger.error(`Failed to save storage key "${key}": ${err}`);
            if (isMounted) {
                setSaveError(err instanceof Error ? err : new Error(String(err)));
            }
        });
        return ()=>{
            isMounted = false;
        };
    }, [
        key,
        storedValue,
        isLoading,
        saveError
    ]);
    const setValue = (0, _react.useCallback)((value)=>{
        // Clear any previous save error on a new update attempt
        if (saveError) {
            setSaveError(null);
        }
        setStoredValue(value);
    }, [
        saveError
    ]);
    return [
        storedValue,
        setValue,
        isLoading,
        saveError
    ];
}
function useLocalStorage(key, initialValue) {
    const [asyncValue, setAsyncValue, isLoading, saveError] = useLocalStorageInternal(key, initialValue);
    const resolvedInitialValue = (0, _react.useMemo)(()=>{
        return typeof initialValue === "function" ? initialValue() : initialValue;
    }, [
        initialValue
    ]);
    // Return initial value while loading, then switch to loaded value (backward compatible)
    const currentValue = isLoading ? resolvedInitialValue : asyncValue !== null && asyncValue !== void 0 ? asyncValue : resolvedInitialValue;
    // Wrapper for the setter to maintain backward compatible interface
    const compatSetValue = (0, _react.useCallback)((value)=>{
        const valueToStore = value instanceof Function ? value(currentValue) : value;
        setAsyncValue(valueToStore);
        // Log save errors (backward compatible - original didn't expose errors)
        if (saveError) {
            logger.warn(`Storage save error (backward compatibility mode): ${saveError.message}`);
        }
    }, [
        currentValue,
        setAsyncValue,
        saveError
    ]);
    return [
        currentValue,
        compatSetValue
    ];
}
function useLocalStorageWithState(key, initialValue) {
    return useLocalStorageInternal(key, initialValue);
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL2hvb2tzL3VzZUxvY2FsU3RvcmFnZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIGxvY2FsU3RvcmFnZSBob29rcyB3aXRoIFJlYWN0IHN0YXRlIG1hbmFnZW1lbnRcbiAqIEBtb2R1bGUgaG9va3MvdXNlTG9jYWxTdG9yYWdlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlcyBjcm9zcy1wbGF0Zm9ybSBsb2NhbFN0b3JhZ2UgZnVuY3Rpb25hbGl0eSB3aXRoIGFzeW5jIHN1cHBvcnQuXG4gKiBVc2VzIHRoZSBQbGF0Zm9ybVNlcnZpY2UgYWJzdHJhY3Rpb24gdG8gd29yayBhY3Jvc3Mgd2ViLCBtb2JpbGUsIGFuZCBkZXNrdG9wLlxuICpcbiAqIFRocmVlIEFQSXMgYXJlIHByb3ZpZGVkOlxuICogLSB1c2VMb2NhbFN0b3JhZ2U6IEJhY2t3YXJkLWNvbXBhdGlibGUgQVBJIHRoYXQgaGlkZXMgYXN5bmMgY29tcGxleGl0eVxuICogLSB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGU6IEZ1bGwtZmVhdHVyZWQgQVBJIHdpdGggbG9hZGluZy9lcnJvciBzdGF0ZXNcbiAqIC0gdXNlTG9jYWxTdG9yYWdlU3luYzogRGVwcmVjYXRlZCBzeW5jIHdyYXBwZXJcbiAqL1xuXG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybVNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvcGxhdGZvcm1cIjtcbmltcG9ydCB7IGdldExvZ2dlciB9IGZyb20gXCIuLi9zZXJ2aWNlcy9sb2dnaW5nXCI7XG5cbmNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpLnNldENvbnRleHQoXCJ1c2VMb2NhbFN0b3JhZ2VcIik7XG5cbi8qKlxuICogSU5URVJOQUw6IEZ1bGwtZmVhdHVyZWQgYXN5bmMgaG9vayB3aXRoIGxvYWRpbmcgc3RhdGUgYW5kIGVycm9yIGhhbmRsaW5nXG4gKiBQcml2YXRlIGltcGxlbWVudGF0aW9uIHVzZWQgYnkgYm90aCBsZWdhY3kgYW5kIG5ldyBBUElzXG4gKlxuICogQHByaXZhdGVcbiAqIEB0ZW1wbGF0ZSBUIC0gVHlwZSBvZiB0aGUgc3RvcmVkIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RvcmFnZSBrZXlcbiAqIEBwYXJhbSB7VCB8ICgoKSA9PiBUKX0gaW5pdGlhbFZhbHVlIC0gSW5pdGlhbCB2YWx1ZSBvciBmYWN0b3J5IGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7W1QgfCB1bmRlZmluZWQsIEZ1bmN0aW9uLCBib29sZWFuLCBFcnJvciB8IG51bGxdfSBUdXBsZSBvZiBbdmFsdWUsIHNldHRlciwgaXNMb2FkaW5nLCBlcnJvcl1cbiAqL1xuZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlSW50ZXJuYWw8VD4oXG4gIGtleTogc3RyaW5nLFxuICBpbml0aWFsVmFsdWU6IFQgfCAoKCkgPT4gVCksXG4pOiBbXG4gIFQgfCB1bmRlZmluZWQsXG4gICh2YWx1ZTogVCB8ICgodmFsOiBUIHwgdW5kZWZpbmVkKSA9PiBUKSkgPT4gdm9pZCxcbiAgYm9vbGVhbixcbiAgRXJyb3IgfCBudWxsLFxuXSB7XG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbml0aWFsVmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoaW5pdGlhbFZhbHVlIGFzICgpID0+IFQpKClcbiAgICAgIDogaW5pdGlhbFZhbHVlO1xuICB9LCBbaW5pdGlhbFZhbHVlXSk7XG5cbiAgY29uc3QgW3N0b3JlZFZhbHVlLCBzZXRTdG9yZWRWYWx1ZV0gPSB1c2VTdGF0ZTxUIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzYXZlRXJyb3IsIHNldFNhdmVFcnJvcl0gPSB1c2VTdGF0ZTxFcnJvciB8IG51bGw+KG51bGwpO1xuXG4gIC8vIEVmZmVjdCBmb3IgaW5pdGlhbCBsb2FkaW5nIGZyb20gc3RvcmFnZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIHNldElzTG9hZGluZyh0cnVlKTtcblxuICAgIGdldFBsYXRmb3JtU2VydmljZSgpXG4gICAgICAuc3RvcmFnZS5sb2FkPFQ+KGtleSlcbiAgICAgIC50aGVuKChpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRTdG9yZWRWYWx1ZShpdGVtICE9PSBudWxsID8gaXRlbSA6IHJlc29sdmVkSW5pdGlhbFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgobG9hZEVycm9yKSA9PiB7XG4gICAgICAgIGxvZ2dlci53YXJuKGBFcnJvciBsb2FkaW5nIHN0b3JhZ2Uga2V5IFwiJHtrZXl9XCI6ICR7bG9hZEVycm9yfWApO1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0U3RvcmVkVmFsdWUocmVzb2x2ZWRJbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAoaXNNb3VudGVkKSB7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW2tleSwgcmVzb2x2ZWRJbml0aWFsVmFsdWVdKTtcblxuICAvLyBSZWYgdG8gcHJldmVudCBzYXZpbmcgdGhlIHZhbHVlIHRoYXQgd2FzIGp1c3QgbG9hZGVkIGZyb20gc3RvcmFnZVxuICBjb25zdCBpc0luaXRpYWxNb3VudEFmdGVyTG9hZCA9IHVzZVJlZih0cnVlKTtcblxuICAvLyBFZmZlY3QgZm9yIHNhdmluZyB0byBzdG9yYWdlIG9uIHZhbHVlIGNoYW5nZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgIGlzSW5pdGlhbE1vdW50QWZ0ZXJMb2FkLmN1cnJlbnQgPSB0cnVlOyAvLyBSZXNldCBvbiByZS1sb2FkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzSW5pdGlhbE1vdW50QWZ0ZXJMb2FkLmN1cnJlbnQpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBhZnRlciBsb2FkaW5nLiBEb24ndCBzYXZlIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgICAgaXNJbml0aWFsTW91bnRBZnRlckxvYWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpc01vdW50ZWQgPSB0cnVlO1xuICAgIGdldFBsYXRmb3JtU2VydmljZSgpXG4gICAgICAuc3RvcmFnZS5zYXZlKGtleSwgc3RvcmVkVmFsdWUpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIC8vIE9uIHN1Y2Nlc3MsIGNsZWFyIGFueSBwcmV2aW91cyBlcnJvclxuICAgICAgICBpZiAoaXNNb3VudGVkICYmIHNhdmVFcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgIHNldFNhdmVFcnJvcihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihgRmFpbGVkIHRvIHNhdmUgc3RvcmFnZSBrZXkgXCIke2tleX1cIjogJHtlcnJ9YCk7XG4gICAgICAgIGlmIChpc01vdW50ZWQpIHtcbiAgICAgICAgICBzZXRTYXZlRXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycikpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW2tleSwgc3RvcmVkVmFsdWUsIGlzTG9hZGluZywgc2F2ZUVycm9yXSk7XG5cbiAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICAodmFsdWU6IFQgfCAoKHZhbDogVCB8IHVuZGVmaW5lZCkgPT4gVCkpID0+IHtcbiAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBzYXZlIGVycm9yIG9uIGEgbmV3IHVwZGF0ZSBhdHRlbXB0XG4gICAgICBpZiAoc2F2ZUVycm9yKSB7XG4gICAgICAgIHNldFNhdmVFcnJvcihudWxsKTtcbiAgICAgIH1cbiAgICAgIHNldFN0b3JlZFZhbHVlKHZhbHVlKTtcbiAgICB9LFxuICAgIFtzYXZlRXJyb3JdLFxuICApO1xuXG4gIHJldHVybiBbc3RvcmVkVmFsdWUsIHNldFZhbHVlLCBpc0xvYWRpbmcsIHNhdmVFcnJvcl07XG59XG5cbi8qKlxuICogQ3VzdG9tIGhvb2sgZm9yIG1hbmFnaW5nIGxvY2FsU3RvcmFnZSB3aXRoIFJlYWN0IHN0YXRlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBVc2VzIHBsYXRmb3JtIGFic3RyYWN0aW9uIGZvciBjcm9zcy1wbGF0Zm9ybSBjb21wYXRpYmlsaXR5LlxuICogVGhpcyBBUEkgbWFpbnRhaW5zIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBhIHNpbXBsZSBbdmFsdWUsIHNldFZhbHVlXSBpbnRlcmZhY2VcbiAqIHdoaWxlIGhhbmRsaW5nIGFzeW5jIG9wZXJhdGlvbnMgaW50ZXJuYWxseS4gTG9hZGluZyBzdGF0ZXMgYW5kIGVycm9ycyBhcmUgaGlkZGVuLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVHlwZSBvZiB0aGUgc3RvcmVkIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gU3RvcmFnZSBrZXkgdG8gdXNlXG4gKiBAcGFyYW0ge1QgfCAoKCkgPT4gVCl9IGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUgb3IgZmFjdG9yeSBmdW5jdGlvblxuICogQHJldHVybnMge1tULCBGdW5jdGlvbl19IFR1cGxlIG9mIFtjdXJyZW50VmFsdWUsIHNldFZhbHVlXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IFt0aGVtZSwgc2V0VGhlbWVdID0gdXNlTG9jYWxTdG9yYWdlKCd0aGVtZScsICdsaWdodCcpO1xuICpcbiAqIC8vIFVwZGF0ZSB2YWx1ZVxuICogc2V0VGhlbWUoJ2RhcmsnKTtcbiAqXG4gKiAvLyBVcGRhdGUgd2l0aCBmdW5jdGlvblxuICogc2V0VGhlbWUocHJldiA9PiBwcmV2ID09PSAnbGlnaHQnID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrc1xuICogLSBSZXR1cm5zIGluaXRpYWxWYWx1ZSB3aGlsZSBsb2FkaW5nIGZyb20gc3RvcmFnZVxuICogLSBBdXRvbWF0aWNhbGx5IHNhdmVzIHRvIHN0b3JhZ2Ugb24gdmFsdWUgY2hhbmdlc1xuICogLSBFcnJvcnMgYXJlIGxvZ2dlZCBidXQgbm90IGV4cG9zZWQgKHVzZSB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUgZm9yIGVycm9yIGhhbmRsaW5nKVxuICogLSBGb3IgbmV3IGNvZGUsIGNvbnNpZGVyIHVzaW5nIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSBmb3IgZnVsbCBhc3luYyBzdXBwb3J0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbFN0b3JhZ2U8VD4oXG4gIGtleTogc3RyaW5nLFxuICBpbml0aWFsVmFsdWU6IFQgfCAoKCkgPT4gVCksXG4pOiBbVCwgKHZhbHVlOiBUIHwgKCh2YWw6IFQpID0+IFQpKSA9PiB2b2lkXSB7XG4gIGNvbnN0IFthc3luY1ZhbHVlLCBzZXRBc3luY1ZhbHVlLCBpc0xvYWRpbmcsIHNhdmVFcnJvcl0gPVxuICAgIHVzZUxvY2FsU3RvcmFnZUludGVybmFsKGtleSwgaW5pdGlhbFZhbHVlKTtcblxuICBjb25zdCByZXNvbHZlZEluaXRpYWxWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gKGluaXRpYWxWYWx1ZSBhcyAoKSA9PiBUKSgpXG4gICAgICA6IGluaXRpYWxWYWx1ZTtcbiAgfSwgW2luaXRpYWxWYWx1ZV0pO1xuXG4gIC8vIFJldHVybiBpbml0aWFsIHZhbHVlIHdoaWxlIGxvYWRpbmcsIHRoZW4gc3dpdGNoIHRvIGxvYWRlZCB2YWx1ZSAoYmFja3dhcmQgY29tcGF0aWJsZSlcbiAgY29uc3QgY3VycmVudFZhbHVlID0gaXNMb2FkaW5nXG4gICAgPyByZXNvbHZlZEluaXRpYWxWYWx1ZVxuICAgIDogKGFzeW5jVmFsdWUgPz8gcmVzb2x2ZWRJbml0aWFsVmFsdWUpO1xuXG4gIC8vIFdyYXBwZXIgZm9yIHRoZSBzZXR0ZXIgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJsZSBpbnRlcmZhY2VcbiAgY29uc3QgY29tcGF0U2V0VmFsdWUgPSB1c2VDYWxsYmFjayhcbiAgICAodmFsdWU6IFQgfCAoKHZhbDogVCkgPT4gVCkpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlVG9TdG9yZSA9XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgRnVuY3Rpb24gPyB2YWx1ZShjdXJyZW50VmFsdWUpIDogdmFsdWU7XG4gICAgICBzZXRBc3luY1ZhbHVlKHZhbHVlVG9TdG9yZSk7XG5cbiAgICAgIC8vIExvZyBzYXZlIGVycm9ycyAoYmFja3dhcmQgY29tcGF0aWJsZSAtIG9yaWdpbmFsIGRpZG4ndCBleHBvc2UgZXJyb3JzKVxuICAgICAgaWYgKHNhdmVFcnJvcikge1xuICAgICAgICBsb2dnZXIud2FybihcbiAgICAgICAgICBgU3RvcmFnZSBzYXZlIGVycm9yIChiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG1vZGUpOiAke3NhdmVFcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbY3VycmVudFZhbHVlLCBzZXRBc3luY1ZhbHVlLCBzYXZlRXJyb3JdLFxuICApO1xuXG4gIHJldHVybiBbY3VycmVudFZhbHVlLCBjb21wYXRTZXRWYWx1ZV07XG59XG5cbi8qKlxuICogRW5oYW5jZWQgbG9jYWxTdG9yYWdlIGhvb2sgd2l0aCBmdWxsIGxvYWRpbmcgc3RhdGUgYW5kIGVycm9yIGhhbmRsaW5nXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBOZXcgQVBJIHRoYXQgZXhwb3NlcyBhbGwgYXN5bmMgYmVoYXZpb3IgYW5kIGVycm9yIHN0YXRlcy5cbiAqIFVzZSB0aGlzIGZvciBuZXcgY29kZSB0aGF0IG5lZWRzIHRvIGhhbmRsZSBsb2FkaW5nIHN0YXRlcyBvciBzYXZlIGVycm9ycy5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFR5cGUgb2YgdGhlIHN0b3JlZCB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFN0b3JhZ2Uga2V5IHRvIHVzZVxuICogQHBhcmFtIHtUIHwgKCgpID0+IFQpfSBpbml0aWFsVmFsdWUgLSBJbml0aWFsIHZhbHVlIG9yIGZhY3RvcnkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtbVCB8IHVuZGVmaW5lZCwgRnVuY3Rpb24sIGJvb2xlYW4sIEVycm9yIHwgbnVsbF19IFR1cGxlIG9mIFt2YWx1ZSwgc2V0VmFsdWUsIGlzTG9hZGluZywgc2F2ZUVycm9yXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IFtzZXR0aW5ncywgc2V0U2V0dGluZ3MsIGlzTG9hZGluZywgZXJyb3JdID0gdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlKCdzZXR0aW5ncycsIHt9KTtcbiAqXG4gKiBpZiAoaXNMb2FkaW5nKSByZXR1cm4gPFNwaW5uZXIgLz47XG4gKiBpZiAoZXJyb3IpIHJldHVybiA8RXJyb3JNZXNzYWdlIGVycm9yPXtlcnJvcn0gLz47XG4gKlxuICogcmV0dXJuIChcbiAqICAgPFNldHRpbmdzRm9ybVxuICogICAgIHNldHRpbmdzPXtzZXR0aW5nc31cbiAqICAgICBvbkNoYW5nZT17c2V0U2V0dGluZ3N9XG4gKiAgIC8+XG4gKiApO1xuICogYGBgXG4gKlxuICogQHJlbWFya3NcbiAqIC0gdmFsdWUgaXMgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsIGxvYWRcbiAqIC0gaXNMb2FkaW5nIGlzIHRydWUgdW50aWwgZmlyc3QgbG9hZCBjb21wbGV0ZXNcbiAqIC0gc2F2ZUVycm9yIGNvbnRhaW5zIGFueSBlcnJvcnMgZnJvbSB0aGUgbGFzdCBzYXZlIGF0dGVtcHRcbiAqIC0gRXJyb3JzIGFyZSBhdXRvbWF0aWNhbGx5IGNsZWFyZWQgb24gc3VjY2Vzc2Z1bCBzYXZlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlPFQ+KFxuICBrZXk6IHN0cmluZyxcbiAgaW5pdGlhbFZhbHVlOiBUIHwgKCgpID0+IFQpLFxuKTogW1xuICBUIHwgdW5kZWZpbmVkLFxuICAodmFsdWU6IFQgfCAoKHZhbDogVCB8IHVuZGVmaW5lZCkgPT4gVCkpID0+IHZvaWQsXG4gIGJvb2xlYW4sXG4gIEVycm9yIHwgbnVsbCxcbl0ge1xuICByZXR1cm4gdXNlTG9jYWxTdG9yYWdlSW50ZXJuYWwoa2V5LCBpbml0aWFsVmFsdWUpO1xufVxuIl0sIm5hbWVzIjpbInVzZUxvY2FsU3RvcmFnZSIsInVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSIsImxvZ2dlciIsImdldExvZ2dlciIsInNldENvbnRleHQiLCJ1c2VMb2NhbFN0b3JhZ2VJbnRlcm5hbCIsImtleSIsImluaXRpYWxWYWx1ZSIsInJlc29sdmVkSW5pdGlhbFZhbHVlIiwidXNlTWVtbyIsInN0b3JlZFZhbHVlIiwic2V0U3RvcmVkVmFsdWUiLCJ1c2VTdGF0ZSIsInVuZGVmaW5lZCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsInNhdmVFcnJvciIsInNldFNhdmVFcnJvciIsInVzZUVmZmVjdCIsImlzTW91bnRlZCIsImdldFBsYXRmb3JtU2VydmljZSIsInN0b3JhZ2UiLCJsb2FkIiwidGhlbiIsIml0ZW0iLCJjYXRjaCIsImxvYWRFcnJvciIsIndhcm4iLCJmaW5hbGx5IiwiaXNJbml0aWFsTW91bnRBZnRlckxvYWQiLCJ1c2VSZWYiLCJjdXJyZW50Iiwic2F2ZSIsImVyciIsImVycm9yIiwiRXJyb3IiLCJTdHJpbmciLCJzZXRWYWx1ZSIsInVzZUNhbGxiYWNrIiwidmFsdWUiLCJhc3luY1ZhbHVlIiwic2V0QXN5bmNWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImNvbXBhdFNldFZhbHVlIiwidmFsdWVUb1N0b3JlIiwiRnVuY3Rpb24iLCJtZXNzYWdlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7O0NBWUM7Ozs7Ozs7Ozs7O1FBbUplQTtlQUFBQTs7UUF1RUFDO2VBQUFBOzs7dUJBeE5rRDswQkFDL0I7eUJBQ1Q7QUFFMUIsTUFBTUMsU0FBU0MsSUFBQUEsa0JBQVMsSUFBR0MsVUFBVSxDQUFDO0FBRXRDOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNDLHdCQUNQQyxHQUFXLEVBQ1hDLFlBQTJCO0lBTzNCLE1BQU1DLHVCQUF1QkMsSUFBQUEsY0FBTyxFQUFDO1FBQ25DLE9BQU8sT0FBT0YsaUJBQWlCLGFBQzNCLEFBQUNBLGlCQUNEQTtJQUNOLEdBQUc7UUFBQ0E7S0FBYTtJQUVqQixNQUFNLENBQUNHLGFBQWFDLGVBQWUsR0FBR0MsSUFBQUEsZUFBUSxFQUFnQkM7SUFDOUQsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdILElBQUFBLGVBQVEsRUFBQztJQUMzQyxNQUFNLENBQUNJLFdBQVdDLGFBQWEsR0FBR0wsSUFBQUEsZUFBUSxFQUFlO0lBRXpELDBDQUEwQztJQUMxQ00sSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUlDLFlBQVk7UUFDaEJKLGFBQWE7UUFFYkssSUFBQUEsNEJBQWtCLElBQ2ZDLE9BQU8sQ0FBQ0MsSUFBSSxDQUFJaEIsS0FDaEJpQixJQUFJLENBQUMsQ0FBQ0M7WUFDTCxJQUFJTCxXQUFXO2dCQUNiUixl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