0249f618db3d235c81a7c32f92b4230a
/**
 * @file Position service implementation
 * @module services/database/PositionService
 *
 * @description
 * Business logic layer for managing chess endgame positions.
 * Handles position-related operations with caching and business rules,
 * completely decoupled from data access implementation through repository pattern.
 *
 * @remarks
 * Key features:
 * - Repository pattern for data abstraction
 * - LRU caching for performance optimization
 * - Comprehensive error handling with logging
 * - Support for CRUD operations
 * - Category and difficulty filtering
 * - Position navigation (next/previous)
 * - Full-text search capabilities
 *
 * The service acts as an intermediary between the UI layer and data layer,
 * enforcing business rules and providing caching for frequently accessed positions.
 *
 * @example
 * ```typescript
 * // Create service with repository
 * const repository = new SQLitePositionRepository();
 * const service = new PositionService(repository, {
 *   cacheEnabled: true,
 *   cacheSize: 100
 * });
 *
 * // Use service
 * const position = await service.getPosition(1);
 * const positions = await service.getPositionsByCategory('basic-checkmates');
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "PositionService", {
    enumerable: true,
    get: function() {
        return PositionService;
    }
});
const _logging = require("../logging");
const _LRUCache = require("../../lib/cache/LRUCache");
const _errors = require("./errors");
const _constants = require("../../constants");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const logger = (0, _logging.getLogger)().setContext("PositionService");
class PositionService {
    /**
   * Get a single position by ID
   *
   * @param {number} id - Position identifier
   * @returns {Promise<EndgamePosition | null>} Position if found, null otherwise
   * @throws {RepositoryError} If repository operation fails
   *
   * @description
   * Retrieves a position by ID with cache-first strategy.
   * If found in cache, returns immediately. Otherwise fetches
   * from repository and caches the result.
   *
   * @example
   * ```typescript
   * const position = await service.getPosition(1);
   * if (position) {
   *   console.log(position.title);
   * }
   * ```
   */ async getPosition(id) {
        var _this_cache;
        // Check cache first
        const cacheKey = id.toString();
        if ((_this_cache = this.cache) === null || _this_cache === void 0 ? void 0 : _this_cache.has(cacheKey)) {
            logger.debug("Cache hit for position", {
                id
            });
            return this.cache.get(cacheKey);
        }
        try {
            const position = await this.repository.getPosition(id);
            if (position && this.cache) {
                this.cache.set(cacheKey, position);
            }
            return position;
        } catch (error) {
            logger.error("Failed to get position", {
                id,
                error
            });
            throw new _errors.RepositoryError("getPosition", error);
        }
    }
    /**
   * Get all positions
   *
   * @returns {Promise<EndgamePosition[]>} Array of all positions
   * @throws {RepositoryError} If repository operation fails
   *
   * @description
   * Retrieves all positions from the repository and caches
   * each position individually for future single-position lookups.
   *
   * @remarks
   * Use with caution on large datasets as this loads all positions
   * into memory. Consider using pagination or filtering for better
   * performance with large position databases.
   *
   * @example
   * ```typescript
   * const allPositions = await service.getAllPositions();
   * console.log(`Total positions: ${allPositions.length}`);
   * ```
   */ async getAllPositions() {
        try {
            const positions = await this.repository.getAllPositions();
            // Cache individual positions
            if (this.cache) {
                positions.forEach((position)=>{
                    this.cache.set(position.id.toString(), position);
                });
            }
            return positions;
        } catch (error) {
            logger.error("Failed to get all positions", {
                error
            });
            throw new _errors.RepositoryError("getAllPositions", error);
        }
    }
    /**
   * Get positions by category
   *
   * @param {string} category - Category identifier (e.g., 'basic-checkmates')
   * @returns {Promise<EndgamePosition[]>} Positions in the category
   *
   * @description
   * Retrieves all positions belonging to a specific category.
   * Results are cached individually for improved performance
   * on subsequent single-position lookups.
   *
   * @example
   * ```typescript
   * const checkmates = await service.getPositionsByCategory('basic-checkmates');
   * const rookEndgames = await service.getPositionsByCategory('rook-endgames');
   * ```
   */ async getPositionsByCategory(category) {
        try {
            const positions = await this.repository.getPositionsByCategory(category);
            // Cache individual positions
            if (this.cache) {
                positions.forEach((position)=>{
                    this.cache.set(position.id.toString(), position);
                });
            }
            return positions;
        } catch (error) {
            logger.error("Failed to get positions by category", {
                category,
                error
            });
            return [];
        }
    }
    /**
   * Get positions by difficulty
   * @param difficulty
   */ async getPositionsByDifficulty(difficulty) {
        try {
            const positions = await this.repository.getPositionsByDifficulty(difficulty);
            // Cache individual positions
            if (this.cache) {
                positions.forEach((position)=>{
                    this.cache.set(position.id.toString(), position);
                });
            }
            return positions;
        } catch (error) {
            logger.error("Failed to get positions by difficulty", {
                difficulty,
                error
            });
            return [];
        }
    }
    /**
   * Search positions by title or description
   *
   * @param {string} searchTerm - Search query
   * @returns {Promise<EndgamePosition[]>} Matching positions
   *
   * @description
   * Performs full-text search across position titles and descriptions.
   * Empty or whitespace-only search terms return empty results.
   * Search is delegated to the repository implementation.
   *
   * @example
   * ```typescript
   * const results = await service.searchPositions('rook checkmate');
   * const queenEndgames = await service.searchPositions('queen vs pawn');
   * ```
   */ async searchPositions(searchTerm) {
        if (!searchTerm.trim()) {
            return [];
        }
        try {
            const positions = await this.repository.searchPositions(searchTerm);
            // Cache individual positions
            if (this.cache) {
                positions.forEach((position)=>{
                    this.cache.set(position.id.toString(), position);
                });
            }
            return positions;
        } catch (error) {
            logger.error("Failed to search positions", {
                searchTerm,
                error
            });
            return [];
        }
    }
    /**
   * Clear the cache
   *
   * @description
   * Removes all cached positions from memory.
   * Useful for testing or when positions are updated externally.
   *
   * @example
   * ```typescript
   * service.clearCache();
   * console.log('Cache cleared');
   * ```
   */ clearCache() {
        var _this_cache;
        (_this_cache = this.cache) === null || _this_cache === void 0 ? void 0 : _this_cache.clear();
        logger.info("Position cache cleared");
    }
    /**
   * Get cache statistics
   *
   * @returns {Object} Cache statistics
   * @returns {number} returns.size - Number of cached items
   * @returns {number[]} returns.keys - Array of cached position IDs
   * @returns {boolean} returns.enabled - Whether caching is enabled
   *
   * @description
   * Provides insight into cache usage for monitoring and debugging.
   *
   * @example
   * ```typescript
   * const stats = service.getCacheStats();
   * console.log(`Cached positions: ${stats.size}`);
   * console.log(`Cache enabled: ${stats.enabled}`);
   * ```
   */ getCacheStats() {
        if (!this.cache) {
            return {
                size: 0,
                keys: [],
                enabled: false
            };
        }
        const stats = this.cache.getStats();
        const keys = this.cache.keys().map((key)=>parseInt(key, 10));
        return {
            size: stats.size,
            keys: keys,
            enabled: true
        };
    }
    /**
   * Get all categories
   */ async getCategories() {
        try {
            return await this.repository.getCategories();
        } catch (error) {
            logger.error("Failed to get categories", {
                error
            });
            return [];
        }
    }
    /**
   * Get all chapters
   */ async getChapters() {
        try {
            return await this.repository.getChapters();
        } catch (error) {
            logger.error("Failed to get chapters", {
                error
            });
            return [];
        }
    }
    /**
   * Get chapters by category
   * @param categoryId
   */ async getChaptersByCategory(categoryId) {
        try {
            return await this.repository.getChaptersByCategory(categoryId);
        } catch (error) {
            logger.error("Failed to get chapters by category", {
                categoryId,
                error
            });
            return [];
        }
    }
    /**
   * Get next position in sequence (for navigation)
   *
   * @param {number} currentId - Current position ID
   * @param {string} [categoryId] - Optional category constraint
   * @returns {Promise<EndgamePosition | null>} Next position or null
   *
   * @description
   * Retrieves the next position in sequence, optionally within
   * the same category. Used for navigation between positions.
   *
   * @example
   * ```typescript
   * // Get next position in any category
   * const next = await service.getNextPosition(5);
   *
   * // Get next position in same category
   * const nextInCategory = await service.getNextPosition(5, 'rook-endgames');
   * ```
   */ async getNextPosition(currentId, categoryId) {
        try {
            const position = await this.repository.getNextPosition(currentId, categoryId);
            if (position && this.cache) {
                this.cache.set(position.id.toString(), position);
            }
            return position;
        } catch (error) {
            logger.error("Failed to get next position", {
                currentId,
                categoryId,
                error
            });
            return null;
        }
    }
    /**
   * Get previous position in sequence (for navigation)
   * @param currentId
   * @param categoryId
   */ async getPreviousPosition(currentId, categoryId) {
        try {
            const position = await this.repository.getPreviousPosition(currentId, categoryId);
            if (position && this.cache) {
                this.cache.set(position.id.toString(), position);
            }
            return position;
        } catch (error) {
            logger.error("Failed to get previous position", {
                currentId,
                categoryId,
                error
            });
            return null;
        }
    }
    /**
   * Get total position count
   */ async getTotalPositionCount() {
        try {
            return await this.repository.getTotalPositionCount();
        } catch (error) {
            logger.error("Failed to get position count", {
                error
            });
            return 0;
        }
    }
    /**
   * Get position count by category
   * @param categoryId
   */ async getPositionCountByCategory(categoryId) {
        try {
            return await this.repository.getPositionCountByCategory(categoryId);
        } catch (error) {
            logger.error("Failed to get position count by category", {
                categoryId,
                error
            });
            return 0;
        }
    }
    /**
   * Create a new position (admin functionality)
   *
   * @param {Omit<EndgamePosition, 'id'>} position - Position data without ID
   * @returns {Promise<EndgamePosition | null>} Created position or null on failure
   *
   * @description
   * Creates a new position in the repository. The ID is auto-generated
   * by the storage backend. Created position is automatically cached.
   *
   * @remarks
   * This is an administrative function that may require special
   * permissions in production environments.
   *
   * @example
   * ```typescript
   * const newPosition = await service.createPosition({
   *   title: 'Queen vs Rook',
   *   fen: '8/8/8/8/3Q4/8/8/3rk3 w - - 0 1',
   *   category: 'queen-endgames',
   *   difficulty: 'advanced'
   * });
   * ```
   */ async createPosition(position) {
        try {
            const created = await this.repository.createPosition(position);
            if (this.cache) {
                this.cache.set(created.id.toString(), created);
            }
            logger.info("Position created", {
                id: created.id
            });
            return created;
        } catch (error) {
            logger.error("Failed to create position", {
                error
            });
            return null;
        }
    }
    /**
   * Update a position (admin functionality)
   * @param id
   * @param updates
   */ async updatePosition(id, updates) {
        try {
            const updated = await this.repository.updatePosition(id, updates);
            if (updated && this.cache) {
                this.cache.set(id.toString(), updated);
            }
            logger.info("Position updated", {
                id
            });
            return updated;
        } catch (error) {
            logger.error("Failed to update position", {
                id,
                error
            });
            return null;
        }
    }
    /**
   * Delete a position (admin functionality)
   * @param id
   */ async deletePosition(id) {
        try {
            const deleted = await this.repository.deletePosition(id);
            if (deleted && this.cache) {
                this.cache.delete(id.toString());
            }
            logger.info("Position deleted", {
                id
            });
            return deleted;
        } catch (error) {
            logger.error("Failed to delete position", {
                id,
                error
            });
            return false;
        }
    }
    /**
   * Creates a new PositionService instance
   *
   * @param {IPositionRepository} repository - Data access repository
   * @param {IPositionServiceConfig} [config={}] - Service configuration
   *
   * @example
   * ```typescript
   * const service = new PositionService(repository, {
   *   cacheEnabled: true,
   *   cacheSize: 100
   * });
   * ```
   */ constructor(repository, config = {}){
        _define_property(this, "repository", void 0);
        _define_property(this, "cache", void 0);
        _define_property(this, "config", void 0);
        this.repository = repository;
        this.config = {
            cacheEnabled: true,
            cacheSize: _constants.CACHE.POSITION_CACHE_SIZE,
            cacheTTL: _constants.CACHE.ANALYSIS_CACHE_TTL,
            ...config
        };
        if (this.config.cacheEnabled) {
            this.cache = new _LRUCache.LRUCache(this.config.cacheSize);
        }
        logger.info("PositionService initialized", {
            config: this.config
        });
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3NlcnZpY2VzL2RhdGFiYXNlL1Bvc2l0aW9uU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFBvc2l0aW9uIHNlcnZpY2UgaW1wbGVtZW50YXRpb25cbiAqIEBtb2R1bGUgc2VydmljZXMvZGF0YWJhc2UvUG9zaXRpb25TZXJ2aWNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBCdXNpbmVzcyBsb2dpYyBsYXllciBmb3IgbWFuYWdpbmcgY2hlc3MgZW5kZ2FtZSBwb3NpdGlvbnMuXG4gKiBIYW5kbGVzIHBvc2l0aW9uLXJlbGF0ZWQgb3BlcmF0aW9ucyB3aXRoIGNhY2hpbmcgYW5kIGJ1c2luZXNzIHJ1bGVzLFxuICogY29tcGxldGVseSBkZWNvdXBsZWQgZnJvbSBkYXRhIGFjY2VzcyBpbXBsZW1lbnRhdGlvbiB0aHJvdWdoIHJlcG9zaXRvcnkgcGF0dGVybi5cbiAqXG4gKiBAcmVtYXJrc1xuICogS2V5IGZlYXR1cmVzOlxuICogLSBSZXBvc2l0b3J5IHBhdHRlcm4gZm9yIGRhdGEgYWJzdHJhY3Rpb25cbiAqIC0gTFJVIGNhY2hpbmcgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvblxuICogLSBDb21wcmVoZW5zaXZlIGVycm9yIGhhbmRsaW5nIHdpdGggbG9nZ2luZ1xuICogLSBTdXBwb3J0IGZvciBDUlVEIG9wZXJhdGlvbnNcbiAqIC0gQ2F0ZWdvcnkgYW5kIGRpZmZpY3VsdHkgZmlsdGVyaW5nXG4gKiAtIFBvc2l0aW9uIG5hdmlnYXRpb24gKG5leHQvcHJldmlvdXMpXG4gKiAtIEZ1bGwtdGV4dCBzZWFyY2ggY2FwYWJpbGl0aWVzXG4gKlxuICogVGhlIHNlcnZpY2UgYWN0cyBhcyBhbiBpbnRlcm1lZGlhcnkgYmV0d2VlbiB0aGUgVUkgbGF5ZXIgYW5kIGRhdGEgbGF5ZXIsXG4gKiBlbmZvcmNpbmcgYnVzaW5lc3MgcnVsZXMgYW5kIHByb3ZpZGluZyBjYWNoaW5nIGZvciBmcmVxdWVudGx5IGFjY2Vzc2VkIHBvc2l0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gQ3JlYXRlIHNlcnZpY2Ugd2l0aCByZXBvc2l0b3J5XG4gKiBjb25zdCByZXBvc2l0b3J5ID0gbmV3IFNRTGl0ZVBvc2l0aW9uUmVwb3NpdG9yeSgpO1xuICogY29uc3Qgc2VydmljZSA9IG5ldyBQb3NpdGlvblNlcnZpY2UocmVwb3NpdG9yeSwge1xuICogICBjYWNoZUVuYWJsZWQ6IHRydWUsXG4gKiAgIGNhY2hlU2l6ZTogMTAwXG4gKiB9KTtcbiAqXG4gKiAvLyBVc2Ugc2VydmljZVxuICogY29uc3QgcG9zaXRpb24gPSBhd2FpdCBzZXJ2aWNlLmdldFBvc2l0aW9uKDEpO1xuICogY29uc3QgcG9zaXRpb25zID0gYXdhaXQgc2VydmljZS5nZXRQb3NpdGlvbnNCeUNhdGVnb3J5KCdiYXNpYy1jaGVja21hdGVzJyk7XG4gKiBgYGBcbiAqL1xuXG5pbXBvcnQgeyBJUG9zaXRpb25SZXBvc2l0b3J5IH0gZnJvbSBcIkBzaGFyZWQvcmVwb3NpdG9yaWVzL0lQb3NpdGlvblJlcG9zaXRvcnlcIjtcbmltcG9ydCB7IElQb3NpdGlvblNlcnZpY2UsIElQb3NpdGlvblNlcnZpY2VDb25maWcgfSBmcm9tIFwiLi9JUG9zaXRpb25TZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBFbmRnYW1lUG9zaXRpb24sXG4gIEVuZGdhbWVDYXRlZ29yeSxcbiAgRW5kZ2FtZUNoYXB0ZXIsXG59IGZyb20gXCJAc2hhcmVkL3R5cGVzXCI7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nXCI7XG5pbXBvcnQgeyBMUlVDYWNoZSB9IGZyb20gXCJAc2hhcmVkL2xpYi9jYWNoZS9MUlVDYWNoZVwiO1xuaW1wb3J0IHsgUmVwb3NpdG9yeUVycm9yIH0gZnJvbSBcIi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBDQUNIRSB9IGZyb20gXCJAc2hhcmVkL2NvbnN0YW50c1wiO1xuXG5jb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KFwiUG9zaXRpb25TZXJ2aWNlXCIpO1xuXG4vKipcbiAqIFNlcnZpY2UgZm9yIG1hbmFnaW5nIGNoZXNzIHBvc2l0aW9uc1xuICpcbiAqIEBjbGFzcyBQb3NpdGlvblNlcnZpY2VcbiAqIEBpbXBsZW1lbnRzIHtJUG9zaXRpb25TZXJ2aWNlfVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSW1wbGVtZW50cyB0aGUgcG9zaXRpb24gc2VydmljZSBpbnRlcmZhY2Ugd2l0aCBjYWNoaW5nIGFuZCBidXNpbmVzcyBsb2dpYy5cbiAqIFVzZXMgcmVwb3NpdG9yeSBwYXR0ZXJuIGZvciBkYXRhIGFjY2VzcyBhYnN0cmFjdGlvbiwgYWxsb3dpbmcgZGlmZmVyZW50XG4gKiBzdG9yYWdlIGJhY2tlbmRzIChTUUxpdGUsIFBvc3RncmVTUUwsIGV0Yy4pIHdpdGhvdXQgY2hhbmdpbmcgc2VydmljZSBjb2RlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBzZXJ2aWNlID0gbmV3IFBvc2l0aW9uU2VydmljZShyZXBvc2l0b3J5LCB7XG4gKiAgIGNhY2hlRW5hYmxlZDogdHJ1ZSxcbiAqICAgY2FjaGVTaXplOiAyMDAsXG4gKiAgIGNhY2hlVFRMOiAzMDAwMDAgLy8gNSBtaW51dGVzXG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgUG9zaXRpb25TZXJ2aWNlIGltcGxlbWVudHMgSVBvc2l0aW9uU2VydmljZSB7XG4gIHByaXZhdGUgcmVwb3NpdG9yeTogSVBvc2l0aW9uUmVwb3NpdG9yeTtcbiAgcHJpdmF0ZSBjYWNoZT86IExSVUNhY2hlPEVuZGdhbWVQb3NpdGlvbj47XG4gIHByaXZhdGUgY29uZmlnOiBJUG9zaXRpb25TZXJ2aWNlQ29uZmlnO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uU2VydmljZSBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge0lQb3NpdGlvblJlcG9zaXRvcnl9IHJlcG9zaXRvcnkgLSBEYXRhIGFjY2VzcyByZXBvc2l0b3J5XG4gICAqIEBwYXJhbSB7SVBvc2l0aW9uU2VydmljZUNvbmZpZ30gW2NvbmZpZz17fV0gLSBTZXJ2aWNlIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzZXJ2aWNlID0gbmV3IFBvc2l0aW9uU2VydmljZShyZXBvc2l0b3J5LCB7XG4gICAqICAgY2FjaGVFbmFibGVkOiB0cnVlLFxuICAgKiAgIGNhY2hlU2l6ZTogMTAwXG4gICAqIH0pO1xuICAgKiBgYGBcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlcG9zaXRvcnk6IElQb3NpdGlvblJlcG9zaXRvcnksXG4gICAgY29uZmlnOiBJUG9zaXRpb25TZXJ2aWNlQ29uZmlnID0ge30sXG4gICkge1xuICAgIHRoaXMucmVwb3NpdG9yeSA9IHJlcG9zaXRvcnk7XG4gICAgdGhpcy5jb25maWcgPSB7XG4gICAgICBjYWNoZUVuYWJsZWQ6IHRydWUsXG4gICAgICBjYWNoZVNpemU6IENBQ0hFLlBPU0lUSU9OX0NBQ0hFX1NJWkUsXG4gICAgICBjYWNoZVRUTDogQ0FDSEUuQU5BTFlTSVNfQ0FDSEVfVFRMLFxuICAgICAgLi4uY29uZmlnLFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb25maWcuY2FjaGVFbmFibGVkKSB7XG4gICAgICB0aGlzLmNhY2hlID0gbmV3IExSVUNhY2hlPEVuZGdhbWVQb3NpdGlvbj4odGhpcy5jb25maWcuY2FjaGVTaXplISk7XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8oXCJQb3NpdGlvblNlcnZpY2UgaW5pdGlhbGl6ZWRcIiwgeyBjb25maWc6IHRoaXMuY29uZmlnIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNpbmdsZSBwb3NpdGlvbiBieSBJRFxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBQb3NpdGlvbiBpZGVudGlmaWVyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVuZGdhbWVQb3NpdGlvbiB8IG51bGw+fSBQb3NpdGlvbiBpZiBmb3VuZCwgbnVsbCBvdGhlcndpc2VcbiAgICogQHRocm93cyB7UmVwb3NpdG9yeUVycm9yfSBJZiByZXBvc2l0b3J5IG9wZXJhdGlvbiBmYWlsc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0cmlldmVzIGEgcG9zaXRpb24gYnkgSUQgd2l0aCBjYWNoZS1maXJzdCBzdHJhdGVneS5cbiAgICogSWYgZm91bmQgaW4gY2FjaGUsIHJldHVybnMgaW1tZWRpYXRlbHkuIE90aGVyd2lzZSBmZXRjaGVzXG4gICAqIGZyb20gcmVwb3NpdG9yeSBhbmQgY2FjaGVzIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgcG9zaXRpb24gPSBhd2FpdCBzZXJ2aWNlLmdldFBvc2l0aW9uKDEpO1xuICAgKiBpZiAocG9zaXRpb24pIHtcbiAgICogICBjb25zb2xlLmxvZyhwb3NpdGlvbi50aXRsZSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBnZXRQb3NpdGlvbihpZDogbnVtYmVyKTogUHJvbWlzZTxFbmRnYW1lUG9zaXRpb24gfCBudWxsPiB7XG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBjb25zdCBjYWNoZUtleSA9IGlkLnRvU3RyaW5nKCk7XG4gICAgaWYgKHRoaXMuY2FjaGU/LmhhcyhjYWNoZUtleSkpIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNhY2hlIGhpdCBmb3IgcG9zaXRpb25cIiwgeyBpZCB9KTtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSkhO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5nZXRQb3NpdGlvbihpZCk7XG5cbiAgICAgIGlmIChwb3NpdGlvbiAmJiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGNhY2hlS2V5LCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBwb3NpdGlvblwiLCB7IGlkLCBlcnJvciB9KTtcbiAgICAgIHRocm93IG5ldyBSZXBvc2l0b3J5RXJyb3IoXCJnZXRQb3NpdGlvblwiLCBlcnJvciBhcyBFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgcG9zaXRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVuZGdhbWVQb3NpdGlvbltdPn0gQXJyYXkgb2YgYWxsIHBvc2l0aW9uc1xuICAgKiBAdGhyb3dzIHtSZXBvc2l0b3J5RXJyb3J9IElmIHJlcG9zaXRvcnkgb3BlcmF0aW9uIGZhaWxzXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgYWxsIHBvc2l0aW9ucyBmcm9tIHRoZSByZXBvc2l0b3J5IGFuZCBjYWNoZXNcbiAgICogZWFjaCBwb3NpdGlvbiBpbmRpdmlkdWFsbHkgZm9yIGZ1dHVyZSBzaW5nbGUtcG9zaXRpb24gbG9va3Vwcy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVXNlIHdpdGggY2F1dGlvbiBvbiBsYXJnZSBkYXRhc2V0cyBhcyB0aGlzIGxvYWRzIGFsbCBwb3NpdGlvbnNcbiAgICogaW50byBtZW1vcnkuIENvbnNpZGVyIHVzaW5nIHBhZ2luYXRpb24gb3IgZmlsdGVyaW5nIGZvciBiZXR0ZXJcbiAgICogcGVyZm9ybWFuY2Ugd2l0aCBsYXJnZSBwb3NpdGlvbiBkYXRhYmFzZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgYWxsUG9zaXRpb25zID0gYXdhaXQgc2VydmljZS5nZXRBbGxQb3NpdGlvbnMoKTtcbiAgICogY29uc29sZS5sb2coYFRvdGFsIHBvc2l0aW9uczogJHthbGxQb3NpdGlvbnMubGVuZ3RofWApO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldEFsbFBvc2l0aW9ucygpOiBQcm9taXNlPEVuZGdhbWVQb3NpdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5nZXRBbGxQb3NpdGlvbnMoKTtcblxuICAgICAgLy8gQ2FjaGUgaW5kaXZpZHVhbCBwb3NpdGlvbnNcbiAgICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3NpdGlvbikgPT4ge1xuICAgICAgICAgIHRoaXMuY2FjaGUhLnNldChwb3NpdGlvbi5pZC50b1N0cmluZygpLCBwb3NpdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9zaXRpb25zO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGFsbCBwb3NpdGlvbnNcIiwgeyBlcnJvciB9KTtcbiAgICAgIHRocm93IG5ldyBSZXBvc2l0b3J5RXJyb3IoXCJnZXRBbGxQb3NpdGlvbnNcIiwgZXJyb3IgYXMgRXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcG9zaXRpb25zIGJ5IGNhdGVnb3J5XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYXRlZ29yeSAtIENhdGVnb3J5IGlkZW50aWZpZXIgKGUuZy4sICdiYXNpYy1jaGVja21hdGVzJylcbiAgICogQHJldHVybnMge1Byb21pc2U8RW5kZ2FtZVBvc2l0aW9uW10+fSBQb3NpdGlvbnMgaW4gdGhlIGNhdGVnb3J5XG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgYWxsIHBvc2l0aW9ucyBiZWxvbmdpbmcgdG8gYSBzcGVjaWZpYyBjYXRlZ29yeS5cbiAgICogUmVzdWx0cyBhcmUgY2FjaGVkIGluZGl2aWR1YWxseSBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2VcbiAgICogb24gc3Vic2VxdWVudCBzaW5nbGUtcG9zaXRpb24gbG9va3Vwcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBjaGVja21hdGVzID0gYXdhaXQgc2VydmljZS5nZXRQb3NpdGlvbnNCeUNhdGVnb3J5KCdiYXNpYy1jaGVja21hdGVzJyk7XG4gICAqIGNvbnN0IHJvb2tFbmRnYW1lcyA9IGF3YWl0IHNlcnZpY2UuZ2V0UG9zaXRpb25zQnlDYXRlZ29yeSgncm9vay1lbmRnYW1lcycpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9uc0J5Q2F0ZWdvcnkoY2F0ZWdvcnk6IHN0cmluZyk6IFByb21pc2U8RW5kZ2FtZVBvc2l0aW9uW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gYXdhaXQgdGhpcy5yZXBvc2l0b3J5LmdldFBvc2l0aW9uc0J5Q2F0ZWdvcnkoY2F0ZWdvcnkpO1xuXG4gICAgICAvLyBDYWNoZSBpbmRpdmlkdWFsIHBvc2l0aW9uc1xuICAgICAgaWYgKHRoaXMuY2FjaGUpIHtcbiAgICAgICAgcG9zaXRpb25zLmZvckVhY2goKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYWNoZSEuc2V0KHBvc2l0aW9uLmlkLnRvU3RyaW5nKCksIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbnM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgcG9zaXRpb25zIGJ5IGNhdGVnb3J5XCIsIHsgY2F0ZWdvcnksIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcG9zaXRpb25zIGJ5IGRpZmZpY3VsdHlcbiAgICogQHBhcmFtIGRpZmZpY3VsdHlcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9uc0J5RGlmZmljdWx0eShcbiAgICBkaWZmaWN1bHR5OiBFbmRnYW1lUG9zaXRpb25bXCJkaWZmaWN1bHR5XCJdLFxuICApOiBQcm9taXNlPEVuZGdhbWVQb3NpdGlvbltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9XG4gICAgICAgIGF3YWl0IHRoaXMucmVwb3NpdG9yeS5nZXRQb3NpdGlvbnNCeURpZmZpY3VsdHkoZGlmZmljdWx0eSk7XG5cbiAgICAgIC8vIENhY2hlIGluZGl2aWR1YWwgcG9zaXRpb25zXG4gICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICB0aGlzLmNhY2hlIS5zZXQocG9zaXRpb24uaWQudG9TdHJpbmcoKSwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBwb3NpdGlvbnMgYnkgZGlmZmljdWx0eVwiLCB7XG4gICAgICAgIGRpZmZpY3VsdHksXG4gICAgICAgIGVycm9yLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlYXJjaCBwb3NpdGlvbnMgYnkgdGl0bGUgb3IgZGVzY3JpcHRpb25cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFRlcm0gLSBTZWFyY2ggcXVlcnlcbiAgICogQHJldHVybnMge1Byb21pc2U8RW5kZ2FtZVBvc2l0aW9uW10+fSBNYXRjaGluZyBwb3NpdGlvbnNcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFBlcmZvcm1zIGZ1bGwtdGV4dCBzZWFyY2ggYWNyb3NzIHBvc2l0aW9uIHRpdGxlcyBhbmQgZGVzY3JpcHRpb25zLlxuICAgKiBFbXB0eSBvciB3aGl0ZXNwYWNlLW9ubHkgc2VhcmNoIHRlcm1zIHJldHVybiBlbXB0eSByZXN1bHRzLlxuICAgKiBTZWFyY2ggaXMgZGVsZWdhdGVkIHRvIHRoZSByZXBvc2l0b3J5IGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzZXJ2aWNlLnNlYXJjaFBvc2l0aW9ucygncm9vayBjaGVja21hdGUnKTtcbiAgICogY29uc3QgcXVlZW5FbmRnYW1lcyA9IGF3YWl0IHNlcnZpY2Uuc2VhcmNoUG9zaXRpb25zKCdxdWVlbiB2cyBwYXduJyk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgc2VhcmNoUG9zaXRpb25zKHNlYXJjaFRlcm06IHN0cmluZyk6IFByb21pc2U8RW5kZ2FtZVBvc2l0aW9uW10+IHtcbiAgICBpZiAoIXNlYXJjaFRlcm0udHJpbSgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5zZWFyY2hQb3NpdGlvbnMoc2VhcmNoVGVybSk7XG5cbiAgICAgIC8vIENhY2hlIGluZGl2aWR1YWwgcG9zaXRpb25zXG4gICAgICBpZiAodGhpcy5jYWNoZSkge1xuICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICB0aGlzLmNhY2hlIS5zZXQocG9zaXRpb24uaWQudG9TdHJpbmcoKSwgcG9zaXRpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHNlYXJjaCBwb3NpdGlvbnNcIiwgeyBzZWFyY2hUZXJtLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXIgdGhlIGNhY2hlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZW1vdmVzIGFsbCBjYWNoZWQgcG9zaXRpb25zIGZyb20gbWVtb3J5LlxuICAgKiBVc2VmdWwgZm9yIHRlc3Rpbmcgb3Igd2hlbiBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQgZXh0ZXJuYWxseS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBzZXJ2aWNlLmNsZWFyQ2FjaGUoKTtcbiAgICogY29uc29sZS5sb2coJ0NhY2hlIGNsZWFyZWQnKTtcbiAgICogYGBgXG4gICAqL1xuICBjbGVhckNhY2hlKCk6IHZvaWQge1xuICAgIHRoaXMuY2FjaGU/LmNsZWFyKCk7XG4gICAgbG9nZ2VyLmluZm8oXCJQb3NpdGlvbiBjYWNoZSBjbGVhcmVkXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjYWNoZSBzdGF0aXN0aWNzXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IENhY2hlIHN0YXRpc3RpY3NcbiAgICogQHJldHVybnMge251bWJlcn0gcmV0dXJucy5zaXplIC0gTnVtYmVyIG9mIGNhY2hlZCBpdGVtc1xuICAgKiBAcmV0dXJucyB7bnVtYmVyW119IHJldHVybnMua2V5cyAtIEFycmF5IG9mIGNhY2hlZCBwb3NpdGlvbiBJRHNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHJldHVybnMuZW5hYmxlZCAtIFdoZXRoZXIgY2FjaGluZyBpcyBlbmFibGVkXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQcm92aWRlcyBpbnNpZ2h0IGludG8gY2FjaGUgdXNhZ2UgZm9yIG1vbml0b3JpbmcgYW5kIGRlYnVnZ2luZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCBzdGF0cyA9IHNlcnZpY2UuZ2V0Q2FjaGVTdGF0cygpO1xuICAgKiBjb25zb2xlLmxvZyhgQ2FjaGVkIHBvc2l0aW9uczogJHtzdGF0cy5zaXplfWApO1xuICAgKiBjb25zb2xlLmxvZyhgQ2FjaGUgZW5hYmxlZDogJHtzdGF0cy5lbmFibGVkfWApO1xuICAgKiBgYGBcbiAgICovXG4gIGdldENhY2hlU3RhdHMoKTogeyBzaXplOiBudW1iZXI7IGtleXM6IG51bWJlcltdOyBlbmFibGVkOiBib29sZWFuIH0ge1xuICAgIGlmICghdGhpcy5jYWNoZSkge1xuICAgICAgcmV0dXJuIHsgc2l6ZTogMCwga2V5czogW10sIGVuYWJsZWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhdHMgPSB0aGlzLmNhY2hlLmdldFN0YXRzKCk7XG4gICAgY29uc3Qga2V5cyA9IHRoaXMuY2FjaGUua2V5cygpLm1hcCgoa2V5KSA9PiBwYXJzZUludChrZXksIDEwKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemU6IHN0YXRzLnNpemUsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgY2F0ZWdvcmllc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2F0ZWdvcmllcygpOiBQcm9taXNlPEVuZGdhbWVDYXRlZ29yeVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZ2V0Q2F0ZWdvcmllcygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IGNhdGVnb3JpZXNcIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBjaGFwdGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q2hhcHRlcnMoKTogUHJvbWlzZTxFbmRnYW1lQ2hhcHRlcltdPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZ2V0Q2hhcHRlcnMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBjaGFwdGVyc1wiLCB7IGVycm9yIH0pO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY2hhcHRlcnMgYnkgY2F0ZWdvcnlcbiAgICogQHBhcmFtIGNhdGVnb3J5SWRcbiAgICovXG4gIGFzeW5jIGdldENoYXB0ZXJzQnlDYXRlZ29yeShjYXRlZ29yeUlkOiBzdHJpbmcpOiBQcm9taXNlPEVuZGdhbWVDaGFwdGVyW10+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucmVwb3NpdG9yeS5nZXRDaGFwdGVyc0J5Q2F0ZWdvcnkoY2F0ZWdvcnlJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgY2hhcHRlcnMgYnkgY2F0ZWdvcnlcIiwgeyBjYXRlZ29yeUlkLCBlcnJvciB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IG5leHQgcG9zaXRpb24gaW4gc2VxdWVuY2UgKGZvciBuYXZpZ2F0aW9uKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudElkIC0gQ3VycmVudCBwb3NpdGlvbiBJRFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5SWRdIC0gT3B0aW9uYWwgY2F0ZWdvcnkgY29uc3RyYWludFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxFbmRnYW1lUG9zaXRpb24gfCBudWxsPn0gTmV4dCBwb3NpdGlvbiBvciBudWxsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgdGhlIG5leHQgcG9zaXRpb24gaW4gc2VxdWVuY2UsIG9wdGlvbmFsbHkgd2l0aGluXG4gICAqIHRoZSBzYW1lIGNhdGVnb3J5LiBVc2VkIGZvciBuYXZpZ2F0aW9uIGJldHdlZW4gcG9zaXRpb25zLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIC8vIEdldCBuZXh0IHBvc2l0aW9uIGluIGFueSBjYXRlZ29yeVxuICAgKiBjb25zdCBuZXh0ID0gYXdhaXQgc2VydmljZS5nZXROZXh0UG9zaXRpb24oNSk7XG4gICAqXG4gICAqIC8vIEdldCBuZXh0IHBvc2l0aW9uIGluIHNhbWUgY2F0ZWdvcnlcbiAgICogY29uc3QgbmV4dEluQ2F0ZWdvcnkgPSBhd2FpdCBzZXJ2aWNlLmdldE5leHRQb3NpdGlvbig1LCAncm9vay1lbmRnYW1lcycpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIGdldE5leHRQb3NpdGlvbihcbiAgICBjdXJyZW50SWQ6IG51bWJlcixcbiAgICBjYXRlZ29yeUlkPzogc3RyaW5nLFxuICApOiBQcm9taXNlPEVuZGdhbWVQb3NpdGlvbiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZ2V0TmV4dFBvc2l0aW9uKFxuICAgICAgICBjdXJyZW50SWQsXG4gICAgICAgIGNhdGVnb3J5SWQsXG4gICAgICApO1xuXG4gICAgICBpZiAocG9zaXRpb24gJiYgdGhpcy5jYWNoZSkge1xuICAgICAgICB0aGlzLmNhY2hlLnNldChwb3NpdGlvbi5pZC50b1N0cmluZygpLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIGdldCBuZXh0IHBvc2l0aW9uXCIsIHtcbiAgICAgICAgY3VycmVudElkLFxuICAgICAgICBjYXRlZ29yeUlkLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBwcmV2aW91cyBwb3NpdGlvbiBpbiBzZXF1ZW5jZSAoZm9yIG5hdmlnYXRpb24pXG4gICAqIEBwYXJhbSBjdXJyZW50SWRcbiAgICogQHBhcmFtIGNhdGVnb3J5SWRcbiAgICovXG4gIGFzeW5jIGdldFByZXZpb3VzUG9zaXRpb24oXG4gICAgY3VycmVudElkOiBudW1iZXIsXG4gICAgY2F0ZWdvcnlJZD86IHN0cmluZyxcbiAgKTogUHJvbWlzZTxFbmRnYW1lUG9zaXRpb24gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gYXdhaXQgdGhpcy5yZXBvc2l0b3J5LmdldFByZXZpb3VzUG9zaXRpb24oXG4gICAgICAgIGN1cnJlbnRJZCxcbiAgICAgICAgY2F0ZWdvcnlJZCxcbiAgICAgICk7XG5cbiAgICAgIGlmIChwb3NpdGlvbiAmJiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KHBvc2l0aW9uLmlkLnRvU3RyaW5nKCksIHBvc2l0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHByZXZpb3VzIHBvc2l0aW9uXCIsIHtcbiAgICAgICAgY3VycmVudElkLFxuICAgICAgICBjYXRlZ29yeUlkLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0b3RhbCBwb3NpdGlvbiBjb3VudFxuICAgKi9cbiAgYXN5bmMgZ2V0VG90YWxQb3NpdGlvbkNvdW50KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZ2V0VG90YWxQb3NpdGlvbkNvdW50KCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgcG9zaXRpb24gY291bnRcIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcG9zaXRpb24gY291bnQgYnkgY2F0ZWdvcnlcbiAgICogQHBhcmFtIGNhdGVnb3J5SWRcbiAgICovXG4gIGFzeW5jIGdldFBvc2l0aW9uQ291bnRCeUNhdGVnb3J5KGNhdGVnb3J5SWQ6IHN0cmluZyk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlcG9zaXRvcnkuZ2V0UG9zaXRpb25Db3VudEJ5Q2F0ZWdvcnkoY2F0ZWdvcnlJZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBnZXQgcG9zaXRpb24gY291bnQgYnkgY2F0ZWdvcnlcIiwge1xuICAgICAgICBjYXRlZ29yeUlkLFxuICAgICAgICBlcnJvcixcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBwb3NpdGlvbiAoYWRtaW4gZnVuY3Rpb25hbGl0eSlcbiAgICpcbiAgICogQHBhcmFtIHtPbWl0PEVuZGdhbWVQb3NpdGlvbiwgJ2lkJz59IHBvc2l0aW9uIC0gUG9zaXRpb24gZGF0YSB3aXRob3V0IElEXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEVuZGdhbWVQb3NpdGlvbiB8IG51bGw+fSBDcmVhdGVkIHBvc2l0aW9uIG9yIG51bGwgb24gZmFpbHVyZVxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIG5ldyBwb3NpdGlvbiBpbiB0aGUgcmVwb3NpdG9yeS4gVGhlIElEIGlzIGF1dG8tZ2VuZXJhdGVkXG4gICAqIGJ5IHRoZSBzdG9yYWdlIGJhY2tlbmQuIENyZWF0ZWQgcG9zaXRpb24gaXMgYXV0b21hdGljYWxseSBjYWNoZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgaXMgYW4gYWRtaW5pc3RyYXRpdmUgZnVuY3Rpb24gdGhhdCBtYXkgcmVxdWlyZSBzcGVjaWFsXG4gICAqIHBlcm1pc3Npb25zIGluIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IG5ld1Bvc2l0aW9uID0gYXdhaXQgc2VydmljZS5jcmVhdGVQb3NpdGlvbih7XG4gICAqICAgdGl0bGU6ICdRdWVlbiB2cyBSb29rJyxcbiAgICogICBmZW46ICc4LzgvOC84LzNRNC84LzgvM3JrMyB3IC0gLSAwIDEnLFxuICAgKiAgIGNhdGVnb3J5OiAncXVlZW4tZW5kZ2FtZXMnLFxuICAgKiAgIGRpZmZpY3VsdHk6ICdhZHZhbmNlZCdcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKi9cbiAgYXN5bmMgY3JlYXRlUG9zaXRpb24oXG4gICAgcG9zaXRpb246IE9taXQ8RW5kZ2FtZVBvc2l0aW9uLCBcImlkXCI+LFxuICApOiBQcm9taXNlPEVuZGdhbWVQb3NpdGlvbiB8IG51bGw+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3JlYXRlZCA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5jcmVhdGVQb3NpdGlvbihwb3NpdGlvbik7XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGNyZWF0ZWQuaWQudG9TdHJpbmcoKSwgY3JlYXRlZCk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5pbmZvKFwiUG9zaXRpb24gY3JlYXRlZFwiLCB7IGlkOiBjcmVhdGVkLmlkIH0pO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgcG9zaXRpb25cIiwgeyBlcnJvciB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgYSBwb3NpdGlvbiAoYWRtaW4gZnVuY3Rpb25hbGl0eSlcbiAgICogQHBhcmFtIGlkXG4gICAqIEBwYXJhbSB1cGRhdGVzXG4gICAqL1xuICBhc3luYyB1cGRhdGVQb3NpdGlvbihcbiAgICBpZDogbnVtYmVyLFxuICAgIHVwZGF0ZXM6IFBhcnRpYWw8RW5kZ2FtZVBvc2l0aW9uPixcbiAgKTogUHJvbWlzZTxFbmRnYW1lUG9zaXRpb24gfCBudWxsPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVwZGF0ZWQgPSBhd2FpdCB0aGlzLnJlcG9zaXRvcnkudXBkYXRlUG9zaXRpb24oaWQsIHVwZGF0ZXMpO1xuXG4gICAgICBpZiAodXBkYXRlZCAmJiB0aGlzLmNhY2hlKSB7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGlkLnRvU3RyaW5nKCksIHVwZGF0ZWQpO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIuaW5mbyhcIlBvc2l0aW9uIHVwZGF0ZWRcIiwgeyBpZCB9KTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoXCJGYWlsZWQgdG8gdXBkYXRlIHBvc2l0aW9uXCIsIHsgaWQsIGVycm9yIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHBvc2l0aW9uIChhZG1pbiBmdW5jdGlvbmFsaXR5KVxuICAgKiBAcGFyYW0gaWRcbiAgICovXG4gIGFzeW5jIGRlbGV0ZVBvc2l0aW9uKGlkOiBudW1iZXIpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVsZXRlZCA9IGF3YWl0IHRoaXMucmVwb3NpdG9yeS5kZWxldGVQb3NpdGlvbihpZCk7XG5cbiAgICAgIGlmIChkZWxldGVkICYmIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoaWQudG9TdHJpbmcoKSk7XG4gICAgICB9XG5cbiAgICAgIGxvZ2dlci5pbmZvKFwiUG9zaXRpb24gZGVsZXRlZFwiLCB7IGlkIH0pO1xuICAgICAgcmV0dXJuIGRlbGV0ZWQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcihcIkZhaWxlZCB0byBkZWxldGUgcG9zaXRpb25cIiwgeyBpZCwgZXJyb3IgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsiUG9zaXRpb25TZXJ2aWNlIiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImdldFBvc2l0aW9uIiwiaWQiLCJjYWNoZUtleSIsInRvU3RyaW5nIiwiY2FjaGUiLCJoYXMiLCJkZWJ1ZyIsImdldCIsInBvc2l0aW9uIiwicmVwb3NpdG9yeSIsInNldCIsImVycm9yIiwiUmVwb3NpdG9yeUVycm9yIiwiZ2V0QWxsUG9zaXRpb25zIiwicG9zaXRpb25zIiwiZm9yRWFjaCIsImdldFBvc2l0aW9uc0J5Q2F0ZWdvcnkiLCJjYXRlZ29yeSIsImdldFBvc2l0aW9uc0J5RGlmZmljdWx0eSIsImRpZmZpY3VsdHkiLCJzZWFyY2hQb3NpdGlvbnMiLCJzZWFyY2hUZXJtIiwidHJpbSIsImNsZWFyQ2FjaGUiLCJjbGVhciIsImluZm8iLCJnZXRDYWNoZVN0YXRzIiwic2l6ZSIsImtleXMiLCJlbmFibGVkIiwic3RhdHMiLCJnZXRTdGF0cyIsIm1hcCIsImtleSIsInBhcnNlSW50IiwiZ2V0Q2F0ZWdvcmllcyIsImdldENoYXB0ZXJzIiwiZ2V0Q2hhcHRlcnNCeUNhdGVnb3J5IiwiY2F0ZWdvcnlJZCIsImdldE5leHRQb3NpdGlvbiIsImN1cnJlbnRJZCIsImdldFByZXZpb3VzUG9zaXRpb24iLCJnZXRUb3RhbFBvc2l0aW9uQ291bnQiLCJnZXRQb3NpdGlvbkNvdW50QnlDYXRlZ29yeSIsImNyZWF0ZVBvc2l0aW9uIiwiY3JlYXRlZCIsInVwZGF0ZVBvc2l0aW9uIiwidXBkYXRlcyIsInVwZGF0ZWQiLCJkZWxldGVQb3NpdGlvbiIsImRlbGV0ZWQiLCJkZWxldGUiLCJjb25maWciLCJjYWNoZUVuYWJsZWQiLCJjYWNoZVNpemUiLCJDQUNIRSIsIlBPU0lUSU9OX0NBQ0hFX1NJWkUiLCJjYWNoZVRUTCIsIkFOQUxZU0lTX0NBQ0hFX1RUTCIsIkxSVUNhY2hlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQ0M7Ozs7K0JBb0NZQTs7O2VBQUFBOzs7eUJBM0JhOzBCQUNEO3dCQUNPOzJCQUNWOzs7Ozs7Ozs7Ozs7OztBQUV0QixNQUFNQyxTQUFTQyxJQUFBQSxrQkFBUyxJQUFHQyxVQUFVLENBQUM7QUFzQi9CLE1BQU1IO0lBc0NYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUJDLEdBQ0QsTUFBTUksWUFBWUMsRUFBVSxFQUFtQztZQUd6RDtRQUZKLG9CQUFvQjtRQUNwQixNQUFNQyxXQUFXRCxHQUFHRSxRQUFRO1FBQzVCLEtBQUksY0FBQSxJQUFJLENBQUNDLEtBQUssY0FBVixrQ0FBQSxZQUFZQyxHQUFHLENBQUNILFdBQVc7WUFDN0JMLE9BQU9TLEtBQUssQ0FBQywwQkFBMEI7Z0JBQUVMO1lBQUc7WUFDNUMsT0FBTyxJQUFJLENBQUNHLEtBQUssQ0FBQ0csR0FBRyxDQUFDTDtRQUN4QjtRQUVBLElBQUk7WUFDRixNQUFNTSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxVQUFVLENBQUNULFdBQVcsQ0FBQ0M7WUFFbkQsSUFBSU8sWUFBWSxJQUFJLENBQUNKLEtBQUssRUFBRTtnQkFDMUIsSUFBSSxDQUFDQSxLQUFLLENBQUNNLEdBQUcsQ0FBQ1IsVUFBVU07WUFDM0I7WUFFQSxPQUFPQTtRQUNULEVBQUUsT0FBT0csT0FBTztZQUNkZCxPQUFPYyxLQUFLLENBQUMsMEJBQTBCO2dCQUFFVjtnQkFBSVU7WUFBTTtZQUNuRCxNQUFNLElBQUlDLHVCQUFlLENBQUMsZUFBZUQ7UUFDM0M7SUFDRjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW9CQyxHQUNELE1BQU1FLGtCQUE4QztRQUNsRCxJQUFJO1lBQ0YsTUFBTUMsWUFBWSxNQUFNLElBQUksQ0FBQ0wsVUFBVSxDQUFDSSxlQUFlO1lBRXZELDZCQUE2QjtZQUM3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