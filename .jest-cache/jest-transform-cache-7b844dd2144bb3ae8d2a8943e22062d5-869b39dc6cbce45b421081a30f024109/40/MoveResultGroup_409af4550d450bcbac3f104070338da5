38e84f8cad0d40e2f7ca22fc03e6dca0
/**
 * @file Move result grouping component
 * @module components/tablebase/MoveResultGroup
 *
 * @description
 * Groups tablebase moves by result type (Win/Draw/Loss) with collapsible sections
 * and clear visual organization. Provides an intuitive interface similar to the
 * Lichess tablebase display for exploring move categories.
 *
 * @remarks
 * Key features:
 * - Collapsible groups for space efficiency
 * - Visual icons and color coding by outcome
 * - Move count display per group
 * - Keyboard accessible expand/collapse
 * - Automatic DTZ normalization within groups
 * - Summary statistics component
 *
 * The component automatically calculates the maximum DTZ within each group
 * to ensure consistent bar scaling for visual comparison.
 */ "use client";
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get CompactMoveResultGroup () {
        return CompactMoveResultGroup;
    },
    get MoveResultGroup () {
        return MoveResultGroup;
    },
    get MoveResultGroupSummary () {
        return MoveResultGroupSummary;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _MoveEvaluationBar = require("./MoveEvaluationBar");
const _resultClassification = require("../../utils/tablebase/resultClassification");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const MoveResultGroup = ({ moves, resultType, title, onMoveSelect, selectedMove, initiallyExpanded = true, compact = false, className = "" })=>{
    const [isExpanded, setIsExpanded] = (0, _react.useState)(initiallyExpanded);
    if (moves.length === 0) {
        return null;
    }
    const groupTitle = title || (0, _resultClassification.getResultTypeTitle)(resultType);
    const icon = (0, _resultClassification.getResultIcon)(resultType);
    const maxDtz = Math.max(...moves.map((move)=>Math.abs(move.dtz)));
    /**
   * Gets CSS color class for result type icons
   *
   * @private
   * @param {MoveResultType} type - The result type to style
   * @returns {string} Tailwind CSS classes for text color
   *
   * @description
   * Maps result types to appropriate color classes with dark mode support.
   * Colors follow standard chess conventions: green for wins, yellow for draws,
   * red for losses, and gray for unknown/unclassified results.
   */ const getTextColorClass = (type)=>{
        switch(type){
            case "win":
                return "text-green-600 dark:text-green-400";
            case "draw":
                return "text-yellow-600 dark:text-yellow-400";
            case "loss":
                return "text-red-600 dark:text-red-400";
            default:
                return "text-gray-600 dark:text-gray-400";
        }
    };
    return /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
        className: `move-result-group ${className}`,
        children: [
            /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                className: `
          flex items-center justify-between py-2 px-1 cursor-pointer
          transition-all duration-200 hover:bg-gray-50 dark:hover:bg-gray-800/50
        `,
                onClick: ()=>setIsExpanded(!isExpanded),
                role: "button",
                tabIndex: 0,
                "aria-label": `${groupTitle} section, ${moves.length} moves`,
                "aria-expanded": isExpanded,
                onKeyDown: (e)=>{
                    if (e.key === "Enter" || e.key === " ") {
                        e.preventDefault();
                        setIsExpanded(!isExpanded);
                    }
                },
                children: [
                    /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
                        className: "flex items-center space-x-3",
                        children: [
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                className: `text-sm font-medium ${getTextColorClass(resultType)}`,
                                "aria-hidden": "true",
                                children: icon
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("h3", {
                                className: "font-medium text-sm text-gray-700 dark:text-gray-300",
                                children: groupTitle
                            }),
                            /*#__PURE__*/ (0, _jsxruntime.jsx)("span", {
                                className: "text-xs text-gray-500 dark:text-gray-400",
                                children: moves.length
                            })
                        ]
                    }),
                    /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                        className: `
            transition-transform duration-200 text-xs text-gray-400
            ${isExpanded ? "rotate-180" : ""}
          `,
                        "aria-hidden": "true",
                        children: "â–¼"
                    })
                ]
            }),
            isExpanded && /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
                className: "mt-1 space-y-0",
                children: moves.map((move, index)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(_MoveEvaluationBar.MoveEvaluationBar, {
                        move: move.san,
                        dtz: move.dtz,
                        maxDtz: maxDtz,
                        onClick: ()=>onMoveSelect(move.san),
                        isSelected: selectedMove === move.san,
                        className: compact ? "text-xs" : "",
                        category: move.category
                    }, `${move.san}-${index}`))
            })
        ]
    });
};
const CompactMoveResultGroup = (props)=>{
    return /*#__PURE__*/ (0, _jsxruntime.jsx)(MoveResultGroup, {
        ...props,
        compact: true,
        className: `compact-move-group ${props.className || ""}`
    });
};
const MoveResultGroupSummary = ({ moves, resultType })=>{
    if (moves.length === 0) return null;
    const avgDtz = moves.reduce((sum, move)=>sum + Math.abs(move.dtz), 0) / moves.length;
    const minDtz = Math.min(...moves.map((move)=>Math.abs(move.dtz)));
    const maxDtz = Math.max(...moves.map((move)=>Math.abs(move.dtz)));
    /**
   * Gets background and text color classes for statistics display
   *
   * @private
   * @param {MoveResultType} type - The result type to style
   * @returns {string} Combined Tailwind CSS classes for styling
   *
   * @description
   * Provides subtle background colors with matching text for the summary
   * statistics component. Uses light backgrounds to avoid overwhelming
   * the interface while maintaining visual consistency.
   */ const getStatsColorClass = (type)=>{
        switch(type){
            case "win":
                return "text-green-600 bg-green-50";
            case "draw":
                return "text-yellow-600 bg-yellow-50";
            case "loss":
                return "text-red-600 bg-red-50";
            default:
                return "text-gray-600 bg-gray-50";
        }
    };
    const statsColorClass = getStatsColorClass(resultType);
    return /*#__PURE__*/ (0, _jsxruntime.jsx)("div", {
        className: `text-xs p-2 rounded ${statsColorClass}`,
        children: /*#__PURE__*/ (0, _jsxruntime.jsxs)("div", {
            className: "flex justify-between items-center",
            children: [
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("span", {
                    children: [
                        "Count: ",
                        moves.length
                    ]
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("span", {
                    children: [
                        "Min DTZ: ",
                        minDtz
                    ]
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("span", {
                    children: [
                        "Avg DTZ: ",
                        avgDtz.toFixed(1)
                    ]
                }),
                /*#__PURE__*/ (0, _jsxruntime.jsxs)("span", {
                    children: [
                        "Max DTZ: ",
                        maxDtz
                    ]
                })
            ]
        })
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL2NvbXBvbmVudHMvdGFibGViYXNlL01vdmVSZXN1bHRHcm91cC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZSBNb3ZlIHJlc3VsdCBncm91cGluZyBjb21wb25lbnRcbiAqIEBtb2R1bGUgY29tcG9uZW50cy90YWJsZWJhc2UvTW92ZVJlc3VsdEdyb3VwXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBHcm91cHMgdGFibGViYXNlIG1vdmVzIGJ5IHJlc3VsdCB0eXBlIChXaW4vRHJhdy9Mb3NzKSB3aXRoIGNvbGxhcHNpYmxlIHNlY3Rpb25zXG4gKiBhbmQgY2xlYXIgdmlzdWFsIG9yZ2FuaXphdGlvbi4gUHJvdmlkZXMgYW4gaW50dWl0aXZlIGludGVyZmFjZSBzaW1pbGFyIHRvIHRoZVxuICogTGljaGVzcyB0YWJsZWJhc2UgZGlzcGxheSBmb3IgZXhwbG9yaW5nIG1vdmUgY2F0ZWdvcmllcy5cbiAqXG4gKiBAcmVtYXJrc1xuICogS2V5IGZlYXR1cmVzOlxuICogLSBDb2xsYXBzaWJsZSBncm91cHMgZm9yIHNwYWNlIGVmZmljaWVuY3lcbiAqIC0gVmlzdWFsIGljb25zIGFuZCBjb2xvciBjb2RpbmcgYnkgb3V0Y29tZVxuICogLSBNb3ZlIGNvdW50IGRpc3BsYXkgcGVyIGdyb3VwXG4gKiAtIEtleWJvYXJkIGFjY2Vzc2libGUgZXhwYW5kL2NvbGxhcHNlXG4gKiAtIEF1dG9tYXRpYyBEVFogbm9ybWFsaXphdGlvbiB3aXRoaW4gZ3JvdXBzXG4gKiAtIFN1bW1hcnkgc3RhdGlzdGljcyBjb21wb25lbnRcbiAqXG4gKiBUaGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgbWF4aW11bSBEVFogd2l0aGluIGVhY2ggZ3JvdXBcbiAqIHRvIGVuc3VyZSBjb25zaXN0ZW50IGJhciBzY2FsaW5nIGZvciB2aXN1YWwgY29tcGFyaXNvbi5cbiAqL1xuXG5cInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBNb3ZlRXZhbHVhdGlvbkJhciB9IGZyb20gXCIuL01vdmVFdmFsdWF0aW9uQmFyXCI7XG5pbXBvcnQge1xuICB0eXBlIE1vdmVSZXN1bHRUeXBlLFxuICB0eXBlIFRhYmxlYmFzZU1vdmUsXG4gIGdldFJlc3VsdFR5cGVUaXRsZSxcbiAgZ2V0UmVzdWx0SWNvbixcbn0gZnJvbSBcIkBzaGFyZWQvdXRpbHMvdGFibGViYXNlL3Jlc3VsdENsYXNzaWZpY2F0aW9uXCI7XG5cbi8qKlxuICogUHJvcHMgZm9yIHRoZSBNb3ZlUmVzdWx0R3JvdXAgY29tcG9uZW50XG4gKlxuICogQGludGVyZmFjZSBNb3ZlUmVzdWx0R3JvdXBQcm9wc1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29uZmlndXJhdGlvbiBmb3IgZ3JvdXBpbmcgYW5kIGRpc3BsYXlpbmcgbW92ZXMgYnkgb3V0Y29tZSB0eXBlLFxuICogd2l0aCBzdXBwb3J0IGZvciBjb2xsYXBzaWJsZSBzZWN0aW9ucyBhbmQgbW92ZSBzZWxlY3Rpb24uXG4gKi9cbmludGVyZmFjZSBNb3ZlUmVzdWx0R3JvdXBQcm9wcyB7XG4gIC8qKiBBcnJheSBvZiBtb3ZlcyBmb3IgdGhpcyByZXN1bHQgdHlwZSAqL1xuICBtb3ZlczogVGFibGViYXNlTW92ZVtdO1xuICAvKiogVGhlIHJlc3VsdCB0eXBlIGZvciB0aGlzIGdyb3VwICovXG4gIHJlc3VsdFR5cGU6IE1vdmVSZXN1bHRUeXBlO1xuICAvKiogQ3VzdG9tIHRpdGxlIGZvciB0aGUgZ3JvdXAgKG9wdGlvbmFsKSAqL1xuICB0aXRsZT86IHN0cmluZztcbiAgLyoqIENhbGxiYWNrIHdoZW4gYSBtb3ZlIGlzIHNlbGVjdGVkICovXG4gIG9uTW92ZVNlbGVjdDogKG1vdmU6IHN0cmluZykgPT4gdm9pZDtcbiAgLyoqIEN1cnJlbnRseSBzZWxlY3RlZCBtb3ZlICovXG4gIHNlbGVjdGVkTW92ZT86IHN0cmluZztcbiAgLyoqIFdoZXRoZXIgdGhlIGdyb3VwIHNob3VsZCBiZSBpbml0aWFsbHkgZXhwYW5kZWQgKi9cbiAgaW5pdGlhbGx5RXhwYW5kZWQ/OiBib29sZWFuO1xuICAvKiogV2hldGhlciB0byBzaG93IGNvbXBhY3QgbGF5b3V0ICovXG4gIGNvbXBhY3Q/OiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBDU1MgY2xhc3NlcyAqL1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTW92ZSByZXN1bHQgZ3JvdXBpbmcgY29tcG9uZW50XG4gKlxuICogQGNvbXBvbmVudFxuICogQGRlc2NyaXB0aW9uXG4gKiBEaXNwbGF5cyB0YWJsZWJhc2UgbW92ZXMgZ3JvdXBlZCBieSBvdXRjb21lIHR5cGUgKFdpbi9EcmF3L0xvc3MpIHdpdGhcbiAqIGNvbGxhcHNpYmxlIHNlY3Rpb25zIGZvciBiZXR0ZXIgb3JnYW5pemF0aW9uLiBFYWNoIGdyb3VwIHNob3dzIG1vdmUgY291bnQsXG4gKiB2aXN1YWwgb3V0Y29tZSBpbmRpY2F0b3JzLCBhbmQgY2FuIGJlIGV4cGFuZGVkL2NvbGxhcHNlZCBmb3Igc3BhY2UgZWZmaWNpZW5jeS5cbiAqXG4gKiBAcmVtYXJrc1xuICogRmVhdHVyZXM6XG4gKiAtIEF1dG9tYXRpYyBEVFogbm9ybWFsaXphdGlvbiB3aXRoaW4gZ3JvdXBzIGZvciBjb25zaXN0ZW50IGJhciBzY2FsaW5nXG4gKiAtIEtleWJvYXJkIGFjY2Vzc2libGUgd2l0aCBFbnRlci9TcGFjZSBmb3IgZXhwYW5kL2NvbGxhcHNlXG4gKiAtIFZpc3VhbCBjb2xvciBjb2Rpbmc6IGdyZWVuICh3aW4pLCB5ZWxsb3cgKGRyYXcpLCByZWQgKGxvc3MpXG4gKiAtIEhvdmVyIHN0YXRlcyBmb3IgYmV0dGVyIGludGVyYWN0aXZpdHlcbiAqIC0gQVJJQSBsYWJlbHMgZm9yIHNjcmVlbiByZWFkZXIgc3VwcG9ydFxuICpcbiAqIFRoZSBjb21wb25lbnQgY2FsY3VsYXRlcyB0aGUgbWF4aW11bSBEVFogd2l0aGluIGVhY2ggZ3JvdXAgdG8gZW5zdXJlXG4gKiBldmFsdWF0aW9uIGJhcnMgc2NhbGUgcHJvcG9ydGlvbmFsbHkgZm9yIGVhc3kgdmlzdWFsIGNvbXBhcmlzb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogPE1vdmVSZXN1bHRHcm91cFxuICogICBtb3Zlcz17d2lubmluZ01vdmVzfVxuICogICByZXN1bHRUeXBlPVwid2luXCJcbiAqICAgb25Nb3ZlU2VsZWN0PXsobW92ZSkgPT4gbWFrZU1vdmUobW92ZSl9XG4gKiAgIHNlbGVjdGVkTW92ZT17Y3VycmVudE1vdmV9XG4gKiAgIGluaXRpYWxseUV4cGFuZGVkPXt0cnVlfVxuICogLz5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TW92ZVJlc3VsdEdyb3VwUHJvcHN9IHByb3BzIC0gQ29tcG9uZW50IGNvbmZpZ3VyYXRpb25cbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudCB8IG51bGx9IFJlbmRlcmVkIGdyb3VwIG9yIG51bGwgaWYgbm8gbW92ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IE1vdmVSZXN1bHRHcm91cDogUmVhY3QuRkM8TW92ZVJlc3VsdEdyb3VwUHJvcHM+ID0gKHtcbiAgbW92ZXMsXG4gIHJlc3VsdFR5cGUsXG4gIHRpdGxlLFxuICBvbk1vdmVTZWxlY3QsXG4gIHNlbGVjdGVkTW92ZSxcbiAgaW5pdGlhbGx5RXhwYW5kZWQgPSB0cnVlLFxuICBjb21wYWN0ID0gZmFsc2UsXG4gIGNsYXNzTmFtZSA9IFwiXCIsXG59KSA9PiB7XG4gIGNvbnN0IFtpc0V4cGFuZGVkLCBzZXRJc0V4cGFuZGVkXSA9IHVzZVN0YXRlKGluaXRpYWxseUV4cGFuZGVkKTtcblxuICBpZiAobW92ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBncm91cFRpdGxlID0gdGl0bGUgfHwgZ2V0UmVzdWx0VHlwZVRpdGxlKHJlc3VsdFR5cGUpO1xuICBjb25zdCBpY29uID0gZ2V0UmVzdWx0SWNvbihyZXN1bHRUeXBlKTtcbiAgY29uc3QgbWF4RHR6ID0gTWF0aC5tYXgoLi4ubW92ZXMubWFwKChtb3ZlKSA9PiBNYXRoLmFicyhtb3ZlLmR0eikpKTtcblxuICAvKipcbiAgICogR2V0cyBDU1MgY29sb3IgY2xhc3MgZm9yIHJlc3VsdCB0eXBlIGljb25zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TW92ZVJlc3VsdFR5cGV9IHR5cGUgLSBUaGUgcmVzdWx0IHR5cGUgdG8gc3R5bGVcbiAgICogQHJldHVybnMge3N0cmluZ30gVGFpbHdpbmQgQ1NTIGNsYXNzZXMgZm9yIHRleHQgY29sb3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIE1hcHMgcmVzdWx0IHR5cGVzIHRvIGFwcHJvcHJpYXRlIGNvbG9yIGNsYXNzZXMgd2l0aCBkYXJrIG1vZGUgc3VwcG9ydC5cbiAgICogQ29sb3JzIGZvbGxvdyBzdGFuZGFyZCBjaGVzcyBjb252ZW50aW9uczogZ3JlZW4gZm9yIHdpbnMsIHllbGxvdyBmb3IgZHJhd3MsXG4gICAqIHJlZCBmb3IgbG9zc2VzLCBhbmQgZ3JheSBmb3IgdW5rbm93bi91bmNsYXNzaWZpZWQgcmVzdWx0cy5cbiAgICovXG4gIGNvbnN0IGdldFRleHRDb2xvckNsYXNzID0gKHR5cGU6IE1vdmVSZXN1bHRUeXBlKTogc3RyaW5nID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ3aW5cIjpcbiAgICAgICAgcmV0dXJuIFwidGV4dC1ncmVlbi02MDAgZGFyazp0ZXh0LWdyZWVuLTQwMFwiO1xuICAgICAgY2FzZSBcImRyYXdcIjpcbiAgICAgICAgcmV0dXJuIFwidGV4dC15ZWxsb3ctNjAwIGRhcms6dGV4dC15ZWxsb3ctNDAwXCI7XG4gICAgICBjYXNlIFwibG9zc1wiOlxuICAgICAgICByZXR1cm4gXCJ0ZXh0LXJlZC02MDAgZGFyazp0ZXh0LXJlZC00MDBcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcInRleHQtZ3JheS02MDAgZGFyazp0ZXh0LWdyYXktNDAwXCI7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2Btb3ZlLXJlc3VsdC1ncm91cCAke2NsYXNzTmFtZX1gfT5cbiAgICAgIHsvKiBHcm91cCBIZWFkZXIgKi99XG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzTmFtZT17YFxuICAgICAgICAgIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBweS0yIHB4LTEgY3Vyc29yLXBvaW50ZXJcbiAgICAgICAgICB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgaG92ZXI6YmctZ3JheS01MCBkYXJrOmhvdmVyOmJnLWdyYXktODAwLzUwXG4gICAgICAgIGB9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpfVxuICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgIGFyaWEtbGFiZWw9e2Ake2dyb3VwVGl0bGV9IHNlY3Rpb24sICR7bW92ZXMubGVuZ3RofSBtb3Zlc2B9XG4gICAgICAgIGFyaWEtZXhwYW5kZWQ9e2lzRXhwYW5kZWR9XG4gICAgICAgIG9uS2V5RG93bj17KGUpID0+IHtcbiAgICAgICAgICBpZiAoZS5rZXkgPT09IFwiRW50ZXJcIiB8fCBlLmtleSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldElzRXhwYW5kZWQoIWlzRXhwYW5kZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTNcIj5cbiAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1zbSBmb250LW1lZGl1bSAke2dldFRleHRDb2xvckNsYXNzKHJlc3VsdFR5cGUpfWB9XG4gICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtpY29ufVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LWdyYXktNzAwIGRhcms6dGV4dC1ncmF5LTMwMFwiPlxuICAgICAgICAgICAge2dyb3VwVGl0bGV9XG4gICAgICAgICAgPC9oMz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtZ3JheS01MDAgZGFyazp0ZXh0LWdyYXktNDAwXCI+XG4gICAgICAgICAgICB7bW92ZXMubGVuZ3RofVxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgey8qIEV4cGFuZC9Db2xsYXBzZSBpbmRpY2F0b3IgKi99XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9e2BcbiAgICAgICAgICAgIHRyYW5zaXRpb24tdHJhbnNmb3JtIGR1cmF0aW9uLTIwMCB0ZXh0LXhzIHRleHQtZ3JheS00MDBcbiAgICAgICAgICAgICR7aXNFeHBhbmRlZCA/IFwicm90YXRlLTE4MFwiIDogXCJcIn1cbiAgICAgICAgICBgfVxuICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgID5cbiAgICAgICAgICDilrxcbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgey8qIE1vdmVzIExpc3QgKi99XG4gICAgICB7aXNFeHBhbmRlZCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMSBzcGFjZS15LTBcIj5cbiAgICAgICAgICB7bW92ZXMubWFwKChtb3ZlLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgPE1vdmVFdmFsdWF0aW9uQmFyXG4gICAgICAgICAgICAgIGtleT17YCR7bW92ZS5zYW59LSR7aW5kZXh9YH1cbiAgICAgICAgICAgICAgbW92ZT17bW92ZS5zYW59XG4gICAgICAgICAgICAgIGR0ej17bW92ZS5kdHp9XG4gICAgICAgICAgICAgIG1heER0ej17bWF4RHR6fVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBvbk1vdmVTZWxlY3QobW92ZS5zYW4pfVxuICAgICAgICAgICAgICBpc1NlbGVjdGVkPXtzZWxlY3RlZE1vdmUgPT09IG1vdmUuc2FufVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NvbXBhY3QgPyBcInRleHQteHNcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgIGNhdGVnb3J5PXttb3ZlLmNhdGVnb3J5fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLyoqXG4gKiBDb21wYWN0IHZlcnNpb24gb2YgTW92ZVJlc3VsdEdyb3VwIGZvciBkZW5zZSBsYXlvdXRzXG4gKlxuICogQGNvbXBvbmVudFxuICogQGRlc2NyaXB0aW9uXG4gKiBBIHNwYWNlLW9wdGltaXplZCB2YXJpYW50IG9mIE1vdmVSZXN1bHRHcm91cCBkZXNpZ25lZCBmb3Igc2lkZWJhcnMsXG4gKiBtb2JpbGUgbGF5b3V0cywgb3IgYW55IGNvbnRleHQgd2hlcmUgc2NyZWVuIHJlYWwgZXN0YXRlIGlzIGxpbWl0ZWQuXG4gKiBNYWludGFpbnMgZnVsbCBmdW5jdGlvbmFsaXR5IHdoaWxlIHJlZHVjaW5nIHZpc3VhbCBmb290cHJpbnQuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIHRoYXQgcGFzc2VzIGNvbXBhY3Q9dHJ1ZSB0byB0aGUgYmFzZVxuICogTW92ZVJlc3VsdEdyb3VwIGNvbXBvbmVudC4gVGhlIGNvbXBhY3QgbW9kZSBhZmZlY3RzOlxuICogLSBSZWR1Y2VkIHBhZGRpbmcgYW5kIG1hcmdpbnNcbiAqIC0gU21hbGxlciBmb250IHNpemVzIGluIGNoaWxkIGNvbXBvbmVudHNcbiAqIC0gVGlnaHRlciBzcGFjaW5nIGJldHdlZW4gZWxlbWVudHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiA8Q29tcGFjdE1vdmVSZXN1bHRHcm91cFxuICogICBtb3Zlcz17ZHJhd01vdmVzfVxuICogICByZXN1bHRUeXBlPVwiZHJhd1wiXG4gKiAgIG9uTW92ZVNlbGVjdD17aGFuZGxlTW92ZVNlbGVjdH1cbiAqICAgaW5pdGlhbGx5RXhwYW5kZWQ9e2ZhbHNlfVxuICogLz5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7TW92ZVJlc3VsdEdyb3VwUHJvcHN9IHByb3BzIC0gU2FtZSBwcm9wcyBhcyBNb3ZlUmVzdWx0R3JvdXBcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gQ29tcGFjdCBtb3ZlIHJlc3VsdCBncm91cFxuICovXG5leHBvcnQgY29uc3QgQ29tcGFjdE1vdmVSZXN1bHRHcm91cDogUmVhY3QuRkM8TW92ZVJlc3VsdEdyb3VwUHJvcHM+ID0gKFxuICBwcm9wcyxcbikgPT4ge1xuICByZXR1cm4gKFxuICAgIDxNb3ZlUmVzdWx0R3JvdXBcbiAgICAgIHsuLi5wcm9wc31cbiAgICAgIGNvbXBhY3Q9e3RydWV9XG4gICAgICBjbGFzc05hbWU9e2Bjb21wYWN0LW1vdmUtZ3JvdXAgJHtwcm9wcy5jbGFzc05hbWUgfHwgXCJcIn1gfVxuICAgIC8+XG4gICk7XG59O1xuXG4vKipcbiAqIFN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSBtb3ZlIHJlc3VsdCBncm91cFxuICpcbiAqIEBjb21wb25lbnRcbiAqIEBkZXNjcmlwdGlvblxuICogRGlzcGxheXMgYWdncmVnYXRlIHN0YXRpc3RpY3MgZm9yIGEgZ3JvdXAgb2YgbW92ZXMgaW5jbHVkaW5nIGNvdW50LFxuICogbWluaW11bS9tYXhpbXVtL2F2ZXJhZ2UgRFRaIHZhbHVlcy4gUHJvdmlkZXMgYSBxdWljayBvdmVydmlldyBvZiBtb3ZlXG4gKiBkaXN0cmlidXRpb24gYW5kIHF1YWxpdHkgd2l0aGluIGEgcmVzdWx0IGNhdGVnb3J5LlxuICpcbiAqIEByZW1hcmtzXG4gKiBTdGF0aXN0aWNzIGRpc3BsYXllZDpcbiAqIC0gQ291bnQ6IFRvdGFsIG51bWJlciBvZiBtb3ZlcyBpbiB0aGUgZ3JvdXBcbiAqIC0gTWluIERUWjogRmFzdGVzdCBwYXRoIHRvIG91dGNvbWVcbiAqIC0gQXZnIERUWjogQXZlcmFnZSBkaXN0YW5jZSB0byBvdXRjb21lXG4gKiAtIE1heCBEVFo6IFNsb3dlc3QgcGF0aCB0byBvdXRjb21lXG4gKlxuICogQ29sb3IgY29kaW5nIG1hdGNoZXMgdGhlIHJlc3VsdCB0eXBlIGZvciB2aXN1YWwgY29uc2lzdGVuY3kuXG4gKiBCYWNrZ3JvdW5kIGNvbG9ycyBwcm92aWRlIHN1YnRsZSB2aXN1YWwgc2VwYXJhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiA8TW92ZVJlc3VsdEdyb3VwU3VtbWFyeVxuICogICBtb3Zlcz17bG9zc2luZ01vdmVzfVxuICogICByZXN1bHRUeXBlPVwibG9zc1wiXG4gKiAvPlxuICogLy8gRGlzcGxheXM6IFwiQ291bnQ6IDMgIE1pbiBEVFo6IDUgIEF2ZyBEVFo6IDEyLjMgIE1heCBEVFo6IDIwXCJcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIENvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtUYWJsZWJhc2VNb3ZlW119IHByb3BzLm1vdmVzIC0gQXJyYXkgb2YgbW92ZXMgdG8gc3VtbWFyaXplXG4gKiBAcGFyYW0ge01vdmVSZXN1bHRUeXBlfSBwcm9wcy5yZXN1bHRUeXBlIC0gVHlwZSBvZiByZXN1bHQgZm9yIHN0eWxpbmdcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudCB8IG51bGx9IFN1bW1hcnkgc3RhdGlzdGljcyBvciBudWxsIGlmIG5vIG1vdmVzXG4gKi9cbmV4cG9ydCBjb25zdCBNb3ZlUmVzdWx0R3JvdXBTdW1tYXJ5OiBSZWFjdC5GQzx7XG4gIG1vdmVzOiBUYWJsZWJhc2VNb3ZlW107XG4gIHJlc3VsdFR5cGU6IE1vdmVSZXN1bHRUeXBlO1xufT4gPSAoeyBtb3ZlcywgcmVzdWx0VHlwZSB9KSA9PiB7XG4gIGlmIChtb3Zlcy5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIGNvbnN0IGF2Z0R0eiA9XG4gICAgbW92ZXMucmVkdWNlKChzdW0sIG1vdmUpID0+IHN1bSArIE1hdGguYWJzKG1vdmUuZHR6KSwgMCkgLyBtb3Zlcy5sZW5ndGg7XG4gIGNvbnN0IG1pbkR0eiA9IE1hdGgubWluKC4uLm1vdmVzLm1hcCgobW92ZSkgPT4gTWF0aC5hYnMobW92ZS5kdHopKSk7XG4gIGNvbnN0IG1heER0eiA9IE1hdGgubWF4KC4uLm1vdmVzLm1hcCgobW92ZSkgPT4gTWF0aC5hYnMobW92ZS5kdHopKSk7XG5cbiAgLyoqXG4gICAqIEdldHMgYmFja2dyb3VuZCBhbmQgdGV4dCBjb2xvciBjbGFzc2VzIGZvciBzdGF0aXN0aWNzIGRpc3BsYXlcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtNb3ZlUmVzdWx0VHlwZX0gdHlwZSAtIFRoZSByZXN1bHQgdHlwZSB0byBzdHlsZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDb21iaW5lZCBUYWlsd2luZCBDU1MgY2xhc3NlcyBmb3Igc3R5bGluZ1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHJvdmlkZXMgc3VidGxlIGJhY2tncm91bmQgY29sb3JzIHdpdGggbWF0Y2hpbmcgdGV4dCBmb3IgdGhlIHN1bW1hcnlcbiAgICogc3RhdGlzdGljcyBjb21wb25lbnQuIFVzZXMgbGlnaHQgYmFja2dyb3VuZHMgdG8gYXZvaWQgb3ZlcndoZWxtaW5nXG4gICAqIHRoZSBpbnRlcmZhY2Ugd2hpbGUgbWFpbnRhaW5pbmcgdmlzdWFsIGNvbnNpc3RlbmN5LlxuICAgKi9cbiAgY29uc3QgZ2V0U3RhdHNDb2xvckNsYXNzID0gKHR5cGU6IE1vdmVSZXN1bHRUeXBlKTogc3RyaW5nID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJ3aW5cIjpcbiAgICAgICAgcmV0dXJuIFwidGV4dC1ncmVlbi02MDAgYmctZ3JlZW4tNTBcIjtcbiAgICAgIGNhc2UgXCJkcmF3XCI6XG4gICAgICAgIHJldHVybiBcInRleHQteWVsbG93LTYwMCBiZy15ZWxsb3ctNTBcIjtcbiAgICAgIGNhc2UgXCJsb3NzXCI6XG4gICAgICAgIHJldHVybiBcInRleHQtcmVkLTYwMCBiZy1yZWQtNTBcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBcInRleHQtZ3JheS02MDAgYmctZ3JheS01MFwiO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBzdGF0c0NvbG9yQ2xhc3MgPSBnZXRTdGF0c0NvbG9yQ2xhc3MocmVzdWx0VHlwZSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YHRleHQteHMgcC0yIHJvdW5kZWQgJHtzdGF0c0NvbG9yQ2xhc3N9YH0+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICA8c3Bhbj5Db3VudDoge21vdmVzLmxlbmd0aH08L3NwYW4+XG4gICAgICAgIDxzcGFuPk1pbiBEVFo6IHttaW5EdHp9PC9zcGFuPlxuICAgICAgICA8c3Bhbj5BdmcgRFRaOiB7YXZnRHR6LnRvRml4ZWQoMSl9PC9zcGFuPlxuICAgICAgICA8c3Bhbj5NYXggRFRaOiB7bWF4RHR6fTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJDb21wYWN0TW92ZVJlc3VsdEdyb3VwIiwiTW92ZVJlc3VsdEdyb3VwIiwiTW92ZVJlc3VsdEdyb3VwU3VtbWFyeSIsIm1vdmVzIiwicmVzdWx0VHlwZSIsInRpdGxlIiwib25Nb3ZlU2VsZWN0Iiwic2VsZWN0ZWRNb3ZlIiwiaW5pdGlhbGx5RXhwYW5kZWQiLCJjb21wYWN0IiwiY2xhc3NOYW1lIiwiaXNFeHBhbmRlZCIsInNldElzRXhwYW5kZWQiLCJ1c2VTdGF0ZSIsImxlbmd0aCIsImdyb3VwVGl0bGUiLCJnZXRSZXN1bHRUeXBlVGl0bGUiLCJpY29uIiwiZ2V0UmVzdWx0SWNvbiIsIm1heER0eiIsIk1hdGgiLCJtYXgiLCJtYXAiLCJtb3ZlIiwiYWJzIiwiZHR6IiwiZ2V0VGV4dENvbG9yQ2xhc3MiLCJ0eXBlIiwiZGl2Iiwib25DbGljayIsInJvbGUiLCJ0YWJJbmRleCIsImFyaWEtbGFiZWwiLCJhcmlhLWV4cGFuZGVkIiwib25LZXlEb3duIiwiZSIsImtleSIsInByZXZlbnREZWZhdWx0Iiwic3BhbiIsImFyaWEtaGlkZGVuIiwiaDMiLCJpbmRleCIsIk1vdmVFdmFsdWF0aW9uQmFyIiwic2FuIiwiaXNTZWxlY3RlZCIsImNhdGVnb3J5IiwicHJvcHMiLCJhdmdEdHoiLCJyZWR1Y2UiLCJzdW0iLCJtaW5EdHoiLCJtaW4iLCJnZXRTdGF0c0NvbG9yQ2xhc3MiLCJzdGF0c0NvbG9yQ2xhc3MiLCJ0b0ZpeGVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FvQkMsR0FFRDs7Ozs7Ozs7Ozs7O1FBdU5hQTtlQUFBQTs7UUE5SUFDO2VBQUFBOztRQTJMQUM7ZUFBQUE7Ozs7K0RBbFFtQjttQ0FDRTtzQ0FNM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdFQSxNQUFNRCxrQkFBa0QsQ0FBQyxFQUM5REUsS0FBSyxFQUNMQyxVQUFVLEVBQ1ZDLEtBQUssRUFDTEMsWUFBWSxFQUNaQyxZQUFZLEVBQ1pDLG9CQUFvQixJQUFJLEVBQ3hCQyxVQUFVLEtBQUssRUFDZkMsWUFBWSxFQUFFLEVBQ2Y7SUFDQyxNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR0MsSUFBQUEsZUFBUSxFQUFDTDtJQUU3QyxJQUFJTCxNQUFNVyxNQUFNLEtBQUssR0FBRztRQUN0QixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxhQUFhVixTQUFTVyxJQUFBQSx3Q0FBa0IsRUFBQ1o7SUFDL0MsTUFBTWEsT0FBT0MsSUFB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