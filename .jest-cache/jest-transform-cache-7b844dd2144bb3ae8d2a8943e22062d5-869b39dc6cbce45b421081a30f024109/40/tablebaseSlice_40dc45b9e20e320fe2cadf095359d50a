7bb5444b8d5198bde5651ab5fca2ae9a
/**
 * @file Tablebase state slice for Zustand store
 * @module store/slices/tablebaseSlice
 * @description Manages tablebase API interactions, caching, and analysis state.
 * This slice handles communication with the Lichess tablebase API and maintains
 * evaluation results for chess positions.
 *
 * @example
 * ```typescript
 * // Using the tablebase slice in a component
 * import { useStore } from '@/store';
 * import { tablebaseSelectors } from '@/store/slices/tablebaseSlice';
 *
 * function TablebasePanel() {
 *   const analysisStatus = useStore(tablebaseSelectors.selectAnalysisStatus);
 *   const currentEval = useStore(tablebaseSelectors.selectCurrentEvaluation);
 *   const isLoading = useStore(tablebaseSelectors.selectIsLoading);
 *
 *   if (isLoading) return <Spinner />;
 *   if (currentEval) return <EvaluationDisplay eval={currentEval} />;
 * }
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createInitialTablebaseState () {
        return createInitialTablebaseState;
    },
    get createTablebaseActions () {
        return createTablebaseActions;
    },
    get createTablebaseSlice () {
        return createTablebaseSlice;
    },
    get createTablebaseState () {
        return createTablebaseState;
    },
    get initialTablebaseState () {
        return initialTablebaseState;
    },
    get tablebaseSelectors () {
        return tablebaseSelectors;
    }
});
const initialTablebaseState = {
    tablebaseMove: undefined,
    analysisStatus: "idle",
    evaluations: [],
    currentEvaluation: undefined
};
const createInitialTablebaseState = ()=>({
        ...initialTablebaseState
    });
const createTablebaseState = ()=>({
        tablebaseMove: undefined,
        analysisStatus: "idle",
        evaluations: [],
        currentEvaluation: undefined
    });
const createTablebaseActions = (set)=>({
        /**
   * Sets the tablebase move for the current position
   *
   * @param {string|null|undefined} move - The tablebase move
   *   - undefined: No tablebase lookup performed yet
   *   - null: Position is a draw (no winning move)
   *   - string: Best move in algebraic notation (e.g., "e4", "Nf3")
   *
   * @fires stateChange - When tablebase move is updated
   *
   * @remarks
   * This action is typically called by orchestrators after receiving
   * a response from the tablebase API. The three-state pattern allows
   * distinguishing between "not checked", "draw", and "has best move".
   *
   * @example
   * ```typescript
   * // No lookup performed yet
   * store.getState().setTablebaseMove(undefined);
   *
   * // Position is a draw
   * store.getState().setTablebaseMove(null);
   *
   * // Best move found
   * store.getState().setTablebaseMove("Ra8#");
   * ```
   */ setTablebaseMove: (move)=>{
            set((state)=>{
                state.tablebase.tablebaseMove = move;
            });
        },
        /**
   * Sets the analysis status for tablebase operations
   *
   * @param {AnalysisStatus} status - The analysis status
   *   - "idle": No analysis in progress
   *   - "loading": Analysis is being performed
   *   - "success": Analysis completed successfully
   *   - "error": Analysis failed
   *
   * @fires stateChange - When analysis status changes
   *
   * @remarks
   * This status is used to show loading spinners, handle errors,
   * and coordinate UI state during async tablebase operations.
   *
   * @example
   * ```typescript
   * // Start analysis
   * store.getState().setAnalysisStatus("loading");
   *
   * // Analysis completed
   * store.getState().setAnalysisStatus("success");
   *
   * // Analysis failed
   * store.getState().setAnalysisStatus("error");
   * ```
   */ setAnalysisStatus: (status)=>{
            set((state)=>{
                state.tablebase.analysisStatus = status;
            });
        },
        /**
   * Adds a position evaluation to the evaluations array
   *
   * @param {PositionAnalysis} evaluation - The position evaluation to add
   *
   * @fires stateChange - When evaluation is added
   *
   * @remarks
   * This action appends evaluations to maintain a history of analyzed
   * positions. Useful for showing analysis history or implementing
   * client-side caching strategies. The array is not automatically
   * limited in size - consider implementing cleanup if needed.
   *
   * @example
   * ```typescript
   * const evaluation: PositionAnalysis = {
   *   fen: "8/8/8/8/8/8/R7/K3k3 w - - 0 1",
   *   evaluation: {
   *     wdl: 1000,
   *     dtz: 5,
   *     outcome: "win",
   *     bestMove: "Ra8#"
   *   },
   *   topMoves: [...],
   *   isTablebasePosition: true
   * };
   *
   * store.getState().addEvaluation(evaluation);
   * ```
   */ addEvaluation: (evaluation)=>{
            set((state)=>{
                state.tablebase.evaluations = [
                    ...state.tablebase.evaluations,
                    evaluation
                ];
            });
        },
        /**
   * Replaces the entire evaluations array
   *
   * @param {PositionAnalysis[]} evaluations - New evaluations array
   *
   * @fires stateChange - When evaluations are replaced
   *
   * @remarks
   * Use this action to bulk update evaluations, clear history,
   * or restore evaluations from a saved state. This replaces
   * the entire array rather than merging.
   *
   * @example
   * ```typescript
   * // Clear all evaluations
   * store.getState().setEvaluations([]);
   *
   * // Set specific evaluations
   * store.getState().setEvaluations([
   *   evaluation1,
   *   evaluation2,
   *   evaluation3
   * ]);
   *
   * // Limit evaluation history
   * const recentEvals = store.getState().evaluations.slice(-10);
   * store.getState().setEvaluations(recentEvals);
   * ```
   */ setEvaluations: (evaluations)=>{
            set((state)=>{
                state.tablebase.evaluations = evaluations;
            });
        },
        /**
   * Sets the current position evaluation
   *
   * @param {PositionAnalysis|undefined} evaluation - The current evaluation or undefined
   *
   * @fires stateChange - When current evaluation changes
   *
   * @remarks
   * The current evaluation represents the active position being analyzed
   * or displayed. This is separate from the evaluations array to allow
   * for quick access without searching. Set to undefined when no position
   * is actively selected.
   *
   * @example
   * ```typescript
   * // Set active evaluation
   * store.getState().setCurrentEvaluation(evaluation);
   *
   * // Clear current evaluation
   * store.getState().setCurrentEvaluation(undefined);
   *
   * // Update from evaluations array
   * const latest = store.getState().evaluations[0];
   * store.getState().setCurrentEvaluation(latest);
   * ```
   */ setCurrentEvaluation: (evaluation)=>{
            set((state)=>{
                state.tablebase.currentEvaluation = evaluation;
            });
        },
        /**
   * Clears all tablebase state to initial values
   *
   * @fires stateChange - When state is cleared
   *
   * @remarks
   * Resets all tablebase-related state to initial values. Useful when
   * switching positions, starting a new game, or cleaning up. This is
   * a complete reset - consider if you need to preserve some data.
   *
   * @example
   * ```typescript
   * // Clear all tablebase data
   * store.getState().clearTablebaseState();
   *
   * // Common usage in game reset
   * store.getState().resetGame();
   * store.getState().clearTablebaseState();
   * store.getState().resetTraining();
   * ```
   */ clearTablebaseState: ()=>{
            set((state)=>{
                Object.assign(state.tablebase, createInitialTablebaseState());
            });
        }
    });
const createTablebaseSlice = (set)=>({
        ...createTablebaseState(),
        ...createTablebaseActions(set)
    });
const tablebaseSelectors = {
    /**
   * Selects the tablebase move
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {string|null|undefined} The tablebase move
   */ selectTablebaseMove: (state)=>state.tablebaseMove,
    /**
   * Selects the analysis status
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {AnalysisStatus} Current analysis status
   */ selectAnalysisStatus: (state)=>state.analysisStatus,
    /**
   * Selects all evaluations
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {PositionAnalysis[]} Array of position evaluations
   */ selectEvaluations: (state)=>state.evaluations,
    /**
   * Selects the current evaluation
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {PositionAnalysis|undefined} Current position evaluation
   */ selectCurrentEvaluation: (state)=>state.currentEvaluation,
    /**
   * Selects whether analysis is currently loading
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {boolean} True if analysis is in progress
   */ selectIsLoading: (state)=>state.analysisStatus === "loading",
    /**
   * Selects whether analysis has completed successfully
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {boolean} True if analysis succeeded
   */ selectIsSuccess: (state)=>state.analysisStatus === "success",
    /**
   * Selects whether analysis has failed
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {boolean} True if analysis failed
   */ selectIsError: (state)=>state.analysisStatus === "error",
    /**
   * Selects whether a tablebase move is available
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {boolean} True if a move is available (not undefined)
   *
   * @remarks
   * Returns true even if move is null (draw), as this still represents
   * a valid tablebase result. Only returns false if undefined.
   */ selectHasTablebaseMove: (state)=>state.tablebaseMove !== undefined,
    /**
   * Selects whether the position is a draw according to tablebase
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {boolean} True if position is a draw (move is null)
   */ selectIsDrawPosition: (state)=>state.tablebaseMove === null,
    /**
   * Selects evaluation for a specific FEN
   * @param {string} fen - The FEN to search for
   * @returns {Function} Selector function that returns the evaluation or undefined
   *
   * @example
   * ```typescript
   * const eval = useStore(
   *   tablebaseSelectors.selectEvaluationByFen("8/8/8/8/8/8/R7/K3k3 w - - 0 1")
   * );
   * ```
   */ selectEvaluationByFen: (fen)=>(state)=>state.evaluations.find((e)=>e.fen === fen),
    /**
   * Selects the number of cached evaluations
   * @param {TablebaseSlice} state - The tablebase slice of the store
   * @returns {number} Count of evaluations in cache
   */ selectEvaluationCount: (state)=>state.evaluations.length
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL3NsaWNlcy90YWJsZWJhc2VTbGljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFRhYmxlYmFzZSBzdGF0ZSBzbGljZSBmb3IgWnVzdGFuZCBzdG9yZVxuICogQG1vZHVsZSBzdG9yZS9zbGljZXMvdGFibGViYXNlU2xpY2VcbiAqIEBkZXNjcmlwdGlvbiBNYW5hZ2VzIHRhYmxlYmFzZSBBUEkgaW50ZXJhY3Rpb25zLCBjYWNoaW5nLCBhbmQgYW5hbHlzaXMgc3RhdGUuXG4gKiBUaGlzIHNsaWNlIGhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBMaWNoZXNzIHRhYmxlYmFzZSBBUEkgYW5kIG1haW50YWluc1xuICogZXZhbHVhdGlvbiByZXN1bHRzIGZvciBjaGVzcyBwb3NpdGlvbnMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFVzaW5nIHRoZSB0YWJsZWJhc2Ugc2xpY2UgaW4gYSBjb21wb25lbnRcbiAqIGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQC9zdG9yZSc7XG4gKiBpbXBvcnQgeyB0YWJsZWJhc2VTZWxlY3RvcnMgfSBmcm9tICdAL3N0b3JlL3NsaWNlcy90YWJsZWJhc2VTbGljZSc7XG4gKlxuICogZnVuY3Rpb24gVGFibGViYXNlUGFuZWwoKSB7XG4gKiAgIGNvbnN0IGFuYWx5c2lzU3RhdHVzID0gdXNlU3RvcmUodGFibGViYXNlU2VsZWN0b3JzLnNlbGVjdEFuYWx5c2lzU3RhdHVzKTtcbiAqICAgY29uc3QgY3VycmVudEV2YWwgPSB1c2VTdG9yZSh0YWJsZWJhc2VTZWxlY3RvcnMuc2VsZWN0Q3VycmVudEV2YWx1YXRpb24pO1xuICogICBjb25zdCBpc0xvYWRpbmcgPSB1c2VTdG9yZSh0YWJsZWJhc2VTZWxlY3RvcnMuc2VsZWN0SXNMb2FkaW5nKTtcbiAqXG4gKiAgIGlmIChpc0xvYWRpbmcpIHJldHVybiA8U3Bpbm5lciAvPjtcbiAqICAgaWYgKGN1cnJlbnRFdmFsKSByZXR1cm4gPEV2YWx1YXRpb25EaXNwbGF5IGV2YWw9e2N1cnJlbnRFdmFsfSAvPjtcbiAqIH1cbiAqIGBgYFxuICovXG5cbmltcG9ydCB7IEltbWVyU3RhdGVDcmVhdG9yLCBUYWJsZWJhc2VTbGljZSwgVGFibGViYXNlU3RhdGUsIFRhYmxlYmFzZUFjdGlvbnMgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IHR5cGUgeyBQb3NpdGlvbkFuYWx5c2lzIH0gZnJvbSBcIkBzaGFyZWQvdHlwZXMvZXZhbHVhdGlvblwiO1xuaW1wb3J0IHR5cGUgeyBBbmFseXNpc1N0YXR1cyB9IGZyb20gXCIuLi90eXBlc1wiO1xuXG4vKipcbiAqIEluaXRpYWwgc3RhdGUgZm9yIHRoZSB0YWJsZWJhc2Ugc2xpY2VcbiAqIEV4cG9ydGVkIHNlcGFyYXRlbHkgdG8gZW5hYmxlIHByb3BlciBzdG9yZSByZXNldCBpbiB0ZXN0c1xuICovXG5leHBvcnQgY29uc3QgaW5pdGlhbFRhYmxlYmFzZVN0YXRlID0ge1xuICB0YWJsZWJhc2VNb3ZlOiB1bmRlZmluZWQgYXMgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgYW5hbHlzaXNTdGF0dXM6IFwiaWRsZVwiIGFzIEFuYWx5c2lzU3RhdHVzLFxuICBldmFsdWF0aW9uczogW10gYXMgUG9zaXRpb25BbmFseXNpc1tdLFxuICBjdXJyZW50RXZhbHVhdGlvbjogdW5kZWZpbmVkIGFzIFBvc2l0aW9uQW5hbHlzaXMgfCB1bmRlZmluZWQsXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGluaXRpYWwgdGFibGViYXNlIHN0YXRlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAqIEBkZXByZWNhdGVkIFVzZSBpbml0aWFsVGFibGViYXNlU3RhdGUgZXhwb3J0IGRpcmVjdGx5XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJbml0aWFsVGFibGViYXNlU3RhdGUgPSAoKSA9PiAoeyAuLi5pbml0aWFsVGFibGViYXNlU3RhdGUgfSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgdGFibGViYXNlIHN0YXRlIChkYXRhIG9ubHksIG5vIGFjdGlvbnMpXG4gKlxuICogQHJldHVybnMge1RhYmxlYmFzZVN0YXRlfSBUYWJsZWJhc2Ugc3RhdGUgcHJvcGVydGllcyBvbmx5XG4gKlxuICogQHJlbWFya3NcbiAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBvbmx5IHRoZSBzdGF0ZSBwcm9wZXJ0aWVzIGZvciB0YWJsZWJhc2Ugc2xpY2UuXG4gKiBBY3Rpb25zIGFyZSBjcmVhdGVkIHNlcGFyYXRlbHkgdG8gYXZvaWQgSW1tZXIgbWlkZGxld2FyZSBzdHJpcHBpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB0YWJsZWJhc2VTdGF0ZSA9IGNyZWF0ZVRhYmxlYmFzZVN0YXRlKCk7XG4gKiBjb25zdCB0YWJsZWJhc2VBY3Rpb25zID0gY3JlYXRlVGFibGViYXNlQWN0aW9ucyhzZXQsIGdldCk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRhYmxlYmFzZVN0YXRlID0gKCk6IFRhYmxlYmFzZVN0YXRlID0+ICh7XG4gIHRhYmxlYmFzZU1vdmU6IHVuZGVmaW5lZCBhcyBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBhbmFseXNpc1N0YXR1czogXCJpZGxlXCIgYXMgQW5hbHlzaXNTdGF0dXMsXG4gIGV2YWx1YXRpb25zOiBbXSxcbiAgY3VycmVudEV2YWx1YXRpb246IHVuZGVmaW5lZCBhcyBQb3NpdGlvbkFuYWx5c2lzIHwgdW5kZWZpbmVkLFxufSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgdGFibGViYXNlIGFjdGlvbnMgKGZ1bmN0aW9ucyBvbmx5LCBubyBzdGF0ZSlcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXQgLSBadXN0YW5kJ3Mgc2V0IGZ1bmN0aW9uIGZvciBzdGF0ZSB1cGRhdGVzXG4gKiBAcmV0dXJucyB7VGFibGViYXNlQWN0aW9uc30gVGFibGViYXNlIGFjdGlvbiBmdW5jdGlvbnNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBjcmVhdGVzIG9ubHkgdGhlIGFjdGlvbiBmdW5jdGlvbnMgZm9yIHRhYmxlYmFzZSBzbGljZS5cbiAqIEFjdGlvbnMgYXJlIGtlcHQgc2VwYXJhdGUgZnJvbSBzdGF0ZSB0byBwcmV2ZW50IEltbWVyIG1pZGRsZXdhcmUgZnJvbSBzdHJpcHBpbmcgdGhlbS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdGFibGViYXNlQWN0aW9ucyA9IGNyZWF0ZVRhYmxlYmFzZUFjdGlvbnMoc2V0LCBnZXQpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUYWJsZWJhc2VBY3Rpb25zID0gKFxuICBzZXQ6IGFueSxcbik6IFRhYmxlYmFzZUFjdGlvbnMgPT4gKHtcblxuICAvKipcbiAgICogU2V0cyB0aGUgdGFibGViYXNlIG1vdmUgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bGx8dW5kZWZpbmVkfSBtb3ZlIC0gVGhlIHRhYmxlYmFzZSBtb3ZlXG4gICAqICAgLSB1bmRlZmluZWQ6IE5vIHRhYmxlYmFzZSBsb29rdXAgcGVyZm9ybWVkIHlldFxuICAgKiAgIC0gbnVsbDogUG9zaXRpb24gaXMgYSBkcmF3IChubyB3aW5uaW5nIG1vdmUpXG4gICAqICAgLSBzdHJpbmc6IEJlc3QgbW92ZSBpbiBhbGdlYnJhaWMgbm90YXRpb24gKGUuZy4sIFwiZTRcIiwgXCJOZjNcIilcbiAgICpcbiAgICogQGZpcmVzIHN0YXRlQ2hhbmdlIC0gV2hlbiB0YWJsZWJhc2UgbW92ZSBpcyB1cGRhdGVkXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoaXMgYWN0aW9uIGlzIHR5cGljYWxseSBjYWxsZWQgYnkgb3JjaGVzdHJhdG9ycyBhZnRlciByZWNlaXZpbmdcbiAgICogYSByZXNwb25zZSBmcm9tIHRoZSB0YWJsZWJhc2UgQVBJLiBUaGUgdGhyZWUtc3RhdGUgcGF0dGVybiBhbGxvd3NcbiAgICogZGlzdGluZ3Vpc2hpbmcgYmV0d2VlbiBcIm5vdCBjaGVja2VkXCIsIFwiZHJhd1wiLCBhbmQgXCJoYXMgYmVzdCBtb3ZlXCIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogLy8gTm8gbG9va3VwIHBlcmZvcm1lZCB5ZXRcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5zZXRUYWJsZWJhc2VNb3ZlKHVuZGVmaW5lZCk7XG4gICAqXG4gICAqIC8vIFBvc2l0aW9uIGlzIGEgZHJhd1xuICAgKiBzdG9yZS5nZXRTdGF0ZSgpLnNldFRhYmxlYmFzZU1vdmUobnVsbCk7XG4gICAqXG4gICAqIC8vIEJlc3QgbW92ZSBmb3VuZFxuICAgKiBzdG9yZS5nZXRTdGF0ZSgpLnNldFRhYmxlYmFzZU1vdmUoXCJSYTgjXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldFRhYmxlYmFzZU1vdmU6IChtb3ZlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUudGFibGViYXNlLnRhYmxlYmFzZU1vdmUgPSBtb3ZlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhbmFseXNpcyBzdGF0dXMgZm9yIHRhYmxlYmFzZSBvcGVyYXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7QW5hbHlzaXNTdGF0dXN9IHN0YXR1cyAtIFRoZSBhbmFseXNpcyBzdGF0dXNcbiAgICogICAtIFwiaWRsZVwiOiBObyBhbmFseXNpcyBpbiBwcm9ncmVzc1xuICAgKiAgIC0gXCJsb2FkaW5nXCI6IEFuYWx5c2lzIGlzIGJlaW5nIHBlcmZvcm1lZFxuICAgKiAgIC0gXCJzdWNjZXNzXCI6IEFuYWx5c2lzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcbiAgICogICAtIFwiZXJyb3JcIjogQW5hbHlzaXMgZmFpbGVkXG4gICAqXG4gICAqIEBmaXJlcyBzdGF0ZUNoYW5nZSAtIFdoZW4gYW5hbHlzaXMgc3RhdHVzIGNoYW5nZXNcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBzdGF0dXMgaXMgdXNlZCB0byBzaG93IGxvYWRpbmcgc3Bpbm5lcnMsIGhhbmRsZSBlcnJvcnMsXG4gICAqIGFuZCBjb29yZGluYXRlIFVJIHN0YXRlIGR1cmluZyBhc3luYyB0YWJsZWJhc2Ugb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBTdGFydCBhbmFseXNpc1xuICAgKiBzdG9yZS5nZXRTdGF0ZSgpLnNldEFuYWx5c2lzU3RhdHVzKFwibG9hZGluZ1wiKTtcbiAgICpcbiAgICogLy8gQW5hbHlzaXMgY29tcGxldGVkXG4gICAqIHN0b3JlLmdldFN0YXRlKCkuc2V0QW5hbHlzaXNTdGF0dXMoXCJzdWNjZXNzXCIpO1xuICAgKlxuICAgKiAvLyBBbmFseXNpcyBmYWlsZWRcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5zZXRBbmFseXNpc1N0YXR1cyhcImVycm9yXCIpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEFuYWx5c2lzU3RhdHVzOiAoc3RhdHVzOiBBbmFseXNpc1N0YXR1cykgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnRhYmxlYmFzZS5hbmFseXNpc1N0YXR1cyA9IHN0YXR1cztcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIHBvc2l0aW9uIGV2YWx1YXRpb24gdG8gdGhlIGV2YWx1YXRpb25zIGFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7UG9zaXRpb25BbmFseXNpc30gZXZhbHVhdGlvbiAtIFRoZSBwb3NpdGlvbiBldmFsdWF0aW9uIHRvIGFkZFxuICAgKlxuICAgKiBAZmlyZXMgc3RhdGVDaGFuZ2UgLSBXaGVuIGV2YWx1YXRpb24gaXMgYWRkZWRcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBhY3Rpb24gYXBwZW5kcyBldmFsdWF0aW9ucyB0byBtYWludGFpbiBhIGhpc3Rvcnkgb2YgYW5hbHl6ZWRcbiAgICogcG9zaXRpb25zLiBVc2VmdWwgZm9yIHNob3dpbmcgYW5hbHlzaXMgaGlzdG9yeSBvciBpbXBsZW1lbnRpbmdcbiAgICogY2xpZW50LXNpZGUgY2FjaGluZyBzdHJhdGVnaWVzLiBUaGUgYXJyYXkgaXMgbm90IGF1dG9tYXRpY2FsbHlcbiAgICogbGltaXRlZCBpbiBzaXplIC0gY29uc2lkZXIgaW1wbGVtZW50aW5nIGNsZWFudXAgaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGV2YWx1YXRpb246IFBvc2l0aW9uQW5hbHlzaXMgPSB7XG4gICAqICAgZmVuOiBcIjgvOC84LzgvOC84L1I3L0szazMgdyAtIC0gMCAxXCIsXG4gICAqICAgZXZhbHVhdGlvbjoge1xuICAgKiAgICAgd2RsOiAxMDAwLFxuICAgKiAgICAgZHR6OiA1LFxuICAgKiAgICAgb3V0Y29tZTogXCJ3aW5cIixcbiAgICogICAgIGJlc3RNb3ZlOiBcIlJhOCNcIlxuICAgKiAgIH0sXG4gICAqICAgdG9wTW92ZXM6IFsuLi5dLFxuICAgKiAgIGlzVGFibGViYXNlUG9zaXRpb246IHRydWVcbiAgICogfTtcbiAgICpcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5hZGRFdmFsdWF0aW9uKGV2YWx1YXRpb24pO1xuICAgKiBgYGBcbiAgICovXG4gIGFkZEV2YWx1YXRpb246IChldmFsdWF0aW9uOiBQb3NpdGlvbkFuYWx5c2lzKSA9PiB7XG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUudGFibGViYXNlLmV2YWx1YXRpb25zID0gWy4uLnN0YXRlLnRhYmxlYmFzZS5ldmFsdWF0aW9ucywgZXZhbHVhdGlvbl07XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIHRoZSBlbnRpcmUgZXZhbHVhdGlvbnMgYXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtQb3NpdGlvbkFuYWx5c2lzW119IGV2YWx1YXRpb25zIC0gTmV3IGV2YWx1YXRpb25zIGFycmF5XG4gICAqXG4gICAqIEBmaXJlcyBzdGF0ZUNoYW5nZSAtIFdoZW4gZXZhbHVhdGlvbnMgYXJlIHJlcGxhY2VkXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFVzZSB0aGlzIGFjdGlvbiB0byBidWxrIHVwZGF0ZSBldmFsdWF0aW9ucywgY2xlYXIgaGlzdG9yeSxcbiAgICogb3IgcmVzdG9yZSBldmFsdWF0aW9ucyBmcm9tIGEgc2F2ZWQgc3RhdGUuIFRoaXMgcmVwbGFjZXNcbiAgICogdGhlIGVudGlyZSBhcnJheSByYXRoZXIgdGhhbiBtZXJnaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIC8vIENsZWFyIGFsbCBldmFsdWF0aW9uc1xuICAgKiBzdG9yZS5nZXRTdGF0ZSgpLnNldEV2YWx1YXRpb25zKFtdKTtcbiAgICpcbiAgICogLy8gU2V0IHNwZWNpZmljIGV2YWx1YXRpb25zXG4gICAqIHN0b3JlLmdldFN0YXRlKCkuc2V0RXZhbHVhdGlvbnMoW1xuICAgKiAgIGV2YWx1YXRpb24xLFxuICAgKiAgIGV2YWx1YXRpb24yLFxuICAgKiAgIGV2YWx1YXRpb24zXG4gICAqIF0pO1xuICAgKlxuICAgKiAvLyBMaW1pdCBldmFsdWF0aW9uIGhpc3RvcnlcbiAgICogY29uc3QgcmVjZW50RXZhbHMgPSBzdG9yZS5nZXRTdGF0ZSgpLmV2YWx1YXRpb25zLnNsaWNlKC0xMCk7XG4gICAqIHN0b3JlLmdldFN0YXRlKCkuc2V0RXZhbHVhdGlvbnMocmVjZW50RXZhbHMpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEV2YWx1YXRpb25zOiAoZXZhbHVhdGlvbnM6IFBvc2l0aW9uQW5hbHlzaXNbXSkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnRhYmxlYmFzZS5ldmFsdWF0aW9ucyA9IGV2YWx1YXRpb25zO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHBvc2l0aW9uIGV2YWx1YXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtQb3NpdGlvbkFuYWx5c2lzfHVuZGVmaW5lZH0gZXZhbHVhdGlvbiAtIFRoZSBjdXJyZW50IGV2YWx1YXRpb24gb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBmaXJlcyBzdGF0ZUNoYW5nZSAtIFdoZW4gY3VycmVudCBldmFsdWF0aW9uIGNoYW5nZXNcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhlIGN1cnJlbnQgZXZhbHVhdGlvbiByZXByZXNlbnRzIHRoZSBhY3RpdmUgcG9zaXRpb24gYmVpbmcgYW5hbHl6ZWRcbiAgICogb3IgZGlzcGxheWVkLiBUaGlzIGlzIHNlcGFyYXRlIGZyb20gdGhlIGV2YWx1YXRpb25zIGFycmF5IHRvIGFsbG93XG4gICAqIGZvciBxdWljayBhY2Nlc3Mgd2l0aG91dCBzZWFyY2hpbmcuIFNldCB0byB1bmRlZmluZWQgd2hlbiBubyBwb3NpdGlvblxuICAgKiBpcyBhY3RpdmVseSBzZWxlY3RlZC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiAvLyBTZXQgYWN0aXZlIGV2YWx1YXRpb25cbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5zZXRDdXJyZW50RXZhbHVhdGlvbihldmFsdWF0aW9uKTtcbiAgICpcbiAgICogLy8gQ2xlYXIgY3VycmVudCBldmFsdWF0aW9uXG4gICAqIHN0b3JlLmdldFN0YXRlKCkuc2V0Q3VycmVudEV2YWx1YXRpb24odW5kZWZpbmVkKTtcbiAgICpcbiAgICogLy8gVXBkYXRlIGZyb20gZXZhbHVhdGlvbnMgYXJyYXlcbiAgICogY29uc3QgbGF0ZXN0ID0gc3RvcmUuZ2V0U3RhdGUoKS5ldmFsdWF0aW9uc1swXTtcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5zZXRDdXJyZW50RXZhbHVhdGlvbihsYXRlc3QpO1xuICAgKiBgYGBcbiAgICovXG4gIHNldEN1cnJlbnRFdmFsdWF0aW9uOiAoZXZhbHVhdGlvbjogUG9zaXRpb25BbmFseXNpcyB8IHVuZGVmaW5lZCkgPT4ge1xuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnRhYmxlYmFzZS5jdXJyZW50RXZhbHVhdGlvbiA9IGV2YWx1YXRpb247XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgdGFibGViYXNlIHN0YXRlIHRvIGluaXRpYWwgdmFsdWVzXG4gICAqXG4gICAqIEBmaXJlcyBzdGF0ZUNoYW5nZSAtIFdoZW4gc3RhdGUgaXMgY2xlYXJlZFxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBSZXNldHMgYWxsIHRhYmxlYmFzZS1yZWxhdGVkIHN0YXRlIHRvIGluaXRpYWwgdmFsdWVzLiBVc2VmdWwgd2hlblxuICAgKiBzd2l0Y2hpbmcgcG9zaXRpb25zLCBzdGFydGluZyBhIG5ldyBnYW1lLCBvciBjbGVhbmluZyB1cC4gVGhpcyBpc1xuICAgKiBhIGNvbXBsZXRlIHJlc2V0IC0gY29uc2lkZXIgaWYgeW91IG5lZWQgdG8gcHJlc2VydmUgc29tZSBkYXRhLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIC8vIENsZWFyIGFsbCB0YWJsZWJhc2UgZGF0YVxuICAgKiBzdG9yZS5nZXRTdGF0ZSgpLmNsZWFyVGFibGViYXNlU3RhdGUoKTtcbiAgICpcbiAgICogLy8gQ29tbW9uIHVzYWdlIGluIGdhbWUgcmVzZXRcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5yZXNldEdhbWUoKTtcbiAgICogc3RvcmUuZ2V0U3RhdGUoKS5jbGVhclRhYmxlYmFzZVN0YXRlKCk7XG4gICAqIHN0b3JlLmdldFN0YXRlKCkucmVzZXRUcmFpbmluZygpO1xuICAgKiBgYGBcbiAgICovXG4gIGNsZWFyVGFibGViYXNlU3RhdGU6ICgpID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLnRhYmxlYmFzZSwgY3JlYXRlSW5pdGlhbFRhYmxlYmFzZVN0YXRlKCkpO1xuICAgIH0pO1xuICB9LFxufSk7XG5cbi8qKlxuICogTGVnYWN5IHNsaWNlIGNyZWF0b3IgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gKiBAZGVwcmVjYXRlZCBVc2UgY3JlYXRlVGFibGViYXNlU3RhdGUoKSBhbmQgY3JlYXRlVGFibGViYXNlQWN0aW9ucygpIHNlcGFyYXRlbHlcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRhYmxlYmFzZVNsaWNlOiBJbW1lclN0YXRlQ3JlYXRvcjxUYWJsZWJhc2VTbGljZT4gPSAoXG4gIHNldCxcbikgPT4gKHtcbiAgLi4uY3JlYXRlVGFibGViYXNlU3RhdGUoKSxcbiAgLi4uY3JlYXRlVGFibGViYXNlQWN0aW9ucyhzZXQpLFxufSk7XG5cbi8qKlxuICogU2VsZWN0b3IgZnVuY3Rpb25zIGZvciBlZmZpY2llbnQgc3RhdGUgYWNjZXNzXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZXNlIHNlbGVjdG9ycyBwcm92aWRlIGEgY29uc2lzdGVudCBBUEkgZm9yIGFjY2Vzc2luZyB0YWJsZWJhc2Ugc3RhdGVcbiAqIGFuZCBjYW4gYmUgdXNlZCB3aXRoIFp1c3RhbmQncyBzdWJzY3JpYmUgbWVjaGFuaXNtIGZvciBvcHRpbWFsXG4gKiByZS1yZW5kZXJzLiBVc2UgdGhlc2UgaW5zdGVhZCBvZiBpbmxpbmUgc2VsZWN0b3JzIHdoZW4gcG9zc2libGUuXG4gKlxuICogVGhlIHNlbGVjdG9ycyBpbmNsdWRlIGJvdGggZGlyZWN0IHN0YXRlIGFjY2VzcyBhbmQgY29tcHV0ZWQgdmFsdWVzXG4gKiBmb3IgY29tbW9uIHVzZSBjYXNlcyBsaWtlIGxvYWRpbmcgc3RhdGVzIGFuZCBtb3ZlIGF2YWlsYWJpbGl0eS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdAL3N0b3JlJztcbiAqIGltcG9ydCB7IHRhYmxlYmFzZVNlbGVjdG9ycyB9IGZyb20gJ0Avc3RvcmUvc2xpY2VzL3RhYmxlYmFzZVNsaWNlJztcbiAqXG4gKiAvLyBJbiBhIGNvbXBvbmVudFxuICogY29uc3QgaXNMb2FkaW5nID0gdXNlU3RvcmUodGFibGViYXNlU2VsZWN0b3JzLnNlbGVjdElzTG9hZGluZyk7XG4gKiBjb25zdCBoYXNNb3ZlID0gdXNlU3RvcmUodGFibGViYXNlU2VsZWN0b3JzLnNlbGVjdEhhc1RhYmxlYmFzZU1vdmUpO1xuICogY29uc3QgZXZhbHVhdGlvbnMgPSB1c2VTdG9yZSh0YWJsZWJhc2VTZWxlY3RvcnMuc2VsZWN0RXZhbHVhdGlvbnMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCB0YWJsZWJhc2VTZWxlY3RvcnMgPSB7XG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSB0YWJsZWJhc2UgbW92ZVxuICAgKiBAcGFyYW0ge1RhYmxlYmFzZVNsaWNlfSBzdGF0ZSAtIFRoZSB0YWJsZWJhc2Ugc2xpY2Ugb2YgdGhlIHN0b3JlXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IFRoZSB0YWJsZWJhc2UgbW92ZVxuICAgKi9cbiAgc2VsZWN0VGFibGViYXNlTW92ZTogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT4gc3RhdGUudGFibGViYXNlTW92ZSxcblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgYW5hbHlzaXMgc3RhdHVzXG4gICAqIEBwYXJhbSB7VGFibGViYXNlU2xpY2V9IHN0YXRlIC0gVGhlIHRhYmxlYmFzZSBzbGljZSBvZiB0aGUgc3RvcmVcbiAgICogQHJldHVybnMge0FuYWx5c2lzU3RhdHVzfSBDdXJyZW50IGFuYWx5c2lzIHN0YXR1c1xuICAgKi9cbiAgc2VsZWN0QW5hbHlzaXNTdGF0dXM6IChzdGF0ZTogVGFibGViYXNlU2xpY2UpID0+IHN0YXRlLmFuYWx5c2lzU3RhdHVzLFxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGFsbCBldmFsdWF0aW9uc1xuICAgKiBAcGFyYW0ge1RhYmxlYmFzZVNsaWNlfSBzdGF0ZSAtIFRoZSB0YWJsZWJhc2Ugc2xpY2Ugb2YgdGhlIHN0b3JlXG4gICAqIEByZXR1cm5zIHtQb3NpdGlvbkFuYWx5c2lzW119IEFycmF5IG9mIHBvc2l0aW9uIGV2YWx1YXRpb25zXG4gICAqL1xuICBzZWxlY3RFdmFsdWF0aW9uczogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT4gc3RhdGUuZXZhbHVhdGlvbnMsXG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGN1cnJlbnQgZXZhbHVhdGlvblxuICAgKiBAcGFyYW0ge1RhYmxlYmFzZVNsaWNlfSBzdGF0ZSAtIFRoZSB0YWJsZWJhc2Ugc2xpY2Ugb2YgdGhlIHN0b3JlXG4gICAqIEByZXR1cm5zIHtQb3NpdGlvbkFuYWx5c2lzfHVuZGVmaW5lZH0gQ3VycmVudCBwb3NpdGlvbiBldmFsdWF0aW9uXG4gICAqL1xuICBzZWxlY3RDdXJyZW50RXZhbHVhdGlvbjogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT4gc3RhdGUuY3VycmVudEV2YWx1YXRpb24sXG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgd2hldGhlciBhbmFseXNpcyBpcyBjdXJyZW50bHkgbG9hZGluZ1xuICAgKiBAcGFyYW0ge1RhYmxlYmFzZVNsaWNlfSBzdGF0ZSAtIFRoZSB0YWJsZWJhc2Ugc2xpY2Ugb2YgdGhlIHN0b3JlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGFuYWx5c2lzIGlzIGluIHByb2dyZXNzXG4gICAqL1xuICBzZWxlY3RJc0xvYWRpbmc6IChzdGF0ZTogVGFibGViYXNlU2xpY2UpID0+XG4gICAgc3RhdGUuYW5hbHlzaXNTdGF0dXMgPT09IFwibG9hZGluZ1wiLFxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHdoZXRoZXIgYW5hbHlzaXMgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHlcbiAgICogQHBhcmFtIHtUYWJsZWJhc2VTbGljZX0gc3RhdGUgLSBUaGUgdGFibGViYXNlIHNsaWNlIG9mIHRoZSBzdG9yZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbmFseXNpcyBzdWNjZWVkZWRcbiAgICovXG4gIHNlbGVjdElzU3VjY2VzczogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT5cbiAgICBzdGF0ZS5hbmFseXNpc1N0YXR1cyA9PT0gXCJzdWNjZXNzXCIsXG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgd2hldGhlciBhbmFseXNpcyBoYXMgZmFpbGVkXG4gICAqIEBwYXJhbSB7VGFibGViYXNlU2xpY2V9IHN0YXRlIC0gVGhlIHRhYmxlYmFzZSBzbGljZSBvZiB0aGUgc3RvcmVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYW5hbHlzaXMgZmFpbGVkXG4gICAqL1xuICBzZWxlY3RJc0Vycm9yOiAoc3RhdGU6IFRhYmxlYmFzZVNsaWNlKSA9PiBzdGF0ZS5hbmFseXNpc1N0YXR1cyA9PT0gXCJlcnJvclwiLFxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHdoZXRoZXIgYSB0YWJsZWJhc2UgbW92ZSBpcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtUYWJsZWJhc2VTbGljZX0gc3RhdGUgLSBUaGUgdGFibGViYXNlIHNsaWNlIG9mIHRoZSBzdG9yZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBhIG1vdmUgaXMgYXZhaWxhYmxlIChub3QgdW5kZWZpbmVkKVxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBSZXR1cm5zIHRydWUgZXZlbiBpZiBtb3ZlIGlzIG51bGwgKGRyYXcpLCBhcyB0aGlzIHN0aWxsIHJlcHJlc2VudHNcbiAgICogYSB2YWxpZCB0YWJsZWJhc2UgcmVzdWx0LiBPbmx5IHJldHVybnMgZmFsc2UgaWYgdW5kZWZpbmVkLlxuICAgKi9cbiAgc2VsZWN0SGFzVGFibGViYXNlTW92ZTogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT5cbiAgICBzdGF0ZS50YWJsZWJhc2VNb3ZlICE9PSB1bmRlZmluZWQsXG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgd2hldGhlciB0aGUgcG9zaXRpb24gaXMgYSBkcmF3IGFjY29yZGluZyB0byB0YWJsZWJhc2VcbiAgICogQHBhcmFtIHtUYWJsZWJhc2VTbGljZX0gc3RhdGUgLSBUaGUgdGFibGViYXNlIHNsaWNlIG9mIHRoZSBzdG9yZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBwb3NpdGlvbiBpcyBhIGRyYXcgKG1vdmUgaXMgbnVsbClcbiAgICovXG4gIHNlbGVjdElzRHJhd1Bvc2l0aW9uOiAoc3RhdGU6IFRhYmxlYmFzZVNsaWNlKSA9PiBzdGF0ZS50YWJsZWJhc2VNb3ZlID09PSBudWxsLFxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIGV2YWx1YXRpb24gZm9yIGEgc3BlY2lmaWMgRkVOXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZW4gLSBUaGUgRkVOIHRvIHNlYXJjaCBmb3JcbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBTZWxlY3RvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGV2YWx1YXRpb24gb3IgdW5kZWZpbmVkXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHR5cGVzY3JpcHRcbiAgICogY29uc3QgZXZhbCA9IHVzZVN0b3JlKFxuICAgKiAgIHRhYmxlYmFzZVNlbGVjdG9ycy5zZWxlY3RFdmFsdWF0aW9uQnlGZW4oXCI4LzgvOC84LzgvOC9SNy9LM2szIHcgLSAtIDAgMVwiKVxuICAgKiApO1xuICAgKiBgYGBcbiAgICovXG4gIHNlbGVjdEV2YWx1YXRpb25CeUZlbjogKGZlbjogc3RyaW5nKSA9PiAoc3RhdGU6IFRhYmxlYmFzZVNsaWNlKSA9PlxuICAgIHN0YXRlLmV2YWx1YXRpb25zLmZpbmQoKGUpID0+IGUuZmVuID09PSBmZW4pLFxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBudW1iZXIgb2YgY2FjaGVkIGV2YWx1YXRpb25zXG4gICAqIEBwYXJhbSB7VGFibGViYXNlU2xpY2V9IHN0YXRlIC0gVGhlIHRhYmxlYmFzZSBzbGljZSBvZiB0aGUgc3RvcmVcbiAgICogQHJldHVybnMge251bWJlcn0gQ291bnQgb2YgZXZhbHVhdGlvbnMgaW4gY2FjaGVcbiAgICovXG4gIHNlbGVjdEV2YWx1YXRpb25Db3VudDogKHN0YXRlOiBUYWJsZWJhc2VTbGljZSkgPT4gc3RhdGUuZXZhbHVhdGlvbnMubGVuZ3RoLFxufTtcbiJdLCJuYW1lcyI6WyJjcmVhdGVJbml0aWFsVGFibGViYXNlU3RhdGUiLCJjcmVhdGVUYWJsZWJhc2VBY3Rpb25zIiwiY3JlYXRlVGFibGViYXNlU2xpY2UiLCJjcmVhdGVUYWJsZWJhc2VTdGF0ZSIsImluaXRpYWxUYWJsZWJhc2VTdGF0ZSIsInRhYmxlYmFzZVNlbGVjdG9ycyIsInRhYmxlYmFzZU1vdmUiLCJ1bmRlZmluZWQiLCJhbmFseXNpc1N0YXR1cyIsImV2YWx1YXRpb25zIiwiY3VycmVudEV2YWx1YXRpb24iLCJzZXQiLCJzZXRUYWJsZWJhc2VNb3ZlIiwibW92ZSIsInN0YXRlIiwidGFibGViYXNlIiwic2V0QW5hbHlzaXNTdGF0dXMiLCJzdGF0dXMiLCJhZGRFdmFsdWF0aW9uIiwiZXZhbHVhdGlvbiIsInNldEV2YWx1YXRpb25zIiwic2V0Q3VycmVudEV2YWx1YXRpb24iLCJjbGVhclRhYmxlYmFzZVN0YXRlIiwiT2JqZWN0IiwiYXNzaWduIiwic2VsZWN0VGFibGViYXNlTW92ZSIsInNlbGVjdEFuYWx5c2lzU3RhdHVzIiwic2VsZWN0RXZhbHVhdGlvbnMiLCJzZWxlY3RDdXJyZW50RXZhbHVhdGlvbiIsInNlbGVjdElzTG9hZGluZyIsInNlbGVjdElzU3VjY2VzcyIsInNlbGVjdElzRXJyb3IiLCJzZWxlY3RIYXNUYWJsZWJhc2VNb3ZlIiwic2VsZWN0SXNEcmF3UG9zaXRpb24iLCJzZWxlY3RFdmFsdWF0aW9uQnlGZW4iLCJmZW4iLCJmaW5kIiwiZSIsInNlbGVjdEV2YWx1YXRpb25Db3VudCIsImxlbmd0aCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzQkM7Ozs7Ozs7Ozs7O1FBcUJZ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