a364c86dcef5e77cb45e6c38c1357546
/**
 * @file Tests for useMoveValidation hook
 * @module tests/unit/hooks/useMoveValidation
 * 
 * @description
 * Comprehensive tests for the useMoveValidation hook that handles
 * move validation and quality assessment logic.
 * 
 * Tests cover:
 * - Move quality evaluation
 * - Tablebase result processing
 * - Analysis status updates
 * - Error handling and edge cases
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useMoveValidation = require("../../../shared/hooks/useMoveValidation");
// Mock dependencies
const mockTablebaseActions = {
    setAnalysisStatus: jest.fn(),
    setAnalysisResult: jest.fn()
};
const mockTablebaseState = {
    analysisStatus: 'idle',
    analysisResult: null,
    cache: new Map()
};
describe('useMoveValidation', ()=>{
    const defaultProps = {
        lastEvaluation: null,
        currentFen: '8/8/8/8/8/8/8/8 w - - 0 1',
        evaluations: [],
        isEvaluating: false,
        tablebaseState: mockTablebaseState,
        tablebaseActions: mockTablebaseActions
    };
    beforeEach(()=>{
        jest.clearAllMocks();
    });
    describe('Hook Initialization', ()=>{
        it('initializes with correct default values', ()=>{
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(defaultProps));
            expect(result1.current).toBeDefined();
        // Hook returns move validation utilities
        });
        it('handles missing dependencies gracefully', ()=>{
            const propsWithMissingDeps = {
                ...defaultProps,
                lastEvaluation: undefined,
                evaluations: undefined
            };
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(propsWithMissingDeps));
            }).not.toThrow();
        });
    });
    describe('Move Quality Assessment', ()=>{
        it('processes tablebase results correctly', ()=>{
            const mockEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1,
                        dtm: 5
                    },
                    {
                        move: 'Kg1',
                        wdl: 0,
                        dtm: 0
                    }
                ],
                isAvailable: true
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockEvaluation,
                isEvaluating: false
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            // Hook should process the evaluation
            expect(result1.current).toBeDefined();
        });
        it('handles unavailable tablebase results', ()=>{
            const mockEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 0,
                moves: [],
                isAvailable: false,
                error: 'Position not in tablebase'
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockEvaluation
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
    });
    describe('Analysis Status Management', ()=>{
        it('updates analysis status when evaluation starts', ()=>{
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: {
                    ...defaultProps,
                    isEvaluating: false
                }
            });
            // Start evaluating
            rerender({
                ...defaultProps,
                isEvaluating: true
            });
            // Status should be updated in some way (hook manages internal state)
            expect(mockTablebaseActions.setAnalysisStatus).toHaveBeenCalled();
        });
        it('clears analysis status when evaluation completes', ()=>{
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: {
                    ...defaultProps,
                    isEvaluating: true
                }
            });
            // Complete evaluation
            const mockResult = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1
                    }
                ],
                isAvailable: true
            };
            rerender({
                ...defaultProps,
                isEvaluating: false,
                lastEvaluation: mockResult
            });
            expect(mockTablebaseActions.setAnalysisStatus).toHaveBeenCalled();
        });
    });
    describe('Error Handling', ()=>{
        it('handles evaluation errors gracefully', ()=>{
            const mockEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 0,
                moves: [],
                isAvailable: false,
                error: 'Network error'
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockEvaluation
            };
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
        it('handles malformed evaluation data', ()=>{
            const malformedEvaluation = {
                // Missing required fields
                moves: null,
                isAvailable: true
            };
            const props = {
                ...defaultProps,
                lastEvaluation: malformedEvaluation
            };
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
    });
    describe('FEN Position Changes', ()=>{
        it('reacts to FEN changes', ()=>{
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: defaultProps
            });
            const newFen = '4k3/8/4K3/4P3/8/8/8/8 w - - 0 1';
            rerender({
                ...defaultProps,
                currentFen: newFen
            });
            // Hook should handle FEN changes - this is a passive hook that processes data
            // It may not directly call setAnalysisStatus, depending on implementation
            expect(mockTablebaseActions.setAnalysisStatus).toHaveBeenCalledTimes(0);
        });
        it('validates FEN format correctly', ()=>{
            const invalidFen = 'invalid-fen-string';
            const props = {
                ...defaultProps,
                currentFen: invalidFen
            };
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
    });
    describe('Evaluation History', ()=>{
        it('processes evaluation history correctly', ()=>{
            const evaluationHistory = [
                {
                    fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                    evaluation: 100
                },
                {
                    fen: '4k3/8/4K3/4P3/8/8/8/8 b - - 1 1',
                    evaluation: -50
                }
            ];
            const props = {
                ...defaultProps,
                evaluations: evaluationHistory
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
        it('handles empty evaluation history', ()=>{
            const props = {
                ...defaultProps,
                evaluations: []
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
    });
    describe('Tablebase State Integration', ()=>{
        it('reads from tablebase state correctly', ()=>{
            const tablebaseStateWithResults = {
                ...mockTablebaseState,
                analysisStatus: 'success',
                analysisResult: {
                    moves: [
                        {
                            move: 'Kh1',
                            wdl: 1,
                            dtm: 3
                        }
                    ]
                }
            };
            const props = {
                ...defaultProps,
                tablebaseState: tablebaseStateWithResults
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
        it('handles tablebase loading states', ()=>{
            const loadingTablebaseState = {
                ...mockTablebaseState,
                analysisStatus: 'loading',
                analysisResult: null
            };
            const props = {
                ...defaultProps,
                tablebaseState: loadingTablebaseState
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
        it('handles tablebase error states', ()=>{
            const errorTablebaseState = {
                ...mockTablebaseState,
                analysisStatus: 'error',
                analysisResult: null
            };
            const props = {
                ...defaultProps,
                tablebaseState: errorTablebaseState
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
    });
    describe('Performance and Memory', ()=>{
        it('maintains stable references between renders', ()=>{
            const { result: result1, rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: defaultProps
            });
            const initialResult = result1.current;
            // Re-render with same props
            rerender(defaultProps);
            // Should maintain reference stability where appropriate
            expect(result1.current).toBeDefined();
        });
        it('properly cleans up on unmount', ()=>{
            const { unmount } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(defaultProps));
            // Should not throw on unmount
            expect(()=>{
                unmount();
            }).not.toThrow();
        });
    });
    describe('Complex Scenarios', ()=>{
        it('handles rapid FEN changes', ()=>{
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: defaultProps
            });
            // Rapidly change FENs
            const fens = [
                '8/8/8/8/8/8/8/8 w - - 0 1',
                '4k3/8/4K3/4P3/8/8/8/8 w - - 0 1',
                '4k3/8/4K3/8/4P3/8/8/8 b - - 1 1'
            ];
            fens.forEach((fen)=>{
                rerender({
                    ...defaultProps,
                    currentFen: fen
                });
            });
            // Should handle rapid changes gracefully - useMoveValidation is a passive processor
            expect(mockTablebaseActions.setAnalysisStatus).toHaveBeenCalledTimes(0);
        });
        it('handles concurrent evaluation states', ()=>{
            const props = {
                ...defaultProps,
                isEvaluating: true,
                lastEvaluation: {
                    fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                    evaluation: 100,
                    moves: [
                        {
                            move: 'Kh1',
                            wdl: 1
                        }
                    ],
                    isAvailable: true
                }
            };
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
    });
    describe('Edge Cases and Safeguards', ()=>{
        it('handles missing setEvaluations action gracefully', ()=>{
            const actionsWithoutSetEvaluations = {
                ...mockTablebaseActions,
                setEvaluations: undefined
            };
            const mockEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1,
                        dtm: 5
                    }
                ],
                isAvailable: true
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockEvaluation,
                tablebaseActions: actionsWithoutSetEvaluations
            };
            // Should not throw when setEvaluations is missing
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
        it('handles missing setAnalysisStatus action gracefully', ()=>{
            const actionsWithoutSetAnalysisStatus = {
                ...mockTablebaseActions,
                setAnalysisStatus: undefined
            };
            const props = {
                ...defaultProps,
                isEvaluating: true,
                tablebaseActions: actionsWithoutSetAnalysisStatus
            };
            // Should not throw when setAnalysisStatus is missing
            expect(()=>{
                (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            }).not.toThrow();
        });
        it('skips already processed evaluations', ()=>{
            const mockEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                mateInMoves: 5,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1,
                        dtm: 5
                    }
                ],
                isAvailable: true
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockEvaluation
            };
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: props
            });
            // First render should process the evaluation
            expect(mockTablebaseActions.setAnalysisResult).toHaveBeenCalledTimes(0);
            // Second render with same evaluation should be skipped
            rerender(props);
            // Should not process the same evaluation twice
            expect(result.current).toBeDefined();
        });
        it('processes different evaluations separately', ()=>{
            const firstEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1,
                        dtm: 5
                    }
                ],
                isAvailable: true
            };
            const secondEvaluation = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 200,
                moves: [
                    {
                        move: 'Kh2',
                        wdl: 1,
                        dtm: 3
                    }
                ],
                isAvailable: true
            };
            const { rerender } = (0, _react.renderHook)((props)=>(0, _useMoveValidation.useMoveValidation)(props), {
                initialProps: {
                    ...defaultProps,
                    lastEvaluation: firstEvaluation
                }
            });
            // Process second evaluation with different score
            rerender({
                ...defaultProps,
                lastEvaluation: secondEvaluation
            });
            // Both evaluations should be processed
            expect(result.current).toBeDefined();
        });
    });
    describe('Integration with Other Hooks', ()=>{
        it('works with evaluation data from usePositionAnalysis', ()=>{
            const mockPositionAnalysisData = {
                fen: '8/8/8/8/8/8/8/8 w - - 0 1',
                evaluation: 100,
                moves: [
                    {
                        move: 'Kh1',
                        wdl: 1,
                        dtm: 5,
                        evaluation: 100
                    },
                    {
                        move: 'Kg1',
                        wdl: 0,
                        dtm: 0,
                        evaluation: 0
                    }
                ],
                isAvailable: true,
                bestMove: 'Kh1'
            };
            const props = {
                ...defaultProps,
                lastEvaluation: mockPositionAnalysisData,
                evaluations: [
                    mockPositionAnalysisData
                ]
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
        it('integrates with tablebase store state', ()=>{
            const richTablebaseState = {
                analysisStatus: 'success',
                analysisResult: {
                    position: '8/8/8/8/8/8/8/8 w - - 0 1',
                    moves: [
                        {
                            move: 'Kh1',
                            wdl: 1,
                            dtm: 3
                        },
                        {
                            move: 'Kg1',
                            wdl: -1,
                            dtm: 15
                        }
                    ],
                    bestMove: 'Kh1'
                },
                cache: new Map([
                    [
                        '8/8/8/8/8/8/8/8 w - - 0 1',
                        {
                            wdl: 1,
                            moves: [
                                'Kh1'
                            ]
                        }
                    ]
                ])
            };
            const props = {
                ...defaultProps,
                tablebaseState: richTablebaseState
            };
            const { result: result1 } = (0, _react.renderHook)(()=>(0, _useMoveValidation.useMoveValidation)(props));
            expect(result1.current).toBeDefined();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VNb3ZlVmFsaWRhdGlvbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgVGVzdHMgZm9yIHVzZU1vdmVWYWxpZGF0aW9uIGhvb2tcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9ob29rcy91c2VNb3ZlVmFsaWRhdGlvblxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIHRoZSB1c2VNb3ZlVmFsaWRhdGlvbiBob29rIHRoYXQgaGFuZGxlc1xuICogbW92ZSB2YWxpZGF0aW9uIGFuZCBxdWFsaXR5IGFzc2Vzc21lbnQgbG9naWMuXG4gKiBcbiAqIFRlc3RzIGNvdmVyOlxuICogLSBNb3ZlIHF1YWxpdHkgZXZhbHVhdGlvblxuICogLSBUYWJsZWJhc2UgcmVzdWx0IHByb2Nlc3NpbmdcbiAqIC0gQW5hbHlzaXMgc3RhdHVzIHVwZGF0ZXNcbiAqIC0gRXJyb3IgaGFuZGxpbmcgYW5kIGVkZ2UgY2FzZXNcbiAqL1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IHVzZU1vdmVWYWxpZGF0aW9uIH0gZnJvbSAnQHNoYXJlZC9ob29rcy91c2VNb3ZlVmFsaWRhdGlvbic7XG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5jb25zdCBtb2NrVGFibGViYXNlQWN0aW9ucyA9IHtcbiAgc2V0QW5hbHlzaXNTdGF0dXM6IGplc3QuZm4oKSxcbiAgc2V0QW5hbHlzaXNSZXN1bHQ6IGplc3QuZm4oKSxcbn07XG5cbmNvbnN0IG1vY2tUYWJsZWJhc2VTdGF0ZSA9IHtcbiAgYW5hbHlzaXNTdGF0dXM6ICdpZGxlJyBhcyBjb25zdCxcbiAgYW5hbHlzaXNSZXN1bHQ6IG51bGwsXG4gIGNhY2hlOiBuZXcgTWFwKCksXG59O1xuXG5kZXNjcmliZSgndXNlTW92ZVZhbGlkYXRpb24nLCAoKSA9PiB7XG4gIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICBsYXN0RXZhbHVhdGlvbjogbnVsbCxcbiAgICBjdXJyZW50RmVuOiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsXG4gICAgZXZhbHVhdGlvbnM6IFtdLFxuICAgIGlzRXZhbHVhdGluZzogZmFsc2UsXG4gICAgdGFibGViYXNlU3RhdGU6IG1vY2tUYWJsZWJhc2VTdGF0ZSxcbiAgICB0YWJsZWJhc2VBY3Rpb25zOiBtb2NrVGFibGViYXNlQWN0aW9ucyxcbiAgfTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0hvb2sgSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ2luaXRpYWxpemVzIHdpdGggY29ycmVjdCBkZWZhdWx0IHZhbHVlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICAvLyBIb29rIHJldHVybnMgbW92ZSB2YWxpZGF0aW9uIHV0aWxpdGllc1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgbWlzc2luZyBkZXBlbmRlbmNpZXMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzV2l0aE1pc3NpbmdEZXBzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIGV2YWx1YXRpb25zOiB1bmRlZmluZWQsXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzV2l0aE1pc3NpbmdEZXBzIGFzIGFueSkpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01vdmUgUXVhbGl0eSBBc3Nlc3NtZW50JywgKCkgPT4ge1xuICAgIGl0KCdwcm9jZXNzZXMgdGFibGViYXNlIHJlc3VsdHMgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2YWx1YXRpb24gPSB7XG4gICAgICAgIGZlbjogJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLFxuICAgICAgICBldmFsdWF0aW9uOiAxMDAsXG4gICAgICAgIG1vdmVzOiBbXG4gICAgICAgICAgeyBtb3ZlOiAnS2gxJywgd2RsOiAxLCBkdG06IDUgfSxcbiAgICAgICAgICB7IG1vdmU6ICdLZzEnLCB3ZGw6IDAsIGR0bTogMCB9LFxuICAgICAgICBdLFxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiBtb2NrRXZhbHVhdGlvbixcbiAgICAgICAgaXNFdmFsdWF0aW5nOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIC8vIEhvb2sgc2hvdWxkIHByb2Nlc3MgdGhlIGV2YWx1YXRpb25cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHVuYXZhaWxhYmxlIHRhYmxlYmFzZSByZXN1bHRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2YWx1YXRpb24gPSB7XG4gICAgICAgIGZlbjogJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLFxuICAgICAgICBldmFsdWF0aW9uOiAwLFxuICAgICAgICBtb3ZlczogW10sXG4gICAgICAgIGlzQXZhaWxhYmxlOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdQb3NpdGlvbiBub3QgaW4gdGFibGViYXNlJyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiBtb2NrRXZhbHVhdGlvbixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0FuYWx5c2lzIFN0YXR1cyBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCd1cGRhdGVzIGFuYWx5c2lzIHN0YXR1cyB3aGVuIGV2YWx1YXRpb24gc3RhcnRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKHByb3BzKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcyksXG4gICAgICAgIHsgXG4gICAgICAgICAgaW5pdGlhbFByb3BzOiB7IC4uLmRlZmF1bHRQcm9wcywgaXNFdmFsdWF0aW5nOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAgIC8vIFN0YXJ0IGV2YWx1YXRpbmdcbiAgICAgIHJlcmVuZGVyKHsgLi4uZGVmYXVsdFByb3BzLCBpc0V2YWx1YXRpbmc6IHRydWUgfSk7XG5cbiAgICAgIC8vIFN0YXR1cyBzaG91bGQgYmUgdXBkYXRlZCBpbiBzb21lIHdheSAoaG9vayBtYW5hZ2VzIGludGVybmFsIHN0YXRlKVxuICAgICAgZXhwZWN0KG1vY2tUYWJsZWJhc2VBY3Rpb25zLnNldEFuYWx5c2lzU3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnY2xlYXJzIGFuYWx5c2lzIHN0YXR1cyB3aGVuIGV2YWx1YXRpb24gY29tcGxldGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKHByb3BzKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcyksXG4gICAgICAgIHsgXG4gICAgICAgICAgaW5pdGlhbFByb3BzOiB7IC4uLmRlZmF1bHRQcm9wcywgaXNFdmFsdWF0aW5nOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgLy8gQ29tcGxldGUgZXZhbHVhdGlvblxuICAgICAgY29uc3QgbW9ja1Jlc3VsdCA9IHtcbiAgICAgICAgZmVuOiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsXG4gICAgICAgIGV2YWx1YXRpb246IDEwMCxcbiAgICAgICAgbW92ZXM6IFt7IG1vdmU6ICdLaDEnLCB3ZGw6IDEgfV0sXG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgcmVyZW5kZXIoeyBcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLCBcbiAgICAgICAgaXNFdmFsdWF0aW5nOiBmYWxzZSxcbiAgICAgICAgbGFzdEV2YWx1YXRpb246IG1vY2tSZXN1bHQgYXMgYW55LFxuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrVGFibGViYXNlQWN0aW9ucy5zZXRBbmFseXNpc1N0YXR1cykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnRXJyb3IgSGFuZGxpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgZXZhbHVhdGlvbiBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFdmFsdWF0aW9uID0ge1xuICAgICAgICBmZW46ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyxcbiAgICAgICAgZXZhbHVhdGlvbjogMCxcbiAgICAgICAgbW92ZXM6IFtdLFxuICAgICAgICBpc0F2YWlsYWJsZTogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTmV0d29yayBlcnJvcicsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICBsYXN0RXZhbHVhdGlvbjogbW9ja0V2YWx1YXRpb24sXG4gICAgICB9O1xuXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgbWFsZm9ybWVkIGV2YWx1YXRpb24gZGF0YScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1hbGZvcm1lZEV2YWx1YXRpb24gPSB7XG4gICAgICAgIC8vIE1pc3NpbmcgcmVxdWlyZWQgZmllbGRzXG4gICAgICAgIG1vdmVzOiBudWxsLFxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiBtYWxmb3JtZWRFdmFsdWF0aW9uIGFzIGFueSxcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHJlbmRlckhvb2soKCkgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdGRU4gUG9zaXRpb24gQ2hhbmdlcycsICgpID0+IHtcbiAgICBpdCgncmVhY3RzIHRvIEZFTiBjaGFuZ2VzJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXJlbmRlciB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKHByb3BzKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcyksXG4gICAgICAgIHsgXG4gICAgICAgICAgaW5pdGlhbFByb3BzOiBkZWZhdWx0UHJvcHNcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3RmVuID0gJzRrMy84LzRLMy80UDMvOC84LzgvOCB3IC0gLSAwIDEnO1xuICAgICAgcmVyZW5kZXIoeyAuLi5kZWZhdWx0UHJvcHMsIGN1cnJlbnRGZW46IG5ld0ZlbiB9KTtcblxuICAgICAgLy8gSG9vayBzaG91bGQgaGFuZGxlIEZFTiBjaGFuZ2VzIC0gdGhpcyBpcyBhIHBhc3NpdmUgaG9vayB0aGF0IHByb2Nlc3NlcyBkYXRhXG4gICAgICAvLyBJdCBtYXkgbm90IGRpcmVjdGx5IGNhbGwgc2V0QW5hbHlzaXNTdGF0dXMsIGRlcGVuZGluZyBvbiBpbXBsZW1lbnRhdGlvblxuICAgICAgZXhwZWN0KG1vY2tUYWJsZWJhc2VBY3Rpb25zLnNldEFuYWx5c2lzU3RhdHVzKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMCk7XG4gICAgfSk7XG5cbiAgICBpdCgndmFsaWRhdGVzIEZFTiBmb3JtYXQgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgaW52YWxpZEZlbiA9ICdpbnZhbGlkLWZlbi1zdHJpbmcnO1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgY3VycmVudEZlbjogaW52YWxpZEZlbixcbiAgICAgIH07XG5cbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIHJlbmRlckhvb2soKCkgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpKTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFdmFsdWF0aW9uIEhpc3RvcnknLCAoKSA9PiB7XG4gICAgaXQoJ3Byb2Nlc3NlcyBldmFsdWF0aW9uIGhpc3RvcnkgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgZXZhbHVhdGlvbkhpc3RvcnkgPSBbXG4gICAgICAgIHsgZmVuOiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsIGV2YWx1YXRpb246IDEwMCB9LFxuICAgICAgICB7IGZlbjogJzRrMy84LzRLMy80UDMvOC84LzgvOCBiIC0gLSAxIDEnLCBldmFsdWF0aW9uOiAtNTAgfSxcbiAgICAgIF07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGV2YWx1YXRpb25zOiBldmFsdWF0aW9uSGlzdG9yeSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGVtcHR5IGV2YWx1YXRpb24gaGlzdG9yeScsICgpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGV2YWx1YXRpb25zOiBbXSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1RhYmxlYmFzZSBTdGF0ZSBJbnRlZ3JhdGlvbicsICgpID0+IHtcbiAgICBpdCgncmVhZHMgZnJvbSB0YWJsZWJhc2Ugc3RhdGUgY29ycmVjdGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgdGFibGViYXNlU3RhdGVXaXRoUmVzdWx0cyA9IHtcbiAgICAgICAgLi4ubW9ja1RhYmxlYmFzZVN0YXRlLFxuICAgICAgICBhbmFseXNpc1N0YXR1czogJ3N1Y2Nlc3MnIGFzIGNvbnN0LFxuICAgICAgICBhbmFseXNpc1Jlc3VsdDoge1xuICAgICAgICAgIG1vdmVzOiBbeyBtb3ZlOiAnS2gxJywgd2RsOiAxLCBkdG06IDMgfV0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICB0YWJsZWJhc2VTdGF0ZTogdGFibGViYXNlU3RhdGVXaXRoUmVzdWx0cyxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIHRhYmxlYmFzZSBsb2FkaW5nIHN0YXRlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IGxvYWRpbmdUYWJsZWJhc2VTdGF0ZSA9IHtcbiAgICAgICAgLi4ubW9ja1RhYmxlYmFzZVN0YXRlLFxuICAgICAgICBhbmFseXNpc1N0YXR1czogJ2xvYWRpbmcnIGFzIGNvbnN0LFxuICAgICAgICBhbmFseXNpc1Jlc3VsdDogbnVsbCxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIHRhYmxlYmFzZVN0YXRlOiBsb2FkaW5nVGFibGViYXNlU3RhdGUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcykpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyB0YWJsZWJhc2UgZXJyb3Igc3RhdGVzJywgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JUYWJsZWJhc2VTdGF0ZSA9IHtcbiAgICAgICAgLi4ubW9ja1RhYmxlYmFzZVN0YXRlLFxuICAgICAgICBhbmFseXNpc1N0YXR1czogJ2Vycm9yJyBhcyBjb25zdCxcbiAgICAgICAgYW5hbHlzaXNSZXN1bHQ6IG51bGwsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICB0YWJsZWJhc2VTdGF0ZTogZXJyb3JUYWJsZWJhc2VTdGF0ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIGFuZCBNZW1vcnknLCAoKSA9PiB7XG4gICAgaXQoJ21haW50YWlucyBzdGFibGUgcmVmZXJlbmNlcyBiZXR3ZWVuIHJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soXG4gICAgICAgIChwcm9wcykgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpLFxuICAgICAgICB7IGluaXRpYWxQcm9wczogZGVmYXVsdFByb3BzIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxSZXN1bHQgPSByZXN1bHQuY3VycmVudDtcblxuICAgICAgLy8gUmUtcmVuZGVyIHdpdGggc2FtZSBwcm9wc1xuICAgICAgcmVyZW5kZXIoZGVmYXVsdFByb3BzKTtcblxuICAgICAgLy8gU2hvdWxkIG1haW50YWluIHJlZmVyZW5jZSBzdGFiaWxpdHkgd2hlcmUgYXBwcm9wcmlhdGVcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdwcm9wZXJseSBjbGVhbnMgdXAgb24gdW5tb3VudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBvbiB1bm1vdW50XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICB1bm1vdW50KCk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQ29tcGxleCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgcmFwaWQgRkVOIGNoYW5nZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXJIb29rKFxuICAgICAgICAocHJvcHMpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSxcbiAgICAgICAgeyBpbml0aWFsUHJvcHM6IGRlZmF1bHRQcm9wcyB9XG4gICAgICApO1xuXG4gICAgICAvLyBSYXBpZGx5IGNoYW5nZSBGRU5zXG4gICAgICBjb25zdCBmZW5zID0gW1xuICAgICAgICAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsXG4gICAgICAgICc0azMvOC80SzMvNFAzLzgvOC84LzggdyAtIC0gMCAxJyxcbiAgICAgICAgJzRrMy84LzRLMy84LzRQMy84LzgvOCBiIC0gLSAxIDEnLFxuICAgICAgXTtcblxuICAgICAgZmVucy5mb3JFYWNoKGZlbiA9PiB7XG4gICAgICAgIHJlcmVuZGVyKHsgLi4uZGVmYXVsdFByb3BzLCBjdXJyZW50RmVuOiBmZW4gfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU2hvdWxkIGhhbmRsZSByYXBpZCBjaGFuZ2VzIGdyYWNlZnVsbHkgLSB1c2VNb3ZlVmFsaWRhdGlvbiBpcyBhIHBhc3NpdmUgcHJvY2Vzc29yXG4gICAgICBleHBlY3QobW9ja1RhYmxlYmFzZUFjdGlvbnMuc2V0QW5hbHlzaXNTdGF0dXMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygwKTtcbiAgICB9KTtcblxuICAgIGl0KCdoYW5kbGVzIGNvbmN1cnJlbnQgZXZhbHVhdGlvbiBzdGF0ZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICBpc0V2YWx1YXRpbmc6IHRydWUsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiB7XG4gICAgICAgICAgZmVuOiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsXG4gICAgICAgICAgZXZhbHVhdGlvbjogMTAwLFxuICAgICAgICAgIG1vdmVzOiBbeyBtb3ZlOiAnS2gxJywgd2RsOiAxIH1dLFxuICAgICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcykpO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0VkZ2UgQ2FzZXMgYW5kIFNhZmVndWFyZHMnLCAoKSA9PiB7XG4gICAgaXQoJ2hhbmRsZXMgbWlzc2luZyBzZXRFdmFsdWF0aW9ucyBhY3Rpb24gZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGlvbnNXaXRob3V0U2V0RXZhbHVhdGlvbnMgPSB7XG4gICAgICAgIC4uLm1vY2tUYWJsZWJhc2VBY3Rpb25zLFxuICAgICAgICBzZXRFdmFsdWF0aW9uczogdW5kZWZpbmVkLCAvLyBNaXNzaW5nIGFjdGlvblxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja0V2YWx1YXRpb24gPSB7XG4gICAgICAgIGZlbjogJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLFxuICAgICAgICBldmFsdWF0aW9uOiAxMDAsXG4gICAgICAgIG1vdmVzOiBbeyBtb3ZlOiAnS2gxJywgd2RsOiAxLCBkdG06IDUgfV0sXG4gICAgICAgIGlzQXZhaWxhYmxlOiB0cnVlLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgbGFzdEV2YWx1YXRpb246IG1vY2tFdmFsdWF0aW9uLFxuICAgICAgICB0YWJsZWJhc2VBY3Rpb25zOiBhY3Rpb25zV2l0aG91dFNldEV2YWx1YXRpb25zIGFzIGFueSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgd2hlbiBzZXRFdmFsdWF0aW9ucyBpcyBtaXNzaW5nXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgbWlzc2luZyBzZXRBbmFseXNpc1N0YXR1cyBhY3Rpb24gZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGlvbnNXaXRob3V0U2V0QW5hbHlzaXNTdGF0dXMgPSB7XG4gICAgICAgIC4uLm1vY2tUYWJsZWJhc2VBY3Rpb25zLFxuICAgICAgICBzZXRBbmFseXNpc1N0YXR1czogdW5kZWZpbmVkLCAvLyBNaXNzaW5nIGFjdGlvblxuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgaXNFdmFsdWF0aW5nOiB0cnVlLFxuICAgICAgICB0YWJsZWJhc2VBY3Rpb25zOiBhY3Rpb25zV2l0aG91dFNldEFuYWx5c2lzU3RhdHVzIGFzIGFueSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3cgd2hlbiBzZXRBbmFseXNpc1N0YXR1cyBpcyBtaXNzaW5nXG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVWYWxpZGF0aW9uKHByb3BzKSk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3NraXBzIGFscmVhZHkgcHJvY2Vzc2VkIGV2YWx1YXRpb25zJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2YWx1YXRpb24gPSB7XG4gICAgICAgIGZlbjogJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLFxuICAgICAgICBldmFsdWF0aW9uOiAxMDAsXG4gICAgICAgIG1hdGVJbk1vdmVzOiA1LFxuICAgICAgICBtb3ZlczogW3sgbW92ZTogJ0toMScsIHdkbDogMSwgZHRtOiA1IH1dLFxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIGxhc3RFdmFsdWF0aW9uOiBtb2NrRXZhbHVhdGlvbixcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soXG4gICAgICAgIChwcm9wcykgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpLFxuICAgICAgICB7IGluaXRpYWxQcm9wczogcHJvcHMgfVxuICAgICAgKTtcblxuICAgICAgLy8gRmlyc3QgcmVuZGVyIHNob3VsZCBwcm9jZXNzIHRoZSBldmFsdWF0aW9uXG4gICAgICBleHBlY3QobW9ja1RhYmxlYmFzZUFjdGlvbnMuc2V0QW5hbHlzaXNSZXN1bHQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygwKTtcblxuICAgICAgLy8gU2Vjb25kIHJlbmRlciB3aXRoIHNhbWUgZXZhbHVhdGlvbiBzaG91bGQgYmUgc2tpcHBlZFxuICAgICAgcmVyZW5kZXIocHJvcHMpO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgbm90IHByb2Nlc3MgdGhlIHNhbWUgZXZhbHVhdGlvbiB0d2ljZVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Byb2Nlc3NlcyBkaWZmZXJlbnQgZXZhbHVhdGlvbnMgc2VwYXJhdGVseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0RXZhbHVhdGlvbiA9IHtcbiAgICAgICAgZmVuOiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsXG4gICAgICAgIGV2YWx1YXRpb246IDEwMCxcbiAgICAgICAgbW92ZXM6IFt7IG1vdmU6ICdLaDEnLCB3ZGw6IDEsIGR0bTogNSB9XSxcbiAgICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzZWNvbmRFdmFsdWF0aW9uID0ge1xuICAgICAgICBmZW46ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyxcbiAgICAgICAgZXZhbHVhdGlvbjogMjAwLCAvLyBEaWZmZXJlbnQgZXZhbHVhdGlvbiBzY29yZVxuICAgICAgICBtb3ZlczogW3sgbW92ZTogJ0toMicsIHdkbDogMSwgZHRtOiAzIH1dLFxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soXG4gICAgICAgIChwcm9wcykgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpLFxuICAgICAgICB7IGluaXRpYWxQcm9wczogeyAuLi5kZWZhdWx0UHJvcHMsIGxhc3RFdmFsdWF0aW9uOiBmaXJzdEV2YWx1YXRpb24gfSB9XG4gICAgICApO1xuXG4gICAgICAvLyBQcm9jZXNzIHNlY29uZCBldmFsdWF0aW9uIHdpdGggZGlmZmVyZW50IHNjb3JlXG4gICAgICByZXJlbmRlcih7IC4uLmRlZmF1bHRQcm9wcywgbGFzdEV2YWx1YXRpb246IHNlY29uZEV2YWx1YXRpb24gfSk7XG5cbiAgICAgIC8vIEJvdGggZXZhbHVhdGlvbnMgc2hvdWxkIGJlIHByb2Nlc3NlZFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnSW50ZWdyYXRpb24gd2l0aCBPdGhlciBIb29rcycsICgpID0+IHtcbiAgICBpdCgnd29ya3Mgd2l0aCBldmFsdWF0aW9uIGRhdGEgZnJvbSB1c2VQb3NpdGlvbkFuYWx5c2lzJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1Bvc2l0aW9uQW5hbHlzaXNEYXRhID0ge1xuICAgICAgICBmZW46ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyxcbiAgICAgICAgZXZhbHVhdGlvbjogMTAwLFxuICAgICAgICBtb3ZlczogW1xuICAgICAgICAgIHsgbW92ZTogJ0toMScsIHdkbDogMSwgZHRtOiA1LCBldmFsdWF0aW9uOiAxMDAgfSxcbiAgICAgICAgICB7IG1vdmU6ICdLZzEnLCB3ZGw6IDAsIGR0bTogMCwgZXZhbHVhdGlvbjogMCB9LFxuICAgICAgICBdLFxuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgYmVzdE1vdmU6ICdLaDEnLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgbGFzdEV2YWx1YXRpb246IG1vY2tQb3NpdGlvbkFuYWx5c2lzRGF0YSxcbiAgICAgICAgZXZhbHVhdGlvbnM6IFttb2NrUG9zaXRpb25BbmFseXNpc0RhdGFdLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTW92ZVZhbGlkYXRpb24ocHJvcHMpKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2ludGVncmF0ZXMgd2l0aCB0YWJsZWJhc2Ugc3RvcmUgc3RhdGUnLCAoKSA9PiB7XG4gICAgICBjb25zdCByaWNoVGFibGViYXNlU3RhdGUgPSB7XG4gICAgICAgIGFuYWx5c2lzU3RhdHVzOiAnc3VjY2VzcycgYXMgY29uc3QsXG4gICAgICAgIGFuYWx5c2lzUmVzdWx0OiB7XG4gICAgICAgICAgcG9zaXRpb246ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyxcbiAgICAgICAgICBtb3ZlczogW1xuICAgICAgICAgICAgeyBtb3ZlOiAnS2gxJywgd2RsOiAxLCBkdG06IDMgfSxcbiAgICAgICAgICAgIHsgbW92ZTogJ0tnMScsIHdkbDogLTEsIGR0bTogMTUgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGJlc3RNb3ZlOiAnS2gxJyxcbiAgICAgICAgfSxcbiAgICAgICAgY2FjaGU6IG5ldyBNYXAoW1xuICAgICAgICAgIFsnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsIHsgd2RsOiAxLCBtb3ZlczogWydLaDEnXSB9XVxuICAgICAgICBdKSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAgIHRhYmxlYmFzZVN0YXRlOiByaWNoVGFibGViYXNlU3RhdGUsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlVmFsaWRhdGlvbihwcm9wcykpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQpLnRvQmVEZWZpbmVkKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbIm1vY2tUYWJsZWJhc2VBY3Rpb25zIiwic2V0QW5hbHlzaXNTdGF0dXMiLCJqZXN0IiwiZm4iLCJzZXRBbmFseXNpc1Jlc3VsdCIsIm1vY2tUYWJsZWJhc2VTdGF0ZSIsImFuYWx5c2lzU3RhdHVzIiwiYW5hbHlzaXNSZXN1bHQiLCJjYWNoZSIsIk1hcCIsImRlc2NyaWJlIiwiZGVmYXVsdFByb3BzIiwibGFzdEV2YWx1YXRpb24iLCJjdXJyZW50RmVuIiwiZXZhbHVhdGlvbnMiLCJpc0V2YWx1YXRpbmciLCJ0YWJsZWJhc2VTdGF0ZSIsInRhYmxlYmFzZUFjdGlvbnMiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIml0IiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZU1vdmVWYWxpZGF0aW9uIiwiZXhwZWN0IiwiY3VycmVudCIsInRvQmVEZWZpbmVkIiwicHJvcHNXaXRoTWlzc2luZ0RlcHMiLCJ1bmRlZmluZWQiLCJub3QiLCJ0b1Rocm93IiwibW9ja0V2YWx1YXRpb24iLCJmZW4iLCJldmFsdWF0aW9uIiwibW92ZXMiLCJtb3ZlIiwid2RsIiwiZHRtIiwiaXNBdmFpbGFibGUiLCJwcm9wcyIsImVycm9yIiwicmVyZW5kZXIiLCJpbml0aWFsUHJvcHMiLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibW9ja1Jlc3VsdCIsIm1hbGZvcm1lZEV2YWx1YXRpb24iLCJuZXdGZW4iLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiLCJpbnZhbGlkRmVuIiwiZXZhbHVhdGlvbkhpc3RvcnkiLCJ0YWJsZWJhc2VTdGF0ZVdpdGhSZXN1bHRzIiwibG9hZGluZ1RhYmxlYmFzZVN0YXRlIiwiZXJyb3JUYWJsZWJhc2VTdGF0ZSIsImluaXRpYWxSZXN1bHQiLCJ1bm1vdW50IiwiZmVucyIsImZvckVhY2giLCJhY3Rpb25zV2l0aG91dFNldEV2YWx1YXRpb25zIiwic2V0RXZhbHVhdGlvbnMiLCJhY3Rpb25zV2l0aG91dFNldEFuYWx5c2lzU3RhdHVzIiwibWF0ZUluTW92ZXMiLCJmaXJzdEV2YWx1YXRpb24iLCJzZWNvbmRFdmFsdWF0aW9uIiwibW9ja1Bvc2l0aW9uQW5hbHlzaXNEYXRhIiwiYmVzdE1vdmUiLCJyaWNoVGFibGViYXNlU3RhdGUiLCJwb3NpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Q0FhQzs7Ozt1QkFFK0I7bUNBQ0U7QUFFbEMsb0JBQW9CO0FBQ3BCLE1BQU1BLHVCQUF1QjtJQUMzQkMsbUJBQW1CQyxLQUFLQyxFQUFFO0lBQzFCQyxtQkFBbUJGLEtBQUtDLEVBQUU7QUFDNUI7QUFFQSxNQUFNRSxxQkFBcUI7SUFDekJDLGdCQUFnQjtJQUNoQkMsZ0JBQWdCO0lBQ2hCQyxPQUFPLElBQUlDO0FBQ2I7QUFFQUMsU0FBUyxxQkFBcUI7SUFDNUIsTUFBTUMsZUFBZTtRQUNuQkMsZ0JBQWdCO1FBQ2hCQyxZQUFZO1FBQ1pDLGFBQWEsRUFBRTtRQUNmQyxjQUFjO1FBQ2RDLGdCQUFnQlg7UUFDaEJZLGtCQUFrQmpCO0lBQ3BCO0lBRUFr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