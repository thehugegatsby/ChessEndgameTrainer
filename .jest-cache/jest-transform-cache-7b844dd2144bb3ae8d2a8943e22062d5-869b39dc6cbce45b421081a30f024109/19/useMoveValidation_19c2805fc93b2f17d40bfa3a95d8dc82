9844ccdfd71da7523b6a443292891eec
/**
 * @file Move validation and evaluation processing hook
 * @module hooks/useMoveValidation
 * 
 * @description
 * Custom hook that encapsulates evaluation processing and analysis status
 * management for chess training. Extracted from TrainingBoard to separate
 * evaluation concerns from UI rendering.
 * 
 * @remarks
 * Key responsibilities:
 * - Evaluation deduplication using processedEvaluationsRef
 * - Analysis status synchronization with tablebase store
 * - Safe handling of tablebase actions availability
 * - Evaluation update coordination
 * 
 * This hook maintains evaluation processing logic while providing
 * a clean interface for move validation and analysis management.
 * 
 * @example
 * ```tsx
 * const moveValidation = useMoveValidation({
 *   lastEvaluation,
 *   currentFen,
 *   evaluations,
 *   isEvaluating,
 *   tablebaseState,
 *   tablebaseActions
 * });
 * 
 * // Hook handles evaluation processing and status updates internally
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useMoveValidation", {
    enumerable: true,
    get: function() {
        return useMoveValidation;
    }
});
const _react = require("react");
const useMoveValidation = ({ lastEvaluation, currentFen, evaluations, isEvaluating, tablebaseState, tablebaseActions })=>{
    // Track processed evaluations to prevent duplicates
    const processedEvaluationsRef = (0, _react.useRef)(new Set());
    const [processedCount, setProcessedCount] = (0, _react.useState)(0);
    // Update Zustand with current evaluation
    (0, _react.useEffect)(()=>{
        if (!lastEvaluation) return;
        var _lastEvaluation_mateInMoves;
        // Create unique key for this evaluation using current FEN and evaluation data
        const evalKey = `${currentFen}_${lastEvaluation.evaluation}_${(_lastEvaluation_mateInMoves = lastEvaluation.mateInMoves) !== null && _lastEvaluation_mateInMoves !== void 0 ? _lastEvaluation_mateInMoves : "null"}`;
        if (processedEvaluationsRef.current.has(evalKey)) {
            return; // Skip if already processed
        }
        processedEvaluationsRef.current.add(evalKey);
        setProcessedCount(processedEvaluationsRef.current.size);
        const currentEvaluations = evaluations || [];
        const updatedEvaluations = [
            ...currentEvaluations,
            lastEvaluation
        ];
        // Check if setEvaluations exists before calling
        if (tablebaseActions === null || tablebaseActions === void 0 ? void 0 : tablebaseActions.setEvaluations) {
            tablebaseActions.setEvaluations(updatedEvaluations);
        } else {
            console.error("‚ùå tablebaseActions.setEvaluations is not available!");
        }
    }, [
        lastEvaluation,
        currentFen,
        evaluations,
        tablebaseActions
    ]);
    // Update analysis status based on evaluation state
    (0, _react.useEffect)(()=>{
        console.debug("üîç TablebaseActions debug", {
            hasTablebaseActions: !!tablebaseActions,
            hasSetAnalysisStatus: !!(tablebaseActions === null || tablebaseActions === void 0 ? void 0 : tablebaseActions.setAnalysisStatus),
            tablebaseActionsKeys: Object.keys(tablebaseActions || {}),
            isEvaluating
        });
        // CRITICAL: Safe-guard to prevent crashes
        if (!(tablebaseActions === null || tablebaseActions === void 0 ? void 0 : tablebaseActions.setAnalysisStatus)) {
            console.warn("‚ö†Ô∏è tablebaseActions.setAnalysisStatus not available, skipping");
            return;
        }
        if (isEvaluating) {
            tablebaseActions.setAnalysisStatus("loading");
        } else if (tablebaseState.analysisStatus === "loading") {
            // Only update to success if we were loading
            tablebaseActions.setAnalysisStatus("success");
        }
    }, [
        isEvaluating,
        tablebaseState,
        tablebaseActions
    ]);
    // Return validation state
    return {
        processedCount,
        isProcessing: isEvaluating
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL2hvb2tzL3VzZU1vdmVWYWxpZGF0aW9uLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgTW92ZSB2YWxpZGF0aW9uIGFuZCBldmFsdWF0aW9uIHByb2Nlc3NpbmcgaG9va1xuICogQG1vZHVsZSBob29rcy91c2VNb3ZlVmFsaWRhdGlvblxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIEN1c3RvbSBob29rIHRoYXQgZW5jYXBzdWxhdGVzIGV2YWx1YXRpb24gcHJvY2Vzc2luZyBhbmQgYW5hbHlzaXMgc3RhdHVzXG4gKiBtYW5hZ2VtZW50IGZvciBjaGVzcyB0cmFpbmluZy4gRXh0cmFjdGVkIGZyb20gVHJhaW5pbmdCb2FyZCB0byBzZXBhcmF0ZVxuICogZXZhbHVhdGlvbiBjb25jZXJucyBmcm9tIFVJIHJlbmRlcmluZy5cbiAqIFxuICogQHJlbWFya3NcbiAqIEtleSByZXNwb25zaWJpbGl0aWVzOlxuICogLSBFdmFsdWF0aW9uIGRlZHVwbGljYXRpb24gdXNpbmcgcHJvY2Vzc2VkRXZhbHVhdGlvbnNSZWZcbiAqIC0gQW5hbHlzaXMgc3RhdHVzIHN5bmNocm9uaXphdGlvbiB3aXRoIHRhYmxlYmFzZSBzdG9yZVxuICogLSBTYWZlIGhhbmRsaW5nIG9mIHRhYmxlYmFzZSBhY3Rpb25zIGF2YWlsYWJpbGl0eVxuICogLSBFdmFsdWF0aW9uIHVwZGF0ZSBjb29yZGluYXRpb25cbiAqIFxuICogVGhpcyBob29rIG1haW50YWlucyBldmFsdWF0aW9uIHByb2Nlc3NpbmcgbG9naWMgd2hpbGUgcHJvdmlkaW5nXG4gKiBhIGNsZWFuIGludGVyZmFjZSBmb3IgbW92ZSB2YWxpZGF0aW9uIGFuZCBhbmFseXNpcyBtYW5hZ2VtZW50LlxuICogXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBtb3ZlVmFsaWRhdGlvbiA9IHVzZU1vdmVWYWxpZGF0aW9uKHtcbiAqICAgbGFzdEV2YWx1YXRpb24sXG4gKiAgIGN1cnJlbnRGZW4sXG4gKiAgIGV2YWx1YXRpb25zLFxuICogICBpc0V2YWx1YXRpbmcsXG4gKiAgIHRhYmxlYmFzZVN0YXRlLFxuICogICB0YWJsZWJhc2VBY3Rpb25zXG4gKiB9KTtcbiAqIFxuICogLy8gSG9vayBoYW5kbGVzIGV2YWx1YXRpb24gcHJvY2Vzc2luZyBhbmQgc3RhdHVzIHVwZGF0ZXMgaW50ZXJuYWxseVxuICogYGBgXG4gKi9cblxuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUG9zaXRpb25BbmFseXNpcyB9IGZyb20gJ0BzaGFyZWQvdHlwZXMnO1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgbW92ZSB2YWxpZGF0aW9uIGhvb2tcbiAqIFxuICogQGludGVyZmFjZSBVc2VNb3ZlVmFsaWRhdGlvbk9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvbiBPcHRpb25zIGZvciBjb25maWd1cmluZyBtb3ZlIHZhbGlkYXRpb24gYmVoYXZpb3JcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VNb3ZlVmFsaWRhdGlvbk9wdGlvbnMge1xuICAvKiogTGFzdCBldmFsdWF0aW9uIGZyb20gcG9zaXRpb24gYW5hbHlzaXMgKi9cbiAgbGFzdEV2YWx1YXRpb246IFBvc2l0aW9uQW5hbHlzaXMgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAvKiogQ3VycmVudCBGRU4gcG9zaXRpb24gKi9cbiAgY3VycmVudEZlbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAvKiogQXJyYXkgb2YgZXZhbHVhdGlvbnMgKi9cbiAgZXZhbHVhdGlvbnM6IFBvc2l0aW9uQW5hbHlzaXNbXSB8IHVuZGVmaW5lZDtcbiAgLyoqIFdoZXRoZXIgZXZhbHVhdGlvbiBpcyBpbiBwcm9ncmVzcyAqL1xuICBpc0V2YWx1YXRpbmc6IGJvb2xlYW47XG4gIC8qKiBUYWJsZWJhc2Ugc3RvcmUgc3RhdGUgKi9cbiAgdGFibGViYXNlU3RhdGU6IHtcbiAgICBhbmFseXNpc1N0YXR1czogJ2lkbGUnIHwgJ2xvYWRpbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2Vycm9yJztcbiAgfTtcbiAgLyoqIFRhYmxlYmFzZSBzdG9yZSBhY3Rpb25zICovXG4gIHRhYmxlYmFzZUFjdGlvbnM6IHtcbiAgICBzZXRFdmFsdWF0aW9ucz86IChldmFsdWF0aW9uczogUG9zaXRpb25BbmFseXNpc1tdKSA9PiB2b2lkO1xuICAgIHNldEFuYWx5c2lzU3RhdHVzPzogKHN0YXR1czogJ2lkbGUnIHwgJ2xvYWRpbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2Vycm9yJykgPT4gdm9pZDtcbiAgfSB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBNb3ZlIHZhbGlkYXRpb24gc3RhdGUgYW5kIHV0aWxpdGllc1xuICogXG4gKiBAaW50ZXJmYWNlIE1vdmVWYWxpZGF0aW9uUmVzdWx0XG4gKiBAZGVzY3JpcHRpb24gUmVzdWx0IG9iamVjdCBjb250YWluaW5nIHZhbGlkYXRpb24gc3RhdGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb3ZlVmFsaWRhdGlvblJlc3VsdCB7XG4gIC8qKiBOdW1iZXIgb2YgcHJvY2Vzc2VkIGV2YWx1YXRpb25zICovXG4gIHByb2Nlc3NlZENvdW50OiBudW1iZXI7XG4gIC8qKiBXaGV0aGVyIGV2YWx1YXRpb24gcHJvY2Vzc2luZyBpcyBhY3RpdmUgKi9cbiAgaXNQcm9jZXNzaW5nOiBib29sZWFuO1xufVxuXG4vKipcbiAqIE1vdmUgdmFsaWRhdGlvbiBhbmQgZXZhbHVhdGlvbiBwcm9jZXNzaW5nIGhvb2tcbiAqIFxuICogQGRlc2NyaXB0aW9uXG4gKiBNYW5hZ2VzIGV2YWx1YXRpb24gcHJvY2Vzc2luZyB3aXRoIGRlZHVwbGljYXRpb24gYW5kIGFuYWx5c2lzXG4gKiBzdGF0dXMgc3luY2hyb25pemF0aW9uLiBIYW5kbGVzIHNhZmUgaW50ZXJhY3Rpb24gd2l0aCB0YWJsZWJhc2VcbiAqIHN0b3JlIGFjdGlvbnMgYW5kIG1haW50YWlucyBldmFsdWF0aW9uIHN0YXRlIGNvbnNpc3RlbmN5LlxuICogXG4gKiBAcGFyYW0ge1VzZU1vdmVWYWxpZGF0aW9uT3B0aW9uc30gb3B0aW9ucyAtIFZhbGlkYXRpb24gY29uZmlndXJhdGlvblxuICogQHJldHVybnMge01vdmVWYWxpZGF0aW9uUmVzdWx0fSBWYWxpZGF0aW9uIHN0YXRlIGFuZCB1dGlsaXRpZXNcbiAqIFxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgbW92ZVZhbGlkYXRpb24gPSB1c2VNb3ZlVmFsaWRhdGlvbih7XG4gKiAgIGxhc3RFdmFsdWF0aW9uOiBldmFsdWF0aW9uRGF0YSxcbiAqICAgY3VycmVudEZlbjogcG9zaXRpb24sXG4gKiAgIGV2YWx1YXRpb25zOiBldmFsdWF0aW9uTGlzdCxcbiAqICAgaXNFdmFsdWF0aW5nOiBsb2FkaW5nLFxuICogICB0YWJsZWJhc2VTdGF0ZTogc3RhdGUsXG4gKiAgIHRhYmxlYmFzZUFjdGlvbnM6IGFjdGlvbnNcbiAqIH0pO1xuICogXG4gKiAvLyBBY2Nlc3MgcHJvY2Vzc2luZyBzdGF0ZVxuICogaWYgKG1vdmVWYWxpZGF0aW9uLmlzUHJvY2Vzc2luZykge1xuICogICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBldmFsdWF0aW9uLi4uJyk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNvbnN0IHVzZU1vdmVWYWxpZGF0aW9uID0gKHtcbiAgbGFzdEV2YWx1YXRpb24sXG4gIGN1cnJlbnRGZW4sXG4gIGV2YWx1YXRpb25zLFxuICBpc0V2YWx1YXRpbmcsXG4gIHRhYmxlYmFzZVN0YXRlLFxuICB0YWJsZWJhc2VBY3Rpb25zXG59OiBVc2VNb3ZlVmFsaWRhdGlvbk9wdGlvbnMpOiBNb3ZlVmFsaWRhdGlvblJlc3VsdCA9PiB7XG4gIFxuICAvLyBUcmFjayBwcm9jZXNzZWQgZXZhbHVhdGlvbnMgdG8gcHJldmVudCBkdXBsaWNhdGVzXG4gIGNvbnN0IHByb2Nlc3NlZEV2YWx1YXRpb25zUmVmID0gdXNlUmVmKG5ldyBTZXQ8c3RyaW5nPigpKTtcbiAgY29uc3QgW3Byb2Nlc3NlZENvdW50LCBzZXRQcm9jZXNzZWRDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgXG4gIC8vIFVwZGF0ZSBadXN0YW5kIHdpdGggY3VycmVudCBldmFsdWF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFsYXN0RXZhbHVhdGlvbikgcmV0dXJuO1xuXG4gICAgLy8gQ3JlYXRlIHVuaXF1ZSBrZXkgZm9yIHRoaXMgZXZhbHVhdGlvbiB1c2luZyBjdXJyZW50IEZFTiBhbmQgZXZhbHVhdGlvbiBkYXRhXG4gICAgY29uc3QgZXZhbEtleSA9IGAke2N1cnJlbnRGZW59XyR7bGFzdEV2YWx1YXRpb24uZXZhbHVhdGlvbn1fJHtsYXN0RXZhbHVhdGlvbi5tYXRlSW5Nb3ZlcyA/PyBcIm51bGxcIn1gO1xuXG4gICAgaWYgKHByb2Nlc3NlZEV2YWx1YXRpb25zUmVmLmN1cnJlbnQuaGFzKGV2YWxLZXkpKSB7XG4gICAgICByZXR1cm47IC8vIFNraXAgaWYgYWxyZWFkeSBwcm9jZXNzZWRcbiAgICB9XG5cbiAgICBwcm9jZXNzZWRFdmFsdWF0aW9uc1JlZi5jdXJyZW50LmFkZChldmFsS2V5KTtcbiAgICBzZXRQcm9jZXNzZWRDb3VudChwcm9jZXNzZWRFdmFsdWF0aW9uc1JlZi5jdXJyZW50LnNpemUpO1xuXG4gICAgY29uc3QgY3VycmVudEV2YWx1YXRpb25zID0gZXZhbHVhdGlvbnMgfHwgW107XG4gICAgY29uc3QgdXBkYXRlZEV2YWx1YXRpb25zID0gWy4uLmN1cnJlbnRFdmFsdWF0aW9ucywgbGFzdEV2YWx1YXRpb25dO1xuXG4gICAgLy8gQ2hlY2sgaWYgc2V0RXZhbHVhdGlvbnMgZXhpc3RzIGJlZm9yZSBjYWxsaW5nXG4gICAgaWYgKHRhYmxlYmFzZUFjdGlvbnM/LnNldEV2YWx1YXRpb25zKSB7XG4gICAgICB0YWJsZWJhc2VBY3Rpb25zLnNldEV2YWx1YXRpb25zKHVwZGF0ZWRFdmFsdWF0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCLinYwgdGFibGViYXNlQWN0aW9ucy5zZXRFdmFsdWF0aW9ucyBpcyBub3QgYXZhaWxhYmxlIVwiKTtcbiAgICB9XG4gIH0sIFtsYXN0RXZhbHVhdGlvbiwgY3VycmVudEZlbiwgZXZhbHVhdGlvbnMsIHRhYmxlYmFzZUFjdGlvbnNdKTtcbiAgXG4gIC8vIFVwZGF0ZSBhbmFseXNpcyBzdGF0dXMgYmFzZWQgb24gZXZhbHVhdGlvbiBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUuZGVidWcoXCLwn5SNIFRhYmxlYmFzZUFjdGlvbnMgZGVidWdcIiwge1xuICAgICAgaGFzVGFibGViYXNlQWN0aW9uczogISF0YWJsZWJhc2VBY3Rpb25zLFxuICAgICAgaGFzU2V0QW5hbHlzaXNTdGF0dXM6ICEhdGFibGViYXNlQWN0aW9ucz8uc2V0QW5hbHlzaXNTdGF0dXMsXG4gICAgICB0YWJsZWJhc2VBY3Rpb25zS2V5czogT2JqZWN0LmtleXModGFibGViYXNlQWN0aW9ucyB8fCB7fSksXG4gICAgICBpc0V2YWx1YXRpbmcsXG4gICAgfSk7XG5cbiAgICAvLyBDUklUSUNBTDogU2FmZS1ndWFyZCB0byBwcmV2ZW50IGNyYXNoZXNcbiAgICBpZiAoIXRhYmxlYmFzZUFjdGlvbnM/LnNldEFuYWx5c2lzU3RhdHVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwi4pqg77iPIHRhYmxlYmFzZUFjdGlvbnMuc2V0QW5hbHlzaXNTdGF0dXMgbm90IGF2YWlsYWJsZSwgc2tpcHBpbmdcIixcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzRXZhbHVhdGluZykge1xuICAgICAgdGFibGViYXNlQWN0aW9ucy5zZXRBbmFseXNpc1N0YXR1cyhcImxvYWRpbmdcIik7XG4gICAgfSBlbHNlIGlmICh0YWJsZWJhc2VTdGF0ZS5hbmFseXNpc1N0YXR1cyA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIC8vIE9ubHkgdXBkYXRlIHRvIHN1Y2Nlc3MgaWYgd2Ugd2VyZSBsb2FkaW5nXG4gICAgICB0YWJsZWJhc2VBY3Rpb25zLnNldEFuYWx5c2lzU3RhdHVzKFwic3VjY2Vzc1wiKTtcbiAgICB9XG4gIH0sIFtpc0V2YWx1YXRpbmcsIHRhYmxlYmFzZVN0YXRlLCB0YWJsZWJhc2VBY3Rpb25zXSk7XG4gIFxuICAvLyBSZXR1cm4gdmFsaWRhdGlvbiBzdGF0ZVxuICByZXR1cm4ge1xuICAgIHByb2Nlc3NlZENvdW50LFxuICAgIGlzUHJvY2Vzc2luZzogaXNFdmFsdWF0aW5nXG4gIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VNb3ZlVmFsaWRhdGlvbiIsImxhc3RFdmFsdWF0aW9uIiwiY3VycmVudEZlbiIsImV2YWx1YXRpb25zIiwiaXNFdmFsdWF0aW5nIiwidGFibGViYXNlU3RhdGUiLCJ0YWJsZWJhc2VBY3Rpb25zIiwicHJvY2Vzc2VkRXZhbHVhdGlvbnNSZWYiLCJ1c2VSZWYiLCJTZXQiLCJwcm9jZXNzZWRDb3VudCIsInNldFByb2Nlc3NlZENvdW50IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJldmFsS2V5IiwiZXZhbHVhdGlvbiIsIm1hdGVJbk1vdmVzIiwiY3VycmVudCIsImhhcyIsImFkZCIsInNpemUiLCJjdXJyZW50RXZhbHVhdGlvbnMiLCJ1cGRhdGVkRXZhbHVhdGlvbnMiLCJzZXRFdmFsdWF0aW9ucyIsImNvbnNvbGUiLCJlcnJvciIsImRlYnVnIiwiaGFzVGFibGViYXNlQWN0aW9ucyIsImhhc1NldEFuYWx5c2lzU3RhdHVzIiwic2V0QW5hbHlzaXNTdGF0dXMiLCJ0YWJsZWJhc2VBY3Rpb25zS2V5cyIsIk9iamVjdCIsImtleXMiLCJ3YXJuIiwiYW5hbHlzaXNTdGF0dXMiLCJpc1Byb2Nlc3NpbmciXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWdDQzs7OzsrQkF3RVlBOzs7ZUFBQUE7Ozt1QkF0RStCO0FBc0VyQyxNQUFNQSxvQkFBb0IsQ0FBQyxFQUNoQ0MsY0FBYyxFQUNkQyxVQUFVLEVBQ1ZDLFdBQVcsRUFDWEMsWUFBWSxFQUNaQyxjQUFjLEVBQ2RDLGdCQUFnQixFQUNTO0lBRXpCLG9EQUFvRDtJQUNwRCxNQUFNQywwQkFBMEJDLElBQUFBLGFBQU0sRUFBQyxJQUFJQztJQUMzQyxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdDLElBQUFBLGVBQVEsRUFBQztJQUVyRCx5Q0FBeUM7SUFDekNDLElBQUFBLGdCQUFTLEVBQUM7UUFDUixJQUFJLENBQUNaLGdCQUFnQjtZQUd5Q0E7UUFEOUQsOEVBQThFO1FBQzlFLE1BQU1hLFVBQVUsR0FBR1osV0FBVyxDQUFDLEVBQUVELGVBQWVjLFVBQVUsQ0FBQyxDQUFDLEVBQUVkLENBQUFBLDhCQUFBQSxlQUFlZSxXQUFXLGNBQTFCZix5Q0FBQUEsOEJBQThCLFFBQVE7UUFFcEcsSUFBSU0sd0JBQXdCVSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osVUFBVTtZQUNoRCxRQUFRLDRCQUE0QjtRQUN0QztRQUVBUCx3QkFBd0JVLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDTDtRQUNwQ0gsa0JBQWtCSix3QkFBd0JVLE9BQU8sQ0FBQ0csSUFBSTtRQUV0RCxNQUFNQyxxQkFBcUJsQixlQUFlLEVBQUU7UUFDNUMsTUFBTW1CLHFCQUFxQjtlQUFJRDtZQUFvQnBCO1NBQWU7UUFFbEUsZ0RBQWdEO1FBQ2hELElBQUlLLDZCQUFBQSx1Q0FBQUEsaUJBQWtCaUIsY0FBYyxFQUFFO1lBQ3BDakIsaUJBQWlCaUIsY0FBYyxDQUFDRDtRQUNsQyxPQUFPO1lBQ0xFLFFBQVFDLEtBQUssQ0FBQztRQUNoQjtJQUNGLEdBQUc7UUFBQ3hCO1FBQWdCQztRQUFZQztRQUFhRztLQUFpQjtJQUU5RCxtREFBbUQ7SUFDbkRPLElBQUFBLGdCQUFTLEVBQUM7UUFDUlcsUUFBUUUsS0FBSyxDQUFDLDZCQUE2QjtZQUN6Q0MscUJBQXFCLENBQUMsQ0FBQ3JCO1lBQ3ZCc0Isc0JBQXNCLENBQUMsRUFBQ3RCLDZCQUFBQSx1Q0FBQUEsaUJBQWtCdUIsaUJBQWlCO1lBQzNEQyxzQkFBc0JDLE9BQU9DLElBQUksQ0FBQzFCLG9CQUFvQixDQUFDO1lBQ3ZERjtRQUNGO1FBRUEsMENBQTBDO1FBQzFDLElBQUksRUFBQ0UsNkJBQUFBLHVDQUFBQSxpQkFBa0J1QixpQkFBaUIsR0FBRTtZQUN4Q0wsUUFBUVMsSUFBSSxDQUNWO1lBRUY7UUFDRjtRQUVBLElBQUk3QixjQUFjO1lBQ2hCRSxpQkFBaUJ1QixpQkFBaUIsQ0FBQztRQUNyQyxPQUFPLElBQUl4QixlQUFlNkIsY0FBYyxLQUFLLFdBQVc7WUFDdEQsNENBQTRDO1lBQzVDNUIsaUJBQWlCdUIsaUJBQWlCLENBQUM7UUFDckM7SUFDRixHQUFHO1FBQUN6QjtRQUFjQztRQUFnQkM7S0FBaUI7SUFFbkQsMEJBQTBCO0lBQzFCLE9BQU87UUFDTEk7UUFDQXlCLGNBQWMvQjtJQUNoQjtBQUNGIn0=