{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/services/TablebaseService.ts"],"sourcesContent":["/**\n * Optimized Tablebase Service - Single API Call Architecture\n *\n * @remarks\n * This service uses the Lichess Tablebase API's \"moves\" field to get all move\n * evaluations in a single API call, instead of making N+1 calls.\n *\n * Key improvements:\n * - 1 API call instead of 20-40 for getTopMoves\n * - Caches complete tablebase entries including moves\n * - Correct WDL perspective handling\n * - No chess.js dependency for move generation\n * - FEN normalization for improved cache hit rate\n *\n * Important limitations:\n * - DTM (Distance to Mate) values are only available for positions with ≤5 pieces\n * - Positions with 6-7 pieces only have DTZ (Distance to Zeroing) values\n * - Rate limiting applies (~130 rapid requests trigger limits)\n */\n\nimport { validateAndSanitizeFen } from \"../utils/fenValidator\";\nimport { getLogger } from \"../services/logging\";\nimport { APP_CONFIG } from \"@/config/constants\";\nimport { z } from \"zod\";\nimport { LichessTablebaseResponseSchema } from \"../types/tablebaseSchemas\";\nimport type {\n  LichessTablebaseResponse,\n  TablebaseEntry,\n  TablebaseCategory,\n  TablebaseCacheEntry,\n  TablebaseMoveInternal,\n  TablebaseMove,\n  TablebaseResult,\n  TablebaseEvaluation,\n  TablebaseMovesResult,\n} from \"../types/tablebase\";\n\n// Re-export types for backward compatibility\nexport type {\n  TablebaseMove,\n  TablebaseResult,\n  TablebaseEvaluation,\n  TablebaseMovesResult,\n};\n\nconst logger = getLogger().setContext(\"TablebaseService\");\n\nclass TablebaseService {\n  private cache = new Map<string, TablebaseCacheEntry>();\n  private readonly maxPieces = 7; // Lichess uses 7-piece Syzygy tablebases\n  private readonly cacheTtl = 300000; // 5 minutes\n  private pendingRequests = new Map<string, Promise<TablebaseEntry | null>>();\n\n  // Metrics for monitoring\n  private metrics = {\n    cacheHits: 0,\n    cacheMisses: 0,\n    apiCalls: 0,\n    apiErrors: new Map<number, number>(),\n    requestsDeduplicated: 0,\n\n    recordCacheHit() {\n      this.cacheHits++;\n    },\n    recordCacheMiss() {\n      this.cacheMisses++;\n    },\n    recordApiCall() {\n      this.apiCalls++;\n    },\n    recordApiError(status: number) {\n      this.apiErrors.set(status, (this.apiErrors.get(status) || 0) + 1);\n    },\n    recordDeduplication() {\n      this.requestsDeduplicated++;\n    },\n\n    getMetrics() {\n      const total = this.cacheHits + this.cacheMisses;\n      return {\n        cacheHitRate: total > 0 ? this.cacheHits / total : 0,\n        totalApiCalls: this.apiCalls,\n        errorBreakdown: Object.fromEntries(this.apiErrors),\n        dedupedRequests: this.requestsDeduplicated,\n      };\n    },\n  };\n\n  /**\n   * Get tablebase evaluation for a position\n   * @param {string} fen - Position in FEN notation\n   * @returns {Promise<TablebaseEvaluation>} Evaluation result\n   *\n   * @example\n   * const eval = await tablebaseService.getEvaluation(fen);\n   * if (eval.isAvailable) {\n   *   logger.info(`Position is ${eval.result.category}`);\n   * }\n   */\n  async getEvaluation(fen: string): Promise<TablebaseEvaluation> {\n    try {\n      const entry = await this._getOrFetchTablebaseEntry(fen);\n\n      if (!entry) {\n        return { isAvailable: false };\n      }\n\n      return {\n        isAvailable: true,\n        result: {\n          wdl: entry.position.wdl,\n          dtz: entry.position.dtz,\n          dtm: entry.position.dtm,\n          category: entry.position.category,\n          precise: entry.position.precise,\n          evaluation: entry.position.evaluation,\n        },\n      };\n    } catch (error) {\n      logger.error(\"Failed to get evaluation\", error as Error, { fen });\n      return {\n        isAvailable: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n\n  /**\n   * Get top moves from tablebase\n   * @param {string} fen - Position in FEN notation\n   * @param {number} limit - Maximum number of moves to return\n   * @returns {Promise<TablebaseMovesResult>} Top moves with evaluations\n   *\n   * @remarks\n   * This now makes only ONE API call and returns moves from the cached entry.\n   * The Lichess API already provides all moves sorted by quality.\n   *\n   * @example\n   * const moves = await tablebaseService.getTopMoves(fen, 5);\n   * if (moves.isAvailable) {\n   *   logger.info(`Best move: ${moves.moves[0].san}`);\n   * }\n   */\n  async getTopMoves(\n    fen: string,\n    limit: number = 3,\n  ): Promise<TablebaseMovesResult> {\n    try {\n      const entry = await this._getOrFetchTablebaseEntry(fen);\n\n      if (!entry || !entry.moves.length) {\n        return {\n          isAvailable: false,\n          error: \"No moves available for this position\",\n        };\n      }\n\n      // Sort moves by quality (WDL value, then DTZ)\n      // Higher WDL = better for the player, then lower DTZ = faster to goal\n      const sortedMoves = [...entry.moves].sort((a, b) => {\n        // Primary sort: by WDL (higher is better)\n        if (a.wdl !== b.wdl) {\n          return b.wdl - a.wdl;\n        }\n\n        // Secondary sort: for moves that are \"wins\" from opponent's perspective after our move,\n        // we want to choose the move that gives the opponent the LONGEST path to win (best defense)\n        if (a.wdl > 0) {\n          // These are \"winning\" positions for the opponent after our move\n          // For optimal defense: prefer moves that give opponent HIGHER DTM (slower win for them)\n          const aDtx = a.dtm ?? a.dtz ?? 0;\n          const bDtx = b.dtm ?? b.dtz ?? 0;\n          return Math.abs(aDtx) - Math.abs(bDtx); // FIXED: Lower DTM first for faster wins\n        } else if (a.wdl < 0) {\n          // Losing - prefer slower loss (larger absolute DTM value)\n          const aDtx = a.dtm ?? a.dtz ?? 0;\n          const bDtx = b.dtm ?? b.dtz ?? 0;\n          return Math.abs(bDtx) - Math.abs(aDtx);\n        }\n\n        // Draw - prefer maintaining draw (DTZ doesn't matter much)\n        return 0;\n      });\n\n      // Take only the best moves (same WDL as the absolute best)\n      const bestWdl = sortedMoves[0]?.wdl ?? 0;\n      const bestMoves = sortedMoves.filter((move) => move.wdl === bestWdl);\n\n      // Return up to 'limit' of the best moves\n      const topInternalMoves = bestMoves.slice(0, limit);\n\n      // Convert internal moves to external format (without zeroing field)\n      const topMoves: TablebaseMove[] = topInternalMoves.map((move) => ({\n        uci: move.uci,\n        san: move.san,\n        wdl: move.wdl,\n        dtz: move.dtz,\n        dtm: move.dtm,\n        category: move.category,\n      }));\n\n      // ENHANCED DEBUG LOGGING\n      logger.info(\"TablebaseService.getTopMoves DETAILED OUTPUT\", {\n        fen,\n        requestedLimit: limit,\n        totalMovesFromAPI: entry.moves.length,\n        bestWdl,\n        movesWithBestWdl: bestMoves.length,\n        returnedMoves: topMoves.length,\n        returnedMoveDetails: topMoves.map((m) => ({\n          san: m.san,\n          wdl: m.wdl,\n          dtm: m.dtm,\n          category: m.category,\n        })),\n        sortingApplied:\n          bestWdl < 0\n            ? \"Defensive (highest DTM first)\"\n            : bestWdl > 0\n              ? \"Offensive (lowest DTM first)\"\n              : \"Draw\",\n      });\n\n      return {\n        isAvailable: true,\n        moves: topMoves,\n      };\n    } catch (error) {\n      logger.error(\"Failed to get top moves\", error as Error, { fen });\n      return {\n        isAvailable: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    }\n  }\n\n  /**\n   * Normalize FEN for tablebase lookup\n   * @private\n   * @param {string} fen - Full FEN string\n   * @returns {string} Normalized FEN (first 4 fields only)\n   *\n   * @remarks\n   * Tablebase only cares about:\n   * 1. Piece placement\n   * 2. Side to move\n   * 3. Castling rights\n   * 4. En passant square\n   *\n   * Halfmove clock and fullmove number are irrelevant for tablebase lookup\n   */\n  private _normalizeFen(fen: string): string {\n    return fen.split(\" \").slice(0, 4).join(\" \");\n  }\n\n  /**\n   * Core method to fetch or retrieve cached tablebase data\n   * @private\n   * @param {string} fen - Position to look up\n   * @returns {Promise<TablebaseEntry | null>} Complete tablebase data or null\n   *\n   * @remarks\n   * This method:\n   * 1. Validates and normalizes the FEN\n   * 2. Checks the cache\n   * 3. Makes ONE API call if needed\n   * 4. Transforms the response to our internal format\n   * 5. Caches the complete entry including all moves\n   */\n  private async _getOrFetchTablebaseEntry(\n    fen: string,\n  ): Promise<TablebaseEntry | null> {\n    // Validate FEN\n    const validation = validateAndSanitizeFen(fen);\n    if (!validation.isValid) {\n      throw new Error(`Invalid FEN: ${validation.errors.join(\", \")}`);\n    }\n    const sanitizedFen = validation.sanitized;\n    const normalizedFen = this._normalizeFen(sanitizedFen);\n\n    // Check piece count\n    const pieceCount = this._countPieces(sanitizedFen);\n    if (pieceCount > this.maxPieces) {\n      logger.debug(\"Too many pieces for tablebase\", {\n        fen: sanitizedFen,\n        pieceCount,\n      });\n      return null;\n    }\n\n    // Check cache with normalized FEN\n    const cached = this.cache.get(normalizedFen);\n    if (cached && cached.expiry > Date.now()) {\n      logger.debug(\"Cache hit for tablebase entry\", { fen: normalizedFen });\n      this.metrics.recordCacheHit();\n      return cached.entry;\n    }\n    this.metrics.recordCacheMiss();\n\n    // Check if request already in flight (request deduplication)\n    const pending = this.pendingRequests.get(normalizedFen);\n    if (pending) {\n      logger.debug(\"Request already in flight, waiting\", {\n        fen: normalizedFen,\n      });\n      this.metrics.recordDeduplication();\n      return pending;\n    }\n\n    // Create new request with proper cleanup on both success and failure\n    const request = this._fetchAndTransform(sanitizedFen, normalizedFen);\n\n    // Store the promise with cleanup handler\n    const promiseWithCleanup = request.finally(() => {\n      // Remove from pending requests on both success and failure\n      this.pendingRequests.delete(normalizedFen);\n    });\n\n    this.pendingRequests.set(normalizedFen, promiseWithCleanup);\n    return promiseWithCleanup;\n  }\n\n  /**\n   * Fetch from API and transform response\n   * @private\n   * @param {string} fen - Original sanitized FEN for API call\n   * @param {string} normalizedFen - Normalized FEN for caching\n   */\n  private async _fetchAndTransform(\n    fen: string,\n    normalizedFen: string,\n  ): Promise<TablebaseEntry | null> {\n    const MAX_RETRIES = 3;\n    this.metrics.recordApiCall();\n\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), 5000);\n\n        // Always request moves to get complete tablebase entry\n        const response = await fetch(\n          `${APP_CONFIG.TABLEBASE_API_URL}/standard?fen=${encodeURIComponent(fen)}&moves=20`,\n          { signal: controller.signal },\n        );\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          this.metrics.recordApiError(response.status);\n\n          if (response.status === 404) {\n            // Position not in tablebase - cache this to avoid repeated queries\n            logger.info(\"Position not in tablebase, caching null\", {\n              fen: normalizedFen,\n            });\n            this._cacheEntry(normalizedFen, null);\n            return null;\n          }\n\n          // Rate limiting - retry with exponential backoff\n          if (response.status === 429) {\n            const delay = Math.min(\n              1000 * Math.pow(2, attempt) + Math.random() * 1000,\n              10000,\n            );\n            logger.warn(`Rate limited, retrying in ${delay}ms`, {\n              attempt,\n              delay,\n            });\n            await new Promise((resolve) => setTimeout(resolve, delay));\n            continue;\n          }\n\n          // Don't retry other client errors\n          if (response.status >= 400 && response.status < 500) {\n            throw new Error(`Client error: ${response.status}`);\n          }\n\n          throw new Error(`API error: ${response.status}`);\n        }\n\n        const responseData = await response.json();\n\n        // Validate the API response structure\n        let validatedData: LichessTablebaseResponse;\n        try {\n          validatedData = LichessTablebaseResponseSchema.parse(responseData);\n        } catch (error) {\n          if (error instanceof z.ZodError) {\n            logger.error(\"Malformed Lichess API response\", {\n              fen,\n              errors: error.issues,\n              received: responseData,\n            });\n            throw new Error(\"Malformed API response\");\n          }\n          throw error;\n        }\n\n        // Transform to our internal format\n        const entry = this._transformApiResponse(validatedData, fen);\n\n        // Cache the transformed entry with normalized FEN\n        this._cacheEntry(normalizedFen, entry);\n\n        logger.info(\"Successfully fetched and cached tablebase entry\", {\n          fen,\n          positionCategory: entry.position.category,\n          moveCount: entry.moves.length,\n        });\n\n        return entry;\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Unknown error\";\n        logger.warn(`Tablebase API attempt ${attempt}/${MAX_RETRIES} failed`, {\n          fen,\n          error: errorMessage,\n        });\n\n        // Don't retry client errors\n        if (\n          error instanceof Error &&\n          error.message.startsWith(\"Client error\")\n        ) {\n          throw error;\n        }\n\n        // Last attempt failed\n        if (attempt === MAX_RETRIES) {\n          logger.error(\"API call failed after max retries\", { error, fen });\n          if (error instanceof Error && error.name === \"AbortError\") {\n            throw new Error(`Request timeout after ${MAX_RETRIES} retries`);\n          }\n          throw new Error(\n            `Max retries (${MAX_RETRIES}) exceeded. Last error: ${errorMessage}`,\n          );\n        }\n\n        // Wait before retry with exponential backoff\n        await new Promise((resolve) => setTimeout(resolve, 250 * attempt));\n      }\n    }\n\n    // Should never reach here\n    throw new Error(\"Unexpected error in fetch loop\");\n  }\n\n  /**\n   * Transform Lichess API response to internal format\n   * @private\n   *\n   * @remarks\n   * Critical transformations:\n   * 1. Convert category strings to typed categories\n   * 2. Calculate WDL values from categories\n   * 3. Invert move evaluations to player-to-move perspective\n   * 4. Handle Black's perspective correctly\n   */\n  private _transformApiResponse(\n    api: LichessTablebaseResponse,\n    fen: string,\n  ): TablebaseEntry {\n    const isBlackToMove = fen.split(\" \")[1] === \"b\";\n\n    // Transform position evaluation\n    const positionCategory = api.category as TablebaseCategory;\n    let positionWdl = this._categoryToWdl(positionCategory);\n\n    // WDL is already from the perspective of the side to move\n    // No need to negate for Black positions - the API gives the result from the mover's perspective\n    // Handle -0 case to ensure it's just 0\n    if (positionWdl === -0) {\n      positionWdl = 0;\n    }\n\n    // Transform moves with correct perspective (moves array guaranteed by schema)\n    const moves: TablebaseMoveInternal[] = (api.moves || []).map((apiMove) => {\n      // API gives evaluation AFTER the move (from opponent's perspective)\n      // We need to invert it to get the evaluation FROM the mover's perspective\n      const moveCategory = this._invertCategory(\n        apiMove.category,\n      ) as TablebaseCategory;\n      let moveWdl = this._categoryToWdl(moveCategory);\n\n      // For Black, we need to negate WDL since it's from White's perspective\n      if (isBlackToMove) {\n        moveWdl = -moveWdl;\n      }\n\n      return {\n        uci: apiMove.uci,\n        san: apiMove.san,\n        category: moveCategory,\n        wdl: moveWdl,\n        dtz: apiMove.dtz,\n        dtm: apiMove.dtm,\n        zeroing: apiMove.zeroing || false,\n      };\n    });\n\n    return {\n      position: {\n        category: positionCategory,\n        wdl: positionWdl,\n        dtz: api.dtz,\n        dtm: api.dtm ?? null,\n        precise: api.precise_dtz !== undefined && api.precise_dtz !== null,\n        evaluation: this._getEvaluationText(positionCategory, api.dtz),\n      },\n      moves,\n      fen,\n      timestamp: Date.now(),\n    };\n  }\n\n  /**\n   * Cache an entry with TTL\n   * @private\n   */\n  private _cacheEntry(fen: string, entry: TablebaseEntry | null): void {\n    this.cache.set(fen, {\n      entry,\n      expiry: Date.now() + this.cacheTtl,\n    });\n\n    // Clean up old entries if cache is getting large\n    if (this.cache.size > 200) {\n      const now = Date.now();\n      for (const [key, value] of this.cache.entries()) {\n        if (value.expiry < now) {\n          this.cache.delete(key);\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert category to WDL value\n   * @private\n   */\n  private _categoryToWdl(category: string): number {\n    switch (category) {\n      case \"win\":\n        return 2;\n      case \"cursed-win\":\n      case \"maybe-win\":\n        return 1;\n      case \"draw\":\n      case \"unknown\":\n        return 0;\n      case \"blessed-loss\":\n      case \"maybe-loss\":\n        return -1;\n      case \"loss\":\n        return -2;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Invert category for perspective change\n   * @private\n   */\n  private _invertCategory(category: string): string {\n    switch (category) {\n      case \"win\":\n        return \"loss\";\n      case \"loss\":\n        return \"win\";\n      case \"cursed-win\":\n        return \"blessed-loss\";\n      case \"blessed-loss\":\n        return \"cursed-win\";\n      case \"maybe-win\":\n        return \"maybe-loss\";\n      case \"maybe-loss\":\n        return \"maybe-win\";\n      case \"draw\":\n      case \"unknown\":\n      default:\n        return category;\n    }\n  }\n\n  /**\n   * Generate evaluation text in German\n   * @private\n   */\n  private _getEvaluationText(category: string, dtz?: number | null): string {\n    switch (category) {\n      case \"win\":\n        return dtz\n          ? `Gewinn in ${Math.abs(dtz)} Zügen`\n          : \"Theoretisch gewonnen\";\n      case \"cursed-win\":\n        return dtz\n          ? `Gewinn in ${Math.abs(dtz)} Zügen (50-Zug-Regel)`\n          : \"Gewinn mit 50-Zug-Regel\";\n      case \"maybe-win\":\n        return \"Wahrscheinlicher Gewinn\";\n      case \"draw\":\n        return \"Theoretisches Remis\";\n      case \"blessed-loss\":\n        return dtz\n          ? `Verlust in ${Math.abs(dtz)} Zügen (50-Zug-Regel)`\n          : \"Verlust mit 50-Zug-Regel\";\n      case \"maybe-loss\":\n        return \"Wahrscheinlicher Verlust\";\n      case \"loss\":\n        return dtz\n          ? `Verlust in ${Math.abs(dtz)} Zügen`\n          : \"Theoretisch verloren\";\n      case \"unknown\":\n        return \"Unbekannte Bewertung\";\n      default:\n        return \"Bewertung nicht verfügbar\";\n    }\n  }\n\n  /**\n   * Count pieces in FEN\n   * @private\n   */\n  private _countPieces(fen: string): number {\n    const piecesPart = fen.split(\" \")[0];\n    return piecesPart.replace(/[^a-zA-Z]/g, \"\").length;\n  }\n\n  /**\n   * Clear cache (for testing)\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.pendingRequests.clear();\n  }\n\n  /**\n   * Get service metrics for monitoring\n   * @returns {object} Current metrics\n   */\n  getMetrics() {\n    return this.metrics.getMetrics();\n  }\n}\n\n/**\n * Singleton instance of optimized TablebaseService\n *\n * @example\n * import { tablebaseService } from '@shared/services/TablebaseService';\n *\n * // Get position evaluation (1 API call)\n * const eval = await tablebaseService.getEvaluation(fen);\n *\n * // Get top moves (uses same API call, no additional requests!)\n * const moves = await tablebaseService.getTopMoves(fen, 5);\n */\nexport const tablebaseService = new TablebaseService();\n"],"names":["tablebaseService","logger","getLogger","setContext","TablebaseService","getEvaluation","fen","entry","_getOrFetchTablebaseEntry","isAvailable","result","wdl","position","dtz","dtm","category","precise","evaluation","error","Error","message","getTopMoves","limit","sortedMoves","moves","length","sort","a","b","aDtx","bDtx","Math","abs","bestWdl","bestMoves","filter","move","topInternalMoves","slice","topMoves","map","uci","san","info","requestedLimit","totalMovesFromAPI","movesWithBestWdl","returnedMoves","returnedMoveDetails","m","sortingApplied","_normalizeFen","split","join","validation","validateAndSanitizeFen","isValid","errors","sanitizedFen","sanitized","normalizedFen","pieceCount","_countPieces","maxPieces","debug","cached","cache","get","expiry","Date","now","metrics","recordCacheHit","recordCacheMiss","pending","pendingRequests","recordDeduplication","request","_fetchAndTransform","promiseWithCleanup","finally","delete","set","MAX_RETRIES","recordApiCall","attempt","controller","AbortController","timeoutId","setTimeout","abort","response","fetch","APP_CONFIG","TABLEBASE_API_URL","encodeURIComponent","signal","clearTimeout","ok","recordApiError","status","_cacheEntry","delay","min","pow","random","warn","Promise","resolve","responseData","json","validatedData","LichessTablebaseResponseSchema","parse","z","ZodError","issues","received","_transformApiResponse","positionCategory","moveCount","errorMessage","startsWith","name","api","isBlackToMove","positionWdl","_categoryToWdl","apiMove","moveCategory","_invertCategory","moveWdl","zeroing","precise_dtz","undefined","_getEvaluationText","timestamp","cacheTtl","size","key","value","entries","piecesPart","replace","clearCache","clear","getMetrics","Map","cacheHits","cacheMisses","apiCalls","apiErrors","requestsDeduplicated","total","cacheHitRate","totalApiCalls","errorBreakdown","Object","fromEntries","dedupedRequests"],"mappings":"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"}