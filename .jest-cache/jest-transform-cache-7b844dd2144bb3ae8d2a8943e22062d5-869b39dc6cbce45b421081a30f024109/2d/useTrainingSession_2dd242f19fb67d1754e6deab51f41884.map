{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/hooks/useTrainingSession.ts"],"sourcesContent":["/**\n * @file Hook for managing chess endgame training sessions\n * @module hooks/useTrainingSession\n *\n * @description\n * Core hook that connects React components to the Zustand store for chess training.\n * Provides a clean API for move execution, history navigation, and game state management.\n * Uses the store as the single source of truth for all chess state.\n */\n\nimport { useCallback } from \"react\";\nimport { useGameStore, useTrainingStore } from \"@shared/store/hooks\";\nimport type { ValidatedMove } from \"@shared/types/chess\";\nimport { ErrorService } from \"@shared/services/ErrorService\";\nimport { getLogger } from \"@shared/services/logging/Logger\";\n\n/**\n * Configuration options for the useTrainingSession hook\n *\n * @interface UseTrainingSessionOptions\n * @property {Function} [onComplete] - Callback fired when training ends (checkmate/stalemate)\n * @property {Function} [onPositionChange] - Callback fired after each move with new FEN and PGN\n */\ninterface UseTrainingSessionOptions {\n  onComplete?: (success: boolean) => void;\n  onPositionChange?: (fen: string, pgn: string) => void;\n}\n\n/**\n * Return value of the useTrainingSession hook\n * @interface UseTrainingSessionReturn\n * @property {Chess} game - Chess.js instance from Zustand store (read-only reference)\n * @property {ValidatedMove[]} history - Array of validated moves played in the endgame\n * @property {boolean} isGameFinished - Whether endgame has ended (checkmate/stalemate)\n * @property {string} currentFen - Current position in FEN notation\n * @property {string} currentPgn - Current game in PGN notation\n * @property {Function} makeMove - Execute a chess move and update store\n * @property {Function} jumpToMove - Navigate to a specific move in history\n * @property {Function} resetGame - Reset to initial endgame position\n * @property {Function} undoMove - Take back the last move\n */\ninterface UseTrainingSessionReturn {\n  game: any; // Chess instance from store\n  history: ValidatedMove[];\n  isGameFinished: boolean;\n  currentFen: string;\n  currentPgn: string;\n  makeMove: (move: {\n    from: string;\n    to: string;\n    promotion?: string;\n  }) => Promise<boolean>;\n  jumpToMove: (moveIndex: number) => void;\n  resetGame: () => void;\n  undoMove: () => boolean;\n}\n\n/**\n * Hook providing training session functionality using Zustand store as single source of truth\n *\n * @description\n * Central hook for chess endgame training sessions. Bridges React components with\n * the Zustand store, providing a clean API for chess operations while maintaining\n * store as the single source of truth.\n *\n * @param {UseTrainingSessionOptions} options - Configuration for the training session hook\n * @param {Function} [options.onComplete] - Called when game ends with success boolean\n * @param {Function} [options.onPositionChange] - Called after moves with (fen, pgn)\n * @returns {UseTrainingSessionReturn} Training session interface with state and methods\n *\n * @remarks\n * This hook is a thin wrapper around Zustand store actions. It:\n * - Delegates all state management to the store (no local state)\n * - Provides callbacks for training events (completion, position changes)\n * - Handles error cases gracefully with ErrorService\n * - Automatically detects game endings and triggers completion\n * - Integrates with tablebase for opponent moves\n *\n * @example\n * ```tsx\n * function TrainingBoard() {\n *   const { game, makeMove, history, isGameFinished } = useTrainingSession({\n *     onComplete: (success) => {\n *       if (success) {\n *         showToast('Well done! You achieved the target outcome!');\n *       } else {\n *         showToast('Game ended. Try again!');\n *       }\n *     },\n *     onPositionChange: (fen, pgn) => {\n *       console.log('New position:', fen);\n *       updateAnalysis(fen);\n *     }\n *   });\n *\n *   const handleMove = async (from: string, to: string) => {\n *     const success = await makeMove({ from, to, promotion: 'q' });\n *     if (!success) {\n *       showError('Invalid move!');\n *     }\n *   };\n *\n *   return (\n *     <Chessboard\n *       position={game.fen()}\n *       onPieceDrop={handleMove}\n *       arePiecesDraggable={!isGameFinished}\n *     />\n *   );\n * }\n * ```\n */\nexport const useTrainingSession = ({\n  onComplete,\n  onPositionChange,\n}: UseTrainingSessionOptions): UseTrainingSessionReturn => {\n  const [gameState, gameActions] = useGameStore();\n  const [trainingState, trainingActions] = useTrainingStore();\n\n  /**\n   * Execute a chess move and update the game state\n   * @param {Object} move - Move to execute\n   * @param {string} move.from - Source square (e.g., 'e2')\n   * @param {string} move.to - Target square (e.g., 'e4')\n   * @param {string} [move.promotion] - Promotion piece ('q', 'r', 'b', 'n')\n   * @returns {Promise<boolean>} True if move was successful, false otherwise\n   */\n  const makeMove = useCallback(\n    async (move: {\n      from: string;\n      to: string;\n      promotion?: string;\n    }): Promise<boolean> => {\n      const logger = getLogger().setContext(\"useTrainingSession\");\n      logger.debug(\"makeMove called\", { move });\n      \n      // CRITICAL DEBUG: Log the exact reason why moves might be blocked\n      logger.debug(\"gameState.isGameFinished check\", {\n        isGameFinished: gameState.isGameFinished,\n        gameResult: gameState.gameResult,\n        currentFen: gameState.currentFen,\n        moveHistoryLength: gameState.moveHistory?.length,\n        checkmate: gameState.isCheckmate,\n        draw: gameState.isDraw,\n        stalemate: gameState.isStalemate\n      });\n      \n      if (gameState.isGameFinished) {\n        logger.warn(\"EARLY RETURN: gameState.isGameFinished is true, blocking move\", {\n          isGameFinished: gameState.isGameFinished,\n          gameResult: gameState.gameResult\n        });\n        return false;\n      }\n\n      try {\n        // Simply delegate to Store - no double validation needed\n        // Store will validate the move and update all states atomically\n        logger.debug(\"Calling trainingActions.handlePlayerMove\");\n        const moveResult = await trainingActions.handlePlayerMove(move as any);\n        logger.debug(\"trainingActions.handlePlayerMove result\", { moveResult });\n        if (!moveResult) return false;\n\n        // Check if game is finished after move\n        if (gameState.isGameFinished) {\n          // Game result is already determined by ChessService\n          const success = gameState.gameResult !== null;\n          trainingActions.completeTraining(success);\n          onComplete?.(success);\n        }\n\n        // Notify position change with current Store state\n        onPositionChange?.(\n          gameState.currentFen || \"\",\n          gameState.currentPgn || \"\",\n        );\n\n        return true;\n      } catch (error) {\n        ErrorService.handleUIError(\n          error instanceof Error ? error : new Error(String(error)),\n          \"useTrainingSession\",\n          { action: \"makeMove\", additionalData: { move } },\n        );\n        return false;\n      }\n    },\n    [\n      gameState.isGameFinished,\n      gameState.currentFen,\n      gameState.currentPgn,\n      trainingActions.handlePlayerMove,\n      trainingActions.completeTraining,\n      trainingState.currentPosition,\n      onComplete,\n      onPositionChange,\n    ],\n  );\n\n  /**\n   * Navigate to a specific move in the game history\n   * @param {number} moveIndex - Move number to jump to (1-based index)\n   */\n  const jumpToMove = useCallback(\n    (moveIndex: number) => {\n      // Convert 1-based index to 0-based for store\n      const zeroBasedIndex = moveIndex - 1;\n      gameActions.goToMove(zeroBasedIndex);\n\n      // Notify position change\n      if (onPositionChange && gameState.currentFen) {\n        onPositionChange(gameState.currentFen, gameState.currentPgn || \"\");\n      }\n    },\n    [\n      gameActions.goToMove,\n      gameState.currentFen,\n      gameState.currentPgn,\n      onPositionChange,\n    ],\n  );\n\n  /**\n   * Reset the game to initial position\n   * Clears move history and resets to starting FEN\n   */\n  const resetGame = useCallback(() => {\n    gameActions.resetGame();\n\n    // Notify position change\n    if (onPositionChange && trainingState.currentPosition) {\n      onPositionChange(trainingState.currentPosition.fen, \"\");\n    }\n  }, [gameActions.resetGame, trainingState.currentPosition, onPositionChange]);\n\n  /**\n   * Undo the last move in the game\n   * @returns {boolean} True if move was undone, false if no moves to undo\n   */\n  const undoMoveAction = useCallback((): boolean => {\n    if (gameState.moveHistory.length === 0) return false;\n\n    // Use the store's undoMove action\n    gameActions.undoMove();\n\n    // Notify position change\n    if (onPositionChange && gameState.currentFen) {\n      onPositionChange(gameState.currentFen, gameState.currentPgn || \"\");\n    }\n\n    return true;\n  }, [\n    gameState.moveHistory,\n    gameState.currentFen,\n    gameState.currentPgn,\n    gameActions.undoMove,\n    onPositionChange,\n  ]);\n\n  return {\n    game: null, // Chess instance now managed by ChessService, not exposed here\n    history: gameState.moveHistory,\n    isGameFinished: gameState.isGameFinished,\n    currentFen:\n      gameState.currentFen || trainingState.currentPosition?.fen || \"\",\n    currentPgn: gameState.currentPgn || \"\",\n    makeMove,\n    jumpToMove,\n    resetGame,\n    undoMove: undoMoveAction,\n  };\n};\n"],"names":["useTrainingSession","onComplete","onPositionChange","trainingState","gameState","gameActions","useGameStore","trainingActions","useTrainingStore","makeMove","useCallback","move","logger","getLogger","setContext","debug","isGameFinished","gameResult","currentFen","moveHistoryLength","moveHistory","length","checkmate","isCheckmate","draw","isDraw","stalemate","isStalemate","warn","moveResult","handlePlayerMove","success","completeTraining","currentPgn","error","ErrorService","handleUIError","Error","String","action","additionalData","currentPosition","jumpToMove","moveIndex","zeroBasedIndex","goToMove","resetGame","fen","undoMoveAction","undoMove","game","history"],"mappings":"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"}