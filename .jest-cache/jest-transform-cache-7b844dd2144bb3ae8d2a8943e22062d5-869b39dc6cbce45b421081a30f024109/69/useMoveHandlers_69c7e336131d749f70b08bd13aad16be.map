{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/hooks/useMoveHandlers.ts"],"sourcesContent":["/**\n * @file Move handlers hook for chess training board\n * @module hooks/useMoveHandlers\n * \n * @description\n * Custom hook that encapsulates all move handling logic for chess training.\n * Extracted from TrainingBoard to separate business logic from UI rendering.\n * Handles drag-and-drop, click-to-move, and core move validation logic.\n * \n * @remarks\n * Key responsibilities:\n * - Chess move validation and execution\n * - Drag-and-drop event handling with promotion detection\n * - Click-to-move functionality with selection state\n * - Position readiness validation\n * - Comprehensive logging and error handling\n * \n * This hook maintains all the complex business logic while providing\n * a clean interface for chess board components.\n * \n * @example\n * ```tsx\n * const { onDrop, onSquareClick, selectedSquare } = useMoveHandlers({\n *   currentFen,\n *   isGameFinished,\n *   isPositionReady,\n *   trainingState,\n *   onMove: makeMove\n * });\n * \n * <Chessboard\n *   fen={currentFen}\n *   onPieceDrop={onDrop}\n *   onSquareClick={onSquareClick}\n *   arePiecesDraggable={!isGameFinished}\n * />\n * ```\n */\n\nimport { useCallback, useState } from 'react';\nimport { Chess } from 'chess.js';\nimport { getLogger } from '@shared/services/logging/Logger';\nimport { useUIStore } from '@shared/store/hooks';\n\n/**\n * Training state structure (subset needed for move handling)\n */\ninterface TrainingStateSubset {\n  currentPosition?: {\n    id: number;\n    fen: string;\n  } | null;\n  isPlayerTurn: boolean;\n  isOpponentThinking: boolean;\n}\n\n/**\n * Props for useMoveHandlers hook\n */\ninterface UseMoveHandlersProps {\n  /** Current FEN position string */\n  currentFen: string;\n  /** Whether the game has finished */\n  isGameFinished: boolean;\n  /** Whether the position is ready for interaction */\n  isPositionReady: boolean;\n  /** Training state subset needed for move validation */\n  trainingState: TrainingStateSubset;\n  /** Callback to execute moves - should be the makeMove function from useTrainingSession */\n  onMove: (move: any) => Promise<boolean | null>;\n}\n\n/**\n * Return value from useMoveHandlers hook\n */\ninterface UseMoveHandlersReturn {\n  /** Event handler for piece drop events from drag-and-drop */\n  onDrop: (sourceSquare: string, targetSquare: string, piece: string) => boolean;\n  /** Event handler for square click events (click-to-move) */\n  onSquareClick: ({ piece, square }: { piece: any; square: string }) => void;\n  /** Currently selected square for click-to-move functionality */\n  selectedSquare: string | null;\n  /** Utility function to clear the current selection */\n  clearSelection: () => void;\n}\n\n/**\n * Custom hook for chess move handling logic\n * \n * @description\n * Encapsulates all move handling logic including:\n * - Core move validation and execution\n * - Drag-and-drop event handling with promotion detection\n * - Click-to-move functionality with selection state management\n * - Position readiness validation and game state checks\n * - Comprehensive logging and error handling\n * \n * @remarks\n * This hook maintains all the complex business logic that was previously\n * embedded in TrainingBoard. It coordinates between multiple services:\n * - Chess.js for move validation\n * - TrainingSession hook for game state via onMove callback\n * - UI actions for user feedback\n * - Logging service for debugging\n * \n * The hook preserves all original functionality while providing a clean\n * interface that separates concerns between UI rendering and business logic.\n * \n * @param props Configuration object with game state and callbacks\n * @returns Object with event handlers and selection state\n */\nexport const useMoveHandlers = ({\n  currentFen,\n  isGameFinished,\n  isPositionReady,\n  trainingState,\n  onMove,\n}: UseMoveHandlersProps): UseMoveHandlersReturn => {\n  const [, uiActions] = useUIStore();\n  \n  // Click-to-move state management\n  const [selectedSquare, setSelectedSquare] = useState<string | null>(null);\n\n  /**\n   * Clear the current square selection\n   */\n  const clearSelection = useCallback(() => {\n    setSelectedSquare(null);\n  }, []);\n\n  /**\n   * Handles chess move execution and validation\n   *\n   * @param {Object} move - Move object with from/to squares\n   * @param {string} move.from - Starting square (e.g., \"e2\")\n   * @param {string} move.to - Target square (e.g., \"e4\")\n   * @param {string} [move.promotion] - Promotion piece if applicable\n   * @returns {Promise<any>} Move result or null if invalid\n   *\n   * @description\n   * Core move handler that:\n   * 1. Validates move legality using chess.js\n   * 2. Executes the move on the game instance\n   * 3. Triggers tablebase analysis for opponent response\n   * 4. Updates all relevant state slices\n   * 5. Handles errors with user feedback\n   *\n   * @remarks\n   * This function coordinates between multiple services:\n   * - Chess.js for move validation\n   * - TrainingSession hook for game state\n   * - Tablebase orchestrator for opponent moves\n   * - UI actions for user feedback\n   *\n   * Invalid moves increment the mistake counter and show\n   * a warning toast without modifying game state.\n   *\n   * @example\n   * ```typescript\n   * // User drags piece\n   * await handleMove({ from: \"e2\", to: \"e4\" });\n   *\n   * // With promotion\n   * await handleMove({ from: \"e7\", to: \"e8\", promotion: \"q\" });\n   * ```\n   */\n  const handleMove = useCallback(\n    async (move: any) => {\n      const logger = getLogger().setContext(\"useMoveHandlers-handleMove\");\n      logger.debug(\"🚀 handleMove called\", {\n        move,\n        isGameFinished,\n        isPositionReady,\n        hasCurrentPosition: !!trainingState.currentPosition,\n        currentFen,\n      });\n\n      // CRITICAL: Block moves if position is not ready\n      if (!isPositionReady) {\n        logger.warn(\"⛔ Position not ready, blocking move\", {\n          hasCurrentPosition: !!trainingState.currentPosition,\n          currentPositionId: trainingState.currentPosition?.id,\n          currentPositionFen: trainingState.currentPosition?.fen,\n        });\n        return false;\n      }\n\n      // Add these critical debug logs\n      const moveLogger = getLogger().setContext(\"useMoveHandlers-handleMove\");\n      moveLogger.debug(\"handleMove called\", { move });\n      moveLogger.debug(\"Current FEN\", { fen: currentFen });\n\n      if (isGameFinished) {\n        logger.warn(\"handleMove early return\", { isGameFinished });\n        return false;\n      }\n\n      // Check if piece was dropped on same square (no move)\n      if (move.from === move.to) {\n        logger.debug(\"Piece dropped on same square, ignoring\", {\n          square: move.from,\n        });\n        return false;\n      }\n\n      try {\n        // Debug: Log game state before validation\n        logger.debug(\"Game state before move validation\", {\n          hasGame: false, // game is now null, handled by ChessService\n          currentFen: currentFen,\n        });\n\n        // Move validation is handled by ChessService in makeMove\n        // We don't need to validate here anymore\n        logger.debug(\"Move validation delegated to ChessService\", {\n          move,\n          currentFen,\n        });\n\n        // First make the move on the local game instance\n        logger.debug(\"Calling onMove callback\", { move });\n        const result = await onMove(move);\n        logger.debug(\"onMove result\", { result });\n\n        // The orchestrator now handles the entire workflow including:\n        // - Move validation\n        // - Error dialog for suboptimal moves\n        // - Opponent turn (only if move was optimal)\n        // TrainingBoard should NOT call handleOpponentTurn directly\n\n        return result;\n      } catch (error) {\n        const errorMessage =\n          error instanceof Error ? error.message : \"Move failed\";\n        uiActions.showToast(errorMessage, \"error\");\n        return false;\n      }\n    },\n    [\n      isGameFinished,\n      onMove,\n      trainingState,\n      uiActions,\n      currentFen,\n      isPositionReady,\n      trainingState.currentPosition,\n    ],\n  );\n\n  /**\n   * Handles piece drop events from the chessboard\n   *\n   * @param {string} sourceSquare - Square where piece was picked up\n   * @param {string} targetSquare - Square where piece was dropped\n   * @param {string} piece - Piece type (required by interface)\n   * @returns {boolean} Whether the drop was accepted\n   *\n   * @description\n   * Converts drag-and-drop events into move objects and delegates\n   * to the main move handler. Always promotes to queen by default.\n   *\n   * @remarks\n   * This is the primary user interaction handler for the chess board.\n   * Returns false if game is finished to prevent further moves.\n   * The actual move validation happens in handleMove.\n   *\n   * @example\n   * ```typescript\n   * // User drags pawn from e2 to e4\n   * onDrop(\"e2\", \"e4\", \"wP\") // returns true if valid\n   * ```\n   */\n  const onDrop = useCallback(\n    (sourceSquare: string, targetSquare: string, piece: string): boolean => {\n      const logger = getLogger().setContext(\"useMoveHandlers-onDrop\");\n\n      logger.debug(\"🎯 onDrop called\", {\n        sourceSquare,\n        targetSquare,\n        piece,\n        isPositionReady,\n        isGameFinished,\n        hasCurrentPosition: !!trainingState.currentPosition,\n        currentFen,\n      });\n\n      // Block drops if position is not ready or game is finished\n      if (!isPositionReady || isGameFinished) {\n        logger.warn(\"⛔ onDrop blocked\", {\n          isPositionReady,\n          isGameFinished,\n          reason: !isPositionReady ? \"position not ready\" : \"game finished\",\n        });\n        return false;\n      }\n\n      // Check if this is a pawn promotion\n      const isPawn = piece.toLowerCase().endsWith(\"p\");\n      const targetRank = targetSquare[1];\n      const isPromotionRank = targetRank === \"8\" || targetRank === \"1\";\n\n      const move: any = {\n        from: sourceSquare,\n        to: targetSquare,\n      };\n\n      // Add promotion if pawn reaches last rank\n      if (isPawn && isPromotionRank) {\n        move.promotion = \"q\"; // Default to queen promotion\n      }\n\n      logger.debug(\"✅ onDrop calling handleMove\", { move });\n      handleMove(move);\n      return true;\n    },\n    [\n      handleMove,\n      isGameFinished,\n      isPositionReady,\n      trainingState.currentPosition,\n      currentFen,\n    ],\n  );\n\n  /**\n   * Handles square click events for click-to-move functionality\n   * \n   * @param {object} args - Arguments from react-chessboard\n   * @param {any} args.piece - Piece on the clicked square (can be null)\n   * @param {string} args.square - Square that was clicked\n   * @returns {void}\n   * \n   * @description\n   * Implements click-to-move interaction pattern for accessibility and E2E testing:\n   * - First click selects piece (if valid piece on square)\n   * - Second click attempts move to target square\n   * - Click on same square deselects piece\n   */\n  const onSquareClick = useCallback(\n    ({ piece, square }: { piece: any; square: string }): void => {\n      const logger = getLogger().setContext(\"useMoveHandlers-onSquareClick\");\n\n      logger.debug(\"🖱️ onSquareClick called\", {\n        square,\n        selectedSquare,\n        isPositionReady,\n        isGameFinished,\n      });\n\n      // Block clicks if position is not ready or game is finished\n      if (!isPositionReady || isGameFinished) {\n        logger.warn(\"⛔ onSquareClick blocked\", {\n          isPositionReady,\n          isGameFinished,\n          reason: !isPositionReady ? \"position not ready\" : \"game finished\",\n        });\n        return;\n      }\n\n      // If no square is selected, select this square if it has a piece\n      if (!selectedSquare) {\n        if (piece) {\n          // Check if it's the right color's turn\n          try {\n            const chess = new Chess(currentFen);\n            const currentTurn = chess.turn();\n            const pieceColor = piece.pieceType?.[0]; // 'w' or 'b'\n            \n            if (pieceColor === currentTurn) {\n              setSelectedSquare(square);\n              logger.debug(\"✅ Square selected\", { square, piece });\n            } else {\n              logger.debug(\"❌ Wrong color piece\", { square, piece, currentTurn });\n            }\n          } catch (error) {\n            logger.error(\"Failed to validate piece color\", error as Error);\n          }\n        } else {\n          logger.debug(\"❌ No piece on square\", { square });\n        }\n        return;\n      }\n\n      // If same square clicked, deselect\n      if (selectedSquare === square) {\n        setSelectedSquare(null);\n        logger.debug(\"🔄 Square deselected\", { square });\n        return;\n      }\n\n      // Try to make move from selected square to clicked square\n      const result = onDrop(selectedSquare, square, \"\"); // Piece type not needed\n      if (result) {\n        setSelectedSquare(null); // Clear selection after successful move\n        logger.debug(\"✅ Move completed via click\", { from: selectedSquare, to: square });\n      } else {\n        logger.debug(\"❌ Move failed via click\", { from: selectedSquare, to: square });\n      }\n    },\n    [selectedSquare, isPositionReady, isGameFinished, currentFen, onDrop],\n  );\n\n  return {\n    onDrop,\n    onSquareClick,\n    selectedSquare,\n    clearSelection,\n  };\n};"],"names":["useMoveHandlers","currentFen","isGameFinished","isPositionReady","trainingState","onMove","uiActions","useUIStore","selectedSquare","setSelectedSquare","useState","clearSelection","useCallback","handleMove","move","logger","getLogger","setContext","debug","hasCurrentPosition","currentPosition","warn","currentPositionId","id","currentPositionFen","fen","moveLogger","from","to","square","hasGame","result","error","errorMessage","Error","message","showToast","onDrop","sourceSquare","targetSquare","piece","reason","isPawn","toLowerCase","endsWith","targetRank","isPromotionRank","promotion","onSquareClick","chess","Chess","currentTurn","turn","pieceColor","pieceType"],"mappings":"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"}