{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/hooks/useProgressSync.ts"],"sourcesContent":["/**\n * @file useProgressSync - Debounced Firebase sync hook with optimistic updates\n * @description Provides intelligent progress synchronization with offline support and optimistic updates\n * \n * Features:\n * - Debounced sync operations (configurable delay)\n * - Optimistic updates for immediate UI feedback\n * - Background synchronization with error handling\n * - Offline queue with automatic retry on reconnection\n * - Exponential backoff for failed sync operations\n * - Conflict resolution for concurrent updates\n * \n * @example\n * ```typescript\n * function TrainingSession({ userId }: { userId: string }) {\n *   const {\n *     syncUserStats,\n *     syncCardProgress,\n *     syncBatch,\n *     syncStatus,\n *     lastSync,\n *     pendingOperations,\n *     clearQueue\n *   } = useProgressSync(userId);\n * \n *   const handleCorrectAnswer = (positionId: string) => {\n *     // Optimistic update with background sync\n *     syncCardProgress(positionId, updatedCard);\n *   };\n * \n *   const handleSessionComplete = (stats: Partial<UserStats>, cards: CardUpdate[]) => {\n *     // Batch sync for session completion\n *     syncBatch(stats, cards);\n *   };\n * }\n * ```\n */\n\nimport { useCallback, useEffect, useRef, useState, useMemo } from 'react';\nimport { useProgressActions } from '@shared/store/hooks/useProgressStore';\nimport { ProgressService } from '@shared/services/ProgressService';\nimport { getLogger } from '@shared/services/logging/Logger';\nimport type { UserStats, CardProgress } from '@shared/store/slices/types';\nimport type { WithFieldValue } from 'firebase/firestore';\n\nconst logger = getLogger().setContext('useProgressSync');\n\n/**\n * Configuration for sync behavior\n */\nexport interface ProgressSyncConfig {\n  /** Debounce delay in milliseconds (default: 2000ms) */\n  debounceMs?: number;\n  /** Maximum retry attempts for failed syncs (default: 3) */\n  maxRetries?: number;\n  /** Base retry delay in milliseconds (default: 1000ms) */\n  retryDelayMs?: number;\n  /** Maximum batch size for sync operations (default: 50) */\n  maxBatchSize?: number;\n  /** Enable optimistic updates (default: true) */\n  enableOptimistic?: boolean;\n}\n\n/**\n * Sync operation types for queuing\n */\nexport type SyncOperation = \n  | { type: 'userStats'; userId: string; updates: Partial<WithFieldValue<UserStats>> }\n  | { type: 'cardProgress'; userId: string; positionId: string; progress: CardProgress }\n  | { type: 'batch'; userId: string; statsUpdate: Partial<WithFieldValue<UserStats>>; cardUpdates: Array<{ positionId: string; progress: CardProgress }> };\n\n/**\n * Sync status information\n */\nexport interface SyncStatus {\n  /** Current sync state */\n  status: 'idle' | 'syncing' | 'error' | 'offline';\n  /** Last successful sync timestamp */\n  lastSync: number | null;\n  /** Current error message if any */\n  error: string | null;\n  /** Number of pending operations in queue */\n  pendingCount: number;\n  /** Whether sync is currently debounced */\n  isDebounced: boolean;\n}\n\n/**\n * Queue item for managing sync operations\n */\ninterface QueueItem {\n  id: string;\n  operation: SyncOperation;\n  timestamp: number;\n  retries: number;\n  lastAttempt: number | null;\n}\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<ProgressSyncConfig> = {\n  debounceMs: 2000,\n  maxRetries: 3,\n  retryDelayMs: 1000,\n  maxBatchSize: 50,\n  enableOptimistic: true,\n};\n\n/**\n * Hook for debounced Firebase progress synchronization with optimistic updates\n * \n * @param userId - User identifier for sync operations\n * @param progressService - ProgressService instance for Firebase operations\n * @param config - Optional configuration for sync behavior\n * @returns Sync functions and status information\n */\nexport function useProgressSync(\n  userId: string | null,\n  progressService: ProgressService,\n  config: ProgressSyncConfig = {}\n) {\n  const mergedConfig = useMemo(() => ({ ...DEFAULT_CONFIG, ...config }), [config]);\n  const progressActions = useProgressActions();\n  \n  // Sync state\n  const [syncStatus, setSyncStatus] = useState<SyncStatus>({\n    status: 'idle',\n    lastSync: null,\n    error: null,\n    pendingCount: 0,\n    isDebounced: false,\n  });\n  \n  // Operation queue for offline/retry handling\n  const queueRef = useRef<QueueItem[]>([]);\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const syncIdCounterRef = useRef(0);\n  const isProcessingRef = useRef(false);\n  const lastSyncRef = useRef<number | null>(null);\n  \n  // Queue size limit to prevent memory bloat\n  const MAX_QUEUE_SIZE = 100;\n  \n  /**\n   * Generate unique ID for sync operations\n   */\n  const generateSyncId = useCallback(() => {\n    return `sync_${Date.now()}_${++syncIdCounterRef.current}`;\n  }, []);\n  \n  /**\n   * Calculate exponential backoff delay\n   */\n  const calculateRetryDelay = useCallback((retries: number): number => {\n    return mergedConfig.retryDelayMs * Math.pow(2, retries);\n  }, [mergedConfig.retryDelayMs]);\n  \n  /**\n   * Update sync status state\n   */\n  const updateSyncStatus = useCallback((updates: Partial<SyncStatus>) => {\n    setSyncStatus(prev => ({\n      ...prev,\n      ...updates,\n      pendingCount: queueRef.current.length,\n    }));\n  }, []);\n  \n  /**\n   * Add operation to sync queue with overflow protection\n   */\n  const queueOperation = useCallback((operation: SyncOperation): string => {\n    // Check queue size limit\n    if (queueRef.current.length >= MAX_QUEUE_SIZE) {\n      logger.warn('Queue size limit exceeded, dropping oldest operations', {\n        currentSize: queueRef.current.length,\n        maxSize: MAX_QUEUE_SIZE,\n      });\n      // Remove oldest operations (FIFO)\n      queueRef.current = queueRef.current.slice(-MAX_QUEUE_SIZE + 10); // Keep some buffer\n    }\n    \n    const id = generateSyncId();\n    const queueItem: QueueItem = {\n      id,\n      operation,\n      timestamp: Date.now(),\n      retries: 0,\n      lastAttempt: null,\n    };\n    \n    queueRef.current.push(queueItem);\n    updateSyncStatus({ pendingCount: queueRef.current.length });\n    \n    logger.debug('Queued sync operation', { \n      id, \n      type: operation.type, \n      queueLength: queueRef.current.length \n    });\n    \n    return id;\n  }, [generateSyncId, updateSyncStatus]);\n  \n  /**\n   * Remove operation from queue\n   */\n  const dequeueOperation = useCallback((id: string) => {\n    const initialLength = queueRef.current.length;\n    queueRef.current = queueRef.current.filter(item => item.id !== id);\n    \n    if (queueRef.current.length !== initialLength) {\n      updateSyncStatus({ pendingCount: queueRef.current.length });\n      logger.debug('Dequeued sync operation', { id, queueLength: queueRef.current.length });\n    }\n  }, [updateSyncStatus]);\n  \n  /**\n   * Execute single sync operation\n   */\n  const executeSyncOperation = useCallback(async (operation: SyncOperation): Promise<void> => {\n    if (!userId) {\n      throw new Error('User ID required for sync operation');\n    }\n    \n    try {\n      switch (operation.type) {\n        case 'userStats':\n          await progressService.updateUserStats(operation.userId, operation.updates);\n          logger.debug('Synced user stats', { userId: operation.userId });\n          break;\n          \n        case 'cardProgress':\n          await progressService.upsertCardProgress(\n            operation.userId, \n            operation.positionId, \n            operation.progress\n          );\n          logger.debug('Synced card progress', { \n            userId: operation.userId, \n            positionId: operation.positionId \n          });\n          break;\n          \n        case 'batch':\n          await progressService.updateProgressTransaction(\n            operation.userId,\n            operation.statsUpdate,\n            operation.cardUpdates\n          );\n          logger.debug('Synced batch operation', { \n            userId: operation.userId, \n            cardCount: operation.cardUpdates.length \n          });\n          break;\n          \n        default:\n          throw new Error(`Unknown operation type: ${(operation as any).type}`);\n      }\n    } catch (error) {\n      logger.error('Sync operation failed', error as Error, { operation });\n      throw error;\n    }\n  }, [userId, progressService]);\n  \n  /**\n   * Process sync queue with retry logic and concurrency protection\n   */\n  const processQueue = useCallback(async (): Promise<void> => {\n    // Prevent concurrent processing\n    if (isProcessingRef.current) {\n      logger.debug('Queue processing already in progress, skipping');\n      return;\n    }\n    \n    if (queueRef.current.length === 0) {\n      updateSyncStatus({ status: 'idle' });\n      return;\n    }\n    \n    // Don't process if offline (use navigator.onLine as source of truth)\n    if (!navigator.onLine) {\n      logger.debug('Skipping queue processing while offline');\n      return;\n    }\n    \n    isProcessingRef.current = true;\n    updateSyncStatus({ status: 'syncing', error: null });\n    \n    const itemsToProcess = [...queueRef.current];\n    const failedItems: QueueItem[] = [];\n    \n    for (const item of itemsToProcess) {\n      try {\n        await executeSyncOperation(item.operation);\n        dequeueOperation(item.id);\n        \n        // Update progress slice sync status optimistically\n        lastSyncRef.current = Date.now();\n        progressActions.setLastSync(lastSyncRef.current);\n        progressActions.setSyncError(null);\n        \n      } catch (error) {\n        const errorMessage = (error as Error).message;\n        \n        // Update retry information\n        const updatedItem = {\n          ...item,\n          retries: item.retries + 1,\n          lastAttempt: Date.now(),\n        };\n        \n        if (updatedItem.retries < mergedConfig.maxRetries) {\n          // Schedule retry with exponential backoff\n          const retryDelay = calculateRetryDelay(updatedItem.retries);\n          \n          setTimeout(() => {\n            // Update item in queue for retry\n            const queueIndex = queueRef.current.findIndex(qi => qi.id === item.id);\n            if (queueIndex !== -1) {\n              queueRef.current[queueIndex] = updatedItem;\n              \n              logger.debug('Scheduled retry for sync operation', {\n                id: item.id,\n                retryAttempt: updatedItem.retries,\n                retryDelay,\n              });\n              \n              // Trigger processing for retry\n              debouncedProcessQueue();\n            }\n          }, retryDelay);\n          \n          failedItems.push(updatedItem);\n        } else {\n          // Max retries exceeded, remove from queue and log error\n          dequeueOperation(item.id);\n          progressActions.setSyncError(errorMessage);\n          \n          logger.error('Sync operation failed permanently after max retries', {\n            id: item.id,\n            retries: updatedItem.retries,\n            error: errorMessage,\n          });\n        }\n      }\n    }\n    \n    // Update queue with failed items for retry\n    queueRef.current = failedItems;\n    \n    const finalStatus = failedItems.length > 0 ? 'error' : 'idle';\n    updateSyncStatus({ \n      status: finalStatus,\n      lastSync: failedItems.length === 0 ? lastSyncRef.current : lastSyncRef.current,\n    });\n    \n    // Always release processing lock\n    isProcessingRef.current = false;\n  }, [\n    updateSyncStatus,\n    executeSyncOperation,\n    dequeueOperation,\n    progressActions,\n    mergedConfig.maxRetries,\n    calculateRetryDelay,\n  ]);\n  \n  /**\n   * Debounced queue processing\n   */\n  const debouncedProcessQueue = useCallback(() => {\n    if (debounceTimeoutRef.current) {\n      clearTimeout(debounceTimeoutRef.current);\n    }\n    \n    updateSyncStatus({ isDebounced: true });\n    \n    debounceTimeoutRef.current = setTimeout(() => {\n      updateSyncStatus({ isDebounced: false });\n      processQueue();\n    }, mergedConfig.debounceMs);\n  }, [processQueue, mergedConfig.debounceMs, updateSyncStatus]);\n  \n  /**\n   * Sync user statistics with optimistic updates\n   */\n  const syncUserStats = useCallback((updates: Partial<WithFieldValue<UserStats>>) => {\n    if (!userId) {\n      logger.warn('Cannot sync user stats without userId');\n      return;\n    }\n    \n    // Optimistic update\n    if (mergedConfig.enableOptimistic) {\n      progressActions.batchUpdateProgress({ userStats: updates as Partial<UserStats> });\n    }\n    \n    // Queue for background sync\n    queueOperation({\n      type: 'userStats',\n      userId,\n      updates,\n    });\n    \n    debouncedProcessQueue();\n  }, [userId, mergedConfig.enableOptimistic, progressActions, queueOperation, debouncedProcessQueue]);\n  \n  /**\n   * Sync card progress with optimistic updates\n   */\n  const syncCardProgress = useCallback((positionId: string, progress: CardProgress) => {\n    if (!userId) {\n      logger.warn('Cannot sync card progress without userId');\n      return;\n    }\n    \n    // Optimistic update\n    if (mergedConfig.enableOptimistic) {\n      progressActions.setCardProgress(positionId, progress);\n    }\n    \n    // Queue for background sync\n    queueOperation({\n      type: 'cardProgress',\n      userId,\n      positionId,\n      progress,\n    });\n    \n    debouncedProcessQueue();\n  }, [userId, mergedConfig.enableOptimistic, progressActions, queueOperation, debouncedProcessQueue]);\n  \n  /**\n   * Sync batch operation (stats + multiple cards) with optimistic updates\n   */\n  const syncBatch = useCallback((\n    statsUpdate: Partial<WithFieldValue<UserStats>>,\n    cardUpdates: Array<{ positionId: string; progress: CardProgress }>\n  ) => {\n    if (!userId) {\n      logger.warn('Cannot sync batch without userId');\n      return;\n    }\n    \n    if (cardUpdates.length > mergedConfig.maxBatchSize) {\n      logger.warn('Batch size exceeds maximum, splitting', {\n        requested: cardUpdates.length,\n        maximum: mergedConfig.maxBatchSize,\n      });\n      \n      // Split into chunks and sync iteratively (not recursively to avoid stack issues)\n      const chunks: Array<{ positionId: string; progress: CardProgress }[]> = [];\n      for (let i = 0; i < cardUpdates.length; i += mergedConfig.maxBatchSize) {\n        chunks.push(cardUpdates.slice(i, i + mergedConfig.maxBatchSize));\n      }\n      \n      // Process chunks\n      chunks.forEach((chunk, index) => {\n        // Only include stats update with the first chunk\n        const chunkStatsUpdate = index === 0 ? statsUpdate : {};\n        \n        // Queue each chunk separately\n        queueOperation({\n          type: 'batch',\n          userId,\n          statsUpdate: chunkStatsUpdate,\n          cardUpdates: chunk,\n        });\n      });\n      \n      debouncedProcessQueue();\n      return;\n    }\n    \n    // Optimistic updates\n    if (mergedConfig.enableOptimistic) {\n      // Update user stats\n      if (Object.keys(statsUpdate).length > 0) {\n        progressActions.batchUpdateProgress({ userStats: statsUpdate as Partial<UserStats> });\n      }\n      \n      // Update card progresses\n      const cardProgressMap: Record<string, CardProgress> = {};\n      cardUpdates.forEach(({ positionId, progress }) => {\n        cardProgressMap[positionId] = progress;\n      });\n      \n      if (Object.keys(cardProgressMap).length > 0) {\n        progressActions.batchUpdateProgress({ cardProgress: cardProgressMap });\n      }\n    }\n    \n    // Queue for background sync\n    queueOperation({\n      type: 'batch',\n      userId,\n      statsUpdate,\n      cardUpdates,\n    });\n    \n    debouncedProcessQueue();\n  }, [userId, mergedConfig.enableOptimistic, mergedConfig.maxBatchSize, progressActions, queueOperation, debouncedProcessQueue]);\n  \n  /**\n   * Force immediate sync without debounce\n   */\n  const forceSync = useCallback(async (): Promise<void> => {\n    if (debounceTimeoutRef.current) {\n      clearTimeout(debounceTimeoutRef.current);\n      debounceTimeoutRef.current = null;\n    }\n    \n    updateSyncStatus({ isDebounced: false });\n    \n    try {\n      await processQueue();\n    } catch (error) {\n      logger.error('Force sync failed', error as Error);\n      updateSyncStatus({ status: 'error', error: (error as Error).message });\n    }\n  }, [processQueue, updateSyncStatus]);\n  \n  /**\n   * Clear all pending operations\n   */\n  const clearQueue = useCallback(() => {\n    queueRef.current = [];\n    updateSyncStatus({ \n      pendingCount: 0, \n      status: 'idle',\n      error: null \n    });\n    \n    if (debounceTimeoutRef.current) {\n      clearTimeout(debounceTimeoutRef.current);\n      debounceTimeoutRef.current = null;\n    }\n    \n    logger.info('Cleared sync queue');\n  }, [updateSyncStatus]);\n  \n  /**\n   * Get current pending operations (for debugging)\n   */\n  const getPendingOperations = useCallback(() => {\n    return queueRef.current.map(item => ({\n      id: item.id,\n      type: item.operation.type,\n      timestamp: item.timestamp,\n      retries: item.retries,\n      lastAttempt: item.lastAttempt,\n    }));\n  }, []);\n  \n  // Initialize queue from localStorage on mount\n  useEffect(() => {\n    if (!userId) return;\n    \n    try {\n      const savedQueue = localStorage.getItem(`syncQueue-${userId}`);\n      if (savedQueue) {\n        queueRef.current = JSON.parse(savedQueue);\n        updateSyncStatus({ pendingCount: queueRef.current.length });\n        logger.debug('Restored sync queue from localStorage', { \n          userId, \n          queueLength: queueRef.current.length \n        });\n      }\n    } catch (error) {\n      logger.warn('Failed to restore sync queue from localStorage', { \n        userId, \n        error: (error as Error).message \n      });\n    }\n  }, [userId, updateSyncStatus]);\n  \n  // Save queue to localStorage on changes\n  useEffect(() => {\n    if (!userId) return;\n    \n    try {\n      localStorage.setItem(`syncQueue-${userId}`, JSON.stringify(queueRef.current));\n    } catch (error) {\n      logger.warn('Failed to save sync queue to localStorage', { \n        userId, \n        error: (error as Error).message \n      });\n    }\n  }, [userId, syncStatus.pendingCount]);\n  \n  // Auto-retry when coming back online\n  useEffect(() => {\n    const handleOnline = () => {\n      logger.info('Network connection restored, processing pending queue');\n      updateSyncStatus({ status: 'idle' });\n      debouncedProcessQueue();\n    };\n    \n    const handleOffline = () => {\n      logger.info('Network connection lost');\n      updateSyncStatus({ status: 'offline' });\n    };\n    \n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n    \n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [debouncedProcessQueue, updateSyncStatus]);\n  \n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (debounceTimeoutRef.current) {\n        clearTimeout(debounceTimeoutRef.current);\n      }\n    };\n  }, []);\n  \n  return {\n    // Sync functions\n    syncUserStats,\n    syncCardProgress,\n    syncBatch,\n    forceSync,\n    clearQueue,\n    \n    // Status information\n    syncStatus,\n    lastSync: syncStatus.lastSync,\n    pendingOperations: getPendingOperations(),\n    \n    // Configuration\n    config: mergedConfig,\n  };\n}\n\n/**\n * Lightweight version of useProgressSync for components that only need status\n */\nexport function useProgressSyncStatus() {\n  const [syncStatus] = useState<Pick<SyncStatus, 'status' | 'lastSync' | 'error'>>({\n    status: 'idle',\n    lastSync: null,\n    error: null,\n  });\n  \n  // This would typically connect to the progress slice's sync status\n  // For now, return basic status\n  return syncStatus;\n}"],"names":["useProgressSync","useProgressSyncStatus","logger","getLogger","setContext","DEFAULT_CONFIG","debounceMs","maxRetries","retryDelayMs","maxBatchSize","enableOptimistic","userId","progressService","config","mergedConfig","useMemo","progressActions","useProgressActions","syncStatus","setSyncStatus","useState","status","lastSync","error","pendingCount","isDebounced","queueRef","useRef","debounceTimeoutRef","syncIdCounterRef","isProcessingRef","lastSyncRef","MAX_QUEUE_SIZE","generateSyncId","useCallback","Date","now","current","calculateRetryDelay","retries","Math","pow","updateSyncStatus","updates","prev","length","queueOperation","operation","warn","currentSize","maxSize","slice","id","queueItem","timestamp","lastAttempt","push","debug","type","queueLength","dequeueOperation","initialLength","filter","item","executeSyncOperation","Error","updateUserStats","upsertCardProgress","positionId","progress","updateProgressTransaction","statsUpdate","cardUpdates","cardCount","processQueue","navigator","onLine","itemsToProcess","failedItems","setLastSync","setSyncError","errorMessage","message","updatedItem","retryDelay","setTimeout","queueIndex","findIndex","qi","retryAttempt","debouncedProcessQueue","finalStatus","clearTimeout","syncUserStats","batchUpdateProgress","userStats","syncCardProgress","setCardProgress","syncBatch","requested","maximum","chunks","i","forEach","chunk","index","chunkStatsUpdate","Object","keys","cardProgressMap","cardProgress","forceSync","clearQueue","info","getPendingOperations","map","useEffect","savedQueue","localStorage","getItem","JSON","parse","setItem","stringify","handleOnline","handleOffline","window","addEventListener","removeEventListener","pendingOperations"],"mappings":"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"}