f72c3bb5a948acf96c36172a7be8a409
/**
 * @file Tests for useDialogHandlers hook
 * @module tests/unit/hooks/useDialogHandlers
 * 
 * @description
 * Comprehensive tests for the useDialogHandlers hook that encapsulates
 * all dialog handling logic for chess training interactions.
 * 
 * Tests cover:
 * - Move error dialog actions (take back, restart, continue, show best move)
 * - Move success dialog actions (close, continue)
 * - Training session reset coordination
 * - Opponent turn scheduling and cancellation
 * - Complex state management and service coordination
 */ "use strict";
// Mock dependencies
jest.mock('@shared/services/logging/Logger', ()=>({
        getLogger: jest.fn(()=>({
                setContext: jest.fn(()=>({
                        debug: jest.fn(),
                        info: jest.fn(),
                        warn: jest.fn(),
                        error: jest.fn()
                    })),
                debug: jest.fn(),
                info: jest.fn(),
                warn: jest.fn(),
                error: jest.fn()
            }))
    }));
jest.mock('@shared/services/ChessService', ()=>({
        chessService: {
            getFen: jest.fn(),
            turn: jest.fn()
        }
    }));
jest.mock('@shared/services/TablebaseService', ()=>({
        tablebaseService: {
            getEvaluation: jest.fn()
        }
    }));
jest.mock('@shared/store/orchestrators/handlePlayerMove', ()=>({
        cancelScheduledOpponentTurn: jest.fn(),
        scheduleOpponentTurn: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useDialogHandlers = require("../../../shared/hooks/useDialogHandlers");
const _ChessService = require("../../../shared/services/ChessService");
const _TablebaseService = require("../../../shared/services/TablebaseService");
const _handlePlayerMove = require("../../../shared/store/orchestrators/handlePlayerMove");
describe('useDialogHandlers', ()=>{
    const mockTrainingActions = {
        setPlayerTurn: jest.fn(),
        clearOpponentThinking: jest.fn(),
        setMoveErrorDialog: jest.fn(),
        setMoveSuccessDialog: jest.fn(),
        setEvaluationBaseline: jest.fn(),
        clearEvaluationBaseline: jest.fn()
    };
    const mockGameActions = {
        resetGame: jest.fn()
    };
    const mockUIActions = {
        showToast: jest.fn()
    };
    const mockTrainingState = {
        isPlayerTurn: true,
        isOpponentThinking: false,
        currentPosition: {
            id: 1,
            colorToTrain: 'white'
        },
        moveErrorDialog: {
            bestMove: 'Kh1'
        }
    };
    const mockStoreApi = {
        getState: jest.fn(()=>({
                training: mockTrainingState,
                game: {
                    moveHistory: [
                        'e4',
                        'e5'
                    ]
                }
            })),
        setState: jest.fn()
    };
    const mockTrainingUIState = {
        handleReset: jest.fn()
    };
    const defaultProps = {
        undoMove: jest.fn(),
        resetGame: jest.fn(),
        clearEvaluations: jest.fn(),
        trainingActions: mockTrainingActions,
        gameActions: mockGameActions,
        uiActions: mockUIActions,
        trainingState: mockTrainingState,
        storeApi: mockStoreApi,
        trainingUIState: mockTrainingUIState
    };
    beforeEach(()=>{
        jest.clearAllMocks();
        // Reset mocked services
        _ChessService.chessService.getFen.mockReturnValue('8/8/8/8/8/8/8/8 w - - 0 1');
        _ChessService.chessService.turn.mockReturnValue('w');
        _TablebaseService.tablebaseService.getEvaluation.mockResolvedValue({
            isAvailable: true,
            result: {
                wdl: 1
            }
        });
    });
    describe('Hook Initialization', ()=>{
        it('returns all required handler functions', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            expect(result.current).toHaveProperty('handleMoveErrorTakeBack');
            expect(result.current).toHaveProperty('handleMoveErrorRestart');
            expect(result.current).toHaveProperty('handleMoveErrorContinue');
            expect(result.current).toHaveProperty('handleShowBestMove');
            expect(result.current).toHaveProperty('handleMoveSuccessClose');
            expect(result.current).toHaveProperty('handleMoveSuccessContinue');
            expect(result.current).toHaveProperty('handleReset');
            // All should be functions
            Object.values(result.current).forEach((handler)=>{
                expect(typeof handler).toBe('function');
            });
        });
    });
    describe('handleReset', ()=>{
        it('calls all reset functions in correct order', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleReset();
            });
            expect(defaultProps.resetGame).toHaveBeenCalledTimes(1);
            expect(defaultProps.clearEvaluations).toHaveBeenCalledTimes(1);
            expect(mockTrainingUIState.handleReset).toHaveBeenCalledTimes(1);
            expect(mockGameActions.resetGame).toHaveBeenCalledTimes(1);
            expect(mockTrainingActions.clearEvaluationBaseline).toHaveBeenCalledTimes(1);
        });
    });
    describe('handleMoveErrorTakeBack', ()=>{
        it('cancels scheduled opponent turn before undoing move', ()=>{
            const mockUndoMove = jest.fn().mockReturnValue(true);
            const props = {
                ...defaultProps,
                undoMove: mockUndoMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            expect(_handlePlayerMove.cancelScheduledOpponentTurn).toHaveBeenCalledTimes(1);
            expect(mockUndoMove).toHaveBeenCalledTimes(1);
        });
        it('sets player turn and clears opponent thinking after successful undo', ()=>{
            const mockUndoMove = jest.fn().mockReturnValue(true);
            const props = {
                ...defaultProps,
                undoMove: mockUndoMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            expect(mockTrainingActions.setPlayerTurn).toHaveBeenCalledWith(true);
            expect(mockTrainingActions.clearOpponentThinking).toHaveBeenCalledTimes(1);
            expect(mockTrainingActions.clearEvaluationBaseline).toHaveBeenCalledTimes(1);
        });
        it('closes move error dialog after successful undo', ()=>{
            const mockUndoMove = jest.fn().mockReturnValue(true);
            const props = {
                ...defaultProps,
                undoMove: mockUndoMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
        it('handles failed undo gracefully', ()=>{
            const mockUndoMove = jest.fn().mockReturnValue(false);
            const props = {
                ...defaultProps,
                undoMove: mockUndoMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            // Should still attempt to close dialog even if undo fails
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
        it('handles missing setMoveErrorDialog action gracefully', ()=>{
            const actionsWithoutDialog = {
                ...mockTrainingActions,
                setMoveErrorDialog: undefined
            };
            const props = {
                ...defaultProps,
                trainingActions: actionsWithoutDialog
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            // Should not throw
            expect(()=>{
                (0, _react.act)(()=>{
                    result.current.handleMoveErrorTakeBack();
                });
            }).not.toThrow();
        });
    });
    describe('handleMoveErrorRestart', ()=>{
        it('calls handleReset and closes error dialog', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorRestart();
            });
            expect(defaultProps.resetGame).toHaveBeenCalledTimes(1);
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
    });
    describe('handleMoveErrorContinue', ()=>{
        it('gets current state and fixes turn state when needed', ()=>{
            const stateWithBlackTurn = {
                training: {
                    ...mockTrainingState,
                    isPlayerTurn: true,
                    currentPosition: {
                        colorToTrain: 'white'
                    }
                },
                game: {
                    moveHistory: []
                }
            };
            const mockStoreApiWithBlackTurn = {
                ...mockStoreApi,
                getState: jest.fn(()=>stateWithBlackTurn)
            };
            // Mock chess service to return black's turn
            _ChessService.chessService.turn.mockReturnValue('b');
            const props = {
                ...defaultProps,
                storeApi: mockStoreApiWithBlackTurn
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            expect(mockTrainingActions.setPlayerTurn).toHaveBeenCalledWith(false);
        });
        it('closes error dialog and schedules opponent turn', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
            expect(_handlePlayerMove.scheduleOpponentTurn).toHaveBeenCalledWith(mockStoreApi, 500, expect.objectContaining({
                onOpponentMoveComplete: expect.any(Function)
            }));
        });
        it('schedules opponent turn with evaluation baseline callback', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            // Get the callback passed to scheduleOpponentTurn
            const scheduleCall = _handlePlayerMove.scheduleOpponentTurn.mock.calls[0];
            const callback = scheduleCall[2].onOpponentMoveComplete;
            // Execute the callback
            await (0, _react.act)(async ()=>{
                await callback();
            });
            expect(_TablebaseService.tablebaseService.getEvaluation).toHaveBeenCalled();
            expect(mockTrainingActions.setEvaluationBaseline).toHaveBeenCalledWith(1, '8/8/8/8/8/8/8/8 w - - 0 1');
        });
        it('handles tablebase unavailable gracefully in callback', async ()=>{
            _TablebaseService.tablebaseService.getEvaluation.mockResolvedValue({
                isAvailable: false
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            const scheduleCall = _handlePlayerMove.scheduleOpponentTurn.mock.calls[0];
            const callback = scheduleCall[2].onOpponentMoveComplete;
            // Should not throw
            await (0, _react.act)(async ()=>{
                await callback();
            });
            expect(mockTrainingActions.setEvaluationBaseline).not.toHaveBeenCalled();
        });
        it('handles tablebase error gracefully in callback', async ()=>{
            _TablebaseService.tablebaseService.getEvaluation.mockRejectedValue(new Error('API Error'));
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            const scheduleCall = _handlePlayerMove.scheduleOpponentTurn.mock.calls[0];
            const callback = scheduleCall[2].onOpponentMoveComplete;
            // Should not throw
            await (0, _react.act)(async ()=>{
                await callback();
            });
            expect(mockTrainingActions.setEvaluationBaseline).not.toHaveBeenCalled();
        });
    });
    describe('handleShowBestMove', ()=>{
        it('shows toast with best move and closes dialog', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleShowBestMove();
            });
            expect(mockUIActions.showToast).toHaveBeenCalledWith('Der beste Zug war: Kh1', 'info');
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
        it('handles missing best move gracefully', ()=>{
            const stateWithoutBestMove = {
                ...mockTrainingState,
                moveErrorDialog: null
            };
            const props = {
                ...defaultProps,
                trainingState: stateWithoutBestMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            (0, _react.act)(()=>{
                result.current.handleShowBestMove();
            });
            expect(mockUIActions.showToast).not.toHaveBeenCalled();
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
        it('handles missing moveErrorDialog gracefully', ()=>{
            const stateWithoutDialog = {
                ...mockTrainingState,
                moveErrorDialog: undefined
            };
            const props = {
                ...defaultProps,
                trainingState: stateWithoutDialog
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            // Should not throw
            expect(()=>{
                (0, _react.act)(()=>{
                    result.current.handleShowBestMove();
                });
            }).not.toThrow();
        });
    });
    describe('handleMoveSuccessClose', ()=>{
        it('closes move success dialog', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveSuccessClose();
            });
            expect(mockTrainingActions.setMoveSuccessDialog).toHaveBeenCalledWith(null);
        });
    });
    describe('handleMoveSuccessContinue', ()=>{
        it('closes move success dialog', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            (0, _react.act)(()=>{
                result.current.handleMoveSuccessContinue();
            });
            expect(mockTrainingActions.setMoveSuccessDialog).toHaveBeenCalledWith(null);
        });
    });
    describe('State and Action Dependencies', ()=>{
        it('reacts to trainingState changes', ()=>{
            const { result, rerender } = (0, _react.renderHook)((props)=>(0, _useDialogHandlers.useDialogHandlers)(props), {
                initialProps: defaultProps
            });
            const newTrainingState = {
                ...mockTrainingState,
                moveErrorDialog: {
                    bestMove: 'Qh8+'
                }
            };
            const newProps = {
                ...defaultProps,
                trainingState: newTrainingState
            };
            rerender(newProps);
            (0, _react.act)(()=>{
                result.current.handleShowBestMove();
            });
            expect(mockUIActions.showToast).toHaveBeenCalledWith('Der beste Zug war: Qh8+', 'info');
        });
        it('maintains stable function references between renders', ()=>{
            const { result, rerender } = (0, _react.renderHook)((props)=>(0, _useDialogHandlers.useDialogHandlers)(props), {
                initialProps: defaultProps
            });
            const initialHandlers = {
                ...result.current
            };
            rerender(defaultProps);
            // Functions should be stable due to useCallback
            Object.entries(result.current).forEach(([key, handler])=>{
                expect(handler).toBe(initialHandlers[key]);
            });
        });
        it('updates when dependencies change', ()=>{
            const { result, rerender } = (0, _react.renderHook)((props)=>(0, _useDialogHandlers.useDialogHandlers)(props), {
                initialProps: defaultProps
            });
            const newUndoMove = jest.fn().mockReturnValue(true);
            const newProps = {
                ...defaultProps,
                undoMove: newUndoMove
            };
            rerender(newProps);
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            expect(newUndoMove).toHaveBeenCalledTimes(1);
            expect(defaultProps.undoMove).not.toHaveBeenCalled();
        });
    });
    describe('Error Handling', ()=>{
        it('handles missing trainingActions gracefully', ()=>{
            const propsWithoutActions = {
                ...defaultProps,
                trainingActions: {}
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(propsWithoutActions));
            // Should not throw when calling handlers
            expect(()=>{
                (0, _react.act)(()=>{
                    result.current.handleMoveSuccessClose();
                });
            }).not.toThrow();
        });
        it('handles storeApi errors gracefully', ()=>{
            const mockStoreApiWithError = {
                ...mockStoreApi,
                getState: jest.fn(()=>{
                    throw new Error('Store error');
                })
            };
            const props = {
                ...defaultProps,
                storeApi: mockStoreApiWithError
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            // Should not crash on store errors
            expect(()=>{
                (0, _react.act)(()=>{
                    result.current.handleMoveErrorContinue();
                });
            }).not.toThrow();
        });
        it('handles chessService errors gracefully', ()=>{
            _ChessService.chessService.getFen.mockImplementation(()=>{
                throw new Error('Chess service error');
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            // Should not crash
            expect(()=>{
                (0, _react.act)(()=>{
                    result.current.handleMoveErrorContinue();
                });
            }).not.toThrow();
        });
    });
    describe('Complex Integration Scenarios', ()=>{
        it('handles complete error dialog workflow', ()=>{
            const mockUndoMove = jest.fn().mockReturnValue(true);
            const props = {
                ...defaultProps,
                undoMove: mockUndoMove
            };
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(props));
            // User clicks "Take Back"
            (0, _react.act)(()=>{
                result.current.handleMoveErrorTakeBack();
            });
            // Verify complete workflow
            expect(_handlePlayerMove.cancelScheduledOpponentTurn).toHaveBeenCalled();
            expect(mockUndoMove).toHaveBeenCalled();
            expect(mockTrainingActions.setPlayerTurn).toHaveBeenCalledWith(true);
            expect(mockTrainingActions.clearOpponentThinking).toHaveBeenCalled();
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
        });
        it('handles complete continue workflow with opponent turn', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useDialogHandlers.useDialogHandlers)(defaultProps));
            // User clicks "Continue Playing"
            (0, _react.act)(()=>{
                result.current.handleMoveErrorContinue();
            });
            expect(mockTrainingActions.setMoveErrorDialog).toHaveBeenCalledWith(null);
            expect(_handlePlayerMove.scheduleOpponentTurn).toHaveBeenCalled();
            // Simulate opponent move completion
            const callback = _handlePlayerMove.scheduleOpponentTurn.mock.calls[0][2].onOpponentMoveComplete;
            await (0, _react.act)(async ()=>{
                await callback();
            });
            expect(mockTrainingActions.setEvaluationBaseline).toHaveBeenCalled();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VEaWFsb2dIYW5kbGVycy50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgVGVzdHMgZm9yIHVzZURpYWxvZ0hhbmRsZXJzIGhvb2tcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9ob29rcy91c2VEaWFsb2dIYW5kbGVyc1xuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbXByZWhlbnNpdmUgdGVzdHMgZm9yIHRoZSB1c2VEaWFsb2dIYW5kbGVycyBob29rIHRoYXQgZW5jYXBzdWxhdGVzXG4gKiBhbGwgZGlhbG9nIGhhbmRsaW5nIGxvZ2ljIGZvciBjaGVzcyB0cmFpbmluZyBpbnRlcmFjdGlvbnMuXG4gKiBcbiAqIFRlc3RzIGNvdmVyOlxuICogLSBNb3ZlIGVycm9yIGRpYWxvZyBhY3Rpb25zICh0YWtlIGJhY2ssIHJlc3RhcnQsIGNvbnRpbnVlLCBzaG93IGJlc3QgbW92ZSlcbiAqIC0gTW92ZSBzdWNjZXNzIGRpYWxvZyBhY3Rpb25zIChjbG9zZSwgY29udGludWUpXG4gKiAtIFRyYWluaW5nIHNlc3Npb24gcmVzZXQgY29vcmRpbmF0aW9uXG4gKiAtIE9wcG9uZW50IHR1cm4gc2NoZWR1bGluZyBhbmQgY2FuY2VsbGF0aW9uXG4gKiAtIENvbXBsZXggc3RhdGUgbWFuYWdlbWVudCBhbmQgc2VydmljZSBjb29yZGluYXRpb25cbiAqL1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QgfSBmcm9tICdAdGVzdGluZy1saWJyYXJ5L3JlYWN0JztcbmltcG9ydCB7IHVzZURpYWxvZ0hhbmRsZXJzIH0gZnJvbSAnQHNoYXJlZC9ob29rcy91c2VEaWFsb2dIYW5kbGVycyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyJztcbmltcG9ydCB7IGNoZXNzU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvQ2hlc3NTZXJ2aWNlJztcbmltcG9ydCB7IHRhYmxlYmFzZVNlcnZpY2UgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL1RhYmxlYmFzZVNlcnZpY2UnO1xuaW1wb3J0IHtcbiAgY2FuY2VsU2NoZWR1bGVkT3Bwb25lbnRUdXJuLFxuICBzY2hlZHVsZU9wcG9uZW50VHVybixcbn0gZnJvbSAnQHNoYXJlZC9zdG9yZS9vcmNoZXN0cmF0b3JzL2hhbmRsZVBsYXllck1vdmUnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyJywgKCkgPT4gKHtcbiAgZ2V0TG9nZ2VyOiBqZXN0LmZuKCgpID0+ICh7XG4gICAgc2V0Q29udGV4dDogamVzdC5mbigoKSA9PiAoe1xuICAgICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICAgIGluZm86IGplc3QuZm4oKSxcbiAgICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICAgIGVycm9yOiBqZXN0LmZuKCksXG4gICAgfSkpLFxuICAgIGRlYnVnOiBqZXN0LmZuKCksXG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICB9KSksXG59KSk7XG5cbmplc3QubW9jaygnQHNoYXJlZC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2UnLCAoKSA9PiAoe1xuICBjaGVzc1NlcnZpY2U6IHtcbiAgICBnZXRGZW46IGplc3QuZm4oKSxcbiAgICB0dXJuOiBqZXN0LmZuKCksXG4gIH0sXG59KSk7XG5cbmplc3QubW9jaygnQHNoYXJlZC9zZXJ2aWNlcy9UYWJsZWJhc2VTZXJ2aWNlJywgKCkgPT4gKHtcbiAgdGFibGViYXNlU2VydmljZToge1xuICAgIGdldEV2YWx1YXRpb246IGplc3QuZm4oKSxcbiAgfSxcbn0pKTtcblxuamVzdC5tb2NrKCdAc2hhcmVkL3N0b3JlL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZScsICgpID0+ICh7XG4gIGNhbmNlbFNjaGVkdWxlZE9wcG9uZW50VHVybjogamVzdC5mbigpLFxuICBzY2hlZHVsZU9wcG9uZW50VHVybjogamVzdC5mbigpLFxufSkpO1xuXG5kZXNjcmliZSgndXNlRGlhbG9nSGFuZGxlcnMnLCAoKSA9PiB7XG4gIGNvbnN0IG1vY2tUcmFpbmluZ0FjdGlvbnMgPSB7XG4gICAgc2V0UGxheWVyVHVybjogamVzdC5mbigpLFxuICAgIGNsZWFyT3Bwb25lbnRUaGlua2luZzogamVzdC5mbigpLFxuICAgIHNldE1vdmVFcnJvckRpYWxvZzogamVzdC5mbigpLFxuICAgIHNldE1vdmVTdWNjZXNzRGlhbG9nOiBqZXN0LmZuKCksXG4gICAgc2V0RXZhbHVhdGlvbkJhc2VsaW5lOiBqZXN0LmZuKCksXG4gICAgY2xlYXJFdmFsdWF0aW9uQmFzZWxpbmU6IGplc3QuZm4oKSxcbiAgfTtcblxuICBjb25zdCBtb2NrR2FtZUFjdGlvbnMgPSB7XG4gICAgcmVzZXRHYW1lOiBqZXN0LmZuKCksXG4gIH07XG5cbiAgY29uc3QgbW9ja1VJQWN0aW9ucyA9IHtcbiAgICBzaG93VG9hc3Q6IGplc3QuZm4oKSxcbiAgfTtcblxuICBjb25zdCBtb2NrVHJhaW5pbmdTdGF0ZSA9IHtcbiAgICBpc1BsYXllclR1cm46IHRydWUsXG4gICAgaXNPcHBvbmVudFRoaW5raW5nOiBmYWxzZSxcbiAgICBjdXJyZW50UG9zaXRpb246IHtcbiAgICAgIGlkOiAxLFxuICAgICAgY29sb3JUb1RyYWluOiAnd2hpdGUnLFxuICAgIH0sXG4gICAgbW92ZUVycm9yRGlhbG9nOiB7XG4gICAgICBiZXN0TW92ZTogJ0toMScsXG4gICAgfSxcbiAgfTtcblxuICBjb25zdCBtb2NrU3RvcmVBcGkgPSB7XG4gICAgZ2V0U3RhdGU6IGplc3QuZm4oKCkgPT4gKHtcbiAgICAgIHRyYWluaW5nOiBtb2NrVHJhaW5pbmdTdGF0ZSxcbiAgICAgIGdhbWU6IHtcbiAgICAgICAgbW92ZUhpc3Rvcnk6IFsnZTQnLCAnZTUnXSxcbiAgICAgIH0sXG4gICAgfSkpLFxuICAgIHNldFN0YXRlOiBqZXN0LmZuKCksXG4gIH07XG5cbiAgY29uc3QgbW9ja1RyYWluaW5nVUlTdGF0ZSA9IHtcbiAgICBoYW5kbGVSZXNldDogamVzdC5mbigpLFxuICB9O1xuXG4gIGNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICB1bmRvTW92ZTogamVzdC5mbigpLFxuICAgIHJlc2V0R2FtZTogamVzdC5mbigpLFxuICAgIGNsZWFyRXZhbHVhdGlvbnM6IGplc3QuZm4oKSxcbiAgICB0cmFpbmluZ0FjdGlvbnM6IG1vY2tUcmFpbmluZ0FjdGlvbnMsXG4gICAgZ2FtZUFjdGlvbnM6IG1vY2tHYW1lQWN0aW9ucyxcbiAgICB1aUFjdGlvbnM6IG1vY2tVSUFjdGlvbnMsXG4gICAgdHJhaW5pbmdTdGF0ZTogbW9ja1RyYWluaW5nU3RhdGUsXG4gICAgc3RvcmVBcGk6IG1vY2tTdG9yZUFwaSxcbiAgICB0cmFpbmluZ1VJU3RhdGU6IG1vY2tUcmFpbmluZ1VJU3RhdGUsXG4gIH07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgXG4gICAgLy8gUmVzZXQgbW9ja2VkIHNlcnZpY2VzXG4gICAgKGNoZXNzU2VydmljZS5nZXRGZW4gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnKTtcbiAgICAoY2hlc3NTZXJ2aWNlLnR1cm4gYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ3cnKTtcbiAgICAodGFibGViYXNlU2VydmljZS5nZXRFdmFsdWF0aW9uIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgaXNBdmFpbGFibGU6IHRydWUsXG4gICAgICByZXN1bHQ6IHsgd2RsOiAxIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdIb29rIEluaXRpYWxpemF0aW9uJywgKCkgPT4ge1xuICAgIGl0KCdyZXR1cm5zIGFsbCByZXF1aXJlZCBoYW5kbGVyIGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQpLnRvSGF2ZVByb3BlcnR5KCdoYW5kbGVNb3ZlRXJyb3JUYWtlQmFjaycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnaGFuZGxlTW92ZUVycm9yUmVzdGFydCcpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnaGFuZGxlTW92ZUVycm9yQ29udGludWUnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ2hhbmRsZVNob3dCZXN0TW92ZScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnaGFuZGxlTW92ZVN1Y2Nlc3NDbG9zZScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnaGFuZGxlTW92ZVN1Y2Nlc3NDb250aW51ZScpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnaGFuZGxlUmVzZXQnKTtcblxuICAgICAgLy8gQWxsIHNob3VsZCBiZSBmdW5jdGlvbnNcbiAgICAgIE9iamVjdC52YWx1ZXMocmVzdWx0LmN1cnJlbnQpLmZvckVhY2goaGFuZGxlciA9PiB7XG4gICAgICAgIGV4cGVjdCh0eXBlb2YgaGFuZGxlcikudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaGFuZGxlUmVzZXQnLCAoKSA9PiB7XG4gICAgaXQoJ2NhbGxzIGFsbCByZXNldCBmdW5jdGlvbnMgaW4gY29ycmVjdCBvcmRlcicsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVSZXNldCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChkZWZhdWx0UHJvcHMucmVzZXRHYW1lKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QoZGVmYXVsdFByb3BzLmNsZWFyRXZhbHVhdGlvbnMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdVSVN0YXRlLmhhbmRsZVJlc2V0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja0dhbWVBY3Rpb25zLnJlc2V0R2FtZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuY2xlYXJFdmFsdWF0aW9uQmFzZWxpbmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhbmRsZU1vdmVFcnJvclRha2VCYWNrJywgKCkgPT4ge1xuICAgIGl0KCdjYW5jZWxzIHNjaGVkdWxlZCBvcHBvbmVudCB0dXJuIGJlZm9yZSB1bmRvaW5nIG1vdmUnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVW5kb01vdmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLmRlZmF1bHRQcm9wcywgdW5kb01vdmU6IG1vY2tVbmRvTW92ZSB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhwcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JUYWtlQmFjaygpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChjYW5jZWxTY2hlZHVsZWRPcHBvbmVudFR1cm4pLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChtb2NrVW5kb01vdmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzZXRzIHBsYXllciB0dXJuIGFuZCBjbGVhcnMgb3Bwb25lbnQgdGhpbmtpbmcgYWZ0ZXIgc3VjY2Vzc2Z1bCB1bmRvJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VuZG9Nb3ZlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIGNvbnN0IHByb3BzID0geyAuLi5kZWZhdWx0UHJvcHMsIHVuZG9Nb3ZlOiBtb2NrVW5kb01vdmUgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yVGFrZUJhY2soKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRQbGF5ZXJUdXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh0cnVlKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLmNsZWFyT3Bwb25lbnRUaGlua2luZykudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuY2xlYXJFdmFsdWF0aW9uQmFzZWxpbmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdjbG9zZXMgbW92ZSBlcnJvciBkaWFsb2cgYWZ0ZXIgc3VjY2Vzc2Z1bCB1bmRvJywgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1VuZG9Nb3ZlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh0cnVlKTtcbiAgICAgIGNvbnN0IHByb3BzID0geyAuLi5kZWZhdWx0UHJvcHMsIHVuZG9Nb3ZlOiBtb2NrVW5kb01vdmUgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yVGFrZUJhY2soKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRNb3ZlRXJyb3JEaWFsb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgZmFpbGVkIHVuZG8gZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tVbmRvTW92ZSA9IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoZmFsc2UpO1xuICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLmRlZmF1bHRQcm9wcywgdW5kb01vdmU6IG1vY2tVbmRvTW92ZSB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhwcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JUYWtlQmFjaygpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBzdGlsbCBhdHRlbXB0IHRvIGNsb3NlIGRpYWxvZyBldmVuIGlmIHVuZG8gZmFpbHNcbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLnNldE1vdmVFcnJvckRpYWxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgobnVsbCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBtaXNzaW5nIHNldE1vdmVFcnJvckRpYWxvZyBhY3Rpb24gZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IGFjdGlvbnNXaXRob3V0RGlhbG9nID0ge1xuICAgICAgICAuLi5tb2NrVHJhaW5pbmdBY3Rpb25zLFxuICAgICAgICBzZXRNb3ZlRXJyb3JEaWFsb2c6IHVuZGVmaW5lZCxcbiAgICAgIH07XG4gICAgICBjb25zdCBwcm9wcyA9IHsgLi4uZGVmYXVsdFByb3BzLCB0cmFpbmluZ0FjdGlvbnM6IGFjdGlvbnNXaXRob3V0RGlhbG9nIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKHByb3BzKSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3dcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yVGFrZUJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaGFuZGxlTW92ZUVycm9yUmVzdGFydCcsICgpID0+IHtcbiAgICBpdCgnY2FsbHMgaGFuZGxlUmVzZXQgYW5kIGNsb3NlcyBlcnJvciBkaWFsb2cnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yUmVzdGFydCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChkZWZhdWx0UHJvcHMucmVzZXRHYW1lKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRNb3ZlRXJyb3JEaWFsb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnaGFuZGxlTW92ZUVycm9yQ29udGludWUnLCAoKSA9PiB7XG4gICAgaXQoJ2dldHMgY3VycmVudCBzdGF0ZSBhbmQgZml4ZXMgdHVybiBzdGF0ZSB3aGVuIG5lZWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlV2l0aEJsYWNrVHVybiA9IHtcbiAgICAgICAgdHJhaW5pbmc6IHtcbiAgICAgICAgICAuLi5tb2NrVHJhaW5pbmdTdGF0ZSxcbiAgICAgICAgICBpc1BsYXllclR1cm46IHRydWUsXG4gICAgICAgICAgY3VycmVudFBvc2l0aW9uOiB7IGNvbG9yVG9UcmFpbjogJ3doaXRlJyB9LFxuICAgICAgICB9LFxuICAgICAgICBnYW1lOiB7IG1vdmVIaXN0b3J5OiBbXSB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbW9ja1N0b3JlQXBpV2l0aEJsYWNrVHVybiA9IHtcbiAgICAgICAgLi4ubW9ja1N0b3JlQXBpLFxuICAgICAgICBnZXRTdGF0ZTogamVzdC5mbigoKSA9PiBzdGF0ZVdpdGhCbGFja1R1cm4pLFxuICAgICAgfTtcblxuICAgICAgLy8gTW9jayBjaGVzcyBzZXJ2aWNlIHRvIHJldHVybiBibGFjaydzIHR1cm5cbiAgICAgIChjaGVzc1NlcnZpY2UudHVybiBhcyBqZXN0Lk1vY2spLm1vY2tSZXR1cm5WYWx1ZSgnYicpO1xuXG4gICAgICBjb25zdCBwcm9wcyA9IHsgXG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcywgXG4gICAgICAgIHN0b3JlQXBpOiBtb2NrU3RvcmVBcGlXaXRoQmxhY2tUdXJuIFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yQ29udGludWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRQbGF5ZXJUdXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgnY2xvc2VzIGVycm9yIGRpYWxvZyBhbmQgc2NoZWR1bGVzIG9wcG9uZW50IHR1cm4nLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yQ29udGludWUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRNb3ZlRXJyb3JEaWFsb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xuICAgICAgZXhwZWN0KHNjaGVkdWxlT3Bwb25lbnRUdXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja1N0b3JlQXBpLCBcbiAgICAgICAgNTAwLCBcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIG9uT3Bwb25lbnRNb3ZlQ29tcGxldGU6IGV4cGVjdC5hbnkoRnVuY3Rpb24pXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3NjaGVkdWxlcyBvcHBvbmVudCB0dXJuIHdpdGggZXZhbHVhdGlvbiBiYXNlbGluZSBjYWxsYmFjaycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JDb250aW51ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEdldCB0aGUgY2FsbGJhY2sgcGFzc2VkIHRvIHNjaGVkdWxlT3Bwb25lbnRUdXJuXG4gICAgICBjb25zdCBzY2hlZHVsZUNhbGwgPSAoc2NoZWR1bGVPcHBvbmVudFR1cm4gYXMgamVzdC5Nb2NrKS5tb2NrLmNhbGxzWzBdO1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSBzY2hlZHVsZUNhbGxbMl0ub25PcHBvbmVudE1vdmVDb21wbGV0ZTtcblxuICAgICAgLy8gRXhlY3V0ZSB0aGUgY2FsbGJhY2tcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHRhYmxlYmFzZVNlcnZpY2UuZ2V0RXZhbHVhdGlvbikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuc2V0RXZhbHVhdGlvbkJhc2VsaW5lKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxLCAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgdGFibGViYXNlIHVuYXZhaWxhYmxlIGdyYWNlZnVsbHkgaW4gY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAodGFibGViYXNlU2VydmljZS5nZXRFdmFsdWF0aW9uIGFzIGplc3QuTW9jaykubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpc0F2YWlsYWJsZTogZmFsc2UsXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMoZGVmYXVsdFByb3BzKSk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZU1vdmVFcnJvckNvbnRpbnVlKCk7XG4gICAgICB9KTtcblxuICAgICAgY29uc3Qgc2NoZWR1bGVDYWxsID0gKHNjaGVkdWxlT3Bwb25lbnRUdXJuIGFzIGplc3QuTW9jaykubW9jay5jYWxsc1swXTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gc2NoZWR1bGVDYWxsWzJdLm9uT3Bwb25lbnRNb3ZlQ29tcGxldGU7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3dcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuc2V0RXZhbHVhdGlvbkJhc2VsaW5lKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgdGFibGViYXNlIGVycm9yIGdyYWNlZnVsbHkgaW4gY2FsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAodGFibGViYXNlU2VydmljZS5nZXRFdmFsdWF0aW9uIGFzIGplc3QuTW9jaykubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBUEkgRXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JDb250aW51ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHNjaGVkdWxlQ2FsbCA9IChzY2hlZHVsZU9wcG9uZW50VHVybiBhcyBqZXN0Lk1vY2spLm1vY2suY2FsbHNbMF07XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHNjaGVkdWxlQ2FsbFsyXS5vbk9wcG9uZW50TW92ZUNvbXBsZXRlO1xuXG4gICAgICAvLyBTaG91bGQgbm90IHRocm93XG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLnNldEV2YWx1YXRpb25CYXNlbGluZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhbmRsZVNob3dCZXN0TW92ZScsICgpID0+IHtcbiAgICBpdCgnc2hvd3MgdG9hc3Qgd2l0aCBiZXN0IG1vdmUgYW5kIGNsb3NlcyBkaWFsb2cnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlU2hvd0Jlc3RNb3ZlKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tVSUFjdGlvbnMuc2hvd1RvYXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0RlciBiZXN0ZSBadWcgd2FyOiBLaDEnLFxuICAgICAgICAnaW5mbydcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRNb3ZlRXJyb3JEaWFsb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgbWlzc2luZyBiZXN0IG1vdmUgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlV2l0aG91dEJlc3RNb3ZlID0ge1xuICAgICAgICAuLi5tb2NrVHJhaW5pbmdTdGF0ZSxcbiAgICAgICAgbW92ZUVycm9yRGlhbG9nOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcHJvcHMgPSB7IFxuICAgICAgICAuLi5kZWZhdWx0UHJvcHMsIFxuICAgICAgICB0cmFpbmluZ1N0YXRlOiBzdGF0ZVdpdGhvdXRCZXN0TW92ZSBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKHByb3BzKSk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZVNob3dCZXN0TW92ZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrVUlBY3Rpb25zLnNob3dUb2FzdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLnNldE1vdmVFcnJvckRpYWxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgobnVsbCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBtaXNzaW5nIG1vdmVFcnJvckRpYWxvZyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3Qgc3RhdGVXaXRob3V0RGlhbG9nID0ge1xuICAgICAgICAuLi5tb2NrVHJhaW5pbmdTdGF0ZSxcbiAgICAgICAgbW92ZUVycm9yRGlhbG9nOiB1bmRlZmluZWQsXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwcm9wcyA9IHsgXG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcywgXG4gICAgICAgIHRyYWluaW5nU3RhdGU6IHN0YXRlV2l0aG91dERpYWxvZyBcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKHByb3BzKSk7XG5cbiAgICAgIC8vIFNob3VsZCBub3QgdGhyb3dcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlU2hvd0Jlc3RNb3ZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkubm90LnRvVGhyb3coKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2hhbmRsZU1vdmVTdWNjZXNzQ2xvc2UnLCAoKSA9PiB7XG4gICAgaXQoJ2Nsb3NlcyBtb3ZlIHN1Y2Nlc3MgZGlhbG9nJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMoZGVmYXVsdFByb3BzKSk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZU1vdmVTdWNjZXNzQ2xvc2UoKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5zZXRNb3ZlU3VjY2Vzc0RpYWxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgobnVsbCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdoYW5kbGVNb3ZlU3VjY2Vzc0NvbnRpbnVlJywgKCkgPT4ge1xuICAgIGl0KCdjbG9zZXMgbW92ZSBzdWNjZXNzIGRpYWxvZycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKGRlZmF1bHRQcm9wcykpO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlU3VjY2Vzc0NvbnRpbnVlKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuc2V0TW92ZVN1Y2Nlc3NEaWFsb2cpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG51bGwpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3RhdGUgYW5kIEFjdGlvbiBEZXBlbmRlbmNpZXMnLCAoKSA9PiB7XG4gICAgaXQoJ3JlYWN0cyB0byB0cmFpbmluZ1N0YXRlIGNoYW5nZXMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soXG4gICAgICAgIChwcm9wcykgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpLFxuICAgICAgICB7IGluaXRpYWxQcm9wczogZGVmYXVsdFByb3BzIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld1RyYWluaW5nU3RhdGUgPSB7XG4gICAgICAgIC4uLm1vY2tUcmFpbmluZ1N0YXRlLFxuICAgICAgICBtb3ZlRXJyb3JEaWFsb2c6IHsgYmVzdE1vdmU6ICdRaDgrJyB9LFxuICAgICAgfTtcblxuICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRQcm9wcyxcbiAgICAgICAgdHJhaW5pbmdTdGF0ZTogbmV3VHJhaW5pbmdTdGF0ZSxcbiAgICAgIH07XG5cbiAgICAgIHJlcmVuZGVyKG5ld1Byb3BzKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlU2hvd0Jlc3RNb3ZlKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tVSUFjdGlvbnMuc2hvd1RvYXN0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgJ0RlciBiZXN0ZSBadWcgd2FyOiBRaDgrJyxcbiAgICAgICAgJ2luZm8nXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ21haW50YWlucyBzdGFibGUgZnVuY3Rpb24gcmVmZXJlbmNlcyBiZXR3ZWVuIHJlbmRlcnMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCwgcmVyZW5kZXIgfSA9IHJlbmRlckhvb2soXG4gICAgICAgIChwcm9wcykgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpLFxuICAgICAgICB7IGluaXRpYWxQcm9wczogZGVmYXVsdFByb3BzIH1cbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGluaXRpYWxIYW5kbGVycyA9IHsgLi4ucmVzdWx0LmN1cnJlbnQgfTtcblxuICAgICAgcmVyZW5kZXIoZGVmYXVsdFByb3BzKTtcblxuICAgICAgLy8gRnVuY3Rpb25zIHNob3VsZCBiZSBzdGFibGUgZHVlIHRvIHVzZUNhbGxiYWNrXG4gICAgICBPYmplY3QuZW50cmllcyhyZXN1bHQuY3VycmVudCkuZm9yRWFjaCgoW2tleSwgaGFuZGxlcl0pID0+IHtcbiAgICAgICAgZXhwZWN0KGhhbmRsZXIpLnRvQmUoaW5pdGlhbEhhbmRsZXJzW2tleSBhcyBrZXlvZiB0eXBlb2YgaW5pdGlhbEhhbmRsZXJzXSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCd1cGRhdGVzIHdoZW4gZGVwZW5kZW5jaWVzIGNoYW5nZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCByZXJlbmRlciB9ID0gcmVuZGVySG9vayhcbiAgICAgICAgKHByb3BzKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhwcm9wcyksXG4gICAgICAgIHsgaW5pdGlhbFByb3BzOiBkZWZhdWx0UHJvcHMgfVxuICAgICAgKTtcblxuICAgICAgY29uc3QgbmV3VW5kb01vdmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgY29uc3QgbmV3UHJvcHMgPSB7IC4uLmRlZmF1bHRQcm9wcywgdW5kb01vdmU6IG5ld1VuZG9Nb3ZlIH07XG5cbiAgICAgIHJlcmVuZGVyKG5ld1Byb3BzKTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yVGFrZUJhY2soKTtcbiAgICAgIH0pO1xuXG4gICAgICBleHBlY3QobmV3VW5kb01vdmUpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIGV4cGVjdChkZWZhdWx0UHJvcHMudW5kb01vdmUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBtaXNzaW5nIHRyYWluaW5nQWN0aW9ucyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgY29uc3QgcHJvcHNXaXRob3V0QWN0aW9ucyA9IHtcbiAgICAgICAgLi4uZGVmYXVsdFByb3BzLFxuICAgICAgICB0cmFpbmluZ0FjdGlvbnM6IHt9IGFzIGFueSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURpYWxvZ0hhbmRsZXJzKHByb3BzV2l0aG91dEFjdGlvbnMpKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyB3aGVuIGNhbGxpbmcgaGFuZGxlcnNcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZVN1Y2Nlc3NDbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBzdG9yZUFwaSBlcnJvcnMgZ3JhY2VmdWxseScsICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tTdG9yZUFwaVdpdGhFcnJvciA9IHtcbiAgICAgICAgLi4ubW9ja1N0b3JlQXBpLFxuICAgICAgICBnZXRTdGF0ZTogamVzdC5mbigoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdG9yZSBlcnJvcicpO1xuICAgICAgICB9KSxcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHByb3BzID0geyAuLi5kZWZhdWx0UHJvcHMsIHN0b3JlQXBpOiBtb2NrU3RvcmVBcGlXaXRoRXJyb3IgfTtcbiAgICAgIFxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGlhbG9nSGFuZGxlcnMocHJvcHMpKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaCBvbiBzdG9yZSBlcnJvcnNcbiAgICAgIGV4cGVjdCgoKSA9PiB7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnQuaGFuZGxlTW92ZUVycm9yQ29udGludWUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgY2hlc3NTZXJ2aWNlIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgKGNoZXNzU2VydmljZS5nZXRGZW4gYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoZXNzIHNlcnZpY2UgZXJyb3InKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCBjcmFzaFxuICAgICAgZXhwZWN0KCgpID0+IHtcbiAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JDb250aW51ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLm5vdC50b1Rocm93KCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdDb21wbGV4IEludGVncmF0aW9uIFNjZW5hcmlvcycsICgpID0+IHtcbiAgICBpdCgnaGFuZGxlcyBjb21wbGV0ZSBlcnJvciBkaWFsb2cgd29ya2Zsb3cnLCAoKSA9PiB7XG4gICAgICBjb25zdCBtb2NrVW5kb01vdmUgPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKHRydWUpO1xuICAgICAgY29uc3QgcHJvcHMgPSB7IC4uLmRlZmF1bHRQcm9wcywgdW5kb01vdmU6IG1vY2tVbmRvTW92ZSB9O1xuICAgICAgXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhwcm9wcykpO1xuXG4gICAgICAvLyBVc2VyIGNsaWNrcyBcIlRha2UgQmFja1wiXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5oYW5kbGVNb3ZlRXJyb3JUYWtlQmFjaygpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmeSBjb21wbGV0ZSB3b3JrZmxvd1xuICAgICAgZXhwZWN0KGNhbmNlbFNjaGVkdWxlZE9wcG9uZW50VHVybikudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tVbmRvTW92ZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuc2V0UGxheWVyVHVybikudG9IYXZlQmVlbkNhbGxlZFdpdGgodHJ1ZSk7XG4gICAgICBleHBlY3QobW9ja1RyYWluaW5nQWN0aW9ucy5jbGVhck9wcG9uZW50VGhpbmtpbmcpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLnNldE1vdmVFcnJvckRpYWxvZykudG9IYXZlQmVlbkNhbGxlZFdpdGgobnVsbCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBjb21wbGV0ZSBjb250aW51ZSB3b3JrZmxvdyB3aXRoIG9wcG9uZW50IHR1cm4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEaWFsb2dIYW5kbGVycyhkZWZhdWx0UHJvcHMpKTtcblxuICAgICAgLy8gVXNlciBjbGlja3MgXCJDb250aW51ZSBQbGF5aW5nXCJcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmhhbmRsZU1vdmVFcnJvckNvbnRpbnVlKCk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KG1vY2tUcmFpbmluZ0FjdGlvbnMuc2V0TW92ZUVycm9yRGlhbG9nKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChudWxsKTtcbiAgICAgIGV4cGVjdChzY2hlZHVsZU9wcG9uZW50VHVybikudG9IYXZlQmVlbkNhbGxlZCgpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBvcHBvbmVudCBtb3ZlIGNvbXBsZXRpb25cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHNjaGVkdWxlT3Bwb25lbnRUdXJuIGFzIGplc3QuTW9jaykubW9jay5jYWxsc1swXVsyXS5vbk9wcG9uZW50TW92ZUNvbXBsZXRlO1xuICAgICAgXG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBjYWxsYmFjaygpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChtb2NrVHJhaW5pbmdBY3Rpb25zLnNldEV2YWx1YXRpb25CYXNlbGluZSkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldExvZ2dlciIsImZuIiwic2V0Q29udGV4dCIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImNoZXNzU2VydmljZSIsImdldEZlbiIsInR1cm4iLCJ0YWJsZWJhc2VTZXJ2aWNlIiwiZ2V0RXZhbHVhdGlvbiIsImNhbmNlbFNjaGVkdWxlZE9wcG9uZW50VHVybiIsInNjaGVkdWxlT3Bwb25lbnRUdXJuIiwiZGVzY3JpYmUiLCJtb2NrVHJhaW5pbmdBY3Rpb25zIiwic2V0UGxheWVyVHVybiIsImNsZWFyT3Bwb25lbnRUaGlua2luZyIsInNldE1vdmVFcnJvckRpYWxvZyIsInNldE1vdmVTdWNjZXNzRGlhbG9nIiwic2V0RXZhbHVhdGlvbkJhc2VsaW5lIiwiY2xlYXJFdmFsdWF0aW9uQmFzZWxpbmUiLCJtb2NrR2FtZUFjdGlvbnMiLCJyZXNldEdhbWUiLCJtb2NrVUlBY3Rpb25zIiwic2hvd1RvYXN0IiwibW9ja1RyYWluaW5nU3RhdGUiLCJpc1BsYXllclR1cm4iLCJpc09wcG9uZW50VGhpbmtpbmciLCJjdXJyZW50UG9zaXRpb24iLCJpZCIsImNvbG9yVG9UcmFpbiIsIm1vdmVFcnJvckRpYWxvZyIsImJlc3RNb3ZlIiwibW9ja1N0b3JlQXBpIiwiZ2V0U3RhdGUiLCJ0cmFpbmluZyIsImdhbWUiLCJtb3ZlSGlzdG9yeSIsInNldFN0YXRlIiwibW9ja1RyYWluaW5nVUlTdGF0ZSIsImhhbmRsZVJlc2V0IiwiZGVmYXVsdFByb3BzIiwidW5kb01vdmUiLCJjbGVhckV2YWx1YXRpb25zIiwidHJhaW5pbmdBY3Rpb25zIiwiZ2FtZUFjdGlvbnMiLCJ1aUFjdGlvbnMiLCJ0cmFpbmluZ1N0YXRlIiwic3RvcmVBcGkiLCJ0cmFpbmluZ1VJU3RhdGUiLCJiZWZvcmVFYWNoIiwiY2xlYXJBbGxNb2NrcyIsIm1vY2tSZXR1cm5WYWx1ZSIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiaXNBdmFpbGFibGUiLCJyZXN1bHQiLCJ3ZGwiLCJpdCIsInJlbmRlckhvb2siLCJ1c2VEaWFsb2dIYW5kbGVycyIsImV4cGVjdCIsImN1cnJlbnQiLCJ0b0hhdmVQcm9wZXJ0eSIsIk9iamVjdCIsInZhbHVlcyIsImZvckVhY2giLCJoYW5kbGVyIiwidG9CZSIsImFjdCIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsIm1vY2tVbmRvTW92ZSIsInByb3BzIiwiaGFuZGxlTW92ZUVycm9yVGFrZUJhY2siLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFjdGlvbnNXaXRob3V0RGlhbG9nIiwidW5kZWZpbmVkIiwibm90IiwidG9UaHJvdyIsImhhbmRsZU1vdmVFcnJvclJlc3RhcnQiLCJzdGF0ZVdpdGhCbGFja1R1cm4iLCJtb2NrU3RvcmVBcGlXaXRoQmxhY2tUdXJuIiwiaGFuZGxlTW92ZUVycm9yQ29udGludWUiLCJvYmplY3RDb250YWluaW5nIiwib25PcHBvbmVudE1vdmVDb21wbGV0ZSIsImFueSIsIkZ1bmN0aW9uIiwic2NoZWR1bGVDYWxsIiwiY2FsbHMiLCJjYWxsYmFjayIsInRvSGF2ZUJlZW5DYWxsZWQiLCJtb2NrUmVqZWN0ZWRWYWx1ZSIsIkVycm9yIiwiaGFuZGxlU2hvd0Jlc3RNb3ZlIiwic3RhdGVXaXRob3V0QmVzdE1vdmUiLCJzdGF0ZVdpdGhvdXREaWFsb2ciLCJoYW5kbGVNb3ZlU3VjY2Vzc0Nsb3NlIiwiaGFuZGxlTW92ZVN1Y2Nlc3NDb250aW51ZSIsInJlcmVuZGVyIiwiaW5pdGlhbFByb3BzIiwibmV3VHJhaW5pbmdTdGF0ZSIsIm5ld1Byb3BzIiwiaW5pdGlhbEhhbmRsZXJzIiwiZW50cmllcyIsImtleSIsIm5ld1VuZG9Nb3ZlIiwicHJvcHNXaXRob3V0QWN0aW9ucyIsIm1vY2tTdG9yZUFwaVdpdGhFcnJvciIsIm1vY2tJbXBsZW1lbnRhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7O0NBY0M7QUFZ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