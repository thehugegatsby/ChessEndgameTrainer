{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/orchestrators/handlePlayerMove/move.completion.ts"],"sourcesContent":["/**\n * @file Training completion logic for handlePlayerMove orchestrator\n * @module store/orchestrators/handlePlayerMove/move.completion\n *\n * @description\n * Handles training completion including success calculation, accuracy metrics,\n * achievement checks, and user feedback. Imports WDL helpers from move.evaluation\n * for consistency.\n */\n\nimport type { StoreApi } from \"../types\";\nimport type { ValidatedMove } from \"@shared/types/chess\";\nimport { chessService } from \"@shared/services/ChessService\";\n\n/**\n * Handles training completion logic\n *\n * @param {StoreApi} api - Store API for state access and actions\n * @param {boolean} isOptimal - Whether the last move was optimal\n * @returns {Promise<void>}\n *\n * @description\n * Processes training completion including:\n * - Calculating accuracy and performance metrics\n * - Updating position progress and spaced repetition\n * - Recording daily statistics\n * - Showing completion feedback\n * - Opening completion modal\n *\n * @remarks\n * A \"perfect game\" requires 100% accuracy, no mistakes, and optimal final move.\n * Success is determined by matching the target outcome (win/draw/loss).\n */\nexport async function handleTrainingCompletion(\n  api: StoreApi,\n  isOptimal: boolean,\n): Promise<void> {\n  const { getState, setState } = api;\n  const state = getState();\n\n  if (!state.training.currentPosition || !state.training.sessionStartTime)\n    return;\n\n  const userMoves = state.game.moveHistory.filter(\n    (m: ValidatedMove) => (m as any).userMove,\n  );\n  const optimalMoves = userMoves.filter(\n    (m: ValidatedMove) => (m as any).isOptimal,\n  ).length;\n  const totalMoves = userMoves.length;\n  const accuracy = totalMoves > 0 ? (optimalMoves / totalMoves) * 100 : 0;\n\n  // Consider the final move's optimality for perfect game calculation\n  const finalMoveOptimal = isOptimal;\n  const isPerfectGame =\n    accuracy === 100 && state.training.mistakeCount === 0 && finalMoveOptimal;\n\n  // Determine success based on game outcome\n  const gameOutcome = chessService.isCheckmate()\n    ? chessService.turn() === \"w\"\n      ? \"0-1\"\n      : \"1-0\"\n    : chessService.isDraw()\n      ? \"1/2-1/2\"\n      : null;\n\n  const success = gameOutcome === state.training.currentPosition.targetOutcome;\n\n  // Complete training using setState\n  setState((draft) => {\n    // Training slice updates - we need to use completeTraining action instead\n    // as TrainingPosition doesn't have completed and lastAttemptSuccess fields\n    // For now, just mark training as complete via the proper action\n\n    // Show completion message\n    if (success) {\n      if (isPerfectGame) {\n        draft.ui.toasts.push({\n          id: Date.now().toString(),\n          message: \"Perfektes Spiel! ðŸŽ‰\",\n          type: \"success\",\n          duration: 5000,\n        });\n      } else {\n        draft.ui.toasts.push({\n          id: Date.now().toString(),\n          message: `Training abgeschlossen! Genauigkeit: ${accuracy.toFixed(0)}%`,\n          type: \"success\",\n          duration: 4000,\n        });\n      }\n    } else {\n      draft.ui.toasts.push({\n        id: Date.now().toString(),\n        message: \"Training nicht erfolgreich - versuche es erneut!\",\n        type: \"warning\",\n        duration: 4000,\n      });\n    }\n\n    // Open completion modal\n    draft.ui.currentModal = \"completion\";\n    // Note: We'd need a separate way to pass completion data (success, accuracy, isPerfectGame)\n    // For now, just showing the toast is enough to fix the immediate issue\n  });\n}\n"],"names":["handleTrainingCompletion","api","isOptimal","getState","setState","state","training","currentPosition","sessionStartTime","userMoves","game","moveHistory","filter","m","userMove","optimalMoves","length","totalMoves","accuracy","finalMoveOptimal","isPerfectGame","mistakeCount","gameOutcome","chessService","isCheckmate","turn","isDraw","success","targetOutcome","draft","ui","toasts","push","id","Date","now","toString","message","type","duration","toFixed","currentModal"],"mappings":"AAAA;;;;;;;;CAQC;;;;+BAyBqBA;;;eAAAA;;;8BArBO;AAqBtB,eAAeA,yBACpBC,GAAa,EACbC,SAAkB;IAElB,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE,GAAGH;IAC/B,MAAMI,QAAQF;IAEd,IAAI,CAACE,MAAMC,QAAQ,CAACC,eAAe,IAAI,CAACF,MAAMC,QAAQ,CAACE,gBAAgB,EACrE;IAEF,MAAMC,YAAYJ,MAAMK,IAAI,CAACC,WAAW,CAACC,MAAM,CAC7C,CAACC,IAAqB,AAACA,EAAUC,QAAQ;IAE3C,MAAMC,eAAeN,UAAUG,MAAM,CACnC,CAACC,IAAqB,AAACA,EAAUX,SAAS,EAC1Cc,MAAM;IACR,MAAMC,aAAaR,UAAUO,MAAM;IACnC,MAAME,WAAWD,aAAa,IAAI,AAACF,eAAeE,aAAc,MAAM;IAEtE,oEAAoE;IACpE,MAAME,mBAAmBjB;IACzB,MAAMkB,gBACJF,aAAa,OAAOb,MAAMC,QAAQ,CAACe,YAAY,KAAK,KAAKF;IAE3D,0CAA0C;IAC1C,MAAMG,cAAcC,0BAAY,CAACC,WAAW,KACxCD,0BAAY,CAACE,IAAI,OAAO,MACtB,QACA,QACFF,0BAAY,CAACG,MAAM,KACjB,YACA;IAEN,MAAMC,UAAUL,gBAAgBjB,MAAMC,QAAQ,CAACC,eAAe,CAACqB,aAAa;IAE5E,mCAAmC;IACnCxB,SAAS,CAACyB;QACR,0EAA0E;QAC1E,2EAA2E;QAC3E,gEAAgE;QAEhE,0BAA0B;QAC1B,IAAIF,SAAS;YACX,IAAIP,eAAe;gBACjBS,MAAMC,EAAE,CAACC,MAAM,CAACC,IAAI,CAAC;oBACnBC,IAAIC,KAAKC,GAAG,GAAGC,QAAQ;oBACvBC,SAAS;oBACTC,MAAM;oBACNC,UAAU;gBACZ;YACF,OAAO;gBACLV,MAAMC,EAAE,CAACC,MAAM,CAACC,IAAI,CAAC;oBACnBC,IAAIC,KAAKC,GAAG,GAAGC,QAAQ;oBACvBC,SAAS,CAAC,qCAAqC,EAAEnB,SAASsB,OAAO,CAAC,GAAG,CAAC,CAAC;oBACvEF,MAAM;oBACNC,UAAU;gBACZ;YACF;QACF,OAAO;YACLV,MAAMC,EAAE,CAACC,MAAM,CAACC,IAAI,CAAC;gBACnBC,IAAIC,KAAKC,GAAG,GAAGC,QAAQ;gBACvBC,SAAS;gBACTC,MAAM;gBACNC,UAAU;YACZ;QACF;QAEA,wBAAwB;QACxBV,MAAMC,EAAE,CAACW,YAAY,GAAG;IACxB,4FAA4F;IAC5F,uEAAuE;IACzE;AACF"}