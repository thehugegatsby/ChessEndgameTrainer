079eee3027b9b4fc9ff145328c32ebbd
/**
 * @file Progress slice for user progress tracking and statistics
 * @description Manages user progress data, session statistics, and sync status
 * 
 * @example
 * ```typescript
 * // Using state
 * const { userStats, syncStatus } = useProgressState();
 * 
 * // Using actions only (no re-renders)
 * const actions = useProgressActions();
 * actions.updateSessionProgress({ positionsCompleted: 1 });
 * 
 * // Using both
 * const [state, actions] = useProgressStore();
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get createProgressSlice () {
        return createProgressSlice;
    },
    get initialProgressState () {
        return initialProgressState;
    }
});
const _Logger = require("../../services/logging/Logger");
const _SpacedRepetitionService = require("../../services/SpacedRepetitionService");
const _ProgressService = require("../../services/ProgressService");
// Lazy initialization to avoid Firebase issues in test environment
let progressService = null;
const getProgressService = ()=>{
    if (!progressService) {
        // Dynamic import to avoid Firebase initialization in tests
        const { db } = require('@/firebase/firebase');
        progressService = new _ProgressService.ProgressService(db);
    }
    return progressService;
};
const initialProgressState = {
    // Core progress data
    userStats: null,
    sessionProgress: {
        positionsCompleted: 0,
        positionsCorrect: 0,
        positionsAttempted: 0,
        timeSpent: 0,
        hintsUsed: 0,
        mistakesMade: 0
    },
    cardProgress: {},
    // Sync status
    loading: false,
    syncStatus: 'idle',
    lastSync: null,
    syncError: null
};
const createProgressSlice = (set, get)=>({
        ...initialProgressState,
        // State setters
        setUserStats: (stats)=>set((state)=>{
                state.progress.userStats = stats;
            }),
        updateSessionProgress: (progress)=>set((state)=>{
                state.progress.sessionProgress = {
                    ...state.progress.sessionProgress,
                    ...progress
                };
            }),
        setLoading: (loading)=>set((state)=>{
                state.progress.loading = loading;
            }),
        setSyncStatus: (status)=>set((state)=>{
                state.progress.syncStatus = status;
            }),
        setLastSync: (timestamp)=>set((state)=>{
                state.progress.lastSync = timestamp;
            }),
        setSyncError: (error)=>set((state)=>{
                state.progress.syncError = error;
            }),
        // Card progress management
        initializeCards: (cards)=>set((state)=>{
                const cardMap = {};
                for (const card of cards){
                    cardMap[card.id] = card;
                }
                state.progress.cardProgress = cardMap;
            }),
        recordAttempt: (positionId, wasCorrect)=>set((state)=>{
                const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
                // Validate positionId
                if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {
                    logger.warn('Invalid positionId provided to recordAttempt', {
                        positionId
                    });
                    return;
                }
                const trimmedId = positionId.trim();
                let card = state.progress.cardProgress[trimmedId];
                if (!card) {
                    // Create new card using SpacedRepetitionService
                    logger.debug('Creating new card progress', {
                        positionId: trimmedId,
                        wasCorrect
                    });
                    card = (0, _SpacedRepetitionService.createNewCard)(trimmedId, Date.now());
                    state.progress.cardProgress[trimmedId] = card;
                }
                // Update card using SpacedRepetitionService with proper SuperMemo-2 algorithm
                try {
                    const quality = (0, _SpacedRepetitionService.mapBinaryToQuality)(wasCorrect);
                    const updatedCard = (0, _SpacedRepetitionService.updateCardProgress)(card, quality, Date.now());
                    state.progress.cardProgress[trimmedId] = updatedCard;
                    logger.debug('Updated card progress with SM-2', {
                        positionId: trimmedId,
                        wasCorrect,
                        quality,
                        oldInterval: card.interval,
                        newInterval: updatedCard.interval,
                        oldEfactor: card.efactor,
                        newEfactor: updatedCard.efactor,
                        nextReviewAt: new Date(updatedCard.nextReviewAt).toISOString()
                    });
                } catch (error) {
                    logger.error('Failed to update card progress', {
                        positionId: trimmedId,
                        error
                    });
                // Fallback: keep the card unchanged rather than corrupting state
                }
            }),
        resetCardProgress: (positionId)=>set((state)=>{
                const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
                if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {
                    logger.warn('Invalid positionId provided to resetCardProgress', {
                        positionId
                    });
                    return;
                }
                const trimmedId = positionId.trim();
                if (state.progress.cardProgress[trimmedId]) {
                    // Use SpacedRepetitionService to create a fresh card instead of deleting
                    state.progress.cardProgress[trimmedId] = (0, _SpacedRepetitionService.resetCardProgress)({
                        id: trimmedId
                    });
                    logger.debug('Reset card progress using SM-2 defaults', {
                        positionId: trimmedId
                    });
                } else {
                    logger.debug('Card not found for reset', {
                        positionId: trimmedId
                    });
                }
            }),
        setCardProgress: (positionId, progress)=>set((state)=>{
                const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
                if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {
                    logger.warn('Invalid positionId provided to setCardProgress', {
                        positionId
                    });
                    return;
                }
                if (!progress || typeof progress !== 'object') {
                    logger.warn('Invalid progress object provided to setCardProgress', {
                        positionId,
                        progress
                    });
                    return;
                }
                const trimmedId = positionId.trim();
                state.progress.cardProgress[trimmedId] = progress;
                logger.debug('Set card progress', {
                    positionId: trimmedId
                });
            }),
        // Batch operations for performance
        batchUpdateProgress: (updates)=>set((state)=>{
                // Handle userStats - use Object.assign for Immer
                if (updates.userStats) {
                    if (state.progress.userStats) {
                        Object.assign(state.progress.userStats, updates.userStats);
                    } else {
                        // Create new if null
                        state.progress.userStats = updates.userStats;
                    }
                }
                // Handle sessionProgress - use Object.assign for Immer
                if (updates.sessionProgress) {
                    Object.assign(state.progress.sessionProgress, updates.sessionProgress);
                }
                // Handle cardProgress - merge entire map
                if (updates.cardProgress) {
                    Object.assign(state.progress.cardProgress, updates.cardProgress);
                }
            }),
        // Reset progress state
        resetProgress: ()=>set((state)=>{
                // Only reset the state properties, not the actions
                Object.assign(state.progress, initialProgressState);
            }),
        // ===== ASYNC FIREBASE OPERATIONS =====
        /**
   * Loads user progress from Firebase
   * 
   * @param userId - User identifier
   */ loadUserProgress: async (userId)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            set((state)=>{
                state.progress.loading = true;
                state.progress.syncStatus = 'syncing';
                state.progress.syncError = null;
            });
            try {
                logger.debug('Loading user progress from Firebase', {
                    userId
                });
                // Load user stats and all card progresses in parallel
                const service = getProgressService();
                const [userStats, cardProgresses] = await Promise.all([
                    service.getUserStats(userId),
                    service.getAllCardProgresses(userId)
                ]);
                set((state)=>{
                    // Update user stats
                    if (userStats) {
                        state.progress.userStats = userStats;
                    }
                    // Update card progresses
                    const cardMap = {};
                    for (const card of cardProgresses){
                        cardMap[card.id] = card;
                    }
                    state.progress.cardProgress = cardMap;
                    // Update sync status
                    state.progress.loading = false;
                    state.progress.syncStatus = 'idle';
                    state.progress.lastSync = Date.now();
                    state.progress.syncError = null;
                });
                logger.info('User progress loaded successfully', {
                    userId,
                    hasStats: !!userStats,
                    cardCount: cardProgresses.length
                });
            } catch (error) {
                logger.error('Failed to load user progress', error, {
                    userId
                });
                set((state)=>{
                    state.progress.loading = false;
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error; // Re-throw for caller to handle
            }
        },
        /**
   * Saves user stats to Firebase
   * 
   * @param userId - User identifier
   * @param updates - Partial user stats to update
   */ saveUserStats: async (userId, updates)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            try {
                logger.debug('Saving user stats to Firebase', {
                    userId,
                    updates
                });
                await getProgressService().updateUserStats(userId, updates);
                set((state)=>{
                    // Optimistically update local state
                    if (state.progress.userStats) {
                        Object.assign(state.progress.userStats, updates);
                    } else {
                        state.progress.userStats = {
                            userId,
                            ...updates
                        };
                    }
                    state.progress.lastSync = Date.now();
                    state.progress.syncError = null;
                });
                logger.debug('User stats saved successfully', {
                    userId
                });
            } catch (error) {
                logger.error('Failed to save user stats', error, {
                    userId
                });
                set((state)=>{
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error;
            }
        },
        /**
   * Saves card progress to Firebase
   * 
   * @param userId - User identifier
   * @param positionId - Position identifier
   * @param progress - Complete card progress object
   */ saveCardProgress: async (userId, positionId, progress)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            try {
                logger.debug('Saving card progress to Firebase', {
                    userId,
                    positionId
                });
                await getProgressService().upsertCardProgress(userId, positionId, progress);
                set((state)=>{
                    // Optimistically update local state
                    state.progress.cardProgress[positionId] = progress;
                    state.progress.lastSync = Date.now();
                    state.progress.syncError = null;
                });
                logger.debug('Card progress saved successfully', {
                    userId,
                    positionId
                });
            } catch (error) {
                logger.error('Failed to save card progress', error, {
                    userId,
                    positionId
                });
                set((state)=>{
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error;
            }
        },
        /**
   * Saves session completion data (user stats + multiple card updates) atomically
   * 
   * @param userId - User identifier
   * @param sessionStats - Partial user stats updates
   * @param cardUpdates - Array of card progress updates
   */ saveSessionComplete: async (userId, sessionStats, cardUpdates)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            set((state)=>{
                state.progress.loading = true;
                state.progress.syncStatus = 'syncing';
            });
            try {
                logger.debug('Saving session completion to Firebase', {
                    userId,
                    sessionStats,
                    cardCount: cardUpdates.length
                });
                await getProgressService().updateProgressTransaction(userId, sessionStats, cardUpdates);
                set((state)=>{
                    // Optimistically update local state
                    if (state.progress.userStats) {
                        Object.assign(state.progress.userStats, sessionStats);
                    } else {
                        state.progress.userStats = {
                            userId,
                            ...sessionStats
                        };
                    }
                    // Update card progresses
                    for (const { positionId, progress } of cardUpdates){
                        state.progress.cardProgress[positionId] = progress;
                    }
                    state.progress.loading = false;
                    state.progress.syncStatus = 'idle';
                    state.progress.lastSync = Date.now();
                    state.progress.syncError = null;
                });
                logger.info('Session completion saved successfully', {
                    userId,
                    cardCount: cardUpdates.length
                });
            } catch (error) {
                logger.error('Failed to save session completion', error, {
                    userId
                });
                set((state)=>{
                    state.progress.loading = false;
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error;
            }
        },
        /**
   * Gets cards due for review from Firebase
   * 
   * @param userId - User identifier
   * @returns Promise resolving to array of due cards
   */ getDueCards: async (userId)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            try {
                logger.debug('Getting due cards from Firebase', {
                    userId
                });
                const dueCards = await getProgressService().getDueCardProgresses(userId);
                logger.debug('Due cards retrieved successfully', {
                    userId,
                    dueCount: dueCards.length
                });
                return dueCards;
            } catch (error) {
                logger.error('Failed to get due cards', error, {
                    userId
                });
                set((state)=>{
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error;
            }
        },
        /**
   * Syncs all progress data to Firebase (full upload)
   * 
   * @param userId - User identifier
   */ syncAllProgress: async (userId)=>{
            const logger = (0, _Logger.getLogger)().setContext('ProgressSlice');
            set((state)=>{
                state.progress.loading = true;
                state.progress.syncStatus = 'syncing';
            });
            try {
                logger.debug('Syncing all progress to Firebase', {
                    userId
                });
                // Get current state
                const currentState = get().progress;
                // Prepare batch updates
                const cardUpdates = Object.entries(currentState.cardProgress).map(([positionId, progress])=>({
                        positionId,
                        progress: progress
                    }));
                // Use transaction to update everything atomically
                await getProgressService().updateProgressTransaction(userId, currentState.userStats || {
                    userId
                }, cardUpdates);
                set((state)=>{
                    state.progress.loading = false;
                    state.progress.syncStatus = 'idle';
                    state.progress.lastSync = Date.now();
                    state.progress.syncError = null;
                });
                logger.info('All progress synced successfully', {
                    userId,
                    cardCount: cardUpdates.length
                });
            } catch (error) {
                logger.error('Failed to sync all progress', error, {
                    userId
                });
                set((state)=>{
                    state.progress.loading = false;
                    state.progress.syncStatus = 'error';
                    state.progress.syncError = error.message;
                });
                throw error;
            }
        }
    });

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL3NsaWNlcy9wcm9ncmVzc1NsaWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgUHJvZ3Jlc3Mgc2xpY2UgZm9yIHVzZXIgcHJvZ3Jlc3MgdHJhY2tpbmcgYW5kIHN0YXRpc3RpY3NcbiAqIEBkZXNjcmlwdGlvbiBNYW5hZ2VzIHVzZXIgcHJvZ3Jlc3MgZGF0YSwgc2Vzc2lvbiBzdGF0aXN0aWNzLCBhbmQgc3luYyBzdGF0dXNcbiAqIFxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIFVzaW5nIHN0YXRlXG4gKiBjb25zdCB7IHVzZXJTdGF0cywgc3luY1N0YXR1cyB9ID0gdXNlUHJvZ3Jlc3NTdGF0ZSgpO1xuICogXG4gKiAvLyBVc2luZyBhY3Rpb25zIG9ubHkgKG5vIHJlLXJlbmRlcnMpXG4gKiBjb25zdCBhY3Rpb25zID0gdXNlUHJvZ3Jlc3NBY3Rpb25zKCk7XG4gKiBhY3Rpb25zLnVwZGF0ZVNlc3Npb25Qcm9ncmVzcyh7IHBvc2l0aW9uc0NvbXBsZXRlZDogMSB9KTtcbiAqIFxuICogLy8gVXNpbmcgYm90aFxuICogY29uc3QgW3N0YXRlLCBhY3Rpb25zXSA9IHVzZVByb2dyZXNzU3RvcmUoKTtcbiAqIGBgYFxuICovXG5cbmltcG9ydCB0eXBlIHsgSW1tZXJTdGF0ZUNyZWF0b3IsIFByb2dyZXNzU2xpY2UsIFByb2dyZXNzU3RhdGUsIFVzZXJTdGF0cywgQ2FyZFByb2dyZXNzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL2xvZ2dpbmcvTG9nZ2VyJztcbmltcG9ydCB7IFxuICB1cGRhdGVDYXJkUHJvZ3Jlc3MsIFxuICBtYXBCaW5hcnlUb1F1YWxpdHksXG4gIGNyZWF0ZU5ld0NhcmQsXG4gIHJlc2V0Q2FyZFByb2dyZXNzIGFzIHJlc2V0Q2FyZFxufSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL1NwYWNlZFJlcGV0aXRpb25TZXJ2aWNlJztcbmltcG9ydCB7IFByb2dyZXNzU2VydmljZSB9IGZyb20gJ0BzaGFyZWQvc2VydmljZXMvUHJvZ3Jlc3NTZXJ2aWNlJztcblxuLy8gTGF6eSBpbml0aWFsaXphdGlvbiB0byBhdm9pZCBGaXJlYmFzZSBpc3N1ZXMgaW4gdGVzdCBlbnZpcm9ubWVudFxubGV0IHByb2dyZXNzU2VydmljZTogUHJvZ3Jlc3NTZXJ2aWNlIHwgbnVsbCA9IG51bGw7XG5cbmNvbnN0IGdldFByb2dyZXNzU2VydmljZSA9ICgpOiBQcm9ncmVzc1NlcnZpY2UgPT4ge1xuICBpZiAoIXByb2dyZXNzU2VydmljZSkge1xuICAgIC8vIER5bmFtaWMgaW1wb3J0IHRvIGF2b2lkIEZpcmViYXNlIGluaXRpYWxpemF0aW9uIGluIHRlc3RzXG4gICAgY29uc3QgeyBkYiB9ID0gcmVxdWlyZSgnQC9maXJlYmFzZS9maXJlYmFzZScpO1xuICAgIHByb2dyZXNzU2VydmljZSA9IG5ldyBQcm9ncmVzc1NlcnZpY2UoZGIpO1xuICB9XG4gIHJldHVybiBwcm9ncmVzc1NlcnZpY2U7XG59O1xuXG4vKipcbiAqIEluaXRpYWwgc3RhdGUgZm9yIHByb2dyZXNzIHNsaWNlXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsUHJvZ3Jlc3NTdGF0ZTogUHJvZ3Jlc3NTdGF0ZSA9IHtcbiAgLy8gQ29yZSBwcm9ncmVzcyBkYXRhXG4gIHVzZXJTdGF0czogbnVsbCxcbiAgc2Vzc2lvblByb2dyZXNzOiB7XG4gICAgcG9zaXRpb25zQ29tcGxldGVkOiAwLFxuICAgIHBvc2l0aW9uc0NvcnJlY3Q6IDAsXG4gICAgcG9zaXRpb25zQXR0ZW1wdGVkOiAwLFxuICAgIHRpbWVTcGVudDogMCxcbiAgICBoaW50c1VzZWQ6IDAsXG4gICAgbWlzdGFrZXNNYWRlOiAwLFxuICB9LFxuICBjYXJkUHJvZ3Jlc3M6IHt9LCAvLyBFbXB0eSBtYXAgaW5pdGlhbGx5XG4gIFxuICAvLyBTeW5jIHN0YXR1c1xuICBsb2FkaW5nOiBmYWxzZSxcbiAgc3luY1N0YXR1czogJ2lkbGUnLFxuICBsYXN0U3luYzogbnVsbCxcbiAgc3luY0Vycm9yOiBudWxsLFxufTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBwcm9ncmVzcyBzbGljZSB3aXRoIEltbWVyIG1pZGRsZXdhcmUgZm9yIGltbXV0YWJsZSB1cGRhdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVQcm9ncmVzc1NsaWNlOiBJbW1lclN0YXRlQ3JlYXRvcjxQcm9ncmVzc1NsaWNlPiA9IChzZXQsIGdldCkgPT4gKHtcbiAgLi4uaW5pdGlhbFByb2dyZXNzU3RhdGUsXG5cbiAgLy8gU3RhdGUgc2V0dGVyc1xuICBzZXRVc2VyU3RhdHM6IChzdGF0cykgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIHN0YXRlLnByb2dyZXNzLnVzZXJTdGF0cyA9IHN0YXRzO1xuICB9KSxcblxuICB1cGRhdGVTZXNzaW9uUHJvZ3Jlc3M6IChwcm9ncmVzcykgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIHN0YXRlLnByb2dyZXNzLnNlc3Npb25Qcm9ncmVzcyA9IHtcbiAgICAgIC4uLnN0YXRlLnByb2dyZXNzLnNlc3Npb25Qcm9ncmVzcyxcbiAgICAgIC4uLnByb2dyZXNzLFxuICAgIH07XG4gIH0pLFxuXG4gIHNldExvYWRpbmc6IChsb2FkaW5nKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgc3RhdGUucHJvZ3Jlc3MubG9hZGluZyA9IGxvYWRpbmc7XG4gIH0pLFxuXG4gIHNldFN5bmNTdGF0dXM6IChzdGF0dXMpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gc3RhdHVzO1xuICB9KSxcblxuICBzZXRMYXN0U3luYzogKHRpbWVzdGFtcCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIHN0YXRlLnByb2dyZXNzLmxhc3RTeW5jID0gdGltZXN0YW1wO1xuICB9KSxcblxuICBzZXRTeW5jRXJyb3I6IChlcnJvcikgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IGVycm9yO1xuICB9KSxcblxuICAvLyBDYXJkIHByb2dyZXNzIG1hbmFnZW1lbnRcbiAgaW5pdGlhbGl6ZUNhcmRzOiAoY2FyZHMpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICBjb25zdCBjYXJkTWFwOiBSZWNvcmQ8c3RyaW5nLCBDYXJkUHJvZ3Jlc3M+ID0ge307XG4gICAgZm9yIChjb25zdCBjYXJkIG9mIGNhcmRzKSB7XG4gICAgICBjYXJkTWFwW2NhcmQuaWRdID0gY2FyZDtcbiAgICB9XG4gICAgc3RhdGUucHJvZ3Jlc3MuY2FyZFByb2dyZXNzID0gY2FyZE1hcDtcbiAgfSksXG5cbiAgcmVjb3JkQXR0ZW1wdDogKHBvc2l0aW9uSWQsIHdhc0NvcnJlY3QpID0+IHNldCgoc3RhdGUpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KCdQcm9ncmVzc1NsaWNlJyk7XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgcG9zaXRpb25JZFxuICAgIGlmICghcG9zaXRpb25JZCB8fCB0eXBlb2YgcG9zaXRpb25JZCAhPT0gJ3N0cmluZycgfHwgcG9zaXRpb25JZC50cmltKCkgPT09ICcnKSB7XG4gICAgICBsb2dnZXIud2FybignSW52YWxpZCBwb3NpdGlvbklkIHByb3ZpZGVkIHRvIHJlY29yZEF0dGVtcHQnLCB7IHBvc2l0aW9uSWQgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRyaW1tZWRJZCA9IHBvc2l0aW9uSWQudHJpbSgpO1xuICAgIGxldCBjYXJkID0gc3RhdGUucHJvZ3Jlc3MuY2FyZFByb2dyZXNzW3RyaW1tZWRJZF07XG4gICAgXG4gICAgaWYgKCFjYXJkKSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IGNhcmQgdXNpbmcgU3BhY2VkUmVwZXRpdGlvblNlcnZpY2VcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ3JlYXRpbmcgbmV3IGNhcmQgcHJvZ3Jlc3MnLCB7IHBvc2l0aW9uSWQ6IHRyaW1tZWRJZCwgd2FzQ29ycmVjdCB9KTtcbiAgICAgIGNhcmQgPSBjcmVhdGVOZXdDYXJkKHRyaW1tZWRJZCwgRGF0ZS5ub3coKSk7XG4gICAgICBzdGF0ZS5wcm9ncmVzcy5jYXJkUHJvZ3Jlc3NbdHJpbW1lZElkXSA9IGNhcmQ7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBjYXJkIHVzaW5nIFNwYWNlZFJlcGV0aXRpb25TZXJ2aWNlIHdpdGggcHJvcGVyIFN1cGVyTWVtby0yIGFsZ29yaXRobVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWFsaXR5ID0gbWFwQmluYXJ5VG9RdWFsaXR5KHdhc0NvcnJlY3QpO1xuICAgICAgY29uc3QgdXBkYXRlZENhcmQgPSB1cGRhdGVDYXJkUHJvZ3Jlc3MoY2FyZCwgcXVhbGl0eSwgRGF0ZS5ub3coKSk7XG4gICAgICBzdGF0ZS5wcm9ncmVzcy5jYXJkUHJvZ3Jlc3NbdHJpbW1lZElkXSA9IHVwZGF0ZWRDYXJkO1xuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoJ1VwZGF0ZWQgY2FyZCBwcm9ncmVzcyB3aXRoIFNNLTInLCB7IFxuICAgICAgICBwb3NpdGlvbklkOiB0cmltbWVkSWQsIFxuICAgICAgICB3YXNDb3JyZWN0LFxuICAgICAgICBxdWFsaXR5LFxuICAgICAgICBvbGRJbnRlcnZhbDogY2FyZC5pbnRlcnZhbCxcbiAgICAgICAgbmV3SW50ZXJ2YWw6IHVwZGF0ZWRDYXJkLmludGVydmFsLFxuICAgICAgICBvbGRFZmFjdG9yOiBjYXJkLmVmYWN0b3IsXG4gICAgICAgIG5ld0VmYWN0b3I6IHVwZGF0ZWRDYXJkLmVmYWN0b3IsXG4gICAgICAgIG5leHRSZXZpZXdBdDogbmV3IERhdGUodXBkYXRlZENhcmQubmV4dFJldmlld0F0KS50b0lTT1N0cmluZygpXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGNhcmQgcHJvZ3Jlc3MnLCB7IHBvc2l0aW9uSWQ6IHRyaW1tZWRJZCwgZXJyb3IgfSk7XG4gICAgICAvLyBGYWxsYmFjazoga2VlcCB0aGUgY2FyZCB1bmNoYW5nZWQgcmF0aGVyIHRoYW4gY29ycnVwdGluZyBzdGF0ZVxuICAgIH1cbiAgfSksXG5cbiAgcmVzZXRDYXJkUHJvZ3Jlc3M6IChwb3NpdGlvbklkKSA9PiBzZXQoKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCkuc2V0Q29udGV4dCgnUHJvZ3Jlc3NTbGljZScpO1xuICAgIFxuICAgIGlmICghcG9zaXRpb25JZCB8fCB0eXBlb2YgcG9zaXRpb25JZCAhPT0gJ3N0cmluZycgfHwgcG9zaXRpb25JZC50cmltKCkgPT09ICcnKSB7XG4gICAgICBsb2dnZXIud2FybignSW52YWxpZCBwb3NpdGlvbklkIHByb3ZpZGVkIHRvIHJlc2V0Q2FyZFByb2dyZXNzJywgeyBwb3NpdGlvbklkIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0cmltbWVkSWQgPSBwb3NpdGlvbklkLnRyaW0oKTtcbiAgICBpZiAoc3RhdGUucHJvZ3Jlc3MuY2FyZFByb2dyZXNzW3RyaW1tZWRJZF0pIHtcbiAgICAgIC8vIFVzZSBTcGFjZWRSZXBldGl0aW9uU2VydmljZSB0byBjcmVhdGUgYSBmcmVzaCBjYXJkIGluc3RlYWQgb2YgZGVsZXRpbmdcbiAgICAgIHN0YXRlLnByb2dyZXNzLmNhcmRQcm9ncmVzc1t0cmltbWVkSWRdID0gcmVzZXRDYXJkKHsgaWQ6IHRyaW1tZWRJZCB9KTtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnUmVzZXQgY2FyZCBwcm9ncmVzcyB1c2luZyBTTS0yIGRlZmF1bHRzJywgeyBwb3NpdGlvbklkOiB0cmltbWVkSWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FyZCBub3QgZm91bmQgZm9yIHJlc2V0JywgeyBwb3NpdGlvbklkOiB0cmltbWVkSWQgfSk7XG4gICAgfVxuICB9KSxcblxuICBzZXRDYXJkUHJvZ3Jlc3M6IChwb3NpdGlvbklkLCBwcm9ncmVzcykgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IGxvZ2dlciA9IGdldExvZ2dlcigpLnNldENvbnRleHQoJ1Byb2dyZXNzU2xpY2UnKTtcbiAgICBcbiAgICBpZiAoIXBvc2l0aW9uSWQgfHwgdHlwZW9mIHBvc2l0aW9uSWQgIT09ICdzdHJpbmcnIHx8IHBvc2l0aW9uSWQudHJpbSgpID09PSAnJykge1xuICAgICAgbG9nZ2VyLndhcm4oJ0ludmFsaWQgcG9zaXRpb25JZCBwcm92aWRlZCB0byBzZXRDYXJkUHJvZ3Jlc3MnLCB7IHBvc2l0aW9uSWQgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICghcHJvZ3Jlc3MgfHwgdHlwZW9mIHByb2dyZXNzICE9PSAnb2JqZWN0Jykge1xuICAgICAgbG9nZ2VyLndhcm4oJ0ludmFsaWQgcHJvZ3Jlc3Mgb2JqZWN0IHByb3ZpZGVkIHRvIHNldENhcmRQcm9ncmVzcycsIHsgcG9zaXRpb25JZCwgcHJvZ3Jlc3MgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRyaW1tZWRJZCA9IHBvc2l0aW9uSWQudHJpbSgpO1xuICAgIHN0YXRlLnByb2dyZXNzLmNhcmRQcm9ncmVzc1t0cmltbWVkSWRdID0gcHJvZ3Jlc3M7XG4gICAgbG9nZ2VyLmRlYnVnKCdTZXQgY2FyZCBwcm9ncmVzcycsIHsgcG9zaXRpb25JZDogdHJpbW1lZElkIH0pO1xuICB9KSxcblxuICAvLyBCYXRjaCBvcGVyYXRpb25zIGZvciBwZXJmb3JtYW5jZVxuICBiYXRjaFVwZGF0ZVByb2dyZXNzOiAodXBkYXRlcykgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIC8vIEhhbmRsZSB1c2VyU3RhdHMgLSB1c2UgT2JqZWN0LmFzc2lnbiBmb3IgSW1tZXJcbiAgICBpZiAodXBkYXRlcy51c2VyU3RhdHMpIHtcbiAgICAgIGlmIChzdGF0ZS5wcm9ncmVzcy51c2VyU3RhdHMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5wcm9ncmVzcy51c2VyU3RhdHMsIHVwZGF0ZXMudXNlclN0YXRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaWYgbnVsbFxuICAgICAgICBzdGF0ZS5wcm9ncmVzcy51c2VyU3RhdHMgPSB1cGRhdGVzLnVzZXJTdGF0cyBhcyBVc2VyU3RhdHM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBzZXNzaW9uUHJvZ3Jlc3MgLSB1c2UgT2JqZWN0LmFzc2lnbiBmb3IgSW1tZXJcbiAgICBpZiAodXBkYXRlcy5zZXNzaW9uUHJvZ3Jlc3MpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUucHJvZ3Jlc3Muc2Vzc2lvblByb2dyZXNzLCB1cGRhdGVzLnNlc3Npb25Qcm9ncmVzcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBjYXJkUHJvZ3Jlc3MgLSBtZXJnZSBlbnRpcmUgbWFwXG4gICAgaWYgKHVwZGF0ZXMuY2FyZFByb2dyZXNzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLnByb2dyZXNzLmNhcmRQcm9ncmVzcywgdXBkYXRlcy5jYXJkUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSksXG5cbiAgLy8gUmVzZXQgcHJvZ3Jlc3Mgc3RhdGVcbiAgcmVzZXRQcm9ncmVzczogKCkgPT4gc2V0KChzdGF0ZSkgPT4ge1xuICAgIC8vIE9ubHkgcmVzZXQgdGhlIHN0YXRlIHByb3BlcnRpZXMsIG5vdCB0aGUgYWN0aW9uc1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUucHJvZ3Jlc3MsIGluaXRpYWxQcm9ncmVzc1N0YXRlKTtcbiAgfSksXG5cbiAgLy8gPT09PT0gQVNZTkMgRklSRUJBU0UgT1BFUkFUSU9OUyA9PT09PVxuXG4gIC8qKlxuICAgKiBMb2FkcyB1c2VyIHByb2dyZXNzIGZyb20gRmlyZWJhc2VcbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgLSBVc2VyIGlkZW50aWZpZXJcbiAgICovXG4gIGxvYWRVc2VyUHJvZ3Jlc3M6IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KCdQcm9ncmVzc1NsaWNlJyk7XG4gICAgXG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJvZ3Jlc3MubG9hZGluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gJ3N5bmNpbmcnO1xuICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY0Vycm9yID0gbnVsbDtcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0xvYWRpbmcgdXNlciBwcm9ncmVzcyBmcm9tIEZpcmViYXNlJywgeyB1c2VySWQgfSk7XG4gICAgICBcbiAgICAgIC8vIExvYWQgdXNlciBzdGF0cyBhbmQgYWxsIGNhcmQgcHJvZ3Jlc3NlcyBpbiBwYXJhbGxlbFxuICAgICAgY29uc3Qgc2VydmljZSA9IGdldFByb2dyZXNzU2VydmljZSgpO1xuICAgICAgY29uc3QgW3VzZXJTdGF0cywgY2FyZFByb2dyZXNzZXNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICBzZXJ2aWNlLmdldFVzZXJTdGF0cyh1c2VySWQpLFxuICAgICAgICBzZXJ2aWNlLmdldEFsbENhcmRQcm9ncmVzc2VzKHVzZXJJZClcbiAgICAgIF0pO1xuXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIFVwZGF0ZSB1c2VyIHN0YXRzXG4gICAgICAgIGlmICh1c2VyU3RhdHMpIHtcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcy51c2VyU3RhdHMgPSB1c2VyU3RhdHM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBjYXJkIHByb2dyZXNzZXNcbiAgICAgICAgY29uc3QgY2FyZE1hcDogUmVjb3JkPHN0cmluZywgQ2FyZFByb2dyZXNzPiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGNhcmQgb2YgY2FyZFByb2dyZXNzZXMpIHtcbiAgICAgICAgICBjYXJkTWFwW2NhcmQuaWRdID0gY2FyZDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5jYXJkUHJvZ3Jlc3MgPSBjYXJkTWFwO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN5bmMgc3RhdHVzXG4gICAgICAgIHN0YXRlLnByb2dyZXNzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY1N0YXR1cyA9ICdpZGxlJztcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3MubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jRXJyb3IgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5pbmZvKCdVc2VyIHByb2dyZXNzIGxvYWRlZCBzdWNjZXNzZnVsbHknLCB7IFxuICAgICAgICB1c2VySWQsIFxuICAgICAgICBoYXNTdGF0czogISF1c2VyU3RhdHMsXG4gICAgICAgIGNhcmRDb3VudDogY2FyZFByb2dyZXNzZXMubGVuZ3RoIFxuICAgICAgfSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gbG9hZCB1c2VyIHByb2dyZXNzJywgZXJyb3IgYXMgRXJyb3IsIHsgdXNlcklkIH0pO1xuICAgICAgXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY1N0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IChlcnJvciBhcyBFcnJvcikubWVzc2FnZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gUmUtdGhyb3cgZm9yIGNhbGxlciB0byBoYW5kbGVcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmVzIHVzZXIgc3RhdHMgdG8gRmlyZWJhc2VcbiAgICogXG4gICAqIEBwYXJhbSB1c2VySWQgLSBVc2VyIGlkZW50aWZpZXJcbiAgICogQHBhcmFtIHVwZGF0ZXMgLSBQYXJ0aWFsIHVzZXIgc3RhdHMgdG8gdXBkYXRlXG4gICAqL1xuICBzYXZlVXNlclN0YXRzOiBhc3luYyAodXNlcklkLCB1cGRhdGVzKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCkuc2V0Q29udGV4dCgnUHJvZ3Jlc3NTbGljZScpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1NhdmluZyB1c2VyIHN0YXRzIHRvIEZpcmViYXNlJywgeyB1c2VySWQsIHVwZGF0ZXMgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGdldFByb2dyZXNzU2VydmljZSgpLnVwZGF0ZVVzZXJTdGF0cyh1c2VySWQsIHVwZGF0ZXMpO1xuICAgICAgXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICBpZiAoc3RhdGUucHJvZ3Jlc3MudXNlclN0YXRzKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5wcm9ncmVzcy51c2VyU3RhdHMsIHVwZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnByb2dyZXNzLnVzZXJTdGF0cyA9IHsgdXNlcklkLCAuLi51cGRhdGVzIH0gYXMgVXNlclN0YXRzO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLmxhc3RTeW5jID0gRGF0ZS5ub3coKTtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY0Vycm9yID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoJ1VzZXIgc3RhdHMgc2F2ZWQgc3VjY2Vzc2Z1bGx5JywgeyB1c2VySWQgfSk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gc2F2ZSB1c2VyIHN0YXRzJywgZXJyb3IgYXMgRXJyb3IsIHsgdXNlcklkIH0pO1xuICAgICAgXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNTdGF0dXMgPSAnZXJyb3InO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jRXJyb3IgPSAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2U7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYXZlcyBjYXJkIHByb2dyZXNzIHRvIEZpcmViYXNlXG4gICAqIFxuICAgKiBAcGFyYW0gdXNlcklkIC0gVXNlciBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSBwb3NpdGlvbklkIC0gUG9zaXRpb24gaWRlbnRpZmllclxuICAgKiBAcGFyYW0gcHJvZ3Jlc3MgLSBDb21wbGV0ZSBjYXJkIHByb2dyZXNzIG9iamVjdFxuICAgKi9cbiAgc2F2ZUNhcmRQcm9ncmVzczogYXN5bmMgKHVzZXJJZCwgcG9zaXRpb25JZCwgcHJvZ3Jlc3MpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KCdQcm9ncmVzc1NsaWNlJyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2F2aW5nIGNhcmQgcHJvZ3Jlc3MgdG8gRmlyZWJhc2UnLCB7IHVzZXJJZCwgcG9zaXRpb25JZCB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgZ2V0UHJvZ3Jlc3NTZXJ2aWNlKCkudXBzZXJ0Q2FyZFByb2dyZXNzKHVzZXJJZCwgcG9zaXRpb25JZCwgcHJvZ3Jlc3MpO1xuICAgICAgXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5jYXJkUHJvZ3Jlc3NbcG9zaXRpb25JZF0gPSBwcm9ncmVzcztcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3MubGFzdFN5bmMgPSBEYXRlLm5vdygpO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jRXJyb3IgPSBudWxsO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGxvZ2dlci5kZWJ1ZygnQ2FyZCBwcm9ncmVzcyBzYXZlZCBzdWNjZXNzZnVsbHknLCB7IHVzZXJJZCwgcG9zaXRpb25JZCB9KTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIGNhcmQgcHJvZ3Jlc3MnLCBlcnJvciBhcyBFcnJvciwgeyB1c2VySWQsIHBvc2l0aW9uSWQgfSk7XG4gICAgICBcbiAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY1N0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IChlcnJvciBhcyBFcnJvcikubWVzc2FnZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhdmVzIHNlc3Npb24gY29tcGxldGlvbiBkYXRhICh1c2VyIHN0YXRzICsgbXVsdGlwbGUgY2FyZCB1cGRhdGVzKSBhdG9taWNhbGx5XG4gICAqIFxuICAgKiBAcGFyYW0gdXNlcklkIC0gVXNlciBpZGVudGlmaWVyXG4gICAqIEBwYXJhbSBzZXNzaW9uU3RhdHMgLSBQYXJ0aWFsIHVzZXIgc3RhdHMgdXBkYXRlc1xuICAgKiBAcGFyYW0gY2FyZFVwZGF0ZXMgLSBBcnJheSBvZiBjYXJkIHByb2dyZXNzIHVwZGF0ZXNcbiAgICovXG4gIHNhdmVTZXNzaW9uQ29tcGxldGU6IGFzeW5jICh1c2VySWQsIHNlc3Npb25TdGF0cywgY2FyZFVwZGF0ZXMpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBnZXRMb2dnZXIoKS5zZXRDb250ZXh0KCdQcm9ncmVzc1NsaWNlJyk7XG4gICAgXG4gICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucHJvZ3Jlc3MubG9hZGluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gJ3N5bmNpbmcnO1xuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlci5kZWJ1ZygnU2F2aW5nIHNlc3Npb24gY29tcGxldGlvbiB0byBGaXJlYmFzZScsIHsgXG4gICAgICAgIHVzZXJJZCwgXG4gICAgICAgIHNlc3Npb25TdGF0cywgXG4gICAgICAgIGNhcmRDb3VudDogY2FyZFVwZGF0ZXMubGVuZ3RoIFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IGdldFByb2dyZXNzU2VydmljZSgpLnVwZGF0ZVByb2dyZXNzVHJhbnNhY3Rpb24oXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgc2Vzc2lvblN0YXRzLFxuICAgICAgICBjYXJkVXBkYXRlc1xuICAgICAgKTtcbiAgICAgIFxuICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBPcHRpbWlzdGljYWxseSB1cGRhdGUgbG9jYWwgc3RhdGVcbiAgICAgICAgaWYgKHN0YXRlLnByb2dyZXNzLnVzZXJTdGF0cykge1xuICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3RhdGUucHJvZ3Jlc3MudXNlclN0YXRzLCBzZXNzaW9uU3RhdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLnByb2dyZXNzLnVzZXJTdGF0cyA9IHsgdXNlcklkLCAuLi5zZXNzaW9uU3RhdHMgfSBhcyBVc2VyU3RhdHM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBjYXJkIHByb2dyZXNzZXNcbiAgICAgICAgZm9yIChjb25zdCB7IHBvc2l0aW9uSWQsIHByb2dyZXNzIH0gb2YgY2FyZFVwZGF0ZXMpIHtcbiAgICAgICAgICBzdGF0ZS5wcm9ncmVzcy5jYXJkUHJvZ3Jlc3NbcG9zaXRpb25JZF0gPSBwcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3MubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gJ2lkbGUnO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5sYXN0U3luYyA9IERhdGUubm93KCk7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ1Nlc3Npb24gY29tcGxldGlvbiBzYXZlZCBzdWNjZXNzZnVsbHknLCB7IFxuICAgICAgICB1c2VySWQsIFxuICAgICAgICBjYXJkQ291bnQ6IGNhcmRVcGRhdGVzLmxlbmd0aCBcbiAgICAgIH0pO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlci5lcnJvcignRmFpbGVkIHRvIHNhdmUgc2Vzc2lvbiBjb21wbGV0aW9uJywgZXJyb3IgYXMgRXJyb3IsIHsgdXNlcklkIH0pO1xuICAgICAgXG4gICAgICBzZXQoKHN0YXRlKSA9PiB7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY1N0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IChlcnJvciBhcyBFcnJvcikubWVzc2FnZTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldHMgY2FyZHMgZHVlIGZvciByZXZpZXcgZnJvbSBGaXJlYmFzZVxuICAgKiBcbiAgICogQHBhcmFtIHVzZXJJZCAtIFVzZXIgaWRlbnRpZmllclxuICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhcnJheSBvZiBkdWUgY2FyZHNcbiAgICovXG4gIGdldER1ZUNhcmRzOiBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCkuc2V0Q29udGV4dCgnUHJvZ3Jlc3NTbGljZScpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ0dldHRpbmcgZHVlIGNhcmRzIGZyb20gRmlyZWJhc2UnLCB7IHVzZXJJZCB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgZHVlQ2FyZHMgPSBhd2FpdCBnZXRQcm9ncmVzc1NlcnZpY2UoKS5nZXREdWVDYXJkUHJvZ3Jlc3Nlcyh1c2VySWQpO1xuICAgICAgXG4gICAgICBsb2dnZXIuZGVidWcoJ0R1ZSBjYXJkcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5JywgeyBcbiAgICAgICAgdXNlcklkLCBcbiAgICAgICAgZHVlQ291bnQ6IGR1ZUNhcmRzLmxlbmd0aCBcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gZHVlQ2FyZHM7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nZ2VyLmVycm9yKCdGYWlsZWQgdG8gZ2V0IGR1ZSBjYXJkcycsIGVycm9yIGFzIEVycm9yLCB7IHVzZXJJZCB9KTtcbiAgICAgIFxuICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gJ2Vycm9yJztcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY0Vycm9yID0gKGVycm9yIGFzIEVycm9yKS5tZXNzYWdlO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU3luY3MgYWxsIHByb2dyZXNzIGRhdGEgdG8gRmlyZWJhc2UgKGZ1bGwgdXBsb2FkKVxuICAgKiBcbiAgICogQHBhcmFtIHVzZXJJZCAtIFVzZXIgaWRlbnRpZmllclxuICAgKi9cbiAgc3luY0FsbFByb2dyZXNzOiBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgY29uc3QgbG9nZ2VyID0gZ2V0TG9nZ2VyKCkuc2V0Q29udGV4dCgnUHJvZ3Jlc3NTbGljZScpO1xuICAgIFxuICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnByb2dyZXNzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgc3RhdGUucHJvZ3Jlc3Muc3luY1N0YXR1cyA9ICdzeW5jaW5nJztcbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBsb2dnZXIuZGVidWcoJ1N5bmNpbmcgYWxsIHByb2dyZXNzIHRvIEZpcmViYXNlJywgeyB1c2VySWQgfSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjdXJyZW50IHN0YXRlXG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXQoKS5wcm9ncmVzcztcbiAgICAgIFxuICAgICAgLy8gUHJlcGFyZSBiYXRjaCB1cGRhdGVzXG4gICAgICBjb25zdCBjYXJkVXBkYXRlcyA9IE9iamVjdC5lbnRyaWVzKGN1cnJlbnRTdGF0ZS5jYXJkUHJvZ3Jlc3MpLm1hcChcbiAgICAgICAgKFtwb3NpdGlvbklkLCBwcm9ncmVzc10pID0+ICh7IHBvc2l0aW9uSWQsIHByb2dyZXNzOiBwcm9ncmVzcyBhcyBDYXJkUHJvZ3Jlc3MgfSlcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFVzZSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgZXZlcnl0aGluZyBhdG9taWNhbGx5XG4gICAgICBhd2FpdCBnZXRQcm9ncmVzc1NlcnZpY2UoKS51cGRhdGVQcm9ncmVzc1RyYW5zYWN0aW9uKFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIGN1cnJlbnRTdGF0ZS51c2VyU3RhdHMgfHwgeyB1c2VySWQgfSxcbiAgICAgICAgY2FyZFVwZGF0ZXNcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHNldCgoc3RhdGUpID0+IHtcbiAgICAgICAgc3RhdGUucHJvZ3Jlc3MubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jU3RhdHVzID0gJ2lkbGUnO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5sYXN0U3luYyA9IERhdGUubm93KCk7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNFcnJvciA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgbG9nZ2VyLmluZm8oJ0FsbCBwcm9ncmVzcyBzeW5jZWQgc3VjY2Vzc2Z1bGx5JywgeyBcbiAgICAgICAgdXNlcklkLCBcbiAgICAgICAgY2FyZENvdW50OiBjYXJkVXBkYXRlcy5sZW5ndGggXG4gICAgICB9KTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBzeW5jIGFsbCBwcm9ncmVzcycsIGVycm9yIGFzIEVycm9yLCB7IHVzZXJJZCB9KTtcbiAgICAgIFxuICAgICAgc2V0KChzdGF0ZSkgPT4ge1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnByb2dyZXNzLnN5bmNTdGF0dXMgPSAnZXJyb3InO1xuICAgICAgICBzdGF0ZS5wcm9ncmVzcy5zeW5jRXJyb3IgPSAoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2U7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9LFxufSk7Il0sIm5hbWVzIjpbImNyZWF0ZVByb2dyZXNzU2xpY2UiLCJpbml0aWFsUHJvZ3Jlc3NTdGF0ZSIsInByb2dyZXNzU2VydmljZSIsImdldFByb2dyZXNzU2VydmljZSIsImRiIiwicmVxdWlyZSIsIlByb2dyZXNzU2VydmljZSIsInVzZXJTdGF0cyIsInNlc3Npb25Qcm9ncmVzcyIsInBvc2l0aW9uc0NvbXBsZXRlZCIsInBvc2l0aW9uc0NvcnJlY3QiLCJwb3NpdGlvbnNBdHRlbXB0ZWQiLCJ0aW1lU3BlbnQiLCJoaW50c1VzZWQiLCJtaXN0YWtlc01hZGUiLCJjYXJkUHJvZ3Jlc3MiLCJsb2FkaW5nIiwic3luY1N0YXR1cyIsImxhc3RTeW5jIiwic3luY0Vycm9yIiwic2V0IiwiZ2V0Iiwic2V0VXNlclN0YXRzIiwic3RhdHMiLCJzdGF0ZSIsInByb2dyZXNzIiwidXBkYXRlU2Vzc2lvblByb2dyZXNzIiwic2V0TG9hZGluZyIsInNldFN5bmNTdGF0dXMiLCJzdGF0dXMiLCJzZXRMYXN0U3luYyIsInRpbWVzdGFtcCIsInNldFN5bmNFcnJvciIsImVycm9yIiwiaW5pdGlhbGl6ZUNhcmRzIiwiY2FyZHMiLCJjYXJkTWFwIiwiY2FyZCIsImlkIiwicmVjb3JkQXR0ZW1wdCIsInBvc2l0aW9uSWQiLCJ3YXNDb3JyZWN0IiwibG9nZ2VyIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsInRyaW0iLCJ3YXJuIiwidHJpbW1lZElkIiwiZGVidWciLCJjcmVhdGVOZXdDYXJkIiwiRGF0ZSIsIm5vdyIsInF1YWxpdHkiLCJtYXBCaW5hcnlUb1F1YWxpdHkiLCJ1cGRhdGVkQ2FyZCIsInVwZGF0ZUNhcmRQcm9ncmVzcyIsIm9sZEludGVydmFsIiwiaW50ZXJ2YWwiLCJuZXdJbnRlcnZhbCIsIm9sZEVmYWN0b3IiLCJlZmFjdG9yIiwibmV3RWZhY3RvciIsIm5leHRSZXZpZXdBdCIsInRvSVNPU3RyaW5nIiwicmVzZXRDYXJkUHJvZ3Jlc3MiLCJyZXNldENhcmQiLCJzZXRDYXJkUHJvZ3Jlc3MiLCJiYXRjaFVwZGF0ZVByb2dyZXNzIiwidXBkYXRlcyIsIk9iamVjdCIsImFzc2lnbiIsInJlc2V0UHJvZ3Jlc3MiLCJsb2FkVXNlclByb2dyZXNzIiwidXNlcklkIiwic2VydmljZSIsImNhcmRQcm9ncmVzc2VzIiwiUHJvbWlzZSIsImFsbCIsImdldFVzZXJTdGF0cyIsImdldEFsbENhcmRQcm9ncmVzc2VzIiwiaW5mbyIsImhhc1N0YXRzIiwiY2FyZENvdW50IiwibGVuZ3RoIiwibWVzc2FnZSIsInNhdmVVc2VyU3RhdHMiLCJ1cGRhdGVVc2VyU3RhdHMiLCJzYXZlQ2FyZFByb2dyZXNzIiwidXBzZXJ0Q2FyZFByb2dyZXNzIiwic2F2ZVNlc3Npb25Db21wbGV0ZSIsInNlc3Npb25TdGF0cyIsImNhcmRVcGRhdGVzIiwidXBkYXRlUHJvZ3Jlc3NUcmFuc2FjdGlvbiIsImdldER1ZUNhcmRzIiwiZHVlQ2FyZHMiLCJnZXREdWVDYXJkUHJvZ3Jlc3NlcyIsImR1ZUNvdW50Iiwic3luY0FsbFByb2dyZXNzIiwiY3VycmVudFN0YXRlIiwiZW50cmllcyIsIm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkM7Ozs7Ozs7Ozs7O1FBa0RZQTtlQUFBQTs7UUF2QkFDO2VBQUFBOzs7d0JBeEJhO3lDQU1uQjtpQ0FDeUI7QUFFaEMsbUVBQW1FO0FBQ25FLElBQUlDLGtCQUEwQztBQUU5QyxNQUFNQyxxQkFBcUI7SUFDekIsSUFBSSxDQUFDRCxpQkFBaUI7UUFDcEIsMkRBQTJEO1FBQzNELE1BQU0sRUFBRUUsRUFBRSxFQUFFLEdBQUdDLFFBQVE7UUFDdkJILGtCQUFrQixJQUFJSSxnQ0FBZSxDQUFDRjtJQUN4QztJQUNBLE9BQU9GO0FBQ1Q7QUFLTyxNQUFNRCx1QkFBc0M7SUFDakQscUJBQXFCO0lBQ3JCTSxXQUFXO0lBQ1hDLGlCQUFpQjtRQUNmQyxvQkFBb0I7UUFDcEJDLGtCQUFrQjtRQUNsQkMsb0JBQW9CO1FBQ3BCQyxXQUFXO1FBQ1hDLFdBQVc7UUFDWEMsY0FBYztJQUNoQjtJQUNBQyxjQUFjLENBQUM7SUFFZixjQUFjO0lBQ2RDLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxVQUFVO0lBQ1ZDLFdBQVc7QUFDYjtBQUtPLE1BQU1uQixzQkFBd0QsQ0FBQ29CLEtBQUtDLE1BQVMsQ0FBQTtRQUNsRixHQUFHcEIsb0JBQW9CO1FBRXZCLGdCQUFnQjtRQUNoQnFCLGNBQWMsQ0FBQ0MsUUFBVUgsSUFBSSxDQUFDSTtnQkFDNUJBLE1BQU1DLFFBQVEsQ0FBQ2xCLFNBQVMsR0FBR2dCO1lBQzdCO1FBRUFHLHVCQUF1QixDQUFDRCxXQUFhTCxJQUFJLENBQUNJO2dCQUN4Q0EsTUFBTUMsUUFBUSxDQUFDakIsZUFBZSxHQUFHO29CQUMvQixHQUFHZ0IsTUFBTUMsUUFBUSxDQUFDakIsZUFBZTtvQkFDakMsR0FBR2lCLFFBQVE7Z0JBQ2I7WUFDRjtRQUVBRSxZQUFZLENBQUNYLFVBQVlJLElBQUksQ0FBQ0k7Z0JBQzVCQSxNQUFNQyxRQUFRLENBQUNULE9BQU8sR0FBR0E7WUFDM0I7UUFFQVksZUFBZSxDQUFDQyxTQUFXVCxJQUFJLENBQUNJO2dCQUM5QkEsTUFBTUMsUUFBUSxDQUFDUixVQUFVLEdBQUdZO1lBQzlCO1FBRUFDLGFBQWEsQ0FBQ0MsWUFBY1gsSUFBSSxDQUFDSTtnQkFDL0JBLE1BQU1DLFFBQVEsQ0FBQ1AsUUFBUSxHQUFHYTtZQUM1QjtRQUVBQyxjQUFjLENBQUNDLFFBQVViLElBQUksQ0FBQ0k7Z0JBQzVCQSxNQUFNQyxRQUFRLENBQUNOLFNBQVMsR0FBR2M7WUFDN0I7UUFFQSwyQkFBMkI7UUFDM0JDLGlCQUFpQixDQUFDQyxRQUFVZixJQUFJLENBQUNJO2dCQUMvQixNQUFNWSxVQUF3QyxDQUFDO2dCQUMvQyxLQUFLLE1BQU1DLFFBQVFGLE1BQU87b0JBQ3hCQyxPQUFPLENBQUNDLEtBQUtDLEVBQUUsQ0FBQyxHQUFHRDtnQkFDckI7Z0JBQ0FiLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxHQUFHcUI7WUFDaEM7UUFFQUcsZUFBZSxDQUFDQyxZQUFZQyxhQUFlckIsSUFBSSxDQUFDSTtnQkFDOUMsTUFBTWtCLFNBQVNDLElBQUFBLGlCQUFTLElBQUdDLFVBQVUsQ0FBQztnQkFFdEMsc0JBQXNCO2dCQUN0QixJQUFJLENBQUNKLGNBQWMsT0FBT0EsZUFBZSxZQUFZQSxXQUFXSyxJQUFJLE9BQU8sSUFBSTtvQkFDN0VILE9BQU9JLElBQUksQ0FBQyxnREFBZ0Q7d0JBQUVOO29CQUFXO29CQUN6RTtnQkFDRjtnQkFFQSxNQUFNTyxZQUFZUCxXQUFXSyxJQUFJO2dCQUNqQyxJQUFJUixPQUFPYixNQUFNQyxRQUFRLENBQUNWLFlBQVksQ0FBQ2dDLFVBQVU7Z0JBRWpELElBQUksQ0FBQ1YsTUFBTTtvQkFDVCxnREFBZ0Q7b0JBQ2hESyxPQUFPTSxLQUFLLENBQUMsOEJBQThCO3dCQUFFUixZQUFZTzt3QkFBV047b0JBQVc7b0JBQy9FSixPQUFPWSxJQUFBQSxzQ0FBYSxFQUFDRixXQUFXRyxLQUFLQyxHQUFHO29CQUN4QzNCLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxDQUFDZ0MsVUFBVSxHQUFHVjtnQkFDM0M7Z0JBRUEsOEVBQThFO2dCQUM5RSxJQUFJO29CQUNGLE1BQU1lLFVBQVVDLElBQUFBLDJDQUFrQixFQUFDWjtvQkFDbkMsTUFBTWEsY0FBY0MsSUFBQUEsMkNBQWtCLEVBQUNsQixNQUFNZSxTQUFTRixLQUFLQyxHQUFHO29CQUM5RDNCLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxDQUFDZ0MsVUFBVSxHQUFHTztvQkFFekNaLE9BQU9NLEtBQUssQ0FBQyxtQ0FBbUM7d0JBQzlDUixZQUFZTzt3QkFDWk47d0JBQ0FXO3dCQUNBSSxhQUFhbkIsS0FBS29CLFFBQVE7d0JBQzFCQyxhQUFhSixZQUFZRyxRQUFRO3dCQUNqQ0UsWUFBWXRCLEtBQUt1QixPQUFPO3dCQUN4QkMsWUFBWVAsWUFBWU0sT0FBTzt3QkFDL0JFLGNBQWMsSUFBSVosS0FBS0ksWUFBWVEsWUFBWSxFQUFFQyxXQUFXO29CQUM5RDtnQkFDRixFQUFFLE9BQU85QixPQUFPO29CQUNkUyxPQUFPVCxLQUFLLENBQUMsa0NBQWtDO3dCQUFFTyxZQUFZTzt3QkFBV2Q7b0JBQU07Z0JBQzlFLGlFQUFpRTtnQkFDbkU7WUFDRjtRQUVBK0IsbUJBQW1CLENBQUN4QixhQUFlcEIsSUFBSSxDQUFDSTtnQkFDdEMsTUFBTWtCLFNBQVNDLElBQUFBLGlCQUFTLElBQUdDLFVBQVUsQ0FBQztnQkFFdEMsSUFBSSxDQUFDSixjQUFjLE9BQU9BLGVBQWUsWUFBWUEsV0FBV0ssSUFBSSxPQUFPLElBQUk7b0JBQzdFSCxPQUFPSSxJQUFJLENBQUMsb0RBQW9EO3dCQUFFTjtvQkFBVztvQkFDN0U7Z0JBQ0Y7Z0JBRUEsTUFBTU8sWUFBWVAsV0FBV0ssSUFBSTtnQkFDakMsSUFBSXJCLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxDQUFDZ0MsVUFBVSxFQUFFO29CQUMxQyx5RUFBeUU7b0JBQ3pFdkIsTUFBTUMsUUFBUSxDQUFDVixZQUFZLENBQUNnQyxVQUFVLEdBQUdrQixJQUFBQSwwQ0FBUyxFQUFDO3dCQUFFM0IsSUFBSVM7b0JBQVU7b0JBQ25FTCxPQUFPTSxLQUFLLENBQUMsMkNBQTJDO3dCQUFFUixZQUFZTztvQkFBVTtnQkFDbEYsT0FBTztvQkFDTEwsT0FBT00sS0FBSyxDQUFDLDRCQUE0Qjt3QkFBRVIsWUFBWU87b0JBQVU7Z0JBQ25FO1lBQ0Y7UUFFQW1CLGlCQUFpQixDQUFDMUIsWUFBWWYsV0FBYUwsSUFBSSxDQUFDSTtnQkFDOUMsTUFBTWtCLFNBQVNDLElBQUFBLGlCQUFTLElBQUdDLFVBQVUsQ0FBQztnQkFFdEMsSUFBSSxDQUFDSixjQUFjLE9BQU9BLGVBQWUsWUFBWUEsV0FBV0ssSUFBSSxPQUFPLElBQUk7b0JBQzdFSCxPQUFPSSxJQUFJLENBQUMsa0RBQWtEO3dCQUFFTjtvQkFBVztvQkFDM0U7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDZixZQUFZLE9BQU9BLGFBQWEsVUFBVTtvQkFDN0NpQixPQUFPSSxJQUFJLENBQUMsdURBQXVEO3dCQUFFTjt3QkFBWWY7b0JBQVM7b0JBQzFGO2dCQUNGO2dCQUVBLE1BQU1zQixZQUFZUCxXQUFXSyxJQUFJO2dCQUNqQ3JCLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxDQUFDZ0MsVUFBVSxHQUFHdEI7Z0JBQ3pDaUIsT0FBT00sS0FBSyxDQUFDLHFCQUFxQjtvQkFBRVIsWUFBWU87Z0JBQVU7WUFDNUQ7UUFFQSxtQ0FBbUM7UUFDbkNvQixxQkFBcUIsQ0FBQ0MsVUFBWWhELElBQUksQ0FBQ0k7Z0JBQ3JDLGlEQUFpRDtnQkFDakQsSUFBSTRDLFFBQVE3RCxTQUFTLEVBQUU7b0JBQ3JCLElBQUlpQixNQUFNQyxRQUFRLENBQUNsQixTQUFTLEVBQUU7d0JBQzVCOEQsT0FBT0MsTUFBTSxDQUFDOUMsTUFBTUMsUUFBUSxDQUFDbEIsU0FBUyxFQUFFNkQsUUFBUTdELFNBQVM7b0JBQzNELE9BQU87d0JBQ0wscUJBQXFCO3dCQUNyQmlCLE1BQU1DLFFBQVEsQ0FBQ2xCLFNBQVMsR0FBRzZELFFBQVE3RCxTQUFTO29CQUM5QztnQkFDRjtnQkFFQSx1REFBdUQ7Z0JBQ3ZELElBQUk2RCxRQUFRNUQsZUFBZSxFQUFFO29CQUMzQjZELE9BQU9DLE1BQU0sQ0FBQzlDLE1BQU1DLFFBQVEsQ0FBQ2pCLGVBQWUsRUFBRTRELFFBQVE1RCxlQUFlO2dCQUN2RTtnQkFFQSx5Q0FBeUM7Z0JBQ3pDLElBQUk0RCxRQUFRckQsWUFBWSxFQUFFO29CQUN4QnNELE9BQU9DLE1BQU0sQ0FBQzlDLE1BQU1DLFFBQVEsQ0FBQ1YsWUFBWSxFQUFFcUQsUUFBUXJELFlBQVk7Z0JBQ2pFO1lBQ0Y7UUFFQSx1QkFBdUI7UUFDdkJ3RCxlQUFlLElBQU1uRCxJQUFJLENBQUNJO2dCQUN4QixtREFBbUQ7Z0JBQ25ENkMsT0FBT0MsTUFBTSxDQUFDOUMsTUFBTUMsUUFBUSxFQUFFeEI7WUFDaEM7UUFFQSx3Q0FBd0M7UUFFeEM7Ozs7R0FJQyxHQUNEdUUsa0JBQWtCLE9BQU9DO1lBQ3ZCLE1BQU0vQixTQUFTQyxJQUFBQSxpQkFBUyxJQUFHQyxVQUFVLENBQUM7WUFFdEN4QixJQUFJLENBQUNJO2dCQUNIQSxNQUFNQyxRQUFRLENBQUNULE9BQU8sR0FBRztnQkFDekJRLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO2dCQUM1Qk8sTUFBTUMsUUFBUSxDQUFDTixTQUFTLEdBQUc7WUFDN0I7WUFFQSxJQUFJO2dCQUNGdUIsT0FBT00sS0FBSyxDQUFDLHVDQUF1QztvQkFBRXlCO2dCQUFPO2dCQUU3RCxzREFBc0Q7Z0JBQ3RELE1BQU1DLFVBQVV2RTtnQkFDaEIsTUFBTSxDQUFDSSxXQUFXb0UsZUFBZSxHQUFHLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQztvQkFDcERILFFBQVFJLFlBQVksQ0FBQ0w7b0JBQ3JCQyxRQUFRSyxvQkFBb0IsQ0FBQ047aUJBQzlCO2dCQUVEckQsSUFBSSxDQUFDSTtvQkFDSCxvQkFBb0I7b0JBQ3BCLElBQUlqQixXQUFXO3dCQUNiaUIsTUFBTUMsUUFBUSxDQUFDbEIsU0FBUyxHQUFHQTtvQkFDN0I7b0JBRUEseUJBQXlCO29CQUN6QixNQUFNNkIsVUFBd0MsQ0FBQztvQkFDL0MsS0FBSyxNQUFNQyxRQUFRc0MsZUFBZ0I7d0JBQ2pDdkMsT0FBTyxDQUFDQyxLQUFLQyxFQUFFLENBQUMsR0FBR0Q7b0JBQ3JCO29CQUNBYixNQUFNQyxRQUFRLENBQUNWLFlBQVksR0FBR3FCO29CQUU5QixxQkFBcUI7b0JBQ3JCWixNQUFNQyxRQUFRLENBQUNULE9BQU8sR0FBRztvQkFDekJRLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO29CQUM1Qk8sTUFBTUMsUUFBUSxDQUFDUCxRQUFRLEdBQUdnQyxLQUFLQyxHQUFHO29CQUNsQzNCLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHO2dCQUM3QjtnQkFFQXVCLE9BQU9zQyxJQUFJLENBQUMscUNBQXFDO29CQUMvQ1A7b0JBQ0FRLFVBQVUsQ0FBQyxDQUFDMUU7b0JBQ1oyRSxXQUFXUCxlQUFlUSxNQUFNO2dCQUNsQztZQUVGLEVBQUUsT0FBT2xELE9BQU87Z0JBQ2RTLE9BQU9ULEtBQUssQ0FBQyxnQ0FBZ0NBLE9BQWdCO29CQUFFd0M7Z0JBQU87Z0JBRXRFckQsSUFBSSxDQUFDSTtvQkFDSEEsTUFBTUMsUUFBUSxDQUFDVCxPQUFPLEdBQUc7b0JBQ3pCUSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztvQkFDNUJPLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHLEFBQUNjLE1BQWdCbUQsT0FBTztnQkFDckQ7Z0JBRUEsTUFBTW5ELE9BQU8sZ0NBQWdDO1lBQy9DO1FBQ0Y7UUFFQTs7Ozs7R0FLQyxHQUNEb0QsZUFBZSxPQUFPWixRQUFRTDtZQUM1QixNQUFNMUIsU0FBU0MsSUFBQUEsaUJBQVMsSUFBR0MsVUFBVSxDQUFDO1lBRXRDLElBQUk7Z0JBQ0ZGLE9BQU9NLEtBQUssQ0FBQyxpQ0FBaUM7b0JBQUV5QjtvQkFBUUw7Z0JBQVE7Z0JBRWhFLE1BQU1qRSxxQkFBcUJtRixlQUFlLENBQUNiLFFBQVFMO2dCQUVuRGhELElBQUksQ0FBQ0k7b0JBQ0gsb0NBQW9DO29CQUNwQyxJQUFJQSxNQUFNQyxRQUFRLENBQUNsQixTQUFTLEVBQUU7d0JBQzVCOEQsT0FBT0MsTUFBTSxDQUFDOUMsTUFBTUMsUUFBUSxDQUFDbEIsU0FBUyxFQUFFNkQ7b0JBQzFDLE9BQU87d0JBQ0w1QyxNQUFNQyxRQUFRLENBQUNsQixTQUFTLEdBQUc7NEJBQUVrRTs0QkFBUSxHQUFHTCxPQUFPO3dCQUFDO29CQUNsRDtvQkFDQTVDLE1BQU1DLFFBQVEsQ0FBQ1AsUUFBUSxHQUFHZ0MsS0FBS0MsR0FBRztvQkFDbEMzQixNQUFNQyxRQUFRLENBQUNOLFNBQVMsR0FBRztnQkFDN0I7Z0JBRUF1QixPQUFPTSxLQUFLLENBQUMsaUNBQWlDO29CQUFFeUI7Z0JBQU87WUFFekQsRUFBRSxPQUFPeEMsT0FBTztnQkFDZFMsT0FBT1QsS0FBSyxDQUFDLDZCQUE2QkEsT0FBZ0I7b0JBQUV3QztnQkFBTztnQkFFbkVyRCxJQUFJLENBQUNJO29CQUNIQSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztvQkFDNUJPLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHLEFBQUNjLE1BQWdCbUQsT0FBTztnQkFDckQ7Z0JBRUEsTUFBTW5EO1lBQ1I7UUFDRjtRQUVBOzs7Ozs7R0FNQyxHQUNEc0Qsa0JBQWtCLE9BQU9kLFFBQVFqQyxZQUFZZjtZQUMzQyxNQUFNaUIsU0FBU0MsSUFBQUEsaUJBQVMsSUFBR0MsVUFBVSxDQUFDO1lBRXRDLElBQUk7Z0JBQ0ZGLE9BQU9NLEtBQUssQ0FBQyxvQ0FBb0M7b0JBQUV5QjtvQkFBUWpDO2dCQUFXO2dCQUV0RSxNQUFNckMscUJBQXFCcUYsa0JBQWtCLENBQUNmLFFBQVFqQyxZQUFZZjtnQkFFbEVMLElBQUksQ0FBQ0k7b0JBQ0gsb0NBQW9DO29CQUNwQ0EsTUFBTUMsUUFBUSxDQUFDVixZQUFZLENBQUN5QixXQUFXLEdBQUdmO29CQUMxQ0QsTUFBTUMsUUFBUSxDQUFDUCxRQUFRLEdBQUdnQyxLQUFLQyxHQUFHO29CQUNsQzNCLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHO2dCQUM3QjtnQkFFQXVCLE9BQU9NLEtBQUssQ0FBQyxvQ0FBb0M7b0JBQUV5QjtvQkFBUWpDO2dCQUFXO1lBRXhFLEVBQUUsT0FBT1AsT0FBTztnQkFDZFMsT0FBT1QsS0FBSyxDQUFDLGdDQUFnQ0EsT0FBZ0I7b0JBQUV3QztvQkFBUWpDO2dCQUFXO2dCQUVsRnBCLElBQUksQ0FBQ0k7b0JBQ0hBLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO29CQUM1Qk8sTUFBTUMsUUFBUSxDQUFDTixTQUFTLEdBQUcsQUFBQ2MsTUFBZ0JtRCxPQUFPO2dCQUNyRDtnQkFFQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUE7Ozs7OztHQU1DLEdBQ0R3RCxxQkFBcUIsT0FBT2hCLFFBQVFpQixjQUFjQztZQUNoRCxNQUFNakQsU0FBU0MsSUFBQUEsaUJBQVMsSUFBR0MsVUFBVSxDQUFDO1lBRXRDeEIsSUFBSSxDQUFDSTtnQkFDSEEsTUFBTUMsUUFBUSxDQUFDVCxPQUFPLEdBQUc7Z0JBQ3pCUSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztZQUM5QjtZQUVBLElBQUk7Z0JBQ0Z5QixPQUFPTSxLQUFLLENBQUMseUNBQXlDO29CQUNwRHlCO29CQUNBaUI7b0JBQ0FSLFdBQVdTLFlBQVlSLE1BQU07Z0JBQy9CO2dCQUVBLE1BQU1oRixxQkFBcUJ5Rix5QkFBeUIsQ0FDbERuQixRQUNBaUIsY0FDQUM7Z0JBR0Z2RSxJQUFJLENBQUNJO29CQUNILG9DQUFvQztvQkFDcEMsSUFBSUEsTUFBTUMsUUFBUSxDQUFDbEIsU0FBUyxFQUFFO3dCQUM1QjhELE9BQU9DLE1BQU0sQ0FBQzlDLE1BQU1DLFFBQVEsQ0FBQ2xCLFNBQVMsRUFBRW1GO29CQUMxQyxPQUFPO3dCQUNMbEUsTUFBTUMsUUFBUSxDQUFDbEIsU0FBUyxHQUFHOzRCQUFFa0U7NEJBQVEsR0FBR2lCLFlBQVk7d0JBQUM7b0JBQ3ZEO29CQUVBLHlCQUF5QjtvQkFDekIsS0FBSyxNQUFNLEVBQUVsRCxVQUFVLEVBQUVmLFFBQVEsRUFBRSxJQUFJa0UsWUFBYTt3QkFDbERuRSxNQUFNQyxRQUFRLENBQUNWLFlBQVksQ0FBQ3lCLFdBQVcsR0FBR2Y7b0JBQzVDO29CQUVBRCxNQUFNQyxRQUFRLENBQUNULE9BQU8sR0FBRztvQkFDekJRLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO29CQUM1Qk8sTUFBTUMsUUFBUSxDQUFDUCxRQUFRLEdBQUdnQyxLQUFLQyxHQUFHO29CQUNsQzNCLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHO2dCQUM3QjtnQkFFQXVCLE9BQU9zQyxJQUFJLENBQUMseUNBQXlDO29CQUNuRFA7b0JBQ0FTLFdBQVdTLFlBQVlSLE1BQU07Z0JBQy9CO1lBRUYsRUFBRSxPQUFPbEQsT0FBTztnQkFDZFMsT0FBT1QsS0FBSyxDQUFDLHFDQUFxQ0EsT0FBZ0I7b0JBQUV3QztnQkFBTztnQkFFM0VyRCxJQUFJLENBQUNJO29CQUNIQSxNQUFNQyxRQUFRLENBQUNULE9BQU8sR0FBRztvQkFDekJRLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO29CQUM1Qk8sTUFBTUMsUUFBUSxDQUFDTixTQUFTLEdBQUcsQUFBQ2MsTUFBZ0JtRCxPQUFPO2dCQUNyRDtnQkFFQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUE7Ozs7O0dBS0MsR0FDRDRELGFBQWEsT0FBT3BCO1lBQ2xCLE1BQU0vQixTQUFTQyxJQUFBQSxpQkFBUyxJQUFHQyxVQUFVLENBQUM7WUFFdEMsSUFBSTtnQkFDRkYsT0FBT00sS0FBSyxDQUFDLG1DQUFtQztvQkFBRXlCO2dCQUFPO2dCQUV6RCxNQUFNcUIsV0FBVyxNQUFNM0YscUJBQXFCNEYsb0JBQW9CLENBQUN0QjtnQkFFakUvQixPQUFPTSxLQUFLLENBQUMsb0NBQW9DO29CQUMvQ3lCO29CQUNBdUIsVUFBVUYsU0FBU1gsTUFBTTtnQkFDM0I7Z0JBRUEsT0FBT1c7WUFFVCxFQUFFLE9BQU83RCxPQUFPO2dCQUNkUyxPQUFPVCxLQUFLLENBQUMsMkJBQTJCQSxPQUFnQjtvQkFBRXdDO2dCQUFPO2dCQUVqRXJELElBQUksQ0FBQ0k7b0JBQ0hBLE1BQU1DLFFBQVEsQ0FBQ1IsVUFBVSxHQUFHO29CQUM1Qk8sTUFBTUMsUUFBUSxDQUFDTixTQUFTLEdBQUcsQUFBQ2MsTUFBZ0JtRCxPQUFPO2dCQUNyRDtnQkFFQSxNQUFNbkQ7WUFDUjtRQUNGO1FBRUE7Ozs7R0FJQyxHQUNEZ0UsaUJBQWlCLE9BQU94QjtZQUN0QixNQUFNL0IsU0FBU0MsSUFBQUEsaUJBQVMsSUFBR0MsVUFBVSxDQUFDO1lBRXRDeEIsSUFBSSxDQUFDSTtnQkFDSEEsTUFBTUMsUUFBUSxDQUFDVCxPQUFPLEdBQUc7Z0JBQ3pCUSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztZQUM5QjtZQUVBLElBQUk7Z0JBQ0Z5QixPQUFPTSxLQUFLLENBQUMsb0NBQW9DO29CQUFFeUI7Z0JBQU87Z0JBRTFELG9CQUFvQjtnQkFDcEIsTUFBTXlCLGVBQWU3RSxNQUFNSSxRQUFRO2dCQUVuQyx3QkFBd0I7Z0JBQ3hCLE1BQU1rRSxjQUFjdEIsT0FBTzhCLE9BQU8sQ0FBQ0QsYUFBYW5GLFlBQVksRUFBRXFGLEdBQUcsQ0FDL0QsQ0FBQyxDQUFDNUQsWUFBWWYsU0FBUyxHQUFNLENBQUE7d0JBQUVlO3dCQUFZZixVQUFVQTtvQkFBeUIsQ0FBQTtnQkFHaEYsa0RBQWtEO2dCQUNsRCxNQUFNdEIscUJBQXFCeUYseUJBQXlCLENBQ2xEbkIsUUFDQXlCLGFBQWEzRixTQUFTLElBQUk7b0JBQUVrRTtnQkFBTyxHQUNuQ2tCO2dCQUdGdkUsSUFBSSxDQUFDSTtvQkFDSEEsTUFBTUMsUUFBUSxDQUFDVCxPQUFPLEdBQUc7b0JBQ3pCUSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztvQkFDNUJPLE1BQU1DLFFBQVEsQ0FBQ1AsUUFBUSxHQUFHZ0MsS0FBS0MsR0FBRztvQkFDbEMzQixNQUFNQyxRQUFRLENBQUNOLFNBQVMsR0FBRztnQkFDN0I7Z0JBRUF1QixPQUFPc0MsSUFBSSxDQUFDLG9DQUFvQztvQkFDOUNQO29CQUNBUyxXQUFXUyxZQUFZUixNQUFNO2dCQUMvQjtZQUVGLEVBQUUsT0FBT2xELE9BQU87Z0JBQ2RTLE9BQU9ULEtBQUssQ0FBQywrQkFBK0JBLE9BQWdCO29CQUFFd0M7Z0JBQU87Z0JBRXJFckQsSUFBSSxDQUFDSTtvQkFDSEEsTUFBTUMsUUFBUSxDQUFDVCxPQUFPLEdBQUc7b0JBQ3pCUSxNQUFNQyxRQUFRLENBQUNSLFVBQVUsR0FBRztvQkFDNUJPLE1BQU1DLFFBQVEsQ0FBQ04sU0FBUyxHQUFHLEFBQUNjLE1BQWdCbUQsT0FBTztnQkFDckQ7Z0JBRUEsTUFBTW5EO1lBQ1I7UUFDRjtJQUNGLENBQUEifQ==