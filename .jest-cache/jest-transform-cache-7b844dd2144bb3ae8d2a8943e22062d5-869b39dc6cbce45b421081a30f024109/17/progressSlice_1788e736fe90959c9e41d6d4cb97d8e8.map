{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/slices/progressSlice.ts"],"sourcesContent":["/**\n * @file Progress slice for user progress tracking and statistics\n * @description Manages user progress data, session statistics, and sync status\n * \n * @example\n * ```typescript\n * // Using state\n * const { userStats, syncStatus } = useProgressState();\n * \n * // Using actions only (no re-renders)\n * const actions = useProgressActions();\n * actions.updateSessionProgress({ positionsCompleted: 1 });\n * \n * // Using both\n * const [state, actions] = useProgressStore();\n * ```\n */\n\nimport type { ImmerStateCreator, ProgressSlice, ProgressState, UserStats, CardProgress } from './types';\nimport { getLogger } from '@shared/services/logging/Logger';\nimport { \n  updateCardProgress, \n  mapBinaryToQuality,\n  createNewCard,\n  resetCardProgress as resetCard\n} from '@shared/services/SpacedRepetitionService';\nimport { ProgressService } from '@shared/services/ProgressService';\n\n// Lazy initialization to avoid Firebase issues in test environment\nlet progressService: ProgressService | null = null;\n\nconst getProgressService = (): ProgressService => {\n  if (!progressService) {\n    // Dynamic import to avoid Firebase initialization in tests\n    const { db } = require('@/firebase/firebase');\n    progressService = new ProgressService(db);\n  }\n  return progressService;\n};\n\n/**\n * Initial state for progress slice\n */\nexport const initialProgressState: ProgressState = {\n  // Core progress data\n  userStats: null,\n  sessionProgress: {\n    positionsCompleted: 0,\n    positionsCorrect: 0,\n    positionsAttempted: 0,\n    timeSpent: 0,\n    hintsUsed: 0,\n    mistakesMade: 0,\n  },\n  cardProgress: {}, // Empty map initially\n  \n  // Sync status\n  loading: false,\n  syncStatus: 'idle',\n  lastSync: null,\n  syncError: null,\n};\n\n/**\n * Creates the progress slice with Immer middleware for immutable updates\n */\nexport const createProgressSlice: ImmerStateCreator<ProgressSlice> = (set, get) => ({\n  ...initialProgressState,\n\n  // State setters\n  setUserStats: (stats) => set((state) => {\n    state.progress.userStats = stats;\n  }),\n\n  updateSessionProgress: (progress) => set((state) => {\n    state.progress.sessionProgress = {\n      ...state.progress.sessionProgress,\n      ...progress,\n    };\n  }),\n\n  setLoading: (loading) => set((state) => {\n    state.progress.loading = loading;\n  }),\n\n  setSyncStatus: (status) => set((state) => {\n    state.progress.syncStatus = status;\n  }),\n\n  setLastSync: (timestamp) => set((state) => {\n    state.progress.lastSync = timestamp;\n  }),\n\n  setSyncError: (error) => set((state) => {\n    state.progress.syncError = error;\n  }),\n\n  // Card progress management\n  initializeCards: (cards) => set((state) => {\n    const cardMap: Record<string, CardProgress> = {};\n    for (const card of cards) {\n      cardMap[card.id] = card;\n    }\n    state.progress.cardProgress = cardMap;\n  }),\n\n  recordAttempt: (positionId, wasCorrect) => set((state) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    // Validate positionId\n    if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {\n      logger.warn('Invalid positionId provided to recordAttempt', { positionId });\n      return;\n    }\n    \n    const trimmedId = positionId.trim();\n    let card = state.progress.cardProgress[trimmedId];\n    \n    if (!card) {\n      // Create new card using SpacedRepetitionService\n      logger.debug('Creating new card progress', { positionId: trimmedId, wasCorrect });\n      card = createNewCard(trimmedId, Date.now());\n      state.progress.cardProgress[trimmedId] = card;\n    }\n    \n    // Update card using SpacedRepetitionService with proper SuperMemo-2 algorithm\n    try {\n      const quality = mapBinaryToQuality(wasCorrect);\n      const updatedCard = updateCardProgress(card, quality, Date.now());\n      state.progress.cardProgress[trimmedId] = updatedCard;\n      \n      logger.debug('Updated card progress with SM-2', { \n        positionId: trimmedId, \n        wasCorrect,\n        quality,\n        oldInterval: card.interval,\n        newInterval: updatedCard.interval,\n        oldEfactor: card.efactor,\n        newEfactor: updatedCard.efactor,\n        nextReviewAt: new Date(updatedCard.nextReviewAt).toISOString()\n      });\n    } catch (error) {\n      logger.error('Failed to update card progress', { positionId: trimmedId, error });\n      // Fallback: keep the card unchanged rather than corrupting state\n    }\n  }),\n\n  resetCardProgress: (positionId) => set((state) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {\n      logger.warn('Invalid positionId provided to resetCardProgress', { positionId });\n      return;\n    }\n    \n    const trimmedId = positionId.trim();\n    if (state.progress.cardProgress[trimmedId]) {\n      // Use SpacedRepetitionService to create a fresh card instead of deleting\n      state.progress.cardProgress[trimmedId] = resetCard({ id: trimmedId });\n      logger.debug('Reset card progress using SM-2 defaults', { positionId: trimmedId });\n    } else {\n      logger.debug('Card not found for reset', { positionId: trimmedId });\n    }\n  }),\n\n  setCardProgress: (positionId, progress) => set((state) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    if (!positionId || typeof positionId !== 'string' || positionId.trim() === '') {\n      logger.warn('Invalid positionId provided to setCardProgress', { positionId });\n      return;\n    }\n    \n    if (!progress || typeof progress !== 'object') {\n      logger.warn('Invalid progress object provided to setCardProgress', { positionId, progress });\n      return;\n    }\n    \n    const trimmedId = positionId.trim();\n    state.progress.cardProgress[trimmedId] = progress;\n    logger.debug('Set card progress', { positionId: trimmedId });\n  }),\n\n  // Batch operations for performance\n  batchUpdateProgress: (updates) => set((state) => {\n    // Handle userStats - use Object.assign for Immer\n    if (updates.userStats) {\n      if (state.progress.userStats) {\n        Object.assign(state.progress.userStats, updates.userStats);\n      } else {\n        // Create new if null\n        state.progress.userStats = updates.userStats as UserStats;\n      }\n    }\n    \n    // Handle sessionProgress - use Object.assign for Immer\n    if (updates.sessionProgress) {\n      Object.assign(state.progress.sessionProgress, updates.sessionProgress);\n    }\n    \n    // Handle cardProgress - merge entire map\n    if (updates.cardProgress) {\n      Object.assign(state.progress.cardProgress, updates.cardProgress);\n    }\n  }),\n\n  // Reset progress state\n  resetProgress: () => set((state) => {\n    // Only reset the state properties, not the actions\n    Object.assign(state.progress, initialProgressState);\n  }),\n\n  // ===== ASYNC FIREBASE OPERATIONS =====\n\n  /**\n   * Loads user progress from Firebase\n   * \n   * @param userId - User identifier\n   */\n  loadUserProgress: async (userId) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    set((state) => {\n      state.progress.loading = true;\n      state.progress.syncStatus = 'syncing';\n      state.progress.syncError = null;\n    });\n\n    try {\n      logger.debug('Loading user progress from Firebase', { userId });\n      \n      // Load user stats and all card progresses in parallel\n      const service = getProgressService();\n      const [userStats, cardProgresses] = await Promise.all([\n        service.getUserStats(userId),\n        service.getAllCardProgresses(userId)\n      ]);\n\n      set((state) => {\n        // Update user stats\n        if (userStats) {\n          state.progress.userStats = userStats;\n        }\n        \n        // Update card progresses\n        const cardMap: Record<string, CardProgress> = {};\n        for (const card of cardProgresses) {\n          cardMap[card.id] = card;\n        }\n        state.progress.cardProgress = cardMap;\n        \n        // Update sync status\n        state.progress.loading = false;\n        state.progress.syncStatus = 'idle';\n        state.progress.lastSync = Date.now();\n        state.progress.syncError = null;\n      });\n      \n      logger.info('User progress loaded successfully', { \n        userId, \n        hasStats: !!userStats,\n        cardCount: cardProgresses.length \n      });\n\n    } catch (error) {\n      logger.error('Failed to load user progress', error as Error, { userId });\n      \n      set((state) => {\n        state.progress.loading = false;\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error; // Re-throw for caller to handle\n    }\n  },\n\n  /**\n   * Saves user stats to Firebase\n   * \n   * @param userId - User identifier\n   * @param updates - Partial user stats to update\n   */\n  saveUserStats: async (userId, updates) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    try {\n      logger.debug('Saving user stats to Firebase', { userId, updates });\n      \n      await getProgressService().updateUserStats(userId, updates);\n      \n      set((state) => {\n        // Optimistically update local state\n        if (state.progress.userStats) {\n          Object.assign(state.progress.userStats, updates);\n        } else {\n          state.progress.userStats = { userId, ...updates } as UserStats;\n        }\n        state.progress.lastSync = Date.now();\n        state.progress.syncError = null;\n      });\n      \n      logger.debug('User stats saved successfully', { userId });\n\n    } catch (error) {\n      logger.error('Failed to save user stats', error as Error, { userId });\n      \n      set((state) => {\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Saves card progress to Firebase\n   * \n   * @param userId - User identifier\n   * @param positionId - Position identifier\n   * @param progress - Complete card progress object\n   */\n  saveCardProgress: async (userId, positionId, progress) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    try {\n      logger.debug('Saving card progress to Firebase', { userId, positionId });\n      \n      await getProgressService().upsertCardProgress(userId, positionId, progress);\n      \n      set((state) => {\n        // Optimistically update local state\n        state.progress.cardProgress[positionId] = progress;\n        state.progress.lastSync = Date.now();\n        state.progress.syncError = null;\n      });\n      \n      logger.debug('Card progress saved successfully', { userId, positionId });\n\n    } catch (error) {\n      logger.error('Failed to save card progress', error as Error, { userId, positionId });\n      \n      set((state) => {\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Saves session completion data (user stats + multiple card updates) atomically\n   * \n   * @param userId - User identifier\n   * @param sessionStats - Partial user stats updates\n   * @param cardUpdates - Array of card progress updates\n   */\n  saveSessionComplete: async (userId, sessionStats, cardUpdates) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    set((state) => {\n      state.progress.loading = true;\n      state.progress.syncStatus = 'syncing';\n    });\n\n    try {\n      logger.debug('Saving session completion to Firebase', { \n        userId, \n        sessionStats, \n        cardCount: cardUpdates.length \n      });\n      \n      await getProgressService().updateProgressTransaction(\n        userId,\n        sessionStats,\n        cardUpdates\n      );\n      \n      set((state) => {\n        // Optimistically update local state\n        if (state.progress.userStats) {\n          Object.assign(state.progress.userStats, sessionStats);\n        } else {\n          state.progress.userStats = { userId, ...sessionStats } as UserStats;\n        }\n        \n        // Update card progresses\n        for (const { positionId, progress } of cardUpdates) {\n          state.progress.cardProgress[positionId] = progress;\n        }\n        \n        state.progress.loading = false;\n        state.progress.syncStatus = 'idle';\n        state.progress.lastSync = Date.now();\n        state.progress.syncError = null;\n      });\n      \n      logger.info('Session completion saved successfully', { \n        userId, \n        cardCount: cardUpdates.length \n      });\n\n    } catch (error) {\n      logger.error('Failed to save session completion', error as Error, { userId });\n      \n      set((state) => {\n        state.progress.loading = false;\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Gets cards due for review from Firebase\n   * \n   * @param userId - User identifier\n   * @returns Promise resolving to array of due cards\n   */\n  getDueCards: async (userId) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    try {\n      logger.debug('Getting due cards from Firebase', { userId });\n      \n      const dueCards = await getProgressService().getDueCardProgresses(userId);\n      \n      logger.debug('Due cards retrieved successfully', { \n        userId, \n        dueCount: dueCards.length \n      });\n      \n      return dueCards;\n\n    } catch (error) {\n      logger.error('Failed to get due cards', error as Error, { userId });\n      \n      set((state) => {\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error;\n    }\n  },\n\n  /**\n   * Syncs all progress data to Firebase (full upload)\n   * \n   * @param userId - User identifier\n   */\n  syncAllProgress: async (userId) => {\n    const logger = getLogger().setContext('ProgressSlice');\n    \n    set((state) => {\n      state.progress.loading = true;\n      state.progress.syncStatus = 'syncing';\n    });\n\n    try {\n      logger.debug('Syncing all progress to Firebase', { userId });\n      \n      // Get current state\n      const currentState = get().progress;\n      \n      // Prepare batch updates\n      const cardUpdates = Object.entries(currentState.cardProgress).map(\n        ([positionId, progress]) => ({ positionId, progress: progress as CardProgress })\n      );\n      \n      // Use transaction to update everything atomically\n      await getProgressService().updateProgressTransaction(\n        userId,\n        currentState.userStats || { userId },\n        cardUpdates\n      );\n      \n      set((state) => {\n        state.progress.loading = false;\n        state.progress.syncStatus = 'idle';\n        state.progress.lastSync = Date.now();\n        state.progress.syncError = null;\n      });\n      \n      logger.info('All progress synced successfully', { \n        userId, \n        cardCount: cardUpdates.length \n      });\n\n    } catch (error) {\n      logger.error('Failed to sync all progress', error as Error, { userId });\n      \n      set((state) => {\n        state.progress.loading = false;\n        state.progress.syncStatus = 'error';\n        state.progress.syncError = (error as Error).message;\n      });\n      \n      throw error;\n    }\n  },\n});"],"names":["createProgressSlice","initialProgressState","progressService","getProgressService","db","require","ProgressService","userStats","sessionProgress","positionsCompleted","positionsCorrect","positionsAttempted","timeSpent","hintsUsed","mistakesMade","cardProgress","loading","syncStatus","lastSync","syncError","set","get","setUserStats","stats","state","progress","updateSessionProgress","setLoading","setSyncStatus","status","setLastSync","timestamp","setSyncError","error","initializeCards","cards","cardMap","card","id","recordAttempt","positionId","wasCorrect","logger","getLogger","setContext","trim","warn","trimmedId","debug","createNewCard","Date","now","quality","mapBinaryToQuality","updatedCard","updateCardProgress","oldInterval","interval","newInterval","oldEfactor","efactor","newEfactor","nextReviewAt","toISOString","resetCardProgress","resetCard","setCardProgress","batchUpdateProgress","updates","Object","assign","resetProgress","loadUserProgress","userId","service","cardProgresses","Promise","all","getUserStats","getAllCardProgresses","info","hasStats","cardCount","length","message","saveUserStats","updateUserStats","saveCardProgress","upsertCardProgress","saveSessionComplete","sessionStats","cardUpdates","updateProgressTransaction","getDueCards","dueCards","getDueCardProgresses","dueCount","syncAllProgress","currentState","entries","map"],"mappings":"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"}