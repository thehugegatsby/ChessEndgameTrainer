74dd6708c076a424f7fe9a979111b3da
/**
 * @file Unit tests for refactored useLocalStorage hook
 * @description Tests the new fully async, ServiceContainer-compatible hook
 * Perfect Jest 30 compatibility - no global mocking required!
 */ "use strict";
// Mock logger
jest.mock("@shared/services/logging", ()=>({
        /**
   *
   */ getLogger: ()=>require("../../shared/logger-utils").createTestLogger()
    }));
// Mock the platform service module to use our test container
jest.mock("@shared/services/platform", ()=>({
        /**
   *
   */ getPlatformService: ()=>({
                storage: mockStorageService
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useLocalStorage = require("../../../shared/hooks/useLocalStorage");
const _utils = require("../../utils");
// Test container and mock service
let testContainer;
let mockStorageService;
describe("useLocalStorage Hook - Refactored Version", ()=>{
    const testKey = "test-key";
    const testValue = {
        count: 42,
        name: "test"
    };
    const testString = "simple string";
    beforeEach(()=>{
        // Create test container with mocked services
        testContainer = (0, _utils.createTestContainer)();
        mockStorageService = testContainer.resolve("platform.storage");
        // Reset all mocks
        jest.clearAllMocks();
    });
    describe("Async Hook - useLocalStorageWithState", ()=>{
        describe("Initialization", ()=>{
            test("should initialize with loading state", ()=>{
                jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
                const [value, setter, isLoading, saveError] = result.current;
                expect(value).toBeUndefined();
                expect(typeof setter).toBe("function");
                expect(isLoading).toBe(true);
                expect(saveError).toBeNull();
            });
            test("should load existing value from storage", async ()=>{
                jest.spyOn(mockStorageService, "load").mockResolvedValue(testValue);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, "default"));
                // Wait for async loading to complete
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false); // isLoading should be false
                });
                const [value, _setter, isLoading, saveError] = result.current;
                expect(value).toEqual(testValue);
                expect(isLoading).toBe(false);
                expect(saveError).toBeNull();
                expect(mockStorageService.load).toHaveBeenCalledWith(testKey);
            });
            test("should use initial value when storage is empty", async ()=>{
                jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                });
                const [value] = result.current;
                expect(value).toBe(testString);
            });
            test("should handle function-based initial value", async ()=>{
                const initialValueFn = jest.fn(()=>testValue);
                jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, initialValueFn));
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                });
                // Function may be called during hook execution and useEffect
                expect(initialValueFn).toHaveBeenCalled();
                expect(result.current[0]).toEqual(testValue);
            });
            test("should handle storage load errors gracefully", async ()=>{
                jest.spyOn(mockStorageService, "load").mockRejectedValue(new Error("Storage error"));
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                });
                const [value] = result.current;
                expect(value).toBe(testString);
            });
        });
        describe("Setting Values", ()=>{
            test("should update state and save to storage", async ()=>{
                jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
                jest.spyOn(mockStorageService, "save").mockResolvedValue(undefined);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
                // Wait for initialization
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                });
                const newValue = "updated value";
                (0, _react.act)(()=>{
                    result.current[1](newValue);
                });
                expect(result.current[0]).toBe(newValue);
                // Wait for save effect to trigger
                await (0, _react.waitFor)(()=>{
                    expect(mockStorageService.save).toHaveBeenCalledWith(testKey, newValue);
                });
            });
            test.skip("should handle function-based updates", async ()=>{
                jest.spyOn(mockStorageService, "load").mockResolvedValue({
                    count: 0
                });
                jest.spyOn(mockStorageService, "save").mockResolvedValue(undefined);
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, {
                        count: 0
                    }));
                // Wait for loading to complete step by step
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                }, {
                    timeout: 3000
                });
                // Then verify the loaded value
                await (0, _react.waitFor)(()=>{
                    expect(result.current[0]).toEqual({
                        count: 0
                    });
                });
                (0, _react.act)(()=>{
                    result.current[1]((prev)=>({
                            count: ((prev === null || prev === void 0 ? void 0 : prev.count) || 0) + 1
                        }));
                });
                expect(result.current[0]).toEqual({
                    count: 1
                });
                // Wait for save effect to trigger
                await (0, _react.waitFor)(()=>{
                    expect(mockStorageService.save).toHaveBeenCalledWith(testKey, {
                        count: 1
                    });
                });
            });
            test("should handle save errors by setting error state", async ()=>{
                var _result_current_;
                jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
                jest.spyOn(mockStorageService, "save").mockRejectedValue(new Error("Save failed"));
                const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
                await (0, _react.waitFor)(()=>{
                    expect(result.current[2]).toBe(false);
                    expect(result.current[0]).toBe(testString);
                });
                // Set a new value (synchronous)
                (0, _react.act)(()=>{
                    result.current[1]("new value");
                });
                // Should immediately show optimistic update
                expect(result.current[0]).toBe("new value");
                // Wait for save effect to fail and set error state
                await (0, _react.waitFor)(()=>{
                    expect(result.current[3]).not.toBeNull();
                });
                // Verify the error and that optimistic state was preserved
                expect(result.current[3]).toBeInstanceOf(Error);
                expect((_result_current_ = result.current[3]) === null || _result_current_ === void 0 ? void 0 : _result_current_.message).toBe("Save failed");
                expect(result.current[0]).toBe("new value");
            });
        });
        describe("Component Lifecycle", ()=>{
            test("should not update state after unmount", async ()=>{
                jest.spyOn(mockStorageService, "load").mockImplementation(()=>new Promise((resolve)=>setTimeout(()=>resolve(testValue), 100)));
                const { result, unmount } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, "default"));
                // Unmount before async load completes
                unmount();
                // Wait longer than the mock delay
                await new Promise((resolve)=>setTimeout(resolve, 150));
                // Should still be in initial state since component was unmounted
                expect(result.current[2]).toBe(true); // Still loading
                expect(result.current[0]).toBeUndefined();
            });
        });
    });
    describe("useLocalStorageWithState Hook", ()=>{
        test("should provide state-based interface", async ()=>{
            jest.spyOn(mockStorageService, "load").mockResolvedValue(testValue);
            const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, "default"));
            // Should start with loading state
            expect(result.current[0]).toBe(undefined);
            // Wait for async load to complete
            await (0, _react.waitFor)(()=>{
                expect(result.current[0]).toEqual(testValue);
            });
        });
        test("should maintain useState-like API", async ()=>{
            jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
            jest.spyOn(mockStorageService, "save").mockResolvedValue(undefined);
            const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, testString));
            // Wait for initialization
            await (0, _react.waitFor)(()=>{
                expect(result.current[0]).toBe(testString);
            });
            // Should have state API
            const [value, setValue] = result.current;
            expect(typeof value).toBe("string");
            expect(typeof setValue).toBe("function");
        });
    });
    describe("ServiceContainer Integration", ()=>{
        test("should use only platform service for storage operations", async ()=>{
            jest.spyOn(mockStorageService, "load").mockResolvedValue(testValue);
            jest.spyOn(mockStorageService, "save").mockResolvedValue(undefined);
            const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, "initial"));
            await (0, _react.waitFor)(()=>{
                expect(result.current[2]).toBe(false);
            });
            await (0, _react.act)(async ()=>{
                await result.current[1]("updated");
            });
            // Verify ONLY platform service was used
            expect(mockStorageService.load).toHaveBeenCalledWith(testKey);
            expect(mockStorageService.save).toHaveBeenCalledWith(testKey, "updated");
            // No window.localStorage access at all!
            expect(jest.isMockFunction(mockStorageService.load)).toBe(true);
            expect(jest.isMockFunction(mockStorageService.save)).toBe(true);
        });
        test("should provide perfect test isolation", async ()=>{
            // Each test gets fresh container and fresh mocks
            const container1 = (0, _utils.createTestContainer)();
            const storage1 = container1.resolve("platform.storage");
            const container2 = (0, _utils.createTestContainer)();
            const storage2 = container2.resolve("platform.storage");
            // Different containers = different service instances
            expect(storage1).not.toBe(storage2);
            // Both should be working mock instances
            expect(typeof storage1.load).toBe("function");
            expect(typeof storage2.save).toBe("function");
        });
        test("should support Jest 30 compatible testing", async ()=>{
            // This test validates Jest 30 compatibility
            // ✅ No global window.localStorage mocking required
            // ✅ No Object.defineProperty usage
            // ✅ Pure dependency injection through ServiceContainer
            // ✅ Perfect mock isolation per test
            jest.spyOn(mockStorageService, "load").mockResolvedValue("test-data");
            const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)("test", "default"));
            await (0, _react.waitFor)(()=>{
                expect(result.current[2]).toBe(false);
            });
            expect(result.current[0]).toBe("test-data");
            // Verify service container pattern works
            expect(testContainer).toBeDefined();
            expect(mockStorageService).toBeDefined();
            expect(jest.isMockFunction(mockStorageService.load)).toBe(true);
        });
    });
    describe("Performance Characteristics", ()=>{
        test("should not create unnecessary re-renders", async ()=>{
            const renderCount = jest.fn();
            jest.spyOn(mockStorageService, "load").mockResolvedValue(testValue);
            const { result, rerender } = (0, _react.renderHook)(()=>{
                renderCount();
                return (0, _useLocalStorage.useLocalStorageWithState)(testKey, "initial");
            });
            await (0, _react.waitFor)(()=>{
                expect(result.current[2]).toBe(false);
            });
            // Multiple re-renders should not trigger additional loads
            rerender();
            rerender();
            expect(mockStorageService.load).toHaveBeenCalledTimes(1);
            // Allow for hook initialization render cycles
            expect(renderCount).toHaveBeenCalledTimes(4); // Initial + loading state change + 2 rerenders
        });
        test("should handle rapid successive updates correctly", async ()=>{
            jest.spyOn(mockStorageService, "load").mockResolvedValue(null);
            jest.spyOn(mockStorageService, "save").mockResolvedValue(undefined);
            const { result } = (0, _react.renderHook)(()=>(0, _useLocalStorage.useLocalStorageWithState)(testKey, 0));
            await (0, _react.waitFor)(()=>{
                expect(result.current[2]).toBe(false);
            });
            // Rapid updates - React batches these, so they trigger as separate effects
            (0, _react.act)(()=>{
                result.current[1](1);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 1);
            });
            (0, _react.act)(()=>{
                result.current[1](2);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 2);
            });
            (0, _react.act)(()=>{
                result.current[1](3);
            });
            await (0, _react.waitFor)(()=>{
                expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 3);
            });
            expect(result.current[0]).toBe(3);
            expect(mockStorageService.save).toHaveBeenCalledTimes(3);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VMb2NhbFN0b3JhZ2UudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFVuaXQgdGVzdHMgZm9yIHJlZmFjdG9yZWQgdXNlTG9jYWxTdG9yYWdlIGhvb2tcbiAqIEBkZXNjcmlwdGlvbiBUZXN0cyB0aGUgbmV3IGZ1bGx5IGFzeW5jLCBTZXJ2aWNlQ29udGFpbmVyLWNvbXBhdGlibGUgaG9va1xuICogUGVyZmVjdCBKZXN0IDMwIGNvbXBhdGliaWxpdHkgLSBubyBnbG9iYWwgbW9ja2luZyByZXF1aXJlZCFcbiAqL1xuXG5pbXBvcnQgeyByZW5kZXJIb29rLCBhY3QsIHdhaXRGb3IgfSBmcm9tIFwiQHRlc3RpbmctbGlicmFyeS9yZWFjdFwiO1xuaW1wb3J0IHsgdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlIH0gZnJvbSBcIkBzaGFyZWQvaG9va3MvdXNlTG9jYWxTdG9yYWdlXCI7XG5pbXBvcnQgeyBjcmVhdGVUZXN0Q29udGFpbmVyIH0gZnJvbSBcIi4uLy4uL3V0aWxzXCI7XG5pbXBvcnQgdHlwZSB7IElQbGF0Zm9ybVN0b3JhZ2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9wbGF0Zm9ybS90eXBlc1wiO1xuXG4vLyBNb2NrIGxvZ2dlclxuamVzdC5tb2NrKFwiQHNoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nXCIsICgpID0+ICh7XG4gIC8qKlxuICAgKlxuICAgKi9cbiAgZ2V0TG9nZ2VyOiAoKSA9PiByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xvZ2dlci11dGlsc1wiKS5jcmVhdGVUZXN0TG9nZ2VyKCksXG59KSk7XG5cbi8vIFRlc3QgY29udGFpbmVyIGFuZCBtb2NrIHNlcnZpY2VcbmxldCB0ZXN0Q29udGFpbmVyOiBSZXR1cm5UeXBlPHR5cGVvZiBjcmVhdGVUZXN0Q29udGFpbmVyPjtcbmxldCBtb2NrU3RvcmFnZVNlcnZpY2U6IElQbGF0Zm9ybVN0b3JhZ2U7XG5cbi8vIE1vY2sgdGhlIHBsYXRmb3JtIHNlcnZpY2UgbW9kdWxlIHRvIHVzZSBvdXIgdGVzdCBjb250YWluZXJcbmplc3QubW9jayhcIkBzaGFyZWQvc2VydmljZXMvcGxhdGZvcm1cIiwgKCkgPT4gKHtcbiAgLyoqXG4gICAqXG4gICAqL1xuICBnZXRQbGF0Zm9ybVNlcnZpY2U6ICgpID0+ICh7XG4gICAgc3RvcmFnZTogbW9ja1N0b3JhZ2VTZXJ2aWNlLFxuICB9KSxcbn0pKTtcblxuZGVzY3JpYmUoXCJ1c2VMb2NhbFN0b3JhZ2UgSG9vayAtIFJlZmFjdG9yZWQgVmVyc2lvblwiLCAoKSA9PiB7XG4gIGNvbnN0IHRlc3RLZXkgPSBcInRlc3Qta2V5XCI7XG4gIGNvbnN0IHRlc3RWYWx1ZSA9IHsgY291bnQ6IDQyLCBuYW1lOiBcInRlc3RcIiB9O1xuICBjb25zdCB0ZXN0U3RyaW5nID0gXCJzaW1wbGUgc3RyaW5nXCI7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgLy8gQ3JlYXRlIHRlc3QgY29udGFpbmVyIHdpdGggbW9ja2VkIHNlcnZpY2VzXG4gICAgdGVzdENvbnRhaW5lciA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcbiAgICBtb2NrU3RvcmFnZVNlcnZpY2UgPSB0ZXN0Q29udGFpbmVyLnJlc29sdmUoXCJwbGF0Zm9ybS5zdG9yYWdlXCIpO1xuXG4gICAgLy8gUmVzZXQgYWxsIG1vY2tzXG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiQXN5bmMgSG9vayAtIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZVwiLCAoKSA9PiB7XG4gICAgZGVzY3JpYmUoXCJJbml0aWFsaXphdGlvblwiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwic2hvdWxkIGluaXRpYWxpemUgd2l0aCBsb2FkaW5nIHN0YXRlXCIsICgpID0+IHtcbiAgICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCB0ZXN0U3RyaW5nKSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBbdmFsdWUsIHNldHRlciwgaXNMb2FkaW5nLCBzYXZlRXJyb3JdID0gcmVzdWx0LmN1cnJlbnQ7XG4gICAgICAgIGV4cGVjdCh2YWx1ZSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICBleHBlY3QodHlwZW9mIHNldHRlcikudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgICAgICBleHBlY3QoaXNMb2FkaW5nKS50b0JlKHRydWUpO1xuICAgICAgICBleHBlY3Qoc2F2ZUVycm9yKS50b0JlTnVsbCgpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJzaG91bGQgbG9hZCBleGlzdGluZyB2YWx1ZSBmcm9tIHN0b3JhZ2VcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKHRlc3RWYWx1ZSk7XG5cbiAgICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAgICAgICAgICB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUodGVzdEtleSwgXCJkZWZhdWx0XCIpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGFzeW5jIGxvYWRpbmcgdG8gY29tcGxldGVcbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzJdKS50b0JlKGZhbHNlKTsgLy8gaXNMb2FkaW5nIHNob3VsZCBiZSBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBbdmFsdWUsIF9zZXR0ZXIsIGlzTG9hZGluZywgc2F2ZUVycm9yXSA9IHJlc3VsdC5jdXJyZW50O1xuICAgICAgICBleHBlY3QodmFsdWUpLnRvRXF1YWwodGVzdFZhbHVlKTtcbiAgICAgICAgZXhwZWN0KGlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICAgIGV4cGVjdChzYXZlRXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgICAgIGV4cGVjdChtb2NrU3RvcmFnZVNlcnZpY2UubG9hZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEtleSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZCB1c2UgaW5pdGlhbCB2YWx1ZSB3aGVuIHN0b3JhZ2UgaXMgZW1wdHlcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlKHRlc3RLZXksIHRlc3RTdHJpbmcpLFxuICAgICAgICApO1xuXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFsyXSkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IFt2YWx1ZV0gPSByZXN1bHQuY3VycmVudDtcbiAgICAgICAgZXhwZWN0KHZhbHVlKS50b0JlKHRlc3RTdHJpbmcpO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIGZ1bmN0aW9uLWJhc2VkIGluaXRpYWwgdmFsdWVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBpbml0aWFsVmFsdWVGbiA9IGplc3QuZm4oKCkgPT4gdGVzdFZhbHVlKTtcbiAgICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcblxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCBpbml0aWFsVmFsdWVGbiksXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzJdKS50b0JlKGZhbHNlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBkdXJpbmcgaG9vayBleGVjdXRpb24gYW5kIHVzZUVmZmVjdFxuICAgICAgICBleHBlY3QoaW5pdGlhbFZhbHVlRm4pLnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0VxdWFsKHRlc3RWYWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgdGVzdChcInNob3VsZCBoYW5kbGUgc3RvcmFnZSBsb2FkIGVycm9ycyBncmFjZWZ1bGx5XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdFxuICAgICAgICAgIC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKVxuICAgICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoXCJTdG9yYWdlIGVycm9yXCIpKTtcblxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCB0ZXN0U3RyaW5nKSxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMl0pLnRvQmUoZmFsc2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBbdmFsdWVdID0gcmVzdWx0LmN1cnJlbnQ7XG4gICAgICAgIGV4cGVjdCh2YWx1ZSkudG9CZSh0ZXN0U3RyaW5nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJTZXR0aW5nIFZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICB0ZXN0KFwic2hvdWxkIHVwZGF0ZSBzdGF0ZSBhbmQgc2F2ZSB0byBzdG9yYWdlXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKS5tb2NrUmVzb2x2ZWRWYWx1ZShudWxsKTtcbiAgICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwic2F2ZVwiKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlKHRlc3RLZXksIHRlc3RTdHJpbmcpLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFsyXSkudG9CZShmYWxzZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gXCJ1cGRhdGVkIHZhbHVlXCI7XG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnRbMV0obmV3VmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMF0pLnRvQmUobmV3VmFsdWUpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHNhdmUgZWZmZWN0IHRvIHRyaWdnZXJcbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KG1vY2tTdG9yYWdlU2VydmljZS5zYXZlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgIHRlc3RLZXksXG4gICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0ZXN0LnNraXAoXCJzaG91bGQgaGFuZGxlIGZ1bmN0aW9uLWJhc2VkIHVwZGF0ZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKHsgY291bnQ6IDAgfSk7XG4gICAgICAgIGplc3Quc3B5T24obW9ja1N0b3JhZ2VTZXJ2aWNlLCBcInNhdmVcIikubW9ja1Jlc29sdmVkVmFsdWUodW5kZWZpbmVkKTtcblxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCB7IGNvdW50OiAwIH0pLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGxvYWRpbmcgdG8gY29tcGxldGUgc3RlcCBieSBzdGVwXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzJdKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgdGltZW91dDogMzAwMCB9LFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRoZW4gdmVyaWZ5IHRoZSBsb2FkZWQgdmFsdWVcbiAgICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0VxdWFsKHsgY291bnQ6IDAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgICAgcmVzdWx0LmN1cnJlbnRbMV0oKHByZXY6IGFueSkgPT4gKHsgY291bnQ6IChwcmV2Py5jb3VudCB8fCAwKSArIDEgfSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMF0pLnRvRXF1YWwoeyBjb3VudDogMSB9KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBzYXZlIGVmZmVjdCB0byB0cmlnZ2VyXG4gICAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChtb2NrU3RvcmFnZVNlcnZpY2Uuc2F2ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEtleSwge1xuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRlc3QoXCJzaG91bGQgaGFuZGxlIHNhdmUgZXJyb3JzIGJ5IHNldHRpbmcgZXJyb3Igc3RhdGVcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgICBqZXN0XG4gICAgICAgICAgLnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJzYXZlXCIpXG4gICAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcihcIlNhdmUgZmFpbGVkXCIpKTtcblxuICAgICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCB0ZXN0U3RyaW5nKSxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMl0pLnRvQmUoZmFsc2UpO1xuICAgICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFswXSkudG9CZSh0ZXN0U3RyaW5nKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2V0IGEgbmV3IHZhbHVlIChzeW5jaHJvbm91cylcbiAgICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgICByZXN1bHQuY3VycmVudFsxXShcIm5ldyB2YWx1ZVwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gU2hvdWxkIGltbWVkaWF0ZWx5IHNob3cgb3B0aW1pc3RpYyB1cGRhdGVcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0JlKFwibmV3IHZhbHVlXCIpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIHNhdmUgZWZmZWN0IHRvIGZhaWwgYW5kIHNldCBlcnJvciBzdGF0ZVxuICAgICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbM10pLm5vdC50b0JlTnVsbCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBWZXJpZnkgdGhlIGVycm9yIGFuZCB0aGF0IG9wdGltaXN0aWMgc3RhdGUgd2FzIHByZXNlcnZlZFxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbM10pLnRvQmVJbnN0YW5jZU9mKEVycm9yKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzNdPy5tZXNzYWdlKS50b0JlKFwiU2F2ZSBmYWlsZWRcIik7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFswXSkudG9CZShcIm5ldyB2YWx1ZVwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoXCJDb21wb25lbnQgTGlmZWN5Y2xlXCIsICgpID0+IHtcbiAgICAgIHRlc3QoXCJzaG91bGQgbm90IHVwZGF0ZSBzdGF0ZSBhZnRlciB1bm1vdW50XCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgamVzdFxuICAgICAgICAgIC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKVxuICAgICAgICAgIC5tb2NrSW1wbGVtZW50YXRpb24oXG4gICAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUodGVzdFZhbHVlKSwgMTAwKSxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHsgcmVzdWx0LCB1bm1vdW50IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgICAgdXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlKHRlc3RLZXksIFwiZGVmYXVsdFwiKSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVbm1vdW50IGJlZm9yZSBhc3luYyBsb2FkIGNvbXBsZXRlc1xuICAgICAgICB1bm1vdW50KCk7XG5cbiAgICAgICAgLy8gV2FpdCBsb25nZXIgdGhhbiB0aGUgbW9jayBkZWxheVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTApKTtcblxuICAgICAgICAvLyBTaG91bGQgc3RpbGwgYmUgaW4gaW5pdGlhbCBzdGF0ZSBzaW5jZSBjb21wb25lbnQgd2FzIHVubW91bnRlZFxuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMl0pLnRvQmUodHJ1ZSk7IC8vIFN0aWxsIGxvYWRpbmdcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoXCJ1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUgSG9va1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBwcm92aWRlIHN0YXRlLWJhc2VkIGludGVyZmFjZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKHRlc3RWYWx1ZSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCBcImRlZmF1bHRcIiksXG4gICAgICApO1xuXG4gICAgICAvLyBTaG91bGQgc3RhcnQgd2l0aCBsb2FkaW5nIHN0YXRlXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMF0pLnRvQmUodW5kZWZpbmVkKTtcblxuICAgICAgLy8gV2FpdCBmb3IgYXN5bmMgbG9hZCB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFswXSkudG9FcXVhbCh0ZXN0VmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0ZXN0KFwic2hvdWxkIG1haW50YWluIHVzZVN0YXRlLWxpa2UgQVBJXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3Quc3B5T24obW9ja1N0b3JhZ2VTZXJ2aWNlLCBcImxvYWRcIikubW9ja1Jlc29sdmVkVmFsdWUobnVsbCk7XG4gICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJzYXZlXCIpLm1vY2tSZXNvbHZlZFZhbHVlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZSh0ZXN0S2V5LCB0ZXN0U3RyaW5nKSxcbiAgICAgICk7XG5cbiAgICAgIC8vIFdhaXQgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0JlKHRlc3RTdHJpbmcpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNob3VsZCBoYXZlIHN0YXRlIEFQSVxuICAgICAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSByZXN1bHQuY3VycmVudDtcbiAgICAgIGV4cGVjdCh0eXBlb2YgdmFsdWUpLnRvQmUoXCJzdHJpbmdcIik7XG4gICAgICBleHBlY3QodHlwZW9mIHNldFZhbHVlKS50b0JlKFwiZnVuY3Rpb25cIik7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKFwiU2VydmljZUNvbnRhaW5lciBJbnRlZ3JhdGlvblwiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCB1c2Ugb25seSBwbGF0Zm9ybSBzZXJ2aWNlIGZvciBzdG9yYWdlIG9wZXJhdGlvbnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwibG9hZFwiKS5tb2NrUmVzb2x2ZWRWYWx1ZSh0ZXN0VmFsdWUpO1xuICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwic2F2ZVwiKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PlxuICAgICAgICB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUodGVzdEtleSwgXCJpbml0aWFsXCIpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFsyXSkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnRbMV0oXCJ1cGRhdGVkXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmeSBPTkxZIHBsYXRmb3JtIHNlcnZpY2Ugd2FzIHVzZWRcbiAgICAgIGV4cGVjdChtb2NrU3RvcmFnZVNlcnZpY2UubG9hZCkudG9IYXZlQmVlbkNhbGxlZFdpdGgodGVzdEtleSk7XG4gICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlLnNhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RLZXksIFwidXBkYXRlZFwiKTtcblxuICAgICAgLy8gTm8gd2luZG93LmxvY2FsU3RvcmFnZSBhY2Nlc3MgYXQgYWxsIVxuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9ja1N0b3JhZ2VTZXJ2aWNlLmxvYWQpKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9ja1N0b3JhZ2VTZXJ2aWNlLnNhdmUpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBwcm92aWRlIHBlcmZlY3QgdGVzdCBpc29sYXRpb25cIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gRWFjaCB0ZXN0IGdldHMgZnJlc2ggY29udGFpbmVyIGFuZCBmcmVzaCBtb2Nrc1xuICAgICAgY29uc3QgY29udGFpbmVyMSA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2UxID0gY29udGFpbmVyMS5yZXNvbHZlKFwicGxhdGZvcm0uc3RvcmFnZVwiKTtcblxuICAgICAgY29uc3QgY29udGFpbmVyMiA9IGNyZWF0ZVRlc3RDb250YWluZXIoKTtcbiAgICAgIGNvbnN0IHN0b3JhZ2UyID0gY29udGFpbmVyMi5yZXNvbHZlKFwicGxhdGZvcm0uc3RvcmFnZVwiKTtcblxuICAgICAgLy8gRGlmZmVyZW50IGNvbnRhaW5lcnMgPSBkaWZmZXJlbnQgc2VydmljZSBpbnN0YW5jZXNcbiAgICAgIGV4cGVjdChzdG9yYWdlMSkubm90LnRvQmUoc3RvcmFnZTIpO1xuXG4gICAgICAvLyBCb3RoIHNob3VsZCBiZSB3b3JraW5nIG1vY2sgaW5zdGFuY2VzXG4gICAgICBleHBlY3QodHlwZW9mIHN0b3JhZ2UxLmxvYWQpLnRvQmUoXCJmdW5jdGlvblwiKTtcbiAgICAgIGV4cGVjdCh0eXBlb2Ygc3RvcmFnZTIuc2F2ZSkudG9CZShcImZ1bmN0aW9uXCIpO1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBzdXBwb3J0IEplc3QgMzAgY29tcGF0aWJsZSB0ZXN0aW5nXCIsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIFRoaXMgdGVzdCB2YWxpZGF0ZXMgSmVzdCAzMCBjb21wYXRpYmlsaXR5XG5cbiAgICAgIC8vIOKchSBObyBnbG9iYWwgd2luZG93LmxvY2FsU3RvcmFnZSBtb2NraW5nIHJlcXVpcmVkXG4gICAgICAvLyDinIUgTm8gT2JqZWN0LmRlZmluZVByb3BlcnR5IHVzYWdlXG4gICAgICAvLyDinIUgUHVyZSBkZXBlbmRlbmN5IGluamVjdGlvbiB0aHJvdWdoIFNlcnZpY2VDb250YWluZXJcbiAgICAgIC8vIOKchSBQZXJmZWN0IG1vY2sgaXNvbGF0aW9uIHBlciB0ZXN0XG5cbiAgICAgIGplc3Quc3B5T24obW9ja1N0b3JhZ2VTZXJ2aWNlLCBcImxvYWRcIikubW9ja1Jlc29sdmVkVmFsdWUoXCJ0ZXN0LWRhdGFcIik7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+XG4gICAgICAgIHVzZUxvY2FsU3RvcmFnZVdpdGhTdGF0ZShcInRlc3RcIiwgXCJkZWZhdWx0XCIpLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgd2FpdEZvcigoKSA9PiB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFsyXSkudG9CZShmYWxzZSk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0JlKFwidGVzdC1kYXRhXCIpO1xuXG4gICAgICAvLyBWZXJpZnkgc2VydmljZSBjb250YWluZXIgcGF0dGVybiB3b3Jrc1xuICAgICAgZXhwZWN0KHRlc3RDb250YWluZXIpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlKS50b0JlRGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KGplc3QuaXNNb2NrRnVuY3Rpb24obW9ja1N0b3JhZ2VTZXJ2aWNlLmxvYWQpKS50b0JlKHRydWUpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZShcIlBlcmZvcm1hbmNlIENoYXJhY3RlcmlzdGljc1wiLCAoKSA9PiB7XG4gICAgdGVzdChcInNob3VsZCBub3QgY3JlYXRlIHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVuZGVyQ291bnQgPSBqZXN0LmZuKCk7XG4gICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKHRlc3RWYWx1ZSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0LCByZXJlbmRlciB9ID0gcmVuZGVySG9vaygoKSA9PiB7XG4gICAgICAgIHJlbmRlckNvdW50KCk7XG4gICAgICAgIHJldHVybiB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUodGVzdEtleSwgXCJpbml0aWFsXCIpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnRbMl0pLnRvQmUoZmFsc2UpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE11bHRpcGxlIHJlLXJlbmRlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGFkZGl0aW9uYWwgbG9hZHNcbiAgICAgIHJlcmVuZGVyKCk7XG4gICAgICByZXJlbmRlcigpO1xuXG4gICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlLmxvYWQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgIC8vIEFsbG93IGZvciBob29rIGluaXRpYWxpemF0aW9uIHJlbmRlciBjeWNsZXNcbiAgICAgIGV4cGVjdChyZW5kZXJDb3VudCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDQpOyAvLyBJbml0aWFsICsgbG9hZGluZyBzdGF0ZSBjaGFuZ2UgKyAyIHJlcmVuZGVyc1xuICAgIH0pO1xuXG4gICAgdGVzdChcInNob3VsZCBoYW5kbGUgcmFwaWQgc3VjY2Vzc2l2ZSB1cGRhdGVzIGNvcnJlY3RseVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICBqZXN0LnNweU9uKG1vY2tTdG9yYWdlU2VydmljZSwgXCJsb2FkXCIpLm1vY2tSZXNvbHZlZFZhbHVlKG51bGwpO1xuICAgICAgamVzdC5zcHlPbihtb2NrU3RvcmFnZVNlcnZpY2UsIFwic2F2ZVwiKS5tb2NrUmVzb2x2ZWRWYWx1ZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VMb2NhbFN0b3JhZ2VXaXRoU3RhdGUodGVzdEtleSwgMCkpO1xuXG4gICAgICBhd2FpdCB3YWl0Rm9yKCgpID0+IHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50WzJdKS50b0JlKGZhbHNlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSYXBpZCB1cGRhdGVzIC0gUmVhY3QgYmF0Y2hlcyB0aGVzZSwgc28gdGhleSB0cmlnZ2VyIGFzIHNlcGFyYXRlIGVmZmVjdHNcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50WzFdKDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlLnNhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RLZXksIDEpO1xuICAgICAgfSk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50WzFdKDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlLnNhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RLZXksIDIpO1xuICAgICAgfSk7XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50WzFdKDMpO1xuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IHdhaXRGb3IoKCkgPT4ge1xuICAgICAgICBleHBlY3QobW9ja1N0b3JhZ2VTZXJ2aWNlLnNhdmUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHRlc3RLZXksIDMpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudFswXSkudG9CZSgzKTtcbiAgICAgIGV4cGVjdChtb2NrU3RvcmFnZVNlcnZpY2Uuc2F2ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0TG9nZ2VyIiwicmVxdWlyZSIsImNyZWF0ZVRlc3RMb2dnZXIiLCJnZXRQbGF0Zm9ybVNlcnZpY2UiLCJzdG9yYWdlIiwibW9ja1N0b3JhZ2VTZXJ2aWNlIiwidGVzdENvbnRhaW5lciIsImRlc2NyaWJlIiwidGVzdEtleSIsInRlc3RWYWx1ZSIsImNvdW50IiwibmFtZSIsInRlc3RTdHJpbmciLCJiZWZvcmVFYWNoIiwiY3JlYXRlVGVzdENvbnRhaW5lciIsInJlc29sdmUiLCJjbGVhckFsbE1vY2tzIiwidGVzdCIsInNweU9uIiwibW9ja1Jlc29sdmVkVmFsdWUiLCJyZXN1bHQiLCJyZW5kZXJIb29rIiwidXNlTG9jYWxTdG9yYWdlV2l0aFN0YXRlIiwidmFsdWUiLCJzZXR0ZXIiLCJpc0xvYWRpbmciLCJzYXZlRXJyb3IiLCJjdXJyZW50IiwiZXhwZWN0IiwidG9CZVVuZGVmaW5lZCIsInRvQmUiLCJ0b0JlTnVsbCIsIndhaXRGb3IiLCJfc2V0dGVyIiwidG9FcXVhbCIsImxvYWQiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImluaXRpYWxWYWx1ZUZuIiwiZm4iLCJ0b0hhdmVCZWVuQ2FsbGVkIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsInVuZGVmaW5lZCIsIm5ld1ZhbHVlIiwiYWN0Iiwic2F2ZSIsInNraXAiLCJ0aW1lb3V0IiwicHJldiIsIm5vdCIsInRvQmVJbnN0YW5jZU9mIiwibWVzc2FnZSIsIm1vY2tJbXBsZW1lbnRhdGlvbiIsIlByb21pc2UiLCJzZXRUaW1lb3V0IiwidW5tb3VudCIsInNldFZhbHVlIiwiaXNNb2NrRnVuY3Rpb24iLCJjb250YWluZXIxIiwic3RvcmFnZTEiLCJjb250YWluZXIyIiwic3RvcmFnZTIiLCJ0b0JlRGVmaW5lZCIsInJlbmRlckNvdW50IiwicmVyZW5kZXIiLCJ0b0hhdmVCZWVuQ2FsbGVkVGltZXMiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFPRCxjQUFj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