{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/tests/unit/hooks/useLocalStorage.test.ts"],"sourcesContent":["/**\n * @file Unit tests for refactored useLocalStorage hook\n * @description Tests the new fully async, ServiceContainer-compatible hook\n * Perfect Jest 30 compatibility - no global mocking required!\n */\n\nimport { renderHook, act, waitFor } from \"@testing-library/react\";\nimport { useLocalStorageWithState } from \"@shared/hooks/useLocalStorage\";\nimport { createTestContainer } from \"../../utils\";\nimport type { IPlatformStorage } from \"@shared/services/platform/types\";\n\n// Mock logger\njest.mock(\"@shared/services/logging\", () => ({\n  /**\n   *\n   */\n  getLogger: () => require(\"../../shared/logger-utils\").createTestLogger(),\n}));\n\n// Test container and mock service\nlet testContainer: ReturnType<typeof createTestContainer>;\nlet mockStorageService: IPlatformStorage;\n\n// Mock the platform service module to use our test container\njest.mock(\"@shared/services/platform\", () => ({\n  /**\n   *\n   */\n  getPlatformService: () => ({\n    storage: mockStorageService,\n  }),\n}));\n\ndescribe(\"useLocalStorage Hook - Refactored Version\", () => {\n  const testKey = \"test-key\";\n  const testValue = { count: 42, name: \"test\" };\n  const testString = \"simple string\";\n\n  beforeEach(() => {\n    // Create test container with mocked services\n    testContainer = createTestContainer();\n    mockStorageService = testContainer.resolve(\"platform.storage\");\n\n    // Reset all mocks\n    jest.clearAllMocks();\n  });\n\n  describe(\"Async Hook - useLocalStorageWithState\", () => {\n    describe(\"Initialization\", () => {\n      test(\"should initialize with loading state\", () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, testString),\n        );\n\n        const [value, setter, isLoading, saveError] = result.current;\n        expect(value).toBeUndefined();\n        expect(typeof setter).toBe(\"function\");\n        expect(isLoading).toBe(true);\n        expect(saveError).toBeNull();\n      });\n\n      test(\"should load existing value from storage\", async () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(testValue);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, \"default\"),\n        );\n\n        // Wait for async loading to complete\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false); // isLoading should be false\n        });\n\n        const [value, _setter, isLoading, saveError] = result.current;\n        expect(value).toEqual(testValue);\n        expect(isLoading).toBe(false);\n        expect(saveError).toBeNull();\n        expect(mockStorageService.load).toHaveBeenCalledWith(testKey);\n      });\n\n      test(\"should use initial value when storage is empty\", async () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, testString),\n        );\n\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false);\n        });\n\n        const [value] = result.current;\n        expect(value).toBe(testString);\n      });\n\n      test(\"should handle function-based initial value\", async () => {\n        const initialValueFn = jest.fn(() => testValue);\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, initialValueFn),\n        );\n\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false);\n        });\n\n        // Function may be called during hook execution and useEffect\n        expect(initialValueFn).toHaveBeenCalled();\n        expect(result.current[0]).toEqual(testValue);\n      });\n\n      test(\"should handle storage load errors gracefully\", async () => {\n        jest\n          .spyOn(mockStorageService, \"load\")\n          .mockRejectedValue(new Error(\"Storage error\"));\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, testString),\n        );\n\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false);\n        });\n\n        const [value] = result.current;\n        expect(value).toBe(testString);\n      });\n    });\n\n    describe(\"Setting Values\", () => {\n      test(\"should update state and save to storage\", async () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n        jest.spyOn(mockStorageService, \"save\").mockResolvedValue(undefined);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, testString),\n        );\n\n        // Wait for initialization\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false);\n        });\n\n        const newValue = \"updated value\";\n        act(() => {\n          result.current[1](newValue);\n        });\n\n        expect(result.current[0]).toBe(newValue);\n\n        // Wait for save effect to trigger\n        await waitFor(() => {\n          expect(mockStorageService.save).toHaveBeenCalledWith(\n            testKey,\n            newValue,\n          );\n        });\n      });\n\n      test.skip(\"should handle function-based updates\", async () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue({ count: 0 });\n        jest.spyOn(mockStorageService, \"save\").mockResolvedValue(undefined);\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, { count: 0 }),\n        );\n\n        // Wait for loading to complete step by step\n        await waitFor(\n          () => {\n            expect(result.current[2]).toBe(false);\n          },\n          { timeout: 3000 },\n        );\n\n        // Then verify the loaded value\n        await waitFor(() => {\n          expect(result.current[0]).toEqual({ count: 0 });\n        });\n\n        act(() => {\n          result.current[1]((prev: any) => ({ count: (prev?.count || 0) + 1 }));\n        });\n\n        expect(result.current[0]).toEqual({ count: 1 });\n\n        // Wait for save effect to trigger\n        await waitFor(() => {\n          expect(mockStorageService.save).toHaveBeenCalledWith(testKey, {\n            count: 1,\n          });\n        });\n      });\n\n      test(\"should handle save errors by setting error state\", async () => {\n        jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n        jest\n          .spyOn(mockStorageService, \"save\")\n          .mockRejectedValue(new Error(\"Save failed\"));\n\n        const { result } = renderHook(() =>\n          useLocalStorageWithState(testKey, testString),\n        );\n\n        await waitFor(() => {\n          expect(result.current[2]).toBe(false);\n          expect(result.current[0]).toBe(testString);\n        });\n\n        // Set a new value (synchronous)\n        act(() => {\n          result.current[1](\"new value\");\n        });\n\n        // Should immediately show optimistic update\n        expect(result.current[0]).toBe(\"new value\");\n\n        // Wait for save effect to fail and set error state\n        await waitFor(() => {\n          expect(result.current[3]).not.toBeNull();\n        });\n\n        // Verify the error and that optimistic state was preserved\n        expect(result.current[3]).toBeInstanceOf(Error);\n        expect(result.current[3]?.message).toBe(\"Save failed\");\n        expect(result.current[0]).toBe(\"new value\");\n      });\n    });\n\n    describe(\"Component Lifecycle\", () => {\n      test(\"should not update state after unmount\", async () => {\n        jest\n          .spyOn(mockStorageService, \"load\")\n          .mockImplementation(\n            () =>\n              new Promise((resolve) =>\n                setTimeout(() => resolve(testValue), 100),\n              ),\n          );\n\n        const { result, unmount } = renderHook(() =>\n          useLocalStorageWithState(testKey, \"default\"),\n        );\n\n        // Unmount before async load completes\n        unmount();\n\n        // Wait longer than the mock delay\n        await new Promise((resolve) => setTimeout(resolve, 150));\n\n        // Should still be in initial state since component was unmounted\n        expect(result.current[2]).toBe(true); // Still loading\n        expect(result.current[0]).toBeUndefined();\n      });\n    });\n  });\n\n  describe(\"useLocalStorageWithState Hook\", () => {\n    test(\"should provide state-based interface\", async () => {\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(testValue);\n\n      const { result } = renderHook(() =>\n        useLocalStorageWithState(testKey, \"default\"),\n      );\n\n      // Should start with loading state\n      expect(result.current[0]).toBe(undefined);\n\n      // Wait for async load to complete\n      await waitFor(() => {\n        expect(result.current[0]).toEqual(testValue);\n      });\n    });\n\n    test(\"should maintain useState-like API\", async () => {\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n      jest.spyOn(mockStorageService, \"save\").mockResolvedValue(undefined);\n\n      const { result } = renderHook(() =>\n        useLocalStorageWithState(testKey, testString),\n      );\n\n      // Wait for initialization\n      await waitFor(() => {\n        expect(result.current[0]).toBe(testString);\n      });\n\n      // Should have state API\n      const [value, setValue] = result.current;\n      expect(typeof value).toBe(\"string\");\n      expect(typeof setValue).toBe(\"function\");\n    });\n  });\n\n  describe(\"ServiceContainer Integration\", () => {\n    test(\"should use only platform service for storage operations\", async () => {\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(testValue);\n      jest.spyOn(mockStorageService, \"save\").mockResolvedValue(undefined);\n\n      const { result } = renderHook(() =>\n        useLocalStorageWithState(testKey, \"initial\"),\n      );\n\n      await waitFor(() => {\n        expect(result.current[2]).toBe(false);\n      });\n\n      await act(async () => {\n        await result.current[1](\"updated\");\n      });\n\n      // Verify ONLY platform service was used\n      expect(mockStorageService.load).toHaveBeenCalledWith(testKey);\n      expect(mockStorageService.save).toHaveBeenCalledWith(testKey, \"updated\");\n\n      // No window.localStorage access at all!\n      expect(jest.isMockFunction(mockStorageService.load)).toBe(true);\n      expect(jest.isMockFunction(mockStorageService.save)).toBe(true);\n    });\n\n    test(\"should provide perfect test isolation\", async () => {\n      // Each test gets fresh container and fresh mocks\n      const container1 = createTestContainer();\n      const storage1 = container1.resolve(\"platform.storage\");\n\n      const container2 = createTestContainer();\n      const storage2 = container2.resolve(\"platform.storage\");\n\n      // Different containers = different service instances\n      expect(storage1).not.toBe(storage2);\n\n      // Both should be working mock instances\n      expect(typeof storage1.load).toBe(\"function\");\n      expect(typeof storage2.save).toBe(\"function\");\n    });\n\n    test(\"should support Jest 30 compatible testing\", async () => {\n      // This test validates Jest 30 compatibility\n\n      // ✅ No global window.localStorage mocking required\n      // ✅ No Object.defineProperty usage\n      // ✅ Pure dependency injection through ServiceContainer\n      // ✅ Perfect mock isolation per test\n\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(\"test-data\");\n\n      const { result } = renderHook(() =>\n        useLocalStorageWithState(\"test\", \"default\"),\n      );\n\n      await waitFor(() => {\n        expect(result.current[2]).toBe(false);\n      });\n\n      expect(result.current[0]).toBe(\"test-data\");\n\n      // Verify service container pattern works\n      expect(testContainer).toBeDefined();\n      expect(mockStorageService).toBeDefined();\n      expect(jest.isMockFunction(mockStorageService.load)).toBe(true);\n    });\n  });\n\n  describe(\"Performance Characteristics\", () => {\n    test(\"should not create unnecessary re-renders\", async () => {\n      const renderCount = jest.fn();\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(testValue);\n\n      const { result, rerender } = renderHook(() => {\n        renderCount();\n        return useLocalStorageWithState(testKey, \"initial\");\n      });\n\n      await waitFor(() => {\n        expect(result.current[2]).toBe(false);\n      });\n\n      // Multiple re-renders should not trigger additional loads\n      rerender();\n      rerender();\n\n      expect(mockStorageService.load).toHaveBeenCalledTimes(1);\n      // Allow for hook initialization render cycles\n      expect(renderCount).toHaveBeenCalledTimes(4); // Initial + loading state change + 2 rerenders\n    });\n\n    test(\"should handle rapid successive updates correctly\", async () => {\n      jest.spyOn(mockStorageService, \"load\").mockResolvedValue(null);\n      jest.spyOn(mockStorageService, \"save\").mockResolvedValue(undefined);\n\n      const { result } = renderHook(() => useLocalStorageWithState(testKey, 0));\n\n      await waitFor(() => {\n        expect(result.current[2]).toBe(false);\n      });\n\n      // Rapid updates - React batches these, so they trigger as separate effects\n      act(() => {\n        result.current[1](1);\n      });\n\n      await waitFor(() => {\n        expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 1);\n      });\n\n      act(() => {\n        result.current[1](2);\n      });\n\n      await waitFor(() => {\n        expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 2);\n      });\n\n      act(() => {\n        result.current[1](3);\n      });\n\n      await waitFor(() => {\n        expect(mockStorageService.save).toHaveBeenCalledWith(testKey, 3);\n      });\n\n      expect(result.current[0]).toBe(3);\n      expect(mockStorageService.save).toHaveBeenCalledTimes(3);\n    });\n  });\n});\n"],"names":["jest","mock","getLogger","require","createTestLogger","getPlatformService","storage","mockStorageService","testContainer","describe","testKey","testValue","count","name","testString","beforeEach","createTestContainer","resolve","clearAllMocks","test","spyOn","mockResolvedValue","result","renderHook","useLocalStorageWithState","value","setter","isLoading","saveError","current","expect","toBeUndefined","toBe","toBeNull","waitFor","_setter","toEqual","load","toHaveBeenCalledWith","initialValueFn","fn","toHaveBeenCalled","mockRejectedValue","Error","undefined","newValue","act","save","skip","timeout","prev","not","toBeInstanceOf","message","mockImplementation","Promise","setTimeout","unmount","setValue","isMockFunction","container1","storage1","container2","storage2","toBeDefined","renderCount","rerender","toHaveBeenCalledTimes"],"mappings":"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"}