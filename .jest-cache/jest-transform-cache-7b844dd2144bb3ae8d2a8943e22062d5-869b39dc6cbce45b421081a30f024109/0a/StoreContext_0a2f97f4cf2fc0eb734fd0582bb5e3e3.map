{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/store/StoreContext.tsx"],"sourcesContent":["\"use client\";\n\n/**\n * @file SSR-safe Zustand store context provider\n * @module store/StoreContext\n * @description Creates a React context for Zustand store to fix SSR hydration issues.\n * This resolves the runtime error where store actions are lost during Next.js hydration.\n *\n * @remarks\n * The singleton Zustand pattern conflicts with SSR because:\n * 1. Server creates one store instance per request\n * 2. Client hydration expects the same instance\n * 3. Hot Module Replacement can cause method binding loss\n *\n * This context pattern ensures:\n * - Fresh store instance per request on server\n * - Consistent store instance during client hydration\n * - Proper method binding preservation\n *\n * @example\n * ```typescript\n * // In _app.tsx\n * import { StoreProvider } from '@/shared/store/StoreContext';\n *\n * export default function MyApp({ Component, pageProps }) {\n *   return (\n *     <StoreProvider>\n *       <Component {...pageProps} />\n *     </StoreProvider>\n *   );\n * }\n *\n * // In components\n * import { useStore } from '@/shared/store/StoreContext';\n *\n * function MyComponent() {\n *   const setMoveErrorDialog = useStore(state => state.training.setMoveErrorDialog);\n *   // setMoveErrorDialog is now guaranteed to exist at runtime\n * }\n * ```\n */\n\nimport React, {\n  createContext,\n  useContext,\n  useRef,\n  useEffect,\n  type ReactNode,\n} from \"react\";\nimport { useStore as useZustandStore } from \"zustand\";\nimport { createStore } from \"./createStore\";\nimport { browserTestApi } from \"@shared/services/test/BrowserTestApi\";\nimport type { RootState } from \"./slices/types\";\n\n/**\n * Store instance type for the context\n */\ntype StoreApi = ReturnType<typeof createStore>;\n\n/**\n * React context for the store\n */\nconst StoreContext = createContext<StoreApi | null>(null);\n\n/**\n * Props for the StoreProvider component\n */\ninterface StoreProviderProps {\n  /** Child components that need access to the store */\n  children: ReactNode;\n  /** Optional initial state for SSR hydration */\n  initialState?: Partial<RootState>;\n}\n\n/**\n * SSR-safe store provider component\n *\n * @param {StoreProviderProps} props - Provider configuration\n * @returns {JSX.Element} Provider wrapper component\n *\n * @remarks\n * This component creates a fresh store instance for each render tree,\n * preventing SSR hydration mismatches. The store is created once using\n * useRef and persists for the lifetime of the provider.\n *\n * Key benefits:\n * - Eliminates \"setMoveErrorDialog is not a function\" errors\n * - Ensures consistent store state across SSR/hydration\n * - Maintains store instance during hot module replacement\n * - Allows per-request store initialization on server\n *\n * @example\n * ```typescript\n * // Basic usage\n * <StoreProvider>\n *   <MyApp />\n * </StoreProvider>\n *\n * // With initial state for SSR\n * <StoreProvider initialState={{ game: { currentFen: startFen } }}>\n *   <MyApp />\n * </StoreProvider>\n * ```\n */\nexport const StoreProvider: React.FC<StoreProviderProps> = ({\n  children,\n  initialState,\n}) => {\n  // Create store instance once per provider instance\n  // This ensures fresh store per request on server, stable store on client\n  const storeRef = useRef<StoreApi | undefined>(undefined);\n\n  if (!storeRef.current) {\n    storeRef.current = createStore(initialState);\n    \n    // Expose store globally for E2E tests (deterministic waiting)\n    // Only in test environments to enable state-based waiting\n    if (typeof window !== 'undefined' && \n        (process.env.NEXT_PUBLIC_IS_E2E_TEST === 'true' || \n         process.env.NODE_ENV === 'test')) {\n      (window as any).__e2e_store = storeRef.current;\n    }\n  }\n\n  // Initialize BrowserTestApi for E2E tests (provides e2e_makeMove, e2e_getGameState)\n  useEffect(() => {\n    if (typeof window !== 'undefined' && \n        (process.env.NEXT_PUBLIC_IS_E2E_TEST === 'true' || \n         process.env.NODE_ENV === 'test')) {\n      // Get store state to access actions\n      const state = storeRef.current?.getState();\n      \n      // Create storeAccess object with required actions for TestApiService\n      const storeAccess = {\n        getState: () => storeRef.current?.getState(),\n        subscribe: (listener: any) => storeRef.current?.subscribe(listener) || (() => {}),\n        setState: (updater: any) => storeRef.current?.setState(updater),\n        // Extract individual actions from state - these need to be fixed in TestApiService\n        // For now, provide empty functions to avoid runtime errors\n        makeMove: state?.handlePlayerMove || (() => {}),\n        _internalApplyMove: (() => {}), // TO BE REMOVED - see issue #99\n        resetPosition: state?.reset || (() => {}),\n        setPosition: (() => {}), // Not directly available in new architecture\n        goToMove: state?.game?.goToMove || (() => {}),\n        setAnalysisStatus: (() => {}), // Not directly available in new architecture\n      };\n      \n      // Initialize BrowserTestApi which exposes e2e_makeMove to window\n      browserTestApi.initialize(storeAccess).catch((error) => {\n        console.error(\"Failed to initialize BrowserTestApi:\", error);\n      });\n    }\n\n    // Cleanup on unmount\n    return () => {\n      if (typeof window !== 'undefined') {\n        browserTestApi.cleanup().catch(() => {\n          // Ignore cleanup errors\n        });\n      }\n    };\n  }, []);\n\n  return (\n    <StoreContext.Provider value={storeRef.current}>\n      {children}\n    </StoreContext.Provider>\n  );\n};\n\n/**\n * Hook for accessing the store from context\n *\n * @param {Function} [selector] - Optional selector function for specific state\n * @returns {any} Selected state or complete store state\n *\n * @throws {Error} When used outside of StoreProvider\n *\n * @remarks\n * This hook replaces the singleton useStore import throughout the app.\n * It ensures that store actions are always available at runtime by\n * accessing the store through React context instead of a global singleton.\n *\n * The hook supports both selector-based and full store access patterns:\n * - With selector: Returns selected state and subscribes to changes\n * - Without selector: Returns complete store state (use sparingly)\n *\n * @example\n * ```typescript\n * // Selector usage (recommended)\n * const setMoveErrorDialog = useStore(state => state.training.setMoveErrorDialog);\n * const currentFen = useStore(state => state.game.currentFen);\n *\n * // Multiple selections with useShallow\n * import { useShallow } from 'zustand/react/shallow';\n * const { currentPosition, isPlayerTurn } = useStore(\n *   useShallow(state => ({\n *     currentPosition: state.training.currentPosition,\n *     isPlayerTurn: state.training.isPlayerTurn\n *   }))\n * );\n *\n * // Full store access (avoid if possible)\n * const store = useStore();\n * ```\n */\nexport const useStore = <T = RootState,>(\n  selector?: (state: RootState) => T,\n): T extends RootState ? RootState : T => {\n  const store = useContext(StoreContext);\n\n  if (!store) {\n    throw new Error(\n      \"useStore must be used within a StoreProvider. \" +\n        \"Make sure to wrap your app with <StoreProvider> in _app.tsx\",\n    );\n  }\n\n  return useZustandStore(store, selector as any);\n};\n\n/**\n * Hook for accessing the raw store API\n *\n * @returns {StoreApi} Raw Zustand store instance\n *\n * @throws {Error} When used outside of StoreProvider\n *\n * @remarks\n * This hook provides access to the raw store instance for:\n * - Direct state access: store.getState()\n * - Manual state updates: store.setState()\n * - Store subscription: store.subscribe()\n * - Testing and debugging\n *\n * Use this sparingly - prefer the selector-based useStore hook\n * for component usage.\n *\n * @example\n * ```typescript\n * // For testing\n * const store = useStoreApi();\n * const currentState = store.getState();\n * store.setState({ training: { hintsUsed: 0 } });\n *\n * // For manual subscriptions (rare)\n * const store = useStoreApi();\n * const unsubscribe = store.subscribe((state) => {\n *   console.log('State changed:', state);\n * });\n * ```\n */\nexport const useStoreApi = (): StoreApi => {\n  const store = useContext(StoreContext);\n\n  if (!store) {\n    throw new Error(\n      \"useStoreApi must be used within a StoreProvider. \" +\n        \"Make sure to wrap your app with <StoreProvider> in _app.tsx\",\n    );\n  }\n\n  return store;\n};\n\n/**\n * Type exports for external usage\n */\nexport type { StoreApi, RootState };\n"],"names":["StoreProvider","useStore","useStoreApi","StoreContext","createContext","children","initialState","storeRef","useRef","undefined","current","createStore","window","process","env","NEXT_PUBLIC_IS_E2E_TEST","NODE_ENV","__e2e_store","useEffect","state","getState","storeAccess","subscribe","listener","setState","updater","makeMove","handlePlayerMove","_internalApplyMove","resetPosition","reset","setPosition","goToMove","game","setAnalysisStatus","browserTestApi","initialize","catch","error","console","cleanup","Provider","value","selector","store","useContext","Error","useZustandStore"],"mappings":"AAAA;;;;;;;;;;;;QAwGaA;eAAAA;;QAsGAC;eAAAA;;QA8CAC;eAAAA;;;;+DA5MN;yBACqC;6BAChB;gCACG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQ/B;;CAEC,GACD,MAAMC,6BAAeC,IAAAA,oBAAa,EAAkB;AA0C7C,MAAMJ,gBAA8C,CAAC,EAC1DK,QAAQ,EACRC,YAAY,EACb;IACC,mDAAmD;IACnD,yEAAyE;IACzE,MAAMC,WAAWC,IAAAA,aAAM,EAAuBC;IAE9C,IAAI,CAACF,SAASG,OAAO,EAAE;QACrBH,SAASG,OAAO,GAAGC,IAAAA,wBAAW,EAACL;QAE/B,8DAA8D;QAC9D,0DAA0D;QAC1D,IAAI,OAAOM,WAAW,eACjBC,CAAAA,QAAQC,GAAG,CAACC,uBAAuB,KAAK,UACxCF,QAAQC,GAAG,CAACE,QAAQ,KAAK,MAAK,GAAI;YACpCJ,OAAeK,WAAW,GAAGV,SAASG,OAAO;QAChD;IACF;IAEA,oFAAoF;IACpFQ,IAAAA,gBAAS,EAAC;QACR,IAAI,OAAON,WAAW,eACjBC,CAAAA,QAAQC,GAAG,CAACC,uBAAuB,KAAK,UACxCF,QAAQC,GAAG,CAACE,QAAQ,KAAK,MAAK,GAAI;gBAEvBT,mBAaFY;YAdZ,oCAAoC;YACpC,MAAMA,SAAQZ,oBAAAA,SAASG,OAAO,cAAhBH,wCAAAA,kBAAkBa,QAAQ;YAExC,qEAAqE;YACrE,MAAMC,cAAc;gBAClBD,UAAU;wBAAMb;4BAAAA,oBAAAA,SAASG,OAAO,cAAhBH,wCAAAA,kBAAkBa,QAAQ;;gBAC1CE,WAAW,CAACC;wBAAkBhB;2BAAAA,EAAAA,oBAAAA,SAASG,OAAO,cAAhBH,wCAAAA,kBAAkBe,SAAS,CAACC,cAAc,CAAA,KAAO,CAAA;;gBAC/EC,UAAU,CAACC;wBAAiBlB;4BAAAA,oBAAAA,SAASG,OAAO,cAAhBH,wCAAAA,kBAAkBiB,QAAQ,CAACC;;gBACvD,mFAAmF;gBACnF,2DAA2D;gBAC3DC,UAAUP,CAAAA,kBAAAA,4BAAAA,MAAOQ,gBAAgB,KAAK,CAAA,KAAO,CAAA;gBAC7CC,oBAAqB,KAAO;gBAC5BC,eAAeV,CAAAA,kBAAAA,4BAAAA,MAAOW,KAAK,KAAK,CAAA,KAAO,CAAA;gBACvCC,aAAc,KAAO;gBACrBC,UAAUb,CAAAA,kBAAAA,6BAAAA,cAAAA,MAAOc,IAAI,cAAXd,kCAAAA,YAAaa,QAAQ,KAAK,CAAA,KAAO,CAAA;gBAC3CE,mBAAoB,KAAO;YAC7B;YAEA,iEAAiE;YACjEC,8BAAc,CAACC,UAAU,CAACf,aAAagB,KAAK,CAAC,CAACC;gBAC5CC,QAAQD,KAAK,CAAC,wCAAwCA;YACxD;QACF;QAEA,qBAAqB;QACrB,OAAO;YACL,IAAI,OAAO1B,WAAW,aAAa;gBACjCuB,8BAAc,CAACK,OAAO,GAAGH,KAAK,CAAC;gBAC7B,wBAAwB;gBAC1B;YACF;QACF;IACF,GAAG,EAAE;IAEL,qBACE,qBAAClC,aAAasC,QAAQ;QAACC,OAAOnC,SAASG,OAAO;kBAC3CL;;AAGP;AAsCO,MAAMJ,WAAW,CACtB0C;IAEA,MAAMC,QAAQC,IAAAA,iBAAU,EAAC1C;IAEzB,IAAI,CAACyC,OAAO;QACV,MAAM,IAAIE,MACR,mDACE;IAEN;IAEA,OAAOC,IAAAA,iBAAe,EAACH,OAAOD;AAChC;AAiCO,MAAMzC,cAAc;IACzB,MAAM0C,QAAQC,IAAAA,iBAAU,EAAC1C;IAEzB,IAAI,CAACyC,OAAO;QACV,MAAM,IAAIE,MACR,sDACE;IAEN;IAEA,OAAOF;AACT"}