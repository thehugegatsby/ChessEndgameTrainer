{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/hooks/useMoveQuality.ts"],"sourcesContent":["/**\n * @file Hook for on-demand move quality assessment\n * @module hooks/useMoveQuality\n *\n * @description\n * Provides controlled move quality analysis with loading/error states.\n * Following clean architecture principles with trigger-based evaluation.\n * Uses tablebase data to determine if moves are optimal, good, or mistakes.\n *\n * @remarks\n * Features:\n * - Race condition protection with AbortController\n * - Robust error handling with state management\n * - Automatic cleanup on unmount\n * - Tablebase-based analysis for endgame positions\n * - Supports both SAN and UCI move notation\n */\n\nimport { useState, useCallback, useRef, useEffect } from \"react\";\nimport { tablebaseService } from \"@shared/services/TablebaseService\";\nimport { assessTablebaseMoveQuality } from \"@shared/utils/moveQuality\";\nimport { Chess } from \"chess.js\";\nimport type { SimplifiedMoveQualityResult } from \"../types/evaluation\";\nimport { Logger } from \"../services/logging/Logger\";\n\nconst logger = new Logger();\n\n/**\n * State interface for move quality analysis\n *\n * @interface UseMoveQualityState\n * @property {SimplifiedMoveQualityResult | null} data - Current move quality result\n * @property {boolean} isLoading - Whether analysis is in progress\n * @property {Error | null} error - Error from analysis if any\n */\ninterface UseMoveQualityState {\n  /** Current move quality result */\n  data: SimplifiedMoveQualityResult | null;\n  /** Whether analysis is in progress */\n  isLoading: boolean;\n  /** Error from analysis */\n  error: Error | null;\n}\n\n/**\n * Hook for on-demand move quality assessment\n *\n * @description\n * Returns state and trigger function for controlled analysis.\n * No automatic evaluation - only when assessMove is called.\n * Uses tablebase API to compare positions before and after moves.\n *\n * @returns {Object} Hook return object\n * @returns {SimplifiedMoveQualityResult | null} returns.data - Current move quality result\n * @returns {boolean} returns.isLoading - Whether analysis is in progress\n * @returns {Error | null} returns.error - Error from analysis if any\n * @returns {Function} returns.assessMove - Trigger function for move quality assessment\n * @returns {Function} returns.clearAnalysis - Clear current analysis data\n *\n * @example\n * ```tsx\n * const { data, isLoading, error, assessMove } = useMoveQuality();\n *\n * // Assess a move when user plays\n * const handleMove = async (move: string) => {\n *   try {\n *     const result = await assessMove(currentFen, move, 'w');\n *     if (result.quality === 'mistake') {\n *       showWarning(result.reason);\n *     }\n *   } catch (err) {\n *     console.error('Move assessment failed:', err);\n *   }\n * };\n * ```\n */\nexport const useMoveQuality = () => {\n  const [state, setState] = useState<UseMoveQualityState>({\n    data: null,\n    isLoading: false,\n    error: null,\n  });\n\n  // Ref to manage abort controller and prevent race conditions\n  const abortControllerRef = useRef<AbortController | null>(null);\n\n  // Clean up on unmount\n  useEffect(() => {\n    return () => {\n      abortControllerRef.current?.abort();\n    };\n  }, []);\n\n  /**\n   * Assess move quality on-demand\n   *\n   * @param fenBefore - FEN position before the move\n   * @param move - Move in SAN or UCI notation\n   * @param playerPerspective - Player who made the move\n   * @returns Promise resolving to move quality result\n   * @throws Error if assessment fails\n   */\n  const assessMove = useCallback(\n    async (\n      fenBefore: string,\n      move: string,\n      playerPerspective: \"w\" | \"b\",\n    ): Promise<SimplifiedMoveQualityResult> => {\n      // Abort previous request if running\n      abortControllerRef.current?.abort();\n\n      // Create new abort controller for this request\n      const controller = new AbortController();\n      abortControllerRef.current = controller;\n\n      // Set loading state\n      setState({ data: null, isLoading: true, error: null });\n\n      try {\n        logger.info(\"[useMoveQuality] Starting move quality assessment\", {\n          fenBefore: fenBefore.slice(0, 30) + \"...\",\n          move,\n          playerPerspective,\n        });\n\n        // Calculate FEN after the move\n        const chess = new Chess(fenBefore);\n        const moveResult = chess.move(move);\n        if (!moveResult) {\n          const result: SimplifiedMoveQualityResult = {\n            quality: \"unknown\",\n            reason: \"Invalid move\",\n            isTablebaseAnalysis: false,\n          };\n          setState({ data: result, isLoading: false, error: null });\n          return result;\n        }\n        const fenAfter = chess.fen();\n\n        // Get tablebase evaluations for both positions\n        const [evalBefore, evalAfter] = await Promise.all([\n          tablebaseService.getEvaluation(fenBefore),\n          tablebaseService.getEvaluation(fenAfter),\n        ]);\n\n        // Check if both positions have tablebase data\n        if (\n          !evalBefore.isAvailable ||\n          !evalAfter.isAvailable ||\n          !evalBefore.result ||\n          !evalAfter.result\n        ) {\n          const result: SimplifiedMoveQualityResult = {\n            quality: \"unknown\",\n            reason: \"No tablebase data available\",\n            isTablebaseAnalysis: false,\n          };\n          setState({ data: result, isLoading: false, error: null });\n          return result;\n        }\n\n        // Detailed logging before assessment\n        logger.info(\"[useMoveQuality] WDL values before assessment\", {\n          move,\n          fenBefore,\n          fenAfter,\n          wdlBefore: evalBefore.result.wdl,\n          wdlAfter: evalAfter.result.wdl,\n          categoryBefore: evalBefore.result.category,\n          categoryAfter: evalAfter.result.category,\n        });\n\n        // Assess move quality using helper function\n        const result = assessTablebaseMoveQuality(\n          evalBefore.result.wdl,\n          evalAfter.result.wdl,\n        );\n\n        // Log the calculation details\n        const wdlChange = -evalAfter.result.wdl - evalBefore.result.wdl;\n        logger.info(\"[useMoveQuality] Quality calculation details\", {\n          wdlBefore: evalBefore.result.wdl,\n          wdlAfter: evalAfter.result.wdl,\n          wdlChange,\n          calculatedQuality: result.quality,\n          formula: `wdlChange = -${evalAfter.result.wdl} - ${evalBefore.result.wdl} = ${wdlChange}`,\n        });\n\n        // Only update state if request wasn't aborted\n        if (!controller.signal.aborted) {\n          setState({ data: result, isLoading: false, error: null });\n          abortControllerRef.current = null; // Request completed\n\n          logger.info(\"[useMoveQuality] Move quality assessment completed\", {\n            quality: result.quality,\n            reason: result.reason,\n            isTablebaseAnalysis: result.isTablebaseAnalysis,\n          });\n        }\n\n        return result;\n      } catch (error) {\n        if (controller.signal.aborted) {\n          logger.warn(\"[useMoveQuality] Assessment aborted by new request\");\n          throw new Error(\"Assessment aborted by new request\");\n        }\n\n        const errorObj =\n          error instanceof Error ? error : new Error(\"Unknown error occurred\");\n\n        logger.error(\n          \"[useMoveQuality] Move quality assessment failed\",\n          errorObj,\n        );\n\n        // Only update state if this was the active request\n        if (abortControllerRef.current === controller) {\n          setState({ data: null, isLoading: false, error: errorObj });\n        }\n\n        throw errorObj;\n      }\n    },\n    [],\n  );\n\n  /**\n   * Clear current analysis data\n   */\n  const clearAnalysis = useCallback(() => {\n    setState({ data: null, isLoading: false, error: null });\n  }, []);\n\n  return {\n    /** Current move quality result */\n    data: state.data,\n    /** Whether analysis is in progress */\n    isLoading: state.isLoading,\n    /** Error from analysis */\n    error: state.error,\n    /** Trigger function for move quality assessment */\n    assessMove,\n    /** Clear current analysis data */\n    clearAnalysis,\n  };\n};\n"],"names":["useMoveQuality","logger","Logger","state","setState","useState","data","isLoading","error","abortControllerRef","useRef","useEffect","current","abort","assessMove","useCallback","fenBefore","move","playerPerspective","controller","AbortController","info","slice","chess","Chess","moveResult","result","quality","reason","isTablebaseAnalysis","fenAfter","fen","evalBefore","evalAfter","Promise","all","tablebaseService","getEvaluation","isAvailable","wdlBefore","wdl","wdlAfter","categoryBefore","category","categoryAfter","assessTablebaseMoveQuality","wdlChange","calculatedQuality","formula","signal","aborted","warn","Error","errorObj","clearAnalysis"],"mappings":"AAAA;;;;;;;;;;;;;;;;CAgBC;;;;+BA4DYA;;;eAAAA;;;uBA1D4C;kCACxB;6BACU;uBACrB;wBAEC;AAEvB,MAAMC,SAAS,IAAIC,cAAM;AAmDlB,MAAMF,iBAAiB;IAC5B,MAAM,CAACG,OAAOC,SAAS,GAAGC,IAAAA,eAAQ,EAAsB;QACtDC,MAAM;QACNC,WAAW;QACXC,OAAO;IACT;IAEA,6DAA6D;IAC7D,MAAMC,qBAAqBC,IAAAA,aAAM,EAAyB;IAE1D,sBAAsB;IACtBC,IAAAA,gBAAS,EAAC;QACR,OAAO;gBACLF;aAAAA,8BAAAA,mBAAmBG,OAAO,cAA1BH,kDAAAA,4BAA4BI,KAAK;QACnC;IACF,GAAG,EAAE;IAEL;;;;;;;;GAQC,GACD,MAAMC,aAAaC,IAAAA,kBAAW,EAC5B,OACEC,WACAC,MACAC;YAEA,oCAAoC;QACpCT;SAAAA,8BAAAA,mBAAmBG,OAAO,cAA1BH,kDAAAA,4BAA4BI,KAAK;QAEjC,+CAA+C;QAC/C,MAAMM,aAAa,IAAIC;QACvBX,mBAAmBG,OAAO,GAAGO;QAE7B,oBAAoB;QACpBf,SAAS;YAAEE,MAAM;YAAMC,WAAW;YAAMC,OAAO;QAAK;QAEpD,IAAI;YACFP,OAAOoB,IAAI,CAAC,qDAAqD;gBAC/DL,WAAWA,UAAUM,KAAK,CAAC,GAAG,MAAM;gBACpCL;gBACAC;YACF;YAEA,+BAA+B;YAC/B,MAAMK,QAAQ,IAAIC,YAAK,CAACR;YACxB,MAAMS,aAAaF,MAAMN,IAAI,CAACA;YAC9B,IAAI,CAACQ,YAAY;gBACf,MAAMC,SAAsC;oBAC1CC,SAAS;oBACTC,QAAQ;oBACRC,qBAAqB;gBACvB;gBACAzB,SAAS;oBAAEE,MAAMoB;oBAAQnB,WAAW;oBAAOC,OAAO;gBAAK;gBACvD,OAAOkB;YACT;YACA,MAAMI,WAAWP,MAAMQ,GAAG;YAE1B,+CAA+C;YAC/C,MAAM,CAACC,YAAYC,UAAU,GAAG,MAAMC,QAAQC,GAAG,CAAC;gBAChDC,kCAAgB,CAACC,aAAa,CAACrB;gBAC/BoB,kCAAgB,CAACC,aAAa,CAACP;aAChC;YAED,8CAA8C;YAC9C,IACE,CAACE,WAAWM,WAAW,IACvB,CAACL,UAAUK,WAAW,IACtB,CAACN,WAAWN,MAAM,IAClB,CAACO,UAAUP,MAAM,EACjB;gBACA,MAAMA,SAAsC;oBAC1CC,SAAS;oBACTC,QAAQ;oBACRC,qBAAqB;gBACvB;gBACAzB,SAAS;oBAAEE,MAAMoB;oBAAQnB,WAAW;oBAAOC,OAAO;gBAAK;gBACvD,OAAOkB;YACT;YAEA,qCAAqC;YACrCzB,OAAOoB,IAAI,CAAC,iDAAiD;gBAC3DJ;gBACAD;gBACAc;gBACAS,WAAWP,WAAWN,MAAM,CAACc,GAAG;gBAChCC,UAAUR,UAAUP,MAAM,CAACc,GAAG;gBAC9BE,gBAAgBV,WAAWN,MAAM,CAACiB,QAAQ;gBAC1CC,eAAeX,UAAUP,MAAM,CAACiB,QAAQ;YAC1C;YAEA,4CAA4C;YAC5C,MAAMjB,SAASmB,IAAAA,uCAA0B,EACvCb,WAAWN,MAAM,CAACc,GAAG,EACrBP,UAAUP,MAAM,CAACc,GAAG;YAGtB,8BAA8B;YAC9B,MAAMM,YAAY,CAACb,UAAUP,MAAM,CAACc,GAAG,GAAGR,WAAWN,MAAM,CAACc,GAAG;YAC/DvC,OAAOoB,IAAI,CAAC,gDAAgD;gBAC1DkB,WAAWP,WAAWN,MAAM,CAACc,GAAG;gBAChCC,UAAUR,UAAUP,MAAM,CAACc,GAAG;gBAC9BM;gBACAC,mBAAmBrB,OAAOC,OAAO;gBACjCqB,SAAS,CAAC,aAAa,EAAEf,UAAUP,MAAM,CAACc,GAAG,CAAC,GAAG,EAAER,WAAWN,MAAM,CAACc,GAAG,CAAC,GAAG,EAAEM,WAAW;YAC3F;YAEA,8CAA8C;YAC9C,IAAI,CAAC3B,WAAW8B,MAAM,CAACC,OAAO,EAAE;gBAC9B9C,SAAS;oBAAEE,MAAMoB;oBAAQnB,WAAW;oBAAOC,OAAO;gBAAK;gBACvDC,mBAAmBG,OAAO,GAAG,MAAM,oBAAoB;gBAEvDX,OAAOoB,IAAI,CAAC,sDAAsD;oBAChEM,SAASD,OAAOC,OAAO;oBACvBC,QAAQF,OAAOE,MAAM;oBACrBC,qBAAqBH,OAAOG,mBAAmB;gBACjD;YACF;YAEA,OAAOH;QACT,EAAE,OAAOlB,OAAO;YACd,IAAIW,WAAW8B,MAAM,CAACC,OAAO,EAAE;gBAC7BjD,OAAOkD,IAAI,CAAC;gBACZ,MAAM,IAAIC,MAAM;YAClB;YAEA,MAAMC,WACJ7C,iBAAiB4C,QAAQ5C,QAAQ,IAAI4C,MAAM;YAE7CnD,OAAOO,KAAK,CACV,mDACA6C;YAGF,mDAAmD;YACnD,IAAI5C,mBAAmBG,OAAO,KAAKO,YAAY;gBAC7Cf,SAAS;oBAAEE,MAAM;oBAAMC,WAAW;oBAAOC,OAAO6C;gBAAS;YAC3D;YAEA,MAAMA;QACR;IACF,GACA,EAAE;IAGJ;;GAEC,GACD,MAAMC,gBAAgBvC,IAAAA,kBAAW,EAAC;QAChCX,SAAS;YAAEE,MAAM;YAAMC,WAAW;YAAOC,OAAO;QAAK;IACvD,GAAG,EAAE;IAEL,OAAO;QACL,gCAAgC,GAChCF,MAAMH,MAAMG,IAAI;QAChB,oCAAoC,GACpCC,WAAWJ,MAAMI,SAAS;QAC1B,wBAAwB,GACxBC,OAAOL,MAAMK,KAAK;QAClB,iDAAiD,GACjDM;QACA,gCAAgC,GAChCwC;IACF;AACF"}