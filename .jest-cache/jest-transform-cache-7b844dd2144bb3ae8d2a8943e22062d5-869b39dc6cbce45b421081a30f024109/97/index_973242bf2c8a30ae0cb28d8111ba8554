2d044f52c03dd6348d97d3945e189515
'use strict';
var React = require('react');
var reactDom = require('react-dom');
var jsxRuntime = {
    exports: {}
};
var reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config.key && (key = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        config = maybeKey.ref;
        return {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            ref: void 0 !== config ? config : null,
            props: maybeKey
        };
    }
    reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
    reactJsxRuntime_production.jsx = jsxProd;
    reactJsxRuntime_production.jsxs = jsxProd;
    return reactJsxRuntime_production;
}
var reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
    if (hasRequiredReactJsxRuntime_development) return reactJsxRuntime_development;
    hasRequiredReactJsxRuntime_development = 1;
    "production" !== process.env.NODE_ENV && function() {
        function getComponentNameFromType(type) {
            if (null == type) return null;
            if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
            if ("string" === typeof type) return type;
            switch(type){
                case REACT_FRAGMENT_TYPE:
                    return "Fragment";
                case REACT_PORTAL_TYPE:
                    return "Portal";
                case REACT_PROFILER_TYPE:
                    return "Profiler";
                case REACT_STRICT_MODE_TYPE:
                    return "StrictMode";
                case REACT_SUSPENSE_TYPE:
                    return "Suspense";
                case REACT_SUSPENSE_LIST_TYPE:
                    return "SuspenseList";
            }
            if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
                case REACT_CONTEXT_TYPE:
                    return (type.displayName || "Context") + ".Provider";
                case REACT_CONSUMER_TYPE:
                    return (type._context.displayName || "Context") + ".Consumer";
                case REACT_FORWARD_REF_TYPE:
                    var innerType = type.render;
                    type = type.displayName;
                    type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                    return type;
                case REACT_MEMO_TYPE:
                    return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE:
                    innerType = type._payload;
                    type = type._init;
                    try {
                        return getComponentNameFromType(type(innerType));
                    } catch (x) {}
            }
            return null;
        }
        function testStringCoercion(value) {
            return "" + value;
        }
        function checkKeyStringCoercion(value) {
            try {
                testStringCoercion(value);
                var JSCompiler_inline_result = !1;
            } catch (e) {
                JSCompiler_inline_result = true;
            }
            if (JSCompiler_inline_result) {
                JSCompiler_inline_result = console;
                var JSCompiler_temp_const = JSCompiler_inline_result.error;
                var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
                JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
                return testStringCoercion(value);
            }
        }
        function disabledLog() {}
        function disableLogs() {
            if (0 === disabledDepth) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                    configurable: true,
                    enumerable: true,
                    value: disabledLog,
                    writable: true
                };
                Object.defineProperties(console, {
                    info: props,
                    log: props,
                    warn: props,
                    error: props,
                    group: props,
                    groupCollapsed: props,
                    groupEnd: props
                });
            }
            disabledDepth++;
        }
        function reenableLogs() {
            disabledDepth--;
            if (0 === disabledDepth) {
                var props = {
                    configurable: true,
                    enumerable: true,
                    writable: true
                };
                Object.defineProperties(console, {
                    log: assign({}, props, {
                        value: prevLog
                    }),
                    info: assign({}, props, {
                        value: prevInfo
                    }),
                    warn: assign({}, props, {
                        value: prevWarn
                    }),
                    error: assign({}, props, {
                        value: prevError
                    }),
                    group: assign({}, props, {
                        value: prevGroup
                    }),
                    groupCollapsed: assign({}, props, {
                        value: prevGroupCollapsed
                    }),
                    groupEnd: assign({}, props, {
                        value: prevGroupEnd
                    })
                });
            }
            0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
        function describeBuiltInComponentFrame(name) {
            if (void 0 === prefix) try {
                throw Error();
            } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
                suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
            return "\n" + prefix + name + suffix;
        }
        function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) return "";
            var frame = componentFrameCache.get(fn);
            if (void 0 !== frame) return frame;
            reentry = true;
            frame = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher = null;
            previousDispatcher = ReactSharedInternals.H;
            ReactSharedInternals.H = null;
            disableLogs();
            try {
                var RunInRootFrame = {
                    DetermineComponentFrameRoot: function() {
                        try {
                            if (construct) {
                                var Fake = function() {
                                    throw Error();
                                };
                                Object.defineProperty(Fake.prototype, "props", {
                                    set: function() {
                                        throw Error();
                                    }
                                });
                                if ("object" === typeof Reflect && Reflect.construct) {
                                    try {
                                        Reflect.construct(Fake, []);
                                    } catch (x) {
                                        var control = x;
                                    }
                                    Reflect.construct(fn, [], Fake);
                                } else {
                                    try {
                                        Fake.call();
                                    } catch (x$0) {
                                        control = x$0;
                                    }
                                    fn.call(Fake.prototype);
                                }
                            } else {
                                try {
                                    throw Error();
                                } catch (x$1) {
                                    control = x$1;
                                }
                                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {});
                            }
                        } catch (sample) {
                            if (sample && control && "string" === typeof sample.stack) return [
                                sample.stack,
                                control.stack
                            ];
                        }
                        return [
                            null,
                            null
                        ];
                    }
                };
                RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
                namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
                    value: "DetermineComponentFrameRoot"
                });
                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
                if (sampleStack && controlStack) {
                    var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
                    for(_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");)namePropDescriptor++;
                    for(; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");)_RunInRootFrame$Deter++;
                    if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for(namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];)_RunInRootFrame$Deter--;
                    for(; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                        if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
                            do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
                                var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
                                fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
                                "function" === typeof fn && componentFrameCache.set(fn, _frame);
                                return _frame;
                            }
                            while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter)
                        }
                        break;
                    }
                }
            } finally{
                reentry = false, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
            }
            sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
            "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
            return sampleLines;
        }
        function describeUnknownElementTypeFrameInDEV(type) {
            if (null == type) return "";
            if ("function" === typeof type) {
                var prototype = type.prototype;
                return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
            }
            if ("string" === typeof type) return describeBuiltInComponentFrame(type);
            switch(type){
                case REACT_SUSPENSE_TYPE:
                    return describeBuiltInComponentFrame("Suspense");
                case REACT_SUSPENSE_LIST_TYPE:
                    return describeBuiltInComponentFrame("SuspenseList");
            }
            if ("object" === typeof type) switch(type.$$typeof){
                case REACT_FORWARD_REF_TYPE:
                    return type = describeNativeComponentFrame(type.render, false), type;
                case REACT_MEMO_TYPE:
                    return describeUnknownElementTypeFrameInDEV(type.type);
                case REACT_LAZY_TYPE:
                    prototype = type._payload;
                    type = type._init;
                    try {
                        return describeUnknownElementTypeFrameInDEV(type(prototype));
                    } catch (x) {}
            }
            return "";
        }
        function getOwner() {
            var dispatcher = ReactSharedInternals.A;
            return null === dispatcher ? null : dispatcher.getOwner();
        }
        function hasValidKey(config) {
            if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) return false;
            }
            return void 0 !== config.key;
        }
        function defineKeyPropWarningGetter(props, displayName) {
            function warnAboutAccessingKey() {
                specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
            }
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
            });
        }
        function elementRefGetterWithDeprecationWarning() {
            var componentName = getComponentNameFromType(this.type);
            didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
            componentName = this.props.ref;
            return void 0 !== componentName ? componentName : null;
        }
        function ReactElement(type, key, self, source, owner, props) {
            self = props.ref;
            type = {
                $$typeof: REACT_ELEMENT_TYPE,
                type: type,
                key: key,
                props: props,
                _owner: owner
            };
            null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
                enumerable: false,
                get: elementRefGetterWithDeprecationWarning
            }) : Object.defineProperty(type, "ref", {
                enumerable: false,
                value: null
            });
            type._store = {};
            Object.defineProperty(type._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: 0
            });
            Object.defineProperty(type, "_debugInfo", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: null
            });
            Object.freeze && (Object.freeze(type.props), Object.freeze(type));
            return type;
        }
        function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
            if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
                var children = config.children;
                if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
                    for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren], type);
                    Object.freeze && Object.freeze(children);
                } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                else validateChildKeys(children, type);
            } else {
                children = "";
                if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
                console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
            }
            if (hasOwnProperty.call(config, "key")) {
                children = getComponentNameFromType(type);
                var keys = Object.keys(config).filter(function(k) {
                    return "key" !== k;
                });
                isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
                didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = true);
            }
            children = null;
            void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
            hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
            if ("key" in config) {
                maybeKey = {};
                for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
            } else maybeKey = config;
            children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
            return ReactElement(type, children, self, source, getOwner(), maybeKey);
        }
        function validateChildKeys(node, parentType) {
            if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) {
                if (isArrayImpl(node)) for(var i = 0; i < node.length; i++){
                    var child = node[i];
                    isValidElement(child) && validateExplicitKey(child, parentType);
                }
                else if (isValidElement(node)) node._store && (node._store.validated = 1);
                else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for(; !(node = i.next()).done;)isValidElement(node.value) && validateExplicitKey(node.value, parentType);
            }
        }
        function isValidElement(object) {
            return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function validateExplicitKey(element, parentType) {
            if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
                ownerHasKeyUseWarning[parentType] = true;
                var childOwner = "";
                element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
                var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
                ReactSharedInternals.getCurrentStack = function() {
                    var stack = describeUnknownElementTypeFrameInDEV(element.type);
                    prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
                    return stack;
                };
                console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
                ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
            }
        }
        function getCurrentComponentErrorInfo(parentType) {
            var info = "", owner = getOwner();
            owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
            info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
            return info;
        }
        var React$1 = React, REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"), ReactSharedInternals = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, assign = Object.assign, REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
        disabledLog.__reactDisabledLog = true;
        var prefix, suffix, reentry = false;
        var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
        var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), specialPropKeyWarningShown;
        var didWarnAboutElementRef = {};
        var didWarnAboutKeySpread = {}, ownerHasKeyUseWarning = {};
        reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
        reactJsxRuntime_development.jsx = function(type, config, maybeKey, source, self) {
            return jsxDEVImpl(type, config, maybeKey, false, source, self);
        };
        reactJsxRuntime_development.jsxs = function(type, config, maybeKey, source, self) {
            return jsxDEVImpl(type, config, maybeKey, true, source, self);
        };
    }();
    return reactJsxRuntime_development;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
    if (hasRequiredJsxRuntime) return jsxRuntime.exports;
    hasRequiredJsxRuntime = 1;
    if (process.env.NODE_ENV === 'production') {
        jsxRuntime.exports = requireReactJsxRuntime_production();
    } else {
        jsxRuntime.exports = requireReactJsxRuntime_development();
    }
    return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js
const canUseDOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
function isWindow(element) {
    const elementString = Object.prototype.toString.call(element);
    return elementString === '[object Window]' || // In Electron context the Window object serializes to [object global]
    elementString === '[object global]';
}
function isNode(node) {
    return 'nodeType' in node;
}
function getWindow(target) {
    var _target$ownerDocument, _target$ownerDocument2;
    if (!target) {
        return window;
    }
    if (isWindow(target)) {
        return target;
    }
    if (!isNode(target)) {
        return window;
    }
    return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node) {
    const { Document } = getWindow(node);
    return node instanceof Document;
}
function isHTMLElement(node) {
    if (isWindow(node)) {
        return false;
    }
    return node instanceof getWindow(node).HTMLElement;
}
function isSVGElement(node) {
    return node instanceof getWindow(node).SVGElement;
}
function getOwnerDocument(target) {
    if (!target) {
        return document;
    }
    if (isWindow(target)) {
        return target.document;
    }
    if (!isNode(target)) {
        return document;
    }
    if (isDocument(target)) {
        return target;
    }
    if (isHTMLElement(target) || isSVGElement(target)) {
        return target.ownerDocument;
    }
    return document;
}
/**
 * A hook that resolves to useEffect on the server and useLayoutEffect on the client
 * @param callback {function} Callback function that is invoked when the dependencies of the hook change
 */ const useIsomorphicLayoutEffect = canUseDOM ? React.useLayoutEffect : React.useEffect;
function useEvent(handler) {
    const handlerRef = React.useRef(handler);
    useIsomorphicLayoutEffect(()=>{
        handlerRef.current = handler;
    });
    return React.useCallback(function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return handlerRef.current == null ? void 0 : handlerRef.current(...args);
    }, []);
}
function useInterval() {
    const intervalRef = React.useRef(null);
    const set = React.useCallback((listener, duration)=>{
        intervalRef.current = setInterval(listener, duration);
    }, []);
    const clear = React.useCallback(()=>{
        if (intervalRef.current !== null) {
            clearInterval(intervalRef.current);
            intervalRef.current = null;
        }
    }, []);
    return [
        set,
        clear
    ];
}
function useLatestValue(value, dependencies) {
    if (dependencies === void 0) {
        dependencies = [
            value
        ];
    }
    const valueRef = React.useRef(value);
    useIsomorphicLayoutEffect(()=>{
        if (valueRef.current !== value) {
            valueRef.current = value;
        }
    }, dependencies);
    return valueRef;
}
function useLazyMemo(callback, dependencies) {
    const valueRef = React.useRef();
    return React.useMemo(()=>{
        const newValue = callback(valueRef.current);
        valueRef.current = newValue;
        return newValue;
    }, [
        ...dependencies
    ]);
}
function useNodeRef(onChange) {
    const onChangeHandler = useEvent(onChange);
    const node = React.useRef(null);
    const setNodeRef = React.useCallback((element)=>{
        if (element !== node.current) {
            onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
        }
        node.current = element;
    }, []);
    return [
        node,
        setNodeRef
    ];
}
function usePrevious(value) {
    const ref = React.useRef();
    React.useEffect(()=>{
        ref.current = value;
    }, [
        value
    ]);
    return ref.current;
}
let ids = {};
function useUniqueId(prefix, value) {
    return React.useMemo(()=>{
        if (value) {
            return value;
        }
        const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
        ids[prefix] = id;
        return prefix + "-" + id;
    }, [
        prefix,
        value
    ]);
}
function createAdjustmentFn(modifier) {
    return function(object) {
        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            adjustments[_key - 1] = arguments[_key];
        }
        return adjustments.reduce((accumulator, adjustment)=>{
            const entries = Object.entries(adjustment);
            for (const [key, valueAdjustment] of entries){
                const value = accumulator[key];
                if (value != null) {
                    accumulator[key] = value + modifier * valueAdjustment;
                }
            }
            return accumulator;
        }, {
            ...object
        });
    };
}
const add = /*#__PURE__*/ createAdjustmentFn(1);
const subtract = /*#__PURE__*/ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
    return 'clientX' in event && 'clientY' in event;
}
function isKeyboardEvent(event) {
    if (!event) {
        return false;
    }
    const { KeyboardEvent } = getWindow(event.target);
    return KeyboardEvent && event instanceof KeyboardEvent;
}
function isTouchEvent(event) {
    if (!event) {
        return false;
    }
    const { TouchEvent } = getWindow(event.target);
    return TouchEvent && event instanceof TouchEvent;
}
/**
 * Returns the normalized x and y coordinates for mouse and touch events.
 */ function getEventCoordinates(event) {
    if (isTouchEvent(event)) {
        if (event.touches && event.touches.length) {
            const { clientX: x, clientY: y } = event.touches[0];
            return {
                x,
                y
            };
        } else if (event.changedTouches && event.changedTouches.length) {
            const { clientX: x, clientY: y } = event.changedTouches[0];
            return {
                x,
                y
            };
        }
    }
    if (hasViewportRelativeCoordinates(event)) {
        return {
            x: event.clientX,
            y: event.clientY
        };
    }
    return null;
}
const CSS = /*#__PURE__*/ Object.freeze({
    Translate: {
        toString (transform) {
            if (!transform) {
                return;
            }
            const { x, y } = transform;
            return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
        }
    },
    Scale: {
        toString (transform) {
            if (!transform) {
                return;
            }
            const { scaleX, scaleY } = transform;
            return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
        }
    },
    Transform: {
        toString (transform) {
            if (!transform) {
                return;
            }
            return [
                CSS.Translate.toString(transform),
                CSS.Scale.toString(transform)
            ].join(' ');
        }
    },
    Transition: {
        toString (_ref) {
            let { property, duration, easing } = _ref;
            return property + " " + duration + "ms " + easing;
        }
    }
});
const SELECTOR = 'a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]';
function findFirstFocusableNode(element) {
    if (element.matches(SELECTOR)) {
        return element;
    }
    return element.querySelector(SELECTOR);
}
const hiddenStyles = {
    display: 'none'
};
function HiddenText(_ref) {
    let { id, value } = _ref;
    return React.createElement("div", {
        id: id,
        style: hiddenStyles
    }, value);
}
function LiveRegion(_ref) {
    let { id, announcement, ariaLiveType = "assertive" } = _ref;
    // Hide element visually but keep it readable by screen readers
    const visuallyHidden = {
        position: 'fixed',
        top: 0,
        left: 0,
        width: 1,
        height: 1,
        margin: -1,
        border: 0,
        padding: 0,
        overflow: 'hidden',
        clip: 'rect(0 0 0 0)',
        clipPath: 'inset(100%)',
        whiteSpace: 'nowrap'
    };
    return React.createElement("div", {
        id: id,
        style: visuallyHidden,
        role: "status",
        "aria-live": ariaLiveType,
        "aria-atomic": true
    }, announcement);
}
function useAnnouncement() {
    const [announcement, setAnnouncement] = React.useState('');
    const announce = React.useCallback((value)=>{
        if (value != null) {
            setAnnouncement(value);
        }
    }, []);
    return {
        announce,
        announcement
    };
}
const DndMonitorContext = /*#__PURE__*/ React.createContext(null);
function useDndMonitor(listener) {
    const registerListener = React.useContext(DndMonitorContext);
    React.useEffect(()=>{
        if (!registerListener) {
            throw new Error('useDndMonitor must be used within a children of <DndContext>');
        }
        const unsubscribe = registerListener(listener);
        return unsubscribe;
    }, [
        listener,
        registerListener
    ]);
}
function useDndMonitorProvider() {
    const [listeners] = React.useState(()=>new Set());
    const registerListener = React.useCallback((listener)=>{
        listeners.add(listener);
        return ()=>listeners.delete(listener);
    }, [
        listeners
    ]);
    const dispatch = React.useCallback((_ref)=>{
        let { type, event } = _ref;
        listeners.forEach((listener)=>{
            var _listener$type;
            return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
        });
    }, [
        listeners
    ]);
    return [
        dispatch,
        registerListener
    ];
}
const defaultScreenReaderInstructions = {
    draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
const defaultAnnouncements = {
    onDragStart (_ref) {
        let { active } = _ref;
        return "Picked up draggable item " + active.id + ".";
    },
    onDragOver (_ref2) {
        let { active, over } = _ref2;
        if (over) {
            return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
        }
        return "Draggable item " + active.id + " is no longer over a droppable area.";
    },
    onDragEnd (_ref3) {
        let { active, over } = _ref3;
        if (over) {
            return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
        }
        return "Draggable item " + active.id + " was dropped.";
    },
    onDragCancel (_ref4) {
        let { active } = _ref4;
        return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
    }
};
function Accessibility(_ref) {
    let { announcements = defaultAnnouncements, container, hiddenTextDescribedById, screenReaderInstructions = defaultScreenReaderInstructions } = _ref;
    const { announce, announcement } = useAnnouncement();
    const liveRegionId = useUniqueId("DndLiveRegion");
    const [mounted, setMounted] = React.useState(false);
    React.useEffect(()=>{
        setMounted(true);
    }, []);
    useDndMonitor(React.useMemo(()=>({
            onDragStart (_ref2) {
                let { active } = _ref2;
                announce(announcements.onDragStart({
                    active
                }));
            },
            onDragMove (_ref3) {
                let { active, over } = _ref3;
                if (announcements.onDragMove) {
                    announce(announcements.onDragMove({
                        active,
                        over
                    }));
                }
            },
            onDragOver (_ref4) {
                let { active, over } = _ref4;
                announce(announcements.onDragOver({
                    active,
                    over
                }));
            },
            onDragEnd (_ref5) {
                let { active, over } = _ref5;
                announce(announcements.onDragEnd({
                    active,
                    over
                }));
            },
            onDragCancel (_ref6) {
                let { active, over } = _ref6;
                announce(announcements.onDragCancel({
                    active,
                    over
                }));
            }
        }), [
        announce,
        announcements
    ]));
    if (!mounted) {
        return null;
    }
    const markup = React.createElement(React.Fragment, null, React.createElement(HiddenText, {
        id: hiddenTextDescribedById,
        value: screenReaderInstructions.draggable
    }), React.createElement(LiveRegion, {
        id: liveRegionId,
        announcement: announcement
    }));
    return container ? reactDom.createPortal(markup, container) : markup;
}
var Action;
(function(Action) {
    Action["DragStart"] = "dragStart";
    Action["DragMove"] = "dragMove";
    Action["DragEnd"] = "dragEnd";
    Action["DragCancel"] = "dragCancel";
    Action["DragOver"] = "dragOver";
    Action["RegisterDroppable"] = "registerDroppable";
    Action["SetDroppableDisabled"] = "setDroppableDisabled";
    Action["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop() {}
function useSensor(sensor, options) {
    return React.useMemo(()=>({
            sensor,
            options: options != null ? options : {}
        }), [
        sensor,
        options
    ]);
}
function useSensors() {
    for(var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++){
        sensors[_key] = arguments[_key];
    }
    return React.useMemo(()=>[
            ...sensors
        ].filter((sensor)=>sensor != null), [
        ...sensors
    ]);
}
const defaultCoordinates = /*#__PURE__*/ Object.freeze({
    x: 0,
    y: 0
});
/**
 * Returns the distance between two points
 */ function distanceBetween(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function getRelativeTransformOrigin(event, rect) {
    const eventCoordinates = getEventCoordinates(event);
    if (!eventCoordinates) {
        return '0 0';
    }
    const transformOrigin = {
        x: (eventCoordinates.x - rect.left) / rect.width * 100,
        y: (eventCoordinates.y - rect.top) / rect.height * 100
    };
    return transformOrigin.x + "% " + transformOrigin.y + "%";
}
/**
 * Sort collisions from smallest to greatest value
 */ function sortCollisionsAsc(_ref, _ref2) {
    let { data: { value: a } } = _ref;
    let { data: { value: b } } = _ref2;
    return a - b;
}
/**
 * Sort collisions from greatest to smallest value
 */ function sortCollisionsDesc(_ref3, _ref4) {
    let { data: { value: a } } = _ref3;
    let { data: { value: b } } = _ref4;
    return b - a;
}
/**
 * Returns the coordinates of the corners of a given rectangle:
 * [TopLeft {x, y}, TopRight {x, y}, BottomLeft {x, y}, BottomRight {x, y}]
 */ function cornersOfRectangle(_ref5) {
    let { left, top, height, width } = _ref5;
    return [
        {
            x: left,
            y: top
        },
        {
            x: left + width,
            y: top
        },
        {
            x: left,
            y: top + height
        },
        {
            x: left + width,
            y: top + height
        }
    ];
}
function getFirstCollision(collisions, property) {
    if (!collisions || collisions.length === 0) {
        return null;
    }
    const [firstCollision] = collisions;
    return firstCollision[property];
}
/**
 * Returns the intersecting rectangle area between two rectangles
 */ function getIntersectionRatio(entry, target) {
    const top = Math.max(target.top, entry.top);
    const left = Math.max(target.left, entry.left);
    const right = Math.min(target.left + target.width, entry.left + entry.width);
    const bottom = Math.min(target.top + target.height, entry.top + entry.height);
    const width = right - left;
    const height = bottom - top;
    if (left < right && top < bottom) {
        const targetArea = target.width * target.height;
        const entryArea = entry.width * entry.height;
        const intersectionArea = width * height;
        const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
        return Number(intersectionRatio.toFixed(4));
    } // Rectangles do not overlap, or overlap has an area of zero (edge/corner overlap)
    return 0;
}
/**
 * Returns the rectangles that has the greatest intersection area with a given
 * rectangle in an array of rectangles.
 */ const rectIntersection = (_ref)=>{
    let { collisionRect, droppableRects, droppableContainers } = _ref;
    const collisions = [];
    for (const droppableContainer of droppableContainers){
        const { id } = droppableContainer;
        const rect = droppableRects.get(id);
        if (rect) {
            const intersectionRatio = getIntersectionRatio(rect, collisionRect);
            if (intersectionRatio > 0) {
                collisions.push({
                    id,
                    data: {
                        droppableContainer,
                        value: intersectionRatio
                    }
                });
            }
        }
    }
    return collisions.sort(sortCollisionsDesc);
};
/**
 * Check if a given point is contained within a bounding rectangle
 */ function isPointWithinRect(point, rect) {
    const { top, left, bottom, right } = rect;
    return top <= point.y && point.y <= bottom && left <= point.x && point.x <= right;
}
/**
 * Returns the rectangles that the pointer is hovering over
 */ const pointerWithin = (_ref)=>{
    let { droppableContainers, droppableRects, pointerCoordinates } = _ref;
    if (!pointerCoordinates) {
        return [];
    }
    const collisions = [];
    for (const droppableContainer of droppableContainers){
        const { id } = droppableContainer;
        const rect = droppableRects.get(id);
        if (rect && isPointWithinRect(pointerCoordinates, rect)) {
            /* There may be more than a single rectangle intersecting
       * with the pointer coordinates. In order to sort the
       * colliding rectangles, we measure the distance between
       * the pointer and the corners of the intersecting rectangle
       */ const corners = cornersOfRectangle(rect);
            const distances = corners.reduce((accumulator, corner)=>{
                return accumulator + distanceBetween(pointerCoordinates, corner);
            }, 0);
            const effectiveDistance = Number((distances / 4).toFixed(4));
            collisions.push({
                id,
                data: {
                    droppableContainer,
                    value: effectiveDistance
                }
            });
        }
    }
    return collisions.sort(sortCollisionsAsc);
};
function adjustScale(transform, rect1, rect2) {
    return {
        ...transform,
        scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
        scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
    };
}
function getRectDelta(rect1, rect2) {
    return rect1 && rect2 ? {
        x: rect1.left - rect2.left,
        y: rect1.top - rect2.top
    } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
    return function adjustClientRect(rect) {
        for(var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            adjustments[_key - 1] = arguments[_key];
        }
        return adjustments.reduce((acc, adjustment)=>({
                ...acc,
                top: acc.top + modifier * adjustment.y,
                bottom: acc.bottom + modifier * adjustment.y,
                left: acc.left + modifier * adjustment.x,
                right: acc.right + modifier * adjustment.x
            }), {
            ...rect
        });
    };
}
const getAdjustedRect = /*#__PURE__*/ createRectAdjustmentFn(1);
function parseTransform(transform) {
    if (transform.startsWith('matrix3d(')) {
        const transformArray = transform.slice(9, -1).split(/, /);
        return {
            x: +transformArray[12],
            y: +transformArray[13],
            scaleX: +transformArray[0],
            scaleY: +transformArray[5]
        };
    } else if (transform.startsWith('matrix(')) {
        const transformArray = transform.slice(7, -1).split(/, /);
        return {
            x: +transformArray[4],
            y: +transformArray[5],
            scaleX: +transformArray[0],
            scaleY: +transformArray[3]
        };
    }
    return null;
}
function inverseTransform(rect, transform, transformOrigin) {
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
        return rect;
    }
    const { scaleX, scaleY, x: translateX, y: translateY } = parsedTransform;
    const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
    const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(' ') + 1));
    const w = scaleX ? rect.width / scaleX : rect.width;
    const h = scaleY ? rect.height / scaleY : rect.height;
    return {
        width: w,
        height: h,
        top: y,
        right: x + w,
        bottom: y + h,
        left: x
    };
}
const defaultOptions = {
    ignoreTransform: false
};
/**
 * Returns the bounding client rect of an element relative to the viewport.
 */ function getClientRect(element, options) {
    if (options === void 0) {
        options = defaultOptions;
    }
    let rect = element.getBoundingClientRect();
    if (options.ignoreTransform) {
        const { transform, transformOrigin } = getWindow(element).getComputedStyle(element);
        if (transform) {
            rect = inverseTransform(rect, transform, transformOrigin);
        }
    }
    const { top, left, width, height, bottom, right } = rect;
    return {
        top,
        left,
        width,
        height,
        bottom,
        right
    };
}
/**
 * Returns the bounding client rect of an element relative to the viewport.
 *
 * @remarks
 * The ClientRect returned by this method does not take into account transforms
 * applied to the element it measures.
 *
 */ function getTransformAgnosticClientRect(element) {
    return getClientRect(element, {
        ignoreTransform: true
    });
}
function getWindowClientRect(element) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
    };
}
function isFixed(node, computedStyle) {
    if (computedStyle === void 0) {
        computedStyle = getWindow(node).getComputedStyle(node);
    }
    return computedStyle.position === 'fixed';
}
function isScrollable(element, computedStyle) {
    if (computedStyle === void 0) {
        computedStyle = getWindow(element).getComputedStyle(element);
    }
    const overflowRegex = /(auto|scroll|overlay)/;
    const properties = [
        'overflow',
        'overflowX',
        'overflowY'
    ];
    return properties.some((property)=>{
        const value = computedStyle[property];
        return typeof value === 'string' ? overflowRegex.test(value) : false;
    });
}
function getScrollableAncestors(element, limit) {
    const scrollParents = [];
    function findScrollableAncestors(node) {
        if (limit != null && scrollParents.length >= limit) {
            return scrollParents;
        }
        if (!node) {
            return scrollParents;
        }
        if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
            scrollParents.push(node.scrollingElement);
            return scrollParents;
        }
        if (!isHTMLElement(node) || isSVGElement(node)) {
            return scrollParents;
        }
        if (scrollParents.includes(node)) {
            return scrollParents;
        }
        const computedStyle = getWindow(element).getComputedStyle(node);
        if (node !== element) {
            if (isScrollable(node, computedStyle)) {
                scrollParents.push(node);
            }
        }
        if (isFixed(node, computedStyle)) {
            return scrollParents;
        }
        return findScrollableAncestors(node.parentNode);
    }
    if (!element) {
        return scrollParents;
    }
    return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
    const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
    return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
    if (!canUseDOM || !element) {
        return null;
    }
    if (isWindow(element)) {
        return element;
    }
    if (!isNode(element)) {
        return null;
    }
    if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
        return window;
    }
    if (isHTMLElement(element)) {
        return element;
    }
    return null;
}
function getScrollXCoordinate(element) {
    if (isWindow(element)) {
        return element.scrollX;
    }
    return element.scrollLeft;
}
function getScrollYCoordinate(element) {
    if (isWindow(element)) {
        return element.scrollY;
    }
    return element.scrollTop;
}
function getScrollCoordinates(element) {
    return {
        x: getScrollXCoordinate(element),
        y: getScrollYCoordinate(element)
    };
}
var Direction;
(function(Direction) {
    Direction[Direction["Forward"] = 1] = "Forward";
    Direction[Direction["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function isDocumentScrollingElement(element) {
    if (!canUseDOM || !element) {
        return false;
    }
    return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
    const minScroll = {
        x: 0,
        y: 0
    };
    const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
        height: window.innerHeight,
        width: window.innerWidth
    } : {
        height: scrollingContainer.clientHeight,
        width: scrollingContainer.clientWidth
    };
    const maxScroll = {
        x: scrollingContainer.scrollWidth - dimensions.width,
        y: scrollingContainer.scrollHeight - dimensions.height
    };
    const isTop = scrollingContainer.scrollTop <= minScroll.y;
    const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
    const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
    const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
    return {
        isTop,
        isLeft,
        isBottom,
        isRight,
        maxScroll,
        minScroll
    };
}
const defaultThreshold = {
    x: 0.2,
    y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
    let { top, left, right, bottom } = _ref;
    if (acceleration === void 0) {
        acceleration = 10;
    }
    if (thresholdPercentage === void 0) {
        thresholdPercentage = defaultThreshold;
    }
    const { isTop, isBottom, isLeft, isRight } = getScrollPosition(scrollContainer);
    const direction = {
        x: 0,
        y: 0
    };
    const speed = {
        x: 0,
        y: 0
    };
    const threshold = {
        height: scrollContainerRect.height * thresholdPercentage.y,
        width: scrollContainerRect.width * thresholdPercentage.x
    };
    if (!isTop && top <= scrollContainerRect.top + threshold.height) {
        // Scroll Up
        direction.y = Direction.Backward;
        speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
    } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
        // Scroll Down
        direction.y = Direction.Forward;
        speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
    }
    if (!isRight && right >= scrollContainerRect.right - threshold.width) {
        // Scroll Right
        direction.x = Direction.Forward;
        speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
    } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
        // Scroll Left
        direction.x = Direction.Backward;
        speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
    }
    return {
        direction,
        speed
    };
}
function getScrollElementRect(element) {
    if (element === document.scrollingElement) {
        const { innerWidth, innerHeight } = window;
        return {
            top: 0,
            left: 0,
            right: innerWidth,
            bottom: innerHeight,
            width: innerWidth,
            height: innerHeight
        };
    }
    const { top, left, right, bottom } = element.getBoundingClientRect();
    return {
        top,
        left,
        right,
        bottom,
        width: element.clientWidth,
        height: element.clientHeight
    };
}
function getScrollOffsets(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node)=>{
        return add(acc, getScrollCoordinates(node));
    }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node)=>{
        return acc + getScrollXCoordinate(node);
    }, 0);
}
function getScrollYOffset(scrollableAncestors) {
    return scrollableAncestors.reduce((acc, node)=>{
        return acc + getScrollYCoordinate(node);
    }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
    if (measure === void 0) {
        measure = getClientRect;
    }
    if (!element) {
        return;
    }
    const { top, left, bottom, right } = measure(element);
    const firstScrollableAncestor = getFirstScrollableAncestor(element);
    if (!firstScrollableAncestor) {
        return;
    }
    if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
        element.scrollIntoView({
            block: 'center',
            inline: 'center'
        });
    }
}
const properties = [
    [
        'x',
        [
            'left',
            'right'
        ],
        getScrollXOffset
    ],
    [
        'y',
        [
            'top',
            'bottom'
        ],
        getScrollYOffset
    ]
];
class Rect {
    constructor(rect, element){
        this.rect = void 0;
        this.width = void 0;
        this.height = void 0;
        this.top = void 0;
        this.bottom = void 0;
        this.right = void 0;
        this.left = void 0;
        const scrollableAncestors = getScrollableAncestors(element);
        const scrollOffsets = getScrollOffsets(scrollableAncestors);
        this.rect = {
            ...rect
        };
        this.width = rect.width;
        this.height = rect.height;
        for (const [axis, keys, getScrollOffset] of properties){
            for (const key of keys){
                Object.defineProperty(this, key, {
                    get: ()=>{
                        const currentOffsets = getScrollOffset(scrollableAncestors);
                        const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
                        return this.rect[key] + scrollOffsetsDeltla;
                    },
                    enumerable: true
                });
            }
        }
        Object.defineProperty(this, 'rect', {
            enumerable: false
        });
    }
}
class Listeners {
    add(eventName, handler, options) {
        var _this$target2;
        (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
        this.listeners.push([
            eventName,
            handler,
            options
        ]);
    }
    constructor(target){
        this.target = void 0;
        this.listeners = [];
        this.removeAll = ()=>{
            this.listeners.forEach((listener)=>{
                var _this$target;
                return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
            });
        };
        this.target = target;
    }
}
function getEventListenerTarget(target) {
    // If the `event.target` element is removed from the document events will still be targeted
    // at it, and hence won't always bubble up to the window or document anymore.
    // If there is any risk of an element being removed while it is being dragged,
    // the best practice is to attach the event listeners directly to the target.
    // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
    const { EventTarget } = getWindow(target);
    return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
    const dx = Math.abs(delta.x);
    const dy = Math.abs(delta.y);
    if (typeof measurement === 'number') {
        return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
    }
    if ('x' in measurement && 'y' in measurement) {
        return dx > measurement.x && dy > measurement.y;
    }
    if ('x' in measurement) {
        return dx > measurement.x;
    }
    if ('y' in measurement) {
        return dy > measurement.y;
    }
    return false;
}
var EventName;
(function(EventName) {
    EventName["Click"] = "click";
    EventName["DragStart"] = "dragstart";
    EventName["Keydown"] = "keydown";
    EventName["ContextMenu"] = "contextmenu";
    EventName["Resize"] = "resize";
    EventName["SelectionChange"] = "selectionchange";
    EventName["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
    event.preventDefault();
}
function stopPropagation(event) {
    event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode) {
    KeyboardCode["Space"] = "Space";
    KeyboardCode["Down"] = "ArrowDown";
    KeyboardCode["Right"] = "ArrowRight";
    KeyboardCode["Left"] = "ArrowLeft";
    KeyboardCode["Up"] = "ArrowUp";
    KeyboardCode["Esc"] = "Escape";
    KeyboardCode["Enter"] = "Enter";
    KeyboardCode["Tab"] = "Tab";
})(KeyboardCode || (KeyboardCode = {}));
const defaultKeyboardCodes = {
    start: [
        KeyboardCode.Space,
        KeyboardCode.Enter
    ],
    cancel: [
        KeyboardCode.Esc
    ],
    end: [
        KeyboardCode.Space,
        KeyboardCode.Enter,
        KeyboardCode.Tab
    ]
};
const defaultKeyboardCoordinateGetter = (event, _ref)=>{
    let { currentCoordinates } = _ref;
    switch(event.code){
        case KeyboardCode.Right:
            return {
                ...currentCoordinates,
                x: currentCoordinates.x + 25
            };
        case KeyboardCode.Left:
            return {
                ...currentCoordinates,
                x: currentCoordinates.x - 25
            };
        case KeyboardCode.Down:
            return {
                ...currentCoordinates,
                y: currentCoordinates.y + 25
            };
        case KeyboardCode.Up:
            return {
                ...currentCoordinates,
                y: currentCoordinates.y - 25
            };
    }
    return undefined;
};
class KeyboardSensor {
    attach() {
        this.handleStart();
        this.windowListeners.add(EventName.Resize, this.handleCancel);
        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
        setTimeout(()=>this.listeners.add(EventName.Keydown, this.handleKeyDown));
    }
    handleStart() {
        const { activeNode, onStart } = this.props;
        const node = activeNode.node.current;
        if (node) {
            scrollIntoViewIfNeeded(node);
        }
        onStart(defaultCoordinates);
    }
    handleKeyDown(event) {
        if (isKeyboardEvent(event)) {
            const { active, context, options } = this.props;
            const { keyboardCodes = defaultKeyboardCodes, coordinateGetter = defaultKeyboardCoordinateGetter, scrollBehavior = 'smooth' } = options;
            const { code } = event;
            if (keyboardCodes.end.includes(code)) {
                this.handleEnd(event);
                return;
            }
            if (keyboardCodes.cancel.includes(code)) {
                this.handleCancel(event);
                return;
            }
            const { collisionRect } = context.current;
            const currentCoordinates = collisionRect ? {
                x: collisionRect.left,
                y: collisionRect.top
            } : defaultCoordinates;
            if (!this.referenceCoordinates) {
                this.referenceCoordinates = currentCoordinates;
            }
            const newCoordinates = coordinateGetter(event, {
                active,
                context: context.current,
                currentCoordinates
            });
            if (newCoordinates) {
                const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
                const scrollDelta = {
                    x: 0,
                    y: 0
                };
                const { scrollableAncestors } = context.current;
                for (const scrollContainer of scrollableAncestors){
                    const direction = event.code;
                    const { isTop, isRight, isLeft, isBottom, maxScroll, minScroll } = getScrollPosition(scrollContainer);
                    const scrollElementRect = getScrollElementRect(scrollContainer);
                    const clampedCoordinates = {
                        x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
                        y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
                    };
                    const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
                    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
                    if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
                        const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
                        const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
                        if (canScrollToNewCoordinates && !coordinatesDelta.y) {
                            // We don't need to update coordinates, the scroll adjustment alone will trigger
                            // logic to auto-detect the new container we are over
                            scrollContainer.scrollTo({
                                left: newScrollCoordinates,
                                behavior: scrollBehavior
                            });
                            return;
                        }
                        if (canScrollToNewCoordinates) {
                            scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
                        } else {
                            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
                        }
                        if (scrollDelta.x) {
                            scrollContainer.scrollBy({
                                left: -scrollDelta.x,
                                behavior: scrollBehavior
                            });
                        }
                        break;
                    } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
                        const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
                        const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
                        if (canScrollToNewCoordinates && !coordinatesDelta.x) {
                            // We don't need to update coordinates, the scroll adjustment alone will trigger
                            // logic to auto-detect the new container we are over
                            scrollContainer.scrollTo({
                                top: newScrollCoordinates,
                                behavior: scrollBehavior
                            });
                            return;
                        }
                        if (canScrollToNewCoordinates) {
                            scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
                        } else {
                            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
                        }
                        if (scrollDelta.y) {
                            scrollContainer.scrollBy({
                                top: -scrollDelta.y,
                                behavior: scrollBehavior
                            });
                        }
                        break;
                    }
                }
                this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
            }
        }
    }
    handleMove(event, coordinates) {
        const { onMove } = this.props;
        event.preventDefault();
        onMove(coordinates);
    }
    handleEnd(event) {
        const { onEnd } = this.props;
        event.preventDefault();
        this.detach();
        onEnd();
    }
    handleCancel(event) {
        const { onCancel } = this.props;
        event.preventDefault();
        this.detach();
        onCancel();
    }
    detach() {
        this.listeners.removeAll();
        this.windowListeners.removeAll();
    }
    constructor(props){
        this.props = void 0;
        this.autoScrollEnabled = false;
        this.referenceCoordinates = void 0;
        this.listeners = void 0;
        this.windowListeners = void 0;
        this.props = props;
        const { event: { target } } = props;
        this.props = props;
        this.listeners = new Listeners(getOwnerDocument(target));
        this.windowListeners = new Listeners(getWindow(target));
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleCancel = this.handleCancel.bind(this);
        this.attach();
    }
}
KeyboardSensor.activators = [
    {
        eventName: 'onKeyDown',
        handler: (event, _ref, _ref2)=>{
            let { keyboardCodes = defaultKeyboardCodes, onActivation } = _ref;
            let { active } = _ref2;
            const { code } = event.nativeEvent;
            if (keyboardCodes.start.includes(code)) {
                const activator = active.activatorNode.current;
                if (activator && event.target !== activator) {
                    return false;
                }
                event.preventDefault();
                onActivation == null ? void 0 : onActivation({
                    event: event.nativeEvent
                });
                return true;
            }
            return false;
        }
    }
];
function isDistanceConstraint(constraint) {
    return Boolean(constraint && 'distance' in constraint);
}
function isDelayConstraint(constraint) {
    return Boolean(constraint && 'delay' in constraint);
}
class AbstractPointerSensor {
    attach() {
        const { events, props: { options: { activationConstraint, bypassActivationConstraint } } } = this;
        this.listeners.add(events.move.name, this.handleMove, {
            passive: false
        });
        this.listeners.add(events.end.name, this.handleEnd);
        if (events.cancel) {
            this.listeners.add(events.cancel.name, this.handleCancel);
        }
        this.windowListeners.add(EventName.Resize, this.handleCancel);
        this.windowListeners.add(EventName.DragStart, preventDefault);
        this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
        this.windowListeners.add(EventName.ContextMenu, preventDefault);
        this.documentListeners.add(EventName.Keydown, this.handleKeydown);
        if (activationConstraint) {
            if (bypassActivationConstraint != null && bypassActivationConstraint({
                event: this.props.event,
                activeNode: this.props.activeNode,
                options: this.props.options
            })) {
                return this.handleStart();
            }
            if (isDelayConstraint(activationConstraint)) {
                this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
                this.handlePending(activationConstraint);
                return;
            }
            if (isDistanceConstraint(activationConstraint)) {
                this.handlePending(activationConstraint);
                return;
            }
        }
        this.handleStart();
    }
    detach() {
        this.listeners.removeAll();
        this.windowListeners.removeAll(); // Wait until the next event loop before removing document listeners
        // This is necessary because we listen for `click` and `selection` events on the document
        setTimeout(this.documentListeners.removeAll, 50);
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
    }
    handlePending(constraint, offset) {
        const { active, onPending } = this.props;
        onPending(active, constraint, this.initialCoordinates, offset);
    }
    handleStart() {
        const { initialCoordinates } = this;
        const { onStart } = this.props;
        if (initialCoordinates) {
            this.activated = true; // Stop propagation of click events once activation constraints are met
            this.documentListeners.add(EventName.Click, stopPropagation, {
                capture: true
            }); // Remove any text selection from the document
            this.removeTextSelection(); // Prevent further text selection while dragging
            this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
            onStart(initialCoordinates);
        }
    }
    handleMove(event) {
        var _getEventCoordinates2;
        const { activated, initialCoordinates, props } = this;
        const { onMove, options: { activationConstraint } } = props;
        if (!initialCoordinates) {
            return;
        }
        const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
        const delta = subtract(initialCoordinates, coordinates); // Constraint validation
        if (!activated && activationConstraint) {
            if (isDistanceConstraint(activationConstraint)) {
                if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
                    return this.handleCancel();
                }
                if (hasExceededDistance(delta, activationConstraint.distance)) {
                    return this.handleStart();
                }
            }
            if (isDelayConstraint(activationConstraint)) {
                if (hasExceededDistance(delta, activationConstraint.tolerance)) {
                    return this.handleCancel();
                }
            }
            this.handlePending(activationConstraint, delta);
            return;
        }
        if (event.cancelable) {
            event.preventDefault();
        }
        onMove(coordinates);
    }
    handleEnd() {
        const { onAbort, onEnd } = this.props;
        this.detach();
        if (!this.activated) {
            onAbort(this.props.active);
        }
        onEnd();
    }
    handleCancel() {
        const { onAbort, onCancel } = this.props;
        this.detach();
        if (!this.activated) {
            onAbort(this.props.active);
        }
        onCancel();
    }
    handleKeydown(event) {
        if (event.code === KeyboardCode.Esc) {
            this.handleCancel();
        }
    }
    removeTextSelection() {
        var _this$document$getSel;
        (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
    }
    constructor(props, events, listenerTarget){
        var _getEventCoordinates;
        if (listenerTarget === void 0) {
            listenerTarget = getEventListenerTarget(props.event.target);
        }
        this.props = void 0;
        this.events = void 0;
        this.autoScrollEnabled = true;
        this.document = void 0;
        this.activated = false;
        this.initialCoordinates = void 0;
        this.timeoutId = null;
        this.listeners = void 0;
        this.documentListeners = void 0;
        this.windowListeners = void 0;
        this.props = props;
        this.events = events;
        const { event } = props;
        const { target } = event;
        this.props = props;
        this.events = events;
        this.document = getOwnerDocument(target);
        this.documentListeners = new Listeners(this.document);
        this.listeners = new Listeners(listenerTarget);
        this.windowListeners = new Listeners(getWindow(target));
        this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
        this.handleStart = this.handleStart.bind(this);
        this.handleMove = this.handleMove.bind(this);
        this.handleEnd = this.handleEnd.bind(this);
        this.handleCancel = this.handleCancel.bind(this);
        this.handleKeydown = this.handleKeydown.bind(this);
        this.removeTextSelection = this.removeTextSelection.bind(this);
        this.attach();
    }
}
const events = {
    cancel: {
        name: 'pointercancel'
    },
    move: {
        name: 'pointermove'
    },
    end: {
        name: 'pointerup'
    }
};
class PointerSensor extends AbstractPointerSensor {
    constructor(props){
        const { event } = props; // Pointer events stop firing if the target is unmounted while dragging
        // Therefore we attach listeners to the owner document instead
        const listenerTarget = getOwnerDocument(event.target);
        super(props, events, listenerTarget);
    }
}
PointerSensor.activators = [
    {
        eventName: 'onPointerDown',
        handler: (_ref, _ref2)=>{
            let { nativeEvent: event } = _ref;
            let { onActivation } = _ref2;
            if (!event.isPrimary || event.button !== 0) {
                return false;
            }
            onActivation == null ? void 0 : onActivation({
                event
            });
            return true;
        }
    }
];
const events$1 = {
    move: {
        name: 'mousemove'
    },
    end: {
        name: 'mouseup'
    }
};
var MouseButton;
(function(MouseButton) {
    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
class MouseSensor extends AbstractPointerSensor {
    constructor(props){
        super(props, events$1, getOwnerDocument(props.event.target));
    }
}
MouseSensor.activators = [
    {
        eventName: 'onMouseDown',
        handler: (_ref, _ref2)=>{
            let { nativeEvent: event } = _ref;
            let { onActivation } = _ref2;
            if (event.button === MouseButton.RightClick) {
                return false;
            }
            onActivation == null ? void 0 : onActivation({
                event
            });
            return true;
        }
    }
];
const events$2 = {
    cancel: {
        name: 'touchcancel'
    },
    move: {
        name: 'touchmove'
    },
    end: {
        name: 'touchend'
    }
};
class TouchSensor extends AbstractPointerSensor {
    static setup() {
        // Adding a non-capture and non-passive `touchmove` listener in order
        // to force `event.preventDefault()` calls to work in dynamically added
        // touchmove event handlers. This is required for iOS Safari.
        window.addEventListener(events$2.move.name, noop, {
            capture: false,
            passive: false
        });
        return function teardown() {
            window.removeEventListener(events$2.move.name, noop);
        }; // We create a new handler because the teardown function of another sensor
        // could remove our event listener if we use a referentially equal listener.
        function noop() {}
    }
    constructor(props){
        super(props, events$2);
    }
}
TouchSensor.activators = [
    {
        eventName: 'onTouchStart',
        handler: (_ref, _ref2)=>{
            let { nativeEvent: event } = _ref;
            let { onActivation } = _ref2;
            const { touches } = event;
            if (touches.length > 1) {
                return false;
            }
            onActivation == null ? void 0 : onActivation({
                event
            });
            return true;
        }
    }
];
var AutoScrollActivator;
(function(AutoScrollActivator) {
    AutoScrollActivator[AutoScrollActivator["Pointer"] = 0] = "Pointer";
    AutoScrollActivator[AutoScrollActivator["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder) {
    TraversalOrder[TraversalOrder["TreeOrder"] = 0] = "TreeOrder";
    TraversalOrder[TraversalOrder["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
    let { acceleration, activator = AutoScrollActivator.Pointer, canScroll, draggingRect, enabled, interval = 5, order = TraversalOrder.TreeOrder, pointerCoordinates, scrollableAncestors, scrollableAncestorRects, delta, threshold } = _ref;
    const scrollIntent = useScrollIntent({
        delta,
        disabled: !enabled
    });
    const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
    const scrollSpeed = React.useRef({
        x: 0,
        y: 0
    });
    const scrollDirection = React.useRef({
        x: 0,
        y: 0
    });
    const rect = React.useMemo(()=>{
        switch(activator){
            case AutoScrollActivator.Pointer:
                return pointerCoordinates ? {
                    top: pointerCoordinates.y,
                    bottom: pointerCoordinates.y,
                    left: pointerCoordinates.x,
                    right: pointerCoordinates.x
                } : null;
            case AutoScrollActivator.DraggableRect:
                return draggingRect;
        }
    }, [
        activator,
        draggingRect,
        pointerCoordinates
    ]);
    const scrollContainerRef = React.useRef(null);
    const autoScroll = React.useCallback(()=>{
        const scrollContainer = scrollContainerRef.current;
        if (!scrollContainer) {
            return;
        }
        const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
        const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
        scrollContainer.scrollBy(scrollLeft, scrollTop);
    }, []);
    const sortedScrollableAncestors = React.useMemo(()=>order === TraversalOrder.TreeOrder ? [
            ...scrollableAncestors
        ].reverse() : scrollableAncestors, [
        order,
        scrollableAncestors
    ]);
    React.useEffect(()=>{
        if (!enabled || !scrollableAncestors.length || !rect) {
            clearAutoScrollInterval();
            return;
        }
        for (const scrollContainer of sortedScrollableAncestors){
            if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
                continue;
            }
            const index = scrollableAncestors.indexOf(scrollContainer);
            const scrollContainerRect = scrollableAncestorRects[index];
            if (!scrollContainerRect) {
                continue;
            }
            const { direction, speed } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
            for (const axis of [
                'x',
                'y'
            ]){
                if (!scrollIntent[axis][direction[axis]]) {
                    speed[axis] = 0;
                    direction[axis] = 0;
                }
            }
            if (speed.x > 0 || speed.y > 0) {
                clearAutoScrollInterval();
                scrollContainerRef.current = scrollContainer;
                setAutoScrollInterval(autoScroll, interval);
                scrollSpeed.current = speed;
                scrollDirection.current = direction;
                return;
            }
        }
        scrollSpeed.current = {
            x: 0,
            y: 0
        };
        scrollDirection.current = {
            x: 0,
            y: 0
        };
        clearAutoScrollInterval();
    }, [
        acceleration,
        autoScroll,
        canScroll,
        clearAutoScrollInterval,
        enabled,
        interval,
        JSON.stringify(rect),
        JSON.stringify(scrollIntent),
        setAutoScrollInterval,
        scrollableAncestors,
        sortedScrollableAncestors,
        scrollableAncestorRects,
        JSON.stringify(threshold)
    ]);
}
const defaultScrollIntent = {
    x: {
        [Direction.Backward]: false,
        [Direction.Forward]: false
    },
    y: {
        [Direction.Backward]: false,
        [Direction.Forward]: false
    }
};
function useScrollIntent(_ref2) {
    let { delta, disabled } = _ref2;
    const previousDelta = usePrevious(delta);
    return useLazyMemo((previousIntent)=>{
        if (disabled || !previousDelta || !previousIntent) {
            // Reset scroll intent tracking when auto-scrolling is disabled
            return defaultScrollIntent;
        }
        const direction = {
            x: Math.sign(delta.x - previousDelta.x),
            y: Math.sign(delta.y - previousDelta.y)
        }; // Keep track of the user intent to scroll in each direction for both axis
        return {
            x: {
                [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
                [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
            },
            y: {
                [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
                [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
            }
        };
    }, [
        disabled,
        delta,
        previousDelta
    ]);
}
function useCachedNode(draggableNodes, id) {
    const draggableNode = id != null ? draggableNodes.get(id) : undefined;
    const node = draggableNode ? draggableNode.node.current : null;
    return useLazyMemo((cachedNode)=>{
        var _ref;
        if (id == null) {
            return null;
        } // In some cases, the draggable node can unmount while dragging
        // This is the case for virtualized lists. In those situations,
        // we fall back to the last known value for that node.
        return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
    }, [
        node,
        id
    ]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
    return React.useMemo(()=>sensors.reduce((accumulator, sensor)=>{
            const { sensor: Sensor } = sensor;
            const sensorActivators = Sensor.activators.map((activator)=>({
                    eventName: activator.eventName,
                    handler: getSyntheticHandler(activator.handler, sensor)
                }));
            return [
                ...accumulator,
                ...sensorActivators
            ];
        }, []), [
        sensors,
        getSyntheticHandler
    ]);
}
var MeasuringStrategy;
(function(MeasuringStrategy) {
    MeasuringStrategy[MeasuringStrategy["Always"] = 0] = "Always";
    MeasuringStrategy[MeasuringStrategy["BeforeDragging"] = 1] = "BeforeDragging";
    MeasuringStrategy[MeasuringStrategy["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency) {
    MeasuringFrequency["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = /*#__PURE__*/ new Map();
function useDroppableMeasuring(containers, _ref) {
    let { dragging, dependencies, config } = _ref;
    const [queue, setQueue] = React.useState(null);
    const { frequency, measure, strategy } = config;
    const containersRef = React.useRef(containers);
    const disabled = isDisabled();
    const disabledRef = useLatestValue(disabled);
    const measureDroppableContainers = React.useCallback(function(ids) {
        if (ids === void 0) {
            ids = [];
        }
        if (disabledRef.current) {
            return;
        }
        setQueue((value)=>{
            if (value === null) {
                return ids;
            }
            return value.concat(ids.filter((id)=>!value.includes(id)));
        });
    }, [
        disabledRef
    ]);
    const timeoutId = React.useRef(null);
    const droppableRects = useLazyMemo((previousValue)=>{
        if (disabled && !dragging) {
            return defaultValue;
        }
        if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
            const map = new Map();
            for (let container of containers){
                if (!container) {
                    continue;
                }
                if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
                    // This container does not need to be re-measured
                    map.set(container.id, container.rect.current);
                    continue;
                }
                const node = container.node.current;
                const rect = node ? new Rect(measure(node), node) : null;
                container.rect.current = rect;
                if (rect) {
                    map.set(container.id, rect);
                }
            }
            return map;
        }
        return previousValue;
    }, [
        containers,
        queue,
        dragging,
        disabled,
        measure
    ]);
    React.useEffect(()=>{
        containersRef.current = containers;
    }, [
        containers
    ]);
    React.useEffect(()=>{
        if (disabled) {
            return;
        }
        measureDroppableContainers();
    }, [
        dragging,
        disabled
    ]);
    React.useEffect(()=>{
        if (queue && queue.length > 0) {
            setQueue(null);
        }
    }, [
        JSON.stringify(queue)
    ]);
    React.useEffect(()=>{
        if (disabled || typeof frequency !== 'number' || timeoutId.current !== null) {
            return;
        }
        timeoutId.current = setTimeout(()=>{
            measureDroppableContainers();
            timeoutId.current = null;
        }, frequency);
    }, [
        frequency,
        disabled,
        measureDroppableContainers,
        ...dependencies
    ]);
    return {
        droppableRects,
        measureDroppableContainers,
        measuringScheduled: queue != null
    };
    function isDisabled() {
        switch(strategy){
            case MeasuringStrategy.Always:
                return false;
            case MeasuringStrategy.BeforeDragging:
                return dragging;
            default:
                return !dragging;
        }
    }
}
function useInitialValue(value, computeFn) {
    return useLazyMemo((previousValue)=>{
        if (!value) {
            return null;
        }
        if (previousValue) {
            return previousValue;
        }
        return typeof computeFn === 'function' ? computeFn(value) : value;
    }, [
        computeFn,
        value
    ]);
}
function useInitialRect(node, measure) {
    return useInitialValue(node, measure);
}
/**
 * Returns a new MutationObserver instance.
 * If `MutationObserver` is undefined in the execution environment, returns `undefined`.
 */ function useMutationObserver(_ref) {
    let { callback, disabled } = _ref;
    const handleMutations = useEvent(callback);
    const mutationObserver = React.useMemo(()=>{
        if (disabled || typeof window === 'undefined' || typeof window.MutationObserver === 'undefined') {
            return undefined;
        }
        const { MutationObserver } = window;
        return new MutationObserver(handleMutations);
    }, [
        handleMutations,
        disabled
    ]);
    React.useEffect(()=>{
        return ()=>mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }, [
        mutationObserver
    ]);
    return mutationObserver;
}
/**
 * Returns a new ResizeObserver instance bound to the `onResize` callback.
 * If `ResizeObserver` is undefined in the execution environment, returns `undefined`.
 */ function useResizeObserver(_ref) {
    let { callback, disabled } = _ref;
    const handleResize = useEvent(callback);
    const resizeObserver = React.useMemo(()=>{
        if (disabled || typeof window === 'undefined' || typeof window.ResizeObserver === 'undefined') {
            return undefined;
        }
        const { ResizeObserver: ResizeObserver1 } = window;
        return new ResizeObserver1(handleResize);
    }, [
        disabled
    ]);
    React.useEffect(()=>{
        return ()=>resizeObserver == null ? void 0 : resizeObserver.disconnect();
    }, [
        resizeObserver
    ]);
    return resizeObserver;
}
function defaultMeasure(element) {
    return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
    if (measure === void 0) {
        measure = defaultMeasure;
    }
    const [rect, setRect] = React.useState(null);
    function measureRect() {
        setRect((currentRect)=>{
            if (!element) {
                return null;
            }
            if (element.isConnected === false) {
                var _ref;
                // Fall back to last rect we measured if the element is
                // no longer connected to the DOM.
                return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
            }
            const newRect = measure(element);
            if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
                return currentRect;
            }
            return newRect;
        });
    }
    const mutationObserver = useMutationObserver({
        callback (records) {
            if (!element) {
                return;
            }
            for (const record of records){
                const { type, target } = record;
                if (type === 'childList' && target instanceof HTMLElement && target.contains(element)) {
                    measureRect();
                    break;
                }
            }
        }
    });
    const resizeObserver = useResizeObserver({
        callback: measureRect
    });
    useIsomorphicLayoutEffect(()=>{
        measureRect();
        if (element) {
            resizeObserver == null ? void 0 : resizeObserver.observe(element);
            mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
                childList: true,
                subtree: true
            });
        } else {
            resizeObserver == null ? void 0 : resizeObserver.disconnect();
            mutationObserver == null ? void 0 : mutationObserver.disconnect();
        }
    }, [
        element
    ]);
    return rect;
}
function useRectDelta(rect) {
    const initialRect = useInitialValue(rect);
    return getRectDelta(rect, initialRect);
}
const defaultValue$1 = [];
function useScrollableAncestors(node) {
    const previousNode = React.useRef(node);
    const ancestors = useLazyMemo((previousValue)=>{
        if (!node) {
            return defaultValue$1;
        }
        if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
            return previousValue;
        }
        return getScrollableAncestors(node);
    }, [
        node
    ]);
    React.useEffect(()=>{
        previousNode.current = node;
    }, [
        node
    ]);
    return ancestors;
}
function useScrollOffsets(elements) {
    const [scrollCoordinates, setScrollCoordinates] = React.useState(null);
    const prevElements = React.useRef(elements); // To-do: Throttle the handleScroll callback
    const handleScroll = React.useCallback((event)=>{
        const scrollingElement = getScrollableElement(event.target);
        if (!scrollingElement) {
            return;
        }
        setScrollCoordinates((scrollCoordinates)=>{
            if (!scrollCoordinates) {
                return null;
            }
            scrollCoordinates.set(scrollingElement, getScrollCoordinates(scrollingElement));
            return new Map(scrollCoordinates);
        });
    }, []);
    React.useEffect(()=>{
        const previousElements = prevElements.current;
        if (elements !== previousElements) {
            cleanup(previousElements);
            const entries = elements.map((element)=>{
                const scrollableElement = getScrollableElement(element);
                if (scrollableElement) {
                    scrollableElement.addEventListener('scroll', handleScroll, {
                        passive: true
                    });
                    return [
                        scrollableElement,
                        getScrollCoordinates(scrollableElement)
                    ];
                }
                return null;
            }).filter((entry)=>entry != null);
            setScrollCoordinates(entries.length ? new Map(entries) : null);
            prevElements.current = elements;
        }
        return ()=>{
            cleanup(elements);
            cleanup(previousElements);
        };
        function cleanup(elements) {
            elements.forEach((element)=>{
                const scrollableElement = getScrollableElement(element);
                scrollableElement == null ? void 0 : scrollableElement.removeEventListener('scroll', handleScroll);
            });
        }
    }, [
        handleScroll,
        elements
    ]);
    return React.useMemo(()=>{
        if (elements.length) {
            return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates)=>add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
        }
        return defaultCoordinates;
    }, [
        elements,
        scrollCoordinates
    ]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
    if (dependencies === void 0) {
        dependencies = [];
    }
    const initialScrollOffsets = React.useRef(null);
    React.useEffect(()=>{
        initialScrollOffsets.current = null;
    }, dependencies);
    React.useEffect(()=>{
        const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
        if (hasScrollOffsets && !initialScrollOffsets.current) {
            initialScrollOffsets.current = scrollOffsets;
        }
        if (!hasScrollOffsets && initialScrollOffsets.current) {
            initialScrollOffsets.current = null;
        }
    }, [
        scrollOffsets
    ]);
    return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
    React.useEffect(()=>{
        if (!canUseDOM) {
            return;
        }
        const teardownFns = sensors.map((_ref)=>{
            let { sensor } = _ref;
            return sensor.setup == null ? void 0 : sensor.setup();
        });
        return ()=>{
            for (const teardown of teardownFns){
                teardown == null ? void 0 : teardown();
            }
        };
    }, // eslint-disable-next-line react-hooks/exhaustive-deps
    sensors.map((_ref2)=>{
        let { sensor } = _ref2;
        return sensor;
    }));
}
function useSyntheticListeners(listeners, id) {
    return React.useMemo(()=>{
        return listeners.reduce((acc, _ref)=>{
            let { eventName, handler } = _ref;
            acc[eventName] = (event)=>{
                handler(event, id);
            };
            return acc;
        }, {});
    }, [
        listeners,
        id
    ]);
}
function useWindowRect(element) {
    return React.useMemo(()=>element ? getWindowClientRect(element) : null, [
        element
    ]);
}
const defaultValue$2 = [];
function useRects(elements, measure) {
    if (measure === void 0) {
        measure = getClientRect;
    }
    const [firstElement] = elements;
    const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
    const [rects, setRects] = React.useState(defaultValue$2);
    function measureRects() {
        setRects(()=>{
            if (!elements.length) {
                return defaultValue$2;
            }
            return elements.map((element)=>isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
        });
    }
    const resizeObserver = useResizeObserver({
        callback: measureRects
    });
    useIsomorphicLayoutEffect(()=>{
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        measureRects();
        elements.forEach((element)=>resizeObserver == null ? void 0 : resizeObserver.observe(element));
    }, [
        elements
    ]);
    return rects;
}
function getMeasurableNode(node) {
    if (!node) {
        return null;
    }
    if (node.children.length > 1) {
        return node;
    }
    const firstChild = node.children[0];
    return isHTMLElement(firstChild) ? firstChild : node;
}
function useDragOverlayMeasuring(_ref) {
    let { measure } = _ref;
    const [rect, setRect] = React.useState(null);
    const handleResize = React.useCallback((entries)=>{
        for (const { target } of entries){
            if (isHTMLElement(target)) {
                setRect((rect)=>{
                    const newRect = measure(target);
                    return rect ? {
                        ...rect,
                        width: newRect.width,
                        height: newRect.height
                    } : newRect;
                });
                break;
            }
        }
    }, [
        measure
    ]);
    const resizeObserver = useResizeObserver({
        callback: handleResize
    });
    const handleNodeChange = React.useCallback((element)=>{
        const node = getMeasurableNode(element);
        resizeObserver == null ? void 0 : resizeObserver.disconnect();
        if (node) {
            resizeObserver == null ? void 0 : resizeObserver.observe(node);
        }
        setRect(node ? measure(node) : null);
    }, [
        measure,
        resizeObserver
    ]);
    const [nodeRef, setRef] = useNodeRef(handleNodeChange);
    return React.useMemo(()=>({
            nodeRef,
            rect,
            setRef
        }), [
        rect,
        nodeRef,
        setRef
    ]);
}
const defaultSensors = [
    {
        sensor: PointerSensor,
        options: {}
    },
    {
        sensor: KeyboardSensor,
        options: {}
    }
];
const defaultData = {
    current: {}
};
const defaultMeasuringConfiguration = {
    draggable: {
        measure: getTransformAgnosticClientRect
    },
    droppable: {
        measure: getTransformAgnosticClientRect,
        strategy: MeasuringStrategy.WhileDragging,
        frequency: MeasuringFrequency.Optimized
    },
    dragOverlay: {
        measure: getClientRect
    }
};
class DroppableContainersMap extends Map {
    get(id) {
        var _super$get;
        return id != null ? (_super$get = super.get(id)) != null ? _super$get : undefined : undefined;
    }
    toArray() {
        return Array.from(this.values());
    }
    getEnabled() {
        return this.toArray().filter((_ref)=>{
            let { disabled } = _ref;
            return !disabled;
        });
    }
    getNodeFor(id) {
        var _this$get$node$curren, _this$get;
        return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : undefined;
    }
}
const defaultPublicContext = {
    activatorEvent: null,
    active: null,
    activeNode: null,
    activeNodeRect: null,
    collisions: null,
    containerNodeRect: null,
    draggableNodes: /*#__PURE__*/ new Map(),
    droppableRects: /*#__PURE__*/ new Map(),
    droppableContainers: /*#__PURE__*/ new DroppableContainersMap(),
    over: null,
    dragOverlay: {
        nodeRef: {
            current: null
        },
        rect: null,
        setRef: noop
    },
    scrollableAncestors: [],
    scrollableAncestorRects: [],
    measuringConfiguration: defaultMeasuringConfiguration,
    measureDroppableContainers: noop,
    windowRect: null,
    measuringScheduled: false
};
const defaultInternalContext = {
    activatorEvent: null,
    activators: [],
    active: null,
    activeNodeRect: null,
    ariaDescribedById: {
        draggable: ''
    },
    dispatch: noop,
    draggableNodes: /*#__PURE__*/ new Map(),
    over: null,
    measureDroppableContainers: noop
};
const InternalContext = /*#__PURE__*/ React.createContext(defaultInternalContext);
const PublicContext = /*#__PURE__*/ React.createContext(defaultPublicContext);
function getInitialState() {
    return {
        draggable: {
            active: null,
            initialCoordinates: {
                x: 0,
                y: 0
            },
            nodes: new Map(),
            translate: {
                x: 0,
                y: 0
            }
        },
        droppable: {
            containers: new DroppableContainersMap()
        }
    };
}
function reducer(state, action) {
    switch(action.type){
        case Action.DragStart:
            return {
                ...state,
                draggable: {
                    ...state.draggable,
                    initialCoordinates: action.initialCoordinates,
                    active: action.active
                }
            };
        case Action.DragMove:
            if (state.draggable.active == null) {
                return state;
            }
            return {
                ...state,
                draggable: {
                    ...state.draggable,
                    translate: {
                        x: action.coordinates.x - state.draggable.initialCoordinates.x,
                        y: action.coordinates.y - state.draggable.initialCoordinates.y
                    }
                }
            };
        case Action.DragEnd:
        case Action.DragCancel:
            return {
                ...state,
                draggable: {
                    ...state.draggable,
                    active: null,
                    initialCoordinates: {
                        x: 0,
                        y: 0
                    },
                    translate: {
                        x: 0,
                        y: 0
                    }
                }
            };
        case Action.RegisterDroppable:
            {
                const { element } = action;
                const { id } = element;
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.set(id, element);
                return {
                    ...state,
                    droppable: {
                        ...state.droppable,
                        containers
                    }
                };
            }
        case Action.SetDroppableDisabled:
            {
                const { id, key, disabled } = action;
                const element = state.droppable.containers.get(id);
                if (!element || key !== element.key) {
                    return state;
                }
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.set(id, {
                    ...element,
                    disabled
                });
                return {
                    ...state,
                    droppable: {
                        ...state.droppable,
                        containers
                    }
                };
            }
        case Action.UnregisterDroppable:
            {
                const { id, key } = action;
                const element = state.droppable.containers.get(id);
                if (!element || key !== element.key) {
                    return state;
                }
                const containers = new DroppableContainersMap(state.droppable.containers);
                containers.delete(id);
                return {
                    ...state,
                    droppable: {
                        ...state.droppable,
                        containers
                    }
                };
            }
        default:
            {
                return state;
            }
    }
}
function RestoreFocus(_ref) {
    let { disabled } = _ref;
    const { active, activatorEvent, draggableNodes } = React.useContext(InternalContext);
    const previousActivatorEvent = usePrevious(activatorEvent);
    const previousActiveId = usePrevious(active == null ? void 0 : active.id); // Restore keyboard focus on the activator node
    React.useEffect(()=>{
        if (disabled) {
            return;
        }
        if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
            if (!isKeyboardEvent(previousActivatorEvent)) {
                return;
            }
            if (document.activeElement === previousActivatorEvent.target) {
                // No need to restore focus
                return;
            }
            const draggableNode = draggableNodes.get(previousActiveId);
            if (!draggableNode) {
                return;
            }
            const { activatorNode, node } = draggableNode;
            if (!activatorNode.current && !node.current) {
                return;
            }
            requestAnimationFrame(()=>{
                for (const element of [
                    activatorNode.current,
                    node.current
                ]){
                    if (!element) {
                        continue;
                    }
                    const focusableNode = findFirstFocusableNode(element);
                    if (focusableNode) {
                        focusableNode.focus();
                        break;
                    }
                }
            });
        }
    }, [
        activatorEvent,
        disabled,
        draggableNodes,
        previousActiveId,
        previousActivatorEvent
    ]);
    return null;
}
function applyModifiers(modifiers, _ref) {
    let { transform, ...args } = _ref;
    return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier)=>{
        return modifier({
            transform: accumulator,
            ...args
        });
    }, transform) : transform;
}
function useMeasuringConfiguration(config) {
    return React.useMemo(()=>({
            draggable: {
                ...defaultMeasuringConfiguration.draggable,
                ...config == null ? void 0 : config.draggable
            },
            droppable: {
                ...defaultMeasuringConfiguration.droppable,
                ...config == null ? void 0 : config.droppable
            },
            dragOverlay: {
                ...defaultMeasuringConfiguration.dragOverlay,
                ...config == null ? void 0 : config.dragOverlay
            }
        }), [
        config == null ? void 0 : config.draggable,
        config == null ? void 0 : config.droppable,
        config == null ? void 0 : config.dragOverlay
    ]);
}
function useLayoutShiftScrollCompensation(_ref) {
    let { activeNode, measure, initialRect, config = true } = _ref;
    const initialized = React.useRef(false);
    const { x, y } = typeof config === 'boolean' ? {
        x: config,
        y: config
    } : config;
    useIsomorphicLayoutEffect(()=>{
        const disabled = !x && !y;
        if (disabled || !activeNode) {
            initialized.current = false;
            return;
        }
        if (initialized.current || !initialRect) {
            // Return early if layout shift scroll compensation was already attempted
            // or if there is no initialRect to compare to.
            return;
        } // Get the most up to date node ref for the active draggable
        const node = activeNode == null ? void 0 : activeNode.node.current;
        if (!node || node.isConnected === false) {
            // Return early if there is no attached node ref or if the node is
            // disconnected from the document.
            return;
        }
        const rect = measure(node);
        const rectDelta = getRectDelta(rect, initialRect);
        if (!x) {
            rectDelta.x = 0;
        }
        if (!y) {
            rectDelta.y = 0;
        } // Only perform layout shift scroll compensation once
        initialized.current = true;
        if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
            const firstScrollableAncestor = getFirstScrollableAncestor(node);
            if (firstScrollableAncestor) {
                firstScrollableAncestor.scrollBy({
                    top: rectDelta.y,
                    left: rectDelta.x
                });
            }
        }
    }, [
        activeNode,
        x,
        y,
        initialRect,
        measure
    ]);
}
const ActiveDraggableContext = /*#__PURE__*/ React.createContext({
    ...defaultCoordinates,
    scaleX: 1,
    scaleY: 1
});
var Status;
(function(Status) {
    Status[Status["Uninitialized"] = 0] = "Uninitialized";
    Status[Status["Initializing"] = 1] = "Initializing";
    Status[Status["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
const DndContext = /*#__PURE__*/ React.memo(function DndContext(_ref) {
    var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
    let { id, accessibility, autoScroll = true, children, sensors = defaultSensors, collisionDetection = rectIntersection, measuring, modifiers, ...props } = _ref;
    const store = React.useReducer(reducer, undefined, getInitialState);
    const [state, dispatch] = store;
    const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
    const [status, setStatus] = React.useState(Status.Uninitialized);
    const isInitialized = status === Status.Initialized;
    const { draggable: { active: activeId, nodes: draggableNodes, translate }, droppable: { containers: droppableContainers } } = state;
    const node = activeId != null ? draggableNodes.get(activeId) : null;
    const activeRects = React.useRef({
        initial: null,
        translated: null
    });
    const active = React.useMemo(()=>{
        var _node$data;
        return activeId != null ? {
            id: activeId,
            // It's possible for the active node to unmount while dragging
            data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
            rect: activeRects
        } : null;
    }, [
        activeId,
        node
    ]);
    const activeRef = React.useRef(null);
    const [activeSensor, setActiveSensor] = React.useState(null);
    const [activatorEvent, setActivatorEvent] = React.useState(null);
    const latestProps = useLatestValue(props, Object.values(props));
    const draggableDescribedById = useUniqueId("DndDescribedBy", id);
    const enabledDroppableContainers = React.useMemo(()=>droppableContainers.getEnabled(), [
        droppableContainers
    ]);
    const measuringConfiguration = useMeasuringConfiguration(measuring);
    const { droppableRects, measureDroppableContainers, measuringScheduled } = useDroppableMeasuring(enabledDroppableContainers, {
        dragging: isInitialized,
        dependencies: [
            translate.x,
            translate.y
        ],
        config: measuringConfiguration.droppable
    });
    const activeNode = useCachedNode(draggableNodes, activeId);
    const activationCoordinates = React.useMemo(()=>activatorEvent ? getEventCoordinates(activatorEvent) : null, [
        activatorEvent
    ]);
    const autoScrollOptions = getAutoScrollerOptions();
    const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
    useLayoutShiftScrollCompensation({
        activeNode: activeId != null ? draggableNodes.get(activeId) : null,
        config: autoScrollOptions.layoutShiftCompensation,
        initialRect: initialActiveNodeRect,
        measure: measuringConfiguration.draggable.measure
    });
    const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
    const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
    const sensorContext = React.useRef({
        activatorEvent: null,
        active: null,
        activeNode,
        collisionRect: null,
        collisions: null,
        droppableRects,
        draggableNodes,
        draggingNode: null,
        draggingNodeRect: null,
        droppableContainers,
        over: null,
        scrollableAncestors: [],
        scrollAdjustedTranslate: null
    });
    const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
    const dragOverlay = useDragOverlayMeasuring({
        measure: measuringConfiguration.dragOverlay.measure
    }); // Use the rect of the drag overlay if it is mounted
    const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
    const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
    const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect); // The delta between the previous and new position of the draggable node
    // is only relevant when there is no drag overlay
    const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect); // Get the window rect of the dragging node
    const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null); // Get scrollable ancestors of the dragging node
    const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
    const scrollableAncestorRects = useRects(scrollableAncestors); // Apply modifiers
    const modifiedTranslate = applyModifiers(modifiers, {
        transform: {
            x: translate.x - nodeRectDelta.x,
            y: translate.y - nodeRectDelta.y,
            scaleX: 1,
            scaleY: 1
        },
        activatorEvent,
        active,
        activeNodeRect,
        containerNodeRect,
        draggingNodeRect,
        over: sensorContext.current.over,
        overlayNodeRect: dragOverlay.rect,
        scrollableAncestors,
        scrollableAncestorRects,
        windowRect
    });
    const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
    const scrollOffsets = useScrollOffsets(scrollableAncestors); // Represents the scroll delta since dragging was initiated
    const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets); // Represents the scroll delta since the last time the active node rect was measured
    const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [
        activeNodeRect
    ]);
    const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
    const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
    const collisions = active && collisionRect ? collisionDetection({
        active,
        collisionRect,
        droppableRects,
        droppableContainers: enabledDroppableContainers,
        pointerCoordinates
    }) : null;
    const overId = getFirstCollision(collisions, 'id');
    const [over, setOver] = React.useState(null); // When there is no drag overlay used, we need to account for the
    // window scroll delta
    const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
    const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
    const activeSensorRef = React.useRef(null);
    const instantiateSensor = React.useCallback((event, _ref2)=>{
        let { sensor: Sensor, options } = _ref2;
        if (activeRef.current == null) {
            return;
        }
        const activeNode = draggableNodes.get(activeRef.current);
        if (!activeNode) {
            return;
        }
        const activatorEvent = event.nativeEvent;
        const sensorInstance = new Sensor({
            active: activeRef.current,
            activeNode,
            event: activatorEvent,
            options,
            // Sensors need to be instantiated with refs for arguments that change over time
            // otherwise they are frozen in time with the stale arguments
            context: sensorContext,
            onAbort (id) {
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                    return;
                }
                const { onDragAbort } = latestProps.current;
                const event = {
                    id
                };
                onDragAbort == null ? void 0 : onDragAbort(event);
                dispatchMonitorEvent({
                    type: 'onDragAbort',
                    event
                });
            },
            onPending (id, constraint, initialCoordinates, offset) {
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                    return;
                }
                const { onDragPending } = latestProps.current;
                const event = {
                    id,
                    constraint,
                    initialCoordinates,
                    offset
                };
                onDragPending == null ? void 0 : onDragPending(event);
                dispatchMonitorEvent({
                    type: 'onDragPending',
                    event
                });
            },
            onStart (initialCoordinates) {
                const id = activeRef.current;
                if (id == null) {
                    return;
                }
                const draggableNode = draggableNodes.get(id);
                if (!draggableNode) {
                    return;
                }
                const { onDragStart } = latestProps.current;
                const event = {
                    activatorEvent,
                    active: {
                        id,
                        data: draggableNode.data,
                        rect: activeRects
                    }
                };
                reactDom.unstable_batchedUpdates(()=>{
                    onDragStart == null ? void 0 : onDragStart(event);
                    setStatus(Status.Initializing);
                    dispatch({
                        type: Action.DragStart,
                        initialCoordinates,
                        active: id
                    });
                    dispatchMonitorEvent({
                        type: 'onDragStart',
                        event
                    });
                    setActiveSensor(activeSensorRef.current);
                    setActivatorEvent(activatorEvent);
                });
            },
            onMove (coordinates) {
                dispatch({
                    type: Action.DragMove,
                    coordinates
                });
            },
            onEnd: createHandler(Action.DragEnd),
            onCancel: createHandler(Action.DragCancel)
        });
        activeSensorRef.current = sensorInstance;
        function createHandler(type) {
            return async function handler() {
                const { active, collisions, over, scrollAdjustedTranslate } = sensorContext.current;
                let event = null;
                if (active && scrollAdjustedTranslate) {
                    const { cancelDrop } = latestProps.current;
                    event = {
                        activatorEvent,
                        active: active,
                        collisions,
                        delta: scrollAdjustedTranslate,
                        over
                    };
                    if (type === Action.DragEnd && typeof cancelDrop === 'function') {
                        const shouldCancel = await Promise.resolve(cancelDrop(event));
                        if (shouldCancel) {
                            type = Action.DragCancel;
                        }
                    }
                }
                activeRef.current = null;
                reactDom.unstable_batchedUpdates(()=>{
                    dispatch({
                        type
                    });
                    setStatus(Status.Uninitialized);
                    setOver(null);
                    setActiveSensor(null);
                    setActivatorEvent(null);
                    activeSensorRef.current = null;
                    const eventName = type === Action.DragEnd ? 'onDragEnd' : 'onDragCancel';
                    if (event) {
                        const handler = latestProps.current[eventName];
                        handler == null ? void 0 : handler(event);
                        dispatchMonitorEvent({
                            type: eventName,
                            event
                        });
                    }
                });
            };
        }
    }, [
        draggableNodes
    ]);
    const bindActivatorToSensorInstantiator = React.useCallback((handler, sensor)=>{
        return (event, active)=>{
            const nativeEvent = event.nativeEvent;
            const activeDraggableNode = draggableNodes.get(active);
            if (activeRef.current !== null || // No active draggable
            !activeDraggableNode || // Event has already been captured
            nativeEvent.dndKit || nativeEvent.defaultPrevented) {
                return;
            }
            const activationContext = {
                active: activeDraggableNode
            };
            const shouldActivate = handler(event, sensor.options, activationContext);
            if (shouldActivate === true) {
                nativeEvent.dndKit = {
                    capturedBy: sensor.sensor
                };
                activeRef.current = active;
                instantiateSensor(event, sensor);
            }
        };
    }, [
        draggableNodes,
        instantiateSensor
    ]);
    const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
    useSensorSetup(sensors);
    useIsomorphicLayoutEffect(()=>{
        if (activeNodeRect && status === Status.Initializing) {
            setStatus(Status.Initialized);
        }
    }, [
        activeNodeRect,
        status
    ]);
    React.useEffect(()=>{
        const { onDragMove } = latestProps.current;
        const { active, activatorEvent, collisions, over } = sensorContext.current;
        if (!active || !activatorEvent) {
            return;
        }
        const event = {
            active,
            activatorEvent,
            collisions,
            delta: {
                x: scrollAdjustedTranslate.x,
                y: scrollAdjustedTranslate.y
            },
            over
        };
        reactDom.unstable_batchedUpdates(()=>{
            onDragMove == null ? void 0 : onDragMove(event);
            dispatchMonitorEvent({
                type: 'onDragMove',
                event
            });
        });
    }, [
        scrollAdjustedTranslate.x,
        scrollAdjustedTranslate.y
    ]);
    React.useEffect(()=>{
        const { active, activatorEvent, collisions, droppableContainers, scrollAdjustedTranslate } = sensorContext.current;
        if (!active || activeRef.current == null || !activatorEvent || !scrollAdjustedTranslate) {
            return;
        }
        const { onDragOver } = latestProps.current;
        const overContainer = droppableContainers.get(overId);
        const over = overContainer && overContainer.rect.current ? {
            id: overContainer.id,
            rect: overContainer.rect.current,
            data: overContainer.data,
            disabled: overContainer.disabled
        } : null;
        const event = {
            active,
            activatorEvent,
            collisions,
            delta: {
                x: scrollAdjustedTranslate.x,
                y: scrollAdjustedTranslate.y
            },
            over
        };
        reactDom.unstable_batchedUpdates(()=>{
            setOver(over);
            onDragOver == null ? void 0 : onDragOver(event);
            dispatchMonitorEvent({
                type: 'onDragOver',
                event
            });
        });
    }, [
        overId
    ]);
    useIsomorphicLayoutEffect(()=>{
        sensorContext.current = {
            activatorEvent,
            active,
            activeNode,
            collisionRect,
            collisions,
            droppableRects,
            draggableNodes,
            draggingNode,
            draggingNodeRect,
            droppableContainers,
            over,
            scrollableAncestors,
            scrollAdjustedTranslate
        };
        activeRects.current = {
            initial: draggingNodeRect,
            translated: collisionRect
        };
    }, [
        active,
        activeNode,
        collisions,
        collisionRect,
        draggableNodes,
        draggingNode,
        draggingNodeRect,
        droppableRects,
        droppableContainers,
        over,
        scrollableAncestors,
        scrollAdjustedTranslate
    ]);
    useAutoScroller({
        ...autoScrollOptions,
        delta: translate,
        draggingRect: collisionRect,
        pointerCoordinates,
        scrollableAncestors,
        scrollableAncestorRects
    });
    const publicContext = React.useMemo(()=>{
        const context = {
            active,
            activeNode,
            activeNodeRect,
            activatorEvent,
            collisions,
            containerNodeRect,
            dragOverlay,
            draggableNodes,
            droppableContainers,
            droppableRects,
            over,
            measureDroppableContainers,
            scrollableAncestors,
            scrollableAncestorRects,
            measuringConfiguration,
            measuringScheduled,
            windowRect
        };
        return context;
    }, [
        active,
        activeNode,
        activeNodeRect,
        activatorEvent,
        collisions,
        containerNodeRect,
        dragOverlay,
        draggableNodes,
        droppableContainers,
        droppableRects,
        over,
        measureDroppableContainers,
        scrollableAncestors,
        scrollableAncestorRects,
        measuringConfiguration,
        measuringScheduled,
        windowRect
    ]);
    const internalContext = React.useMemo(()=>{
        const context = {
            activatorEvent,
            activators,
            active,
            activeNodeRect,
            ariaDescribedById: {
                draggable: draggableDescribedById
            },
            dispatch,
            draggableNodes,
            over,
            measureDroppableContainers
        };
        return context;
    }, [
        activatorEvent,
        activators,
        active,
        activeNodeRect,
        dispatch,
        draggableDescribedById,
        draggableNodes,
        over,
        measureDroppableContainers
    ]);
    return React.createElement(DndMonitorContext.Provider, {
        value: registerMonitorListener
    }, React.createElement(InternalContext.Provider, {
        value: internalContext
    }, React.createElement(PublicContext.Provider, {
        value: publicContext
    }, React.createElement(ActiveDraggableContext.Provider, {
        value: transform
    }, children)), React.createElement(RestoreFocus, {
        disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
    })), React.createElement(Accessibility, {
        ...accessibility,
        hiddenTextDescribedById: draggableDescribedById
    }));
    function getAutoScrollerOptions() {
        const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
        const autoScrollGloballyDisabled = typeof autoScroll === 'object' ? autoScroll.enabled === false : autoScroll === false;
        const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
        if (typeof autoScroll === 'object') {
            return {
                ...autoScroll,
                enabled
            };
        }
        return {
            enabled
        };
    }
});
const NullContext = /*#__PURE__*/ React.createContext(null);
const defaultRole = 'button';
const ID_PREFIX = 'Draggable';
function useDraggable(_ref) {
    let { id, data, disabled = false, attributes } = _ref;
    const key = useUniqueId(ID_PREFIX);
    const { activators, activatorEvent, active, activeNodeRect, ariaDescribedById, draggableNodes, over } = React.useContext(InternalContext);
    const { role = defaultRole, roleDescription = 'draggable', tabIndex = 0 } = attributes != null ? attributes : {};
    const isDragging = (active == null ? void 0 : active.id) === id;
    const transform = React.useContext(isDragging ? ActiveDraggableContext : NullContext);
    const [node, setNodeRef] = useNodeRef();
    const [activatorNode, setActivatorNodeRef] = useNodeRef();
    const listeners = useSyntheticListeners(activators, id);
    const dataRef = useLatestValue(data);
    useIsomorphicLayoutEffect(()=>{
        draggableNodes.set(id, {
            id,
            key,
            node,
            activatorNode,
            data: dataRef
        });
        return ()=>{
            const node = draggableNodes.get(id);
            if (node && node.key === key) {
                draggableNodes.delete(id);
            }
        };
    }, [
        draggableNodes,
        id
    ]);
    const memoizedAttributes = React.useMemo(()=>({
            role,
            tabIndex,
            'aria-disabled': disabled,
            'aria-pressed': isDragging && role === defaultRole ? true : undefined,
            'aria-roledescription': roleDescription,
            'aria-describedby': ariaDescribedById.draggable
        }), [
        disabled,
        role,
        tabIndex,
        isDragging,
        roleDescription,
        ariaDescribedById.draggable
    ]);
    return {
        active,
        activatorEvent,
        activeNodeRect,
        attributes: memoizedAttributes,
        isDragging,
        listeners: disabled ? undefined : listeners,
        node,
        over,
        setNodeRef,
        setActivatorNodeRef,
        transform
    };
}
function useDndContext() {
    return React.useContext(PublicContext);
}
const ID_PREFIX$1 = 'Droppable';
const defaultResizeObserverConfig = {
    timeout: 25
};
function useDroppable(_ref) {
    let { data, disabled = false, id, resizeObserverConfig } = _ref;
    const key = useUniqueId(ID_PREFIX$1);
    const { active, dispatch, over, measureDroppableContainers } = React.useContext(InternalContext);
    const previous = React.useRef({
        disabled
    });
    const resizeObserverConnected = React.useRef(false);
    const rect = React.useRef(null);
    const callbackId = React.useRef(null);
    const { disabled: resizeObserverDisabled, updateMeasurementsFor, timeout: resizeObserverTimeout } = {
        ...defaultResizeObserverConfig,
        ...resizeObserverConfig
    };
    const ids = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
    const handleResize = React.useCallback(()=>{
        if (!resizeObserverConnected.current) {
            // ResizeObserver invokes the `handleResize` callback as soon as `observe` is called,
            // assuming the element is rendered and displayed.
            resizeObserverConnected.current = true;
            return;
        }
        if (callbackId.current != null) {
            clearTimeout(callbackId.current);
        }
        callbackId.current = setTimeout(()=>{
            measureDroppableContainers(Array.isArray(ids.current) ? ids.current : [
                ids.current
            ]);
            callbackId.current = null;
        }, resizeObserverTimeout);
    }, [
        resizeObserverTimeout
    ]);
    const resizeObserver = useResizeObserver({
        callback: handleResize,
        disabled: resizeObserverDisabled || !active
    });
    const handleNodeChange = React.useCallback((newElement, previousElement)=>{
        if (!resizeObserver) {
            return;
        }
        if (previousElement) {
            resizeObserver.unobserve(previousElement);
            resizeObserverConnected.current = false;
        }
        if (newElement) {
            resizeObserver.observe(newElement);
        }
    }, [
        resizeObserver
    ]);
    const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
    const dataRef = useLatestValue(data);
    React.useEffect(()=>{
        if (!resizeObserver || !nodeRef.current) {
            return;
        }
        resizeObserver.disconnect();
        resizeObserverConnected.current = false;
        resizeObserver.observe(nodeRef.current);
    }, [
        nodeRef,
        resizeObserver
    ]);
    React.useEffect(()=>{
        dispatch({
            type: Action.RegisterDroppable,
            element: {
                id,
                key,
                disabled,
                node: nodeRef,
                rect,
                data: dataRef
            }
        });
        return ()=>dispatch({
                type: Action.UnregisterDroppable,
                key,
                id
            });
    }, [
        id
    ]);
    React.useEffect(()=>{
        if (disabled !== previous.current.disabled) {
            dispatch({
                type: Action.SetDroppableDisabled,
                id,
                key,
                disabled
            });
            previous.current.disabled = disabled;
        }
    }, [
        id,
        key,
        disabled,
        dispatch
    ]);
    return {
        active,
        rect,
        isOver: (over == null ? void 0 : over.id) === id,
        node: nodeRef,
        over,
        setNodeRef
    };
}
function AnimationManager(_ref) {
    let { animation, children } = _ref;
    const [clonedChildren, setClonedChildren] = React.useState(null);
    const [element, setElement] = React.useState(null);
    const previousChildren = usePrevious(children);
    if (!children && !clonedChildren && previousChildren) {
        setClonedChildren(previousChildren);
    }
    useIsomorphicLayoutEffect(()=>{
        if (!element) {
            return;
        }
        const key = clonedChildren == null ? void 0 : clonedChildren.key;
        const id = clonedChildren == null ? void 0 : clonedChildren.props.id;
        if (key == null || id == null) {
            setClonedChildren(null);
            return;
        }
        Promise.resolve(animation(id, element)).then(()=>{
            setClonedChildren(null);
        });
    }, [
        animation,
        clonedChildren,
        element
    ]);
    return React.createElement(React.Fragment, null, children, clonedChildren ? React.cloneElement(clonedChildren, {
        ref: setElement
    }) : null);
}
const defaultTransform = {
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1
};
function NullifiedContextProvider(_ref) {
    let { children } = _ref;
    return React.createElement(InternalContext.Provider, {
        value: defaultInternalContext
    }, React.createElement(ActiveDraggableContext.Provider, {
        value: defaultTransform
    }, children));
}
const baseStyles = {
    position: 'fixed',
    touchAction: 'none'
};
const defaultTransition = (activatorEvent)=>{
    const isKeyboardActivator = isKeyboardEvent(activatorEvent);
    return isKeyboardActivator ? 'transform 250ms ease' : undefined;
};
const PositionedOverlay = /*#__PURE__*/ React.forwardRef((_ref, ref)=>{
    let { as, activatorEvent, adjustScale, children, className, rect, style, transform, transition = defaultTransition } = _ref;
    if (!rect) {
        return null;
    }
    const scaleAdjustedTransform = adjustScale ? transform : {
        ...transform,
        scaleX: 1,
        scaleY: 1
    };
    const styles = {
        ...baseStyles,
        width: rect.width,
        height: rect.height,
        top: rect.top,
        left: rect.left,
        transform: CSS.Transform.toString(scaleAdjustedTransform),
        transformOrigin: adjustScale && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : undefined,
        transition: typeof transition === 'function' ? transition(activatorEvent) : transition,
        ...style
    };
    return React.createElement(as, {
        className,
        style: styles,
        ref
    }, children);
});
const defaultDropAnimationSideEffects = (options)=>(_ref)=>{
        let { active, dragOverlay } = _ref;
        const originalStyles = {};
        const { styles, className } = options;
        if (styles != null && styles.active) {
            for (const [key, value] of Object.entries(styles.active)){
                if (value === undefined) {
                    continue;
                }
                originalStyles[key] = active.node.style.getPropertyValue(key);
                active.node.style.setProperty(key, value);
            }
        }
        if (styles != null && styles.dragOverlay) {
            for (const [key, value] of Object.entries(styles.dragOverlay)){
                if (value === undefined) {
                    continue;
                }
                dragOverlay.node.style.setProperty(key, value);
            }
        }
        if (className != null && className.active) {
            active.node.classList.add(className.active);
        }
        if (className != null && className.dragOverlay) {
            dragOverlay.node.classList.add(className.dragOverlay);
        }
        return function cleanup() {
            for (const [key, value] of Object.entries(originalStyles)){
                active.node.style.setProperty(key, value);
            }
            if (className != null && className.active) {
                active.node.classList.remove(className.active);
            }
        };
    };
const defaultKeyframeResolver = (_ref2)=>{
    let { transform: { initial, final } } = _ref2;
    return [
        {
            transform: CSS.Transform.toString(initial)
        },
        {
            transform: CSS.Transform.toString(final)
        }
    ];
};
const defaultDropAnimationConfiguration = {
    duration: 250,
    easing: 'ease',
    keyframes: defaultKeyframeResolver,
    sideEffects: /*#__PURE__*/ defaultDropAnimationSideEffects({
        styles: {
            active: {
                opacity: '0'
            }
        }
    })
};
function useDropAnimation(_ref3) {
    let { config, draggableNodes, droppableContainers, measuringConfiguration } = _ref3;
    return useEvent((id, node)=>{
        if (config === null) {
            return;
        }
        const activeDraggable = draggableNodes.get(id);
        if (!activeDraggable) {
            return;
        }
        const activeNode = activeDraggable.node.current;
        if (!activeNode) {
            return;
        }
        const measurableNode = getMeasurableNode(node);
        if (!measurableNode) {
            return;
        }
        const { transform } = getWindow(node).getComputedStyle(node);
        const parsedTransform = parseTransform(transform);
        if (!parsedTransform) {
            return;
        }
        const animation = typeof config === 'function' ? config : createDefaultDropAnimation(config);
        scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);
        return animation({
            active: {
                id,
                data: activeDraggable.data,
                node: activeNode,
                rect: measuringConfiguration.draggable.measure(activeNode)
            },
            draggableNodes,
            dragOverlay: {
                node,
                rect: measuringConfiguration.dragOverlay.measure(measurableNode)
            },
            droppableContainers,
            measuringConfiguration,
            transform: parsedTransform
        });
    });
}
function createDefaultDropAnimation(options) {
    const { duration, easing, sideEffects, keyframes } = {
        ...defaultDropAnimationConfiguration,
        ...options
    };
    return (_ref4)=>{
        let { active, dragOverlay, transform, ...rest } = _ref4;
        if (!duration) {
            // Do not animate if animation duration is zero.
            return;
        }
        const delta = {
            x: dragOverlay.rect.left - active.rect.left,
            y: dragOverlay.rect.top - active.rect.top
        };
        const scale = {
            scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,
            scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1
        };
        const finalTransform = {
            x: transform.x - delta.x,
            y: transform.y - delta.y,
            ...scale
        };
        const animationKeyframes = keyframes({
            ...rest,
            active,
            dragOverlay,
            transform: {
                initial: transform,
                final: finalTransform
            }
        });
        const [firstKeyframe] = animationKeyframes;
        const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];
        if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {
            // The start and end keyframes are the same, infer that there is no animation needed.
            return;
        }
        const cleanup = sideEffects == null ? void 0 : sideEffects({
            active,
            dragOverlay,
            ...rest
        });
        const animation = dragOverlay.node.animate(animationKeyframes, {
            duration,
            easing,
            fill: 'forwards'
        });
        return new Promise((resolve)=>{
            animation.onfinish = ()=>{
                cleanup == null ? void 0 : cleanup();
                resolve();
            };
        });
    };
}
let key = 0;
function useKey(id) {
    return React.useMemo(()=>{
        if (id == null) {
            return;
        }
        key++;
        return key;
    }, [
        id
    ]);
}
const DragOverlay = /*#__PURE__*/ React.memo((_ref)=>{
    let { adjustScale = false, children, dropAnimation: dropAnimationConfig, style, transition, modifiers, wrapperElement = 'div', className, zIndex = 999 } = _ref;
    const { activatorEvent, active, activeNodeRect, containerNodeRect, draggableNodes, droppableContainers, dragOverlay, over, measuringConfiguration, scrollableAncestors, scrollableAncestorRects, windowRect } = useDndContext();
    const transform = React.useContext(ActiveDraggableContext);
    const key = useKey(active == null ? void 0 : active.id);
    const modifiedTransform = applyModifiers(modifiers, {
        activatorEvent,
        active,
        activeNodeRect,
        containerNodeRect,
        draggingNodeRect: dragOverlay.rect,
        over,
        overlayNodeRect: dragOverlay.rect,
        scrollableAncestors,
        scrollableAncestorRects,
        transform,
        windowRect
    });
    const initialRect = useInitialValue(activeNodeRect);
    const dropAnimation = useDropAnimation({
        config: dropAnimationConfig,
        draggableNodes,
        droppableContainers,
        measuringConfiguration
    }); // We need to wait for the active node to be measured before connecting the drag overlay ref
    // otherwise collisions can be computed against a mispositioned drag overlay
    const ref = initialRect ? dragOverlay.setRef : undefined;
    return React.createElement(NullifiedContextProvider, null, React.createElement(AnimationManager, {
        animation: dropAnimation
    }, active && key ? React.createElement(PositionedOverlay, {
        key: key,
        id: active.id,
        ref: ref,
        as: wrapperElement,
        activatorEvent: activatorEvent,
        adjustScale: adjustScale,
        className: className,
        transition: transition,
        rect: initialRect,
        style: {
            zIndex,
            ...style
        },
        transform: modifiedTransform
    }, children) : null));
});
const snapCenterToCursor = (_ref)=>{
    let { activatorEvent, draggingNodeRect, transform } = _ref;
    if (draggingNodeRect && activatorEvent) {
        const activatorCoordinates = getEventCoordinates(activatorEvent);
        if (!activatorCoordinates) {
            return transform;
        }
        const offsetX = activatorCoordinates.x - draggingNodeRect.left;
        const offsetY = activatorCoordinates.y - draggingNodeRect.top;
        return {
            ...transform,
            x: transform.x + offsetX - draggingNodeRect.width / 2,
            y: transform.y + offsetY - draggingNodeRect.height / 2
        };
    }
    return transform;
};
function generateBoard(noOfRows, noOfColumns, boardOrientation) {
    const board = Array.from(Array(noOfRows), ()=>new Array(noOfColumns));
    for(let row = 0; row < noOfRows; row++){
        for(let column = 0; column < noOfColumns; column++){
            board[row][column] = {
                squareId: `${columnIndexToChessColumn(column, noOfColumns, boardOrientation)}${rowIndexToChessRow(row, noOfRows, boardOrientation)}`,
                isLightSquare: (row + column) % 2 === 0
            };
        }
    }
    return board;
}
function rowIndexToChessRow(row, noOfRows, boardOrientation) {
    return boardOrientation === 'white' ? (noOfRows - row).toString() : (row + 1).toString();
}
function columnIndexToChessColumn(column, noOfColumns, boardOrientation) {
    return boardOrientation === 'white' ? String.fromCharCode(97 + column) : String.fromCharCode(97 + noOfColumns - column - 1);
}
function chessColumnToColumnIndex(column, noOfColumns, boardOrientation) {
    return boardOrientation === 'white' ? column.charCodeAt(0) - 97 : noOfColumns - (column.charCodeAt(0) - 97) - 1;
}
function chessRowToRowIndex(row, noOfRows, boardOrientation) {
    return boardOrientation === 'white' ? noOfRows - Number(row) : Number(row) - 1;
}
function fenStringToPositionObject(fen, noOfRows, noOfColumns) {
    const positionObject = {};
    const rows = fen.split(' ')[0].split('/');
    // rows start from top of the board (black rank) in white orientation, and bottom of the board (white rank) in black orientation
    for(let row = 0; row < rows.length; row++){
        let column = 0;
        for (const char of rows[row]){
            // if char is a letter, it is a piece
            if (isNaN(Number(char))) {
                // force orientation to flip fen string when black orientation used
                const position = `${columnIndexToChessColumn(column, noOfColumns, 'white')}${rowIndexToChessRow(row, noOfRows, 'white')}`;
                // set piece at position (e.g. 0-0 for a8 on a normal board)
                positionObject[position] = {
                    pieceType: fenToPieceCode(char)
                };
                // increment column for next piece
                column++;
            } else {
                // if char is a number, it is empty squares, skip that many columns
                column += Number(char);
            }
        }
    }
    return positionObject;
}
/**
 * Convert fen piece code (e.g. p, N) to camel case notation (e.g. bP, wK).
 */ function fenToPieceCode(piece) {
    // lower case is black piece
    if (piece.toLowerCase() === piece) {
        return 'b' + piece.toUpperCase();
    }
    // upper case is white piece
    return 'w' + piece.toUpperCase();
}
// todo: if already in updates, find next candidate
/**
 * Return an object with the pieces that have moved from the old position to the new position.
 * The keys are the source square names (e.g. "e2") and the values are the new square positions (e.g. "e4"), indicating that the piece in square "e2" has moved to square "e4".
 */ function getPositionUpdates(oldPosition, newPosition, noOfColumns, boardOrientation) {
    const updates = {};
    for(const newSquare in newPosition){
        var _oldPosition_newSquare;
        const candidateSquares = [];
        // the piece hasn't moved, so we don't need to do anything
        if (((_oldPosition_newSquare = oldPosition[newSquare]) === null || _oldPosition_newSquare === void 0 ? void 0 : _oldPosition_newSquare.pieceType) === newPosition[newSquare].pieceType) {
            continue;
        }
        for(const oldSquare in oldPosition){
            var _newPosition_oldSquare;
            // if the piece type is the same, and the new square is not the old square, and the piece has moved, then we have found a candidate for the new position
            if (oldPosition[oldSquare].pieceType === newPosition[newSquare].pieceType && oldSquare !== newSquare && oldPosition[oldSquare].pieceType !== ((_newPosition_oldSquare = newPosition[oldSquare]) === null || _newPosition_oldSquare === void 0 ? void 0 : _newPosition_oldSquare.pieceType)) {
                candidateSquares.push(oldSquare);
            }
        }
        if (candidateSquares.length === 1) {
            // if there is only one candidate, we can just return it
            updates[candidateSquares[0]] = newSquare;
        } else {
            // if there are multiple candidates, we need to find the one that is correct to the best of our ability by standard chess rules
            for (const candidateSquare of candidateSquares){
                var _candidateSquare_match, _newSquare_match, _candidateSquare_match1, _newSquare_match1, _candidateSquare_match2, _candidateSquare_match3, _newSquare_match2, _newSquare_match3;
                // get the piece type of the candidate e.g. 'P', 'N', 'B', 'R', 'Q', 'K'
                const candidatePieceType = oldPosition[candidateSquare].pieceType[1];
                var _candidateSquare_match_, _newSquare_match_;
                const columnDifference = Math.abs(chessColumnToColumnIndex((_candidateSquare_match_ = (_candidateSquare_match = candidateSquare.match(/^[a-z]+/)) === null || _candidateSquare_match === void 0 ? void 0 : _candidateSquare_match[0]) !== null && _candidateSquare_match_ !== void 0 ? _candidateSquare_match_ : '', noOfColumns, boardOrientation) - chessColumnToColumnIndex((_newSquare_match_ = (_newSquare_match = newSquare.match(/^[a-z]+/)) === null || _newSquare_match === void 0 ? void 0 : _newSquare_match[0]) !== null && _newSquare_match_ !== void 0 ? _newSquare_match_ : '', noOfColumns, boardOrientation));
                var _candidateSquare_match_1, _newSquare_match_1;
                const rowDifference = Math.abs(Number((_candidateSquare_match_1 = (_candidateSquare_match1 = candidateSquare.match(/\d+$/)) === null || _candidateSquare_match1 === void 0 ? void 0 : _candidateSquare_match1[0]) !== null && _candidateSquare_match_1 !== void 0 ? _candidateSquare_match_1 : '') - Number((_newSquare_match_1 = (_newSquare_match1 = newSquare.match(/\d+$/)) === null || _newSquare_match1 === void 0 ? void 0 : _newSquare_match1[0]) !== null && _newSquare_match_1 !== void 0 ? _newSquare_match_1 : ''));
                var _candidateSquare_match_2, _candidateSquare_match_3;
                const isOldSquareLight = (chessColumnToColumnIndex((_candidateSquare_match_2 = (_candidateSquare_match2 = candidateSquare.match(/^[a-z]+/)) === null || _candidateSquare_match2 === void 0 ? void 0 : _candidateSquare_match2[0]) !== null && _candidateSquare_match_2 !== void 0 ? _candidateSquare_match_2 : '', noOfColumns, boardOrientation) + Number((_candidateSquare_match_3 = (_candidateSquare_match3 = candidateSquare.match(/\d+$/)) === null || _candidateSquare_match3 === void 0 ? void 0 : _candidateSquare_match3[0]) !== null && _candidateSquare_match_3 !== void 0 ? _candidateSquare_match_3 : '')) % 2 === 0;
                var _newSquare_match_2, _newSquare_match_3;
                const isNewSquareLight = (chessColumnToColumnIndex((_newSquare_match_2 = (_newSquare_match2 = newSquare.match(/^[a-z]+/)) === null || _newSquare_match2 === void 0 ? void 0 : _newSquare_match2[0]) !== null && _newSquare_match_2 !== void 0 ? _newSquare_match_2 : '', noOfColumns, boardOrientation) + Number((_newSquare_match_3 = (_newSquare_match3 = newSquare.match(/\d+$/)) === null || _newSquare_match3 === void 0 ? void 0 : _newSquare_match3[0]) !== null && _newSquare_match_3 !== void 0 ? _newSquare_match_3 : '')) % 2 === 0;
                // prioritise pawns on same file
                if (candidatePieceType === 'P') {
                    var _candidateSquare_match4, _newSquare_match4;
                    if (((_candidateSquare_match4 = candidateSquare.match(/^[a-z]+/)) === null || _candidateSquare_match4 === void 0 ? void 0 : _candidateSquare_match4[0]) === ((_newSquare_match4 = newSquare.match(/^[a-z]+/)) === null || _newSquare_match4 === void 0 ? void 0 : _newSquare_match4[0])) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
                // prioritise knights by euclidean distance
                if (candidatePieceType === 'N') {
                    if (columnDifference === 2 && rowDifference === 1 || columnDifference === 1 && rowDifference === 2) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
                // prioritise bishops that have moved diagonally and are on the same color square
                if (candidatePieceType === 'B') {
                    if (columnDifference === rowDifference && isOldSquareLight === isNewSquareLight) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
                // prioritise rooks that have moved horizontally or vertically
                if (candidatePieceType === 'R') {
                    if (columnDifference === 0 || rowDifference === 0) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
                // prioritise queens that have moved diagonally, horizontally or vertically
                if (candidatePieceType === 'Q') {
                    if (columnDifference === 0 || rowDifference === 0 || columnDifference === rowDifference) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
                // prioritise kings that have moved one square in any direction
                if (candidatePieceType === 'K') {
                    if (columnDifference <= 1 && rowDifference <= 1) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
            }
            // if we still don't have a candidate, use the first candidate that has not been used yet
            if (!Object.values(updates).includes(newSquare) && candidateSquares.length > 0) {
                for (const candidateSquare of candidateSquares){
                    if (!Object.keys(updates).includes(candidateSquare)) {
                        updates[candidateSquare] = newSquare;
                        break;
                    }
                }
            }
        }
    }
    return updates;
}
/**
 * Retrieves the coordinates at the centre of the requested square, relative to the top left of the board (0, 0).
 */ function getRelativeCoords(boardOrientation, boardWidth, chessboardColumns, chessboardRows, square) {
    var _square_match, _square_match1;
    const squareWidth = boardWidth / chessboardColumns;
    var _square_match_;
    const x = chessColumnToColumnIndex((_square_match_ = (_square_match = square.match(/^[a-z]+/)) === null || _square_match === void 0 ? void 0 : _square_match[0]) !== null && _square_match_ !== void 0 ? _square_match_ : '', chessboardColumns, boardOrientation) * squareWidth + squareWidth / 2;
    var _square_match_1;
    const y = chessRowToRowIndex((_square_match_1 = (_square_match1 = square.match(/\d+$/)) === null || _square_match1 === void 0 ? void 0 : _square_match1[0]) !== null && _square_match_1 !== void 0 ? _square_match_1 : '', chessboardRows, boardOrientation) * squareWidth + squareWidth / 2;
    return {
        x,
        y
    };
}
const defaultPieces = {
    wP: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsx("path", {
                d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z",
                style: {
                    opacity: '1',
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                    fillOpacity: '1',
                    fillRule: 'nonzero',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'miter',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                }
            })
        });
    },
    wR: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 34,14 L 31,17 L 14,17 L 11,14"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 31,17 L 31,29.5 L 14,29.5 L 14,17",
                        style: {
                            strokeLinecap: 'butt',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 31,29.5 L 32.5,32 L 12.5,32 L 14,29.5"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11,14 L 34,14",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        }
                    })
                ]
            })
        });
    },
    wN: (props)=>{
        var _props_fill, _props_fill1;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: 'none',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18",
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10",
                        style: {
                            fill: (_props_fill1 = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill1 !== void 0 ? _props_fill1 : '#ffffff',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z",
                        style: {
                            fill: '#000000',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z",
                        transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)",
                        style: {
                            fill: '#000000',
                            stroke: '#000000'
                        }
                    })
                ]
            })
        });
    },
    wB: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: 'none',
                    fillRule: 'evenodd',
                    fillOpacity: '1',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsxs("g", {
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                            stroke: '#000000',
                            strokeLinecap: 'butt'
                        },
                        children: [
                            jsxRuntimeExports.jsx("path", {
                                d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z"
                            })
                        ]
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        }
                    })
                ]
            })
        });
    },
    wQ: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinejoin: 'round'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9,26 C 9,28 10.5,28 11.5,30 C 12.5,31.5 12.5,31 12,33.5 C 10.5,34.5 11,36 11,36 C 9.5,37.5 11,38.5 11,38.5 C 17.5,39.5 27.5,39.5 34,38.5 C 34,38.5 35.5,37.5 34,36 C 34,36 34.5,34.5 33,33.5 C 32.5,31 32.5,31.5 33.5,30 C 34.5,28 36,28 36,26 C 27.5,24.5 17.5,24.5 9,26 z"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11.5,30 C 15,29 30,29 33.5,30",
                        style: {
                            fill: 'none'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12,33.5 C 18,32.5 27,32.5 33,33.5",
                        style: {
                            fill: 'none'
                        }
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "6",
                        cy: "12",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "14",
                        cy: "9",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "22.5",
                        cy: "8",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "31",
                        cy: "9",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "39",
                        cy: "12",
                        r: "2"
                    })
                ]
            })
        });
    },
    wK: (props)=>{
        var _props_fill, _props_fill1;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    fill: 'none',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22.5,11.63 L 22.5,6",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 20,8 L 25,8",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25",
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#ffffff',
                            stroke: '#000000',
                            strokeLinecap: 'butt',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37",
                        style: {
                            fill: (_props_fill1 = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill1 !== void 0 ? _props_fill1 : '#ffffff',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,30 C 18,27 27,27 32.5,30",
                        style: {
                            fill: 'none',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5",
                        style: {
                            fill: 'none',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,37 C 18,34 27,34 32.5,37",
                        style: {
                            fill: 'none',
                            stroke: '#000000'
                        }
                    })
                ]
            })
        });
    },
    bP: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsx("path", {
                d: "m 22.5,9 c -2.21,0 -4,1.79 -4,4 0,0.89 0.29,1.71 0.78,2.38 C 17.33,16.5 16,18.59 16,21 c 0,2.03 0.94,3.84 2.41,5.03 C 15.41,27.09 11,31.58 11,39.5 H 34 C 34,31.58 29.59,27.09 26.59,26.03 28.06,24.84 29,23.03 29,21 29,18.59 27.67,16.5 25.72,15.38 26.21,14.71 26.5,13.89 26.5,13 c 0,-2.21 -1.79,-4 -4,-4 z",
                style: {
                    opacity: '1',
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                    fillOpacity: '1',
                    fillRule: 'nonzero',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'miter',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                }
            })
        });
    },
    bR: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9,39 L 36,39 L 36,36 L 9,36 L 9,39 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,32 L 14,29.5 L 31,29.5 L 32.5,32 L 12.5,32 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12,36 L 12,32 L 33,32 L 33,36 L 12,36 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 14,29.5 L 14,16.5 L 31,16.5 L 31,29.5 L 14,29.5 z ",
                        style: {
                            strokeLinecap: 'butt',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 14,16.5 L 11,14 L 34,14 L 31,16.5 L 14,16.5 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11,14 L 11,9 L 15,9 L 15,11 L 20,11 L 20,9 L 25,9 L 25,11 L 30,11 L 30,9 L 34,9 L 34,14 L 11,14 z ",
                        style: {
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12,35.5 L 33,35.5 L 33,35.5",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeWidth: '1',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 13,31.5 L 32,31.5",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeWidth: '1',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 14,29.5 L 31,29.5",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeWidth: '1',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 14,16.5 L 31,16.5",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeWidth: '1',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11,14 L 34,14",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeWidth: '1',
                            strokeLinejoin: 'miter'
                        }
                    })
                ]
            })
        });
    },
    bN: (props)=>{
        var _props_fill, _props_fill1;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: 'none',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22,10 C 32.5,11 38.5,18 38,39 L 15,39 C 15,30 25,32.5 23,18",
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 24,18 C 24.38,20.91 18.45,25.37 16,27 C 13,29 13.18,31.34 11,31 C 9.958,30.06 12.41,27.96 11,28 C 10,28 11.19,29.23 10,30 C 9,30 5.997,31 6,26 C 6,24 12,14 12,14 C 12,14 13.89,12.1 14,10.5 C 13.27,9.506 13.5,8.5 13.5,7.5 C 14.5,6.5 16.5,10 16.5,10 L 18.5,10 C 18.5,10 19.28,8.008 21,7 C 22,7 22,10 22,10",
                        style: {
                            fill: (_props_fill1 = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill1 !== void 0 ? _props_fill1 : '#000000',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9.5 25.5 A 0.5 0.5 0 1 1 8.5,25.5 A 0.5 0.5 0 1 1 9.5 25.5 z",
                        style: {
                            fill: '#ffffff',
                            stroke: '#ffffff'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 15 15.5 A 0.5 1.5 0 1 1  14,15.5 A 0.5 1.5 0 1 1  15 15.5 z",
                        transform: "matrix(0.866,0.5,-0.5,0.866,9.693,-5.173)",
                        style: {
                            fill: '#ffffff',
                            stroke: '#ffffff'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 24.55,10.4 L 24.1,11.85 L 24.6,12 C 27.75,13 30.25,14.49 32.5,18.75 C 34.75,23.01 35.75,29.06 35.25,39 L 35.2,39.5 L 37.45,39.5 L 37.5,39 C 38,28.94 36.62,22.15 34.25,17.66 C 31.88,13.17 28.46,11.02 25.06,10.5 L 24.55,10.4 z ",
                        style: {
                            fill: '#ffffff',
                            stroke: 'none'
                        }
                    })
                ]
            })
        });
    },
    bB: (props)=>{
        var _props_fill;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    opacity: '1',
                    fill: 'none',
                    fillRule: 'evenodd',
                    fillOpacity: '1',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsxs("g", {
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                            stroke: '#000000',
                            strokeLinecap: 'butt'
                        },
                        children: [
                            jsxRuntimeExports.jsx("path", {
                                d: "M 9,36 C 12.39,35.03 19.11,36.43 22.5,34 C 25.89,36.43 32.61,35.03 36,36 C 36,36 37.65,36.54 39,38 C 38.32,38.97 37.35,38.99 36,38.5 C 32.61,37.53 25.89,38.96 22.5,37.5 C 19.11,38.96 12.39,37.53 9,38.5 C 7.65,38.99 6.68,38.97 6,38 C 7.35,36.54 9,36 9,36 z"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 15,32 C 17.5,34.5 27.5,34.5 30,32 C 30.5,30.5 30,30 30,30 C 30,27.5 27.5,26 27.5,26 C 33,24.5 33.5,14.5 22.5,10.5 C 11.5,14.5 12,24.5 17.5,26 C 17.5,26 15,27.5 15,30 C 15,30 14.5,30.5 15,32 z"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 25 8 A 2.5 2.5 0 1 1  20,8 A 2.5 2.5 0 1 1  25 8 z"
                            })
                        ]
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 17.5,26 L 27.5,26 M 15,30 L 30,30 M 22.5,15.5 L 22.5,20.5 M 20,18 L 25,18",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff',
                            strokeLinejoin: 'miter'
                        }
                    })
                ]
            })
        });
    },
    bQ: (props)=>{
        var _props_fill, _props_fill1;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 9,26 C 17.5,24.5 30,24.5 36,26 L 38.5,13.5 L 31,25 L 30.7,10.9 L 25.5,24.5 L 22.5,10 L 19.5,24.5 L 14.3,10.9 L 14,25 L 6.5,13.5 L 9,26 z",
                        style: {
                            strokeLinecap: 'butt',
                            fill: (_props_fill1 = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill1 !== void 0 ? _props_fill1 : '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "m 9,26 c 0,2 1.5,2 2.5,4 1,1.5 1,1 0.5,3.5 -1.5,1 -1,2.5 -1,2.5 -1.5,1.5 0,2.5 0,2.5 6.5,1 16.5,1 23,0 0,0 1.5,-1 0,-2.5 0,0 0.5,-1.5 -1,-2.5 -0.5,-2.5 -0.5,-2 0.5,-3.5 1,-2 2.5,-2 2.5,-4 -8.5,-1.5 -18.5,-1.5 -27,0 z"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11.5,30 C 15,29 30,29 33.5,30"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "m 12,33.5 c 6,-1 15,-1 21,0"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "6",
                        cy: "12",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "14",
                        cy: "9",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "22.5",
                        cy: "8",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "31",
                        cy: "9",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("circle", {
                        cx: "39",
                        cy: "12",
                        r: "2"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 11,38.5 A 35,35 1 0 0 34,38.5",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinecap: 'butt'
                        }
                    }),
                    jsxRuntimeExports.jsxs("g", {
                        style: {
                            fill: 'none',
                            stroke: '#ffffff'
                        },
                        children: [
                            jsxRuntimeExports.jsx("path", {
                                d: "M 11,29 A 35,35 1 0 1 34,29"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 12.5,31.5 L 32.5,31.5"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 11.5,34.5 A 35,35 1 0 0 33.5,34.5"
                            }),
                            jsxRuntimeExports.jsx("path", {
                                d: "M 10.5,37.5 A 35,35 1 0 0 34.5,37.5"
                            })
                        ]
                    })
                ]
            })
        });
    },
    bK: (props)=>{
        var _props_fill, _props_fill1;
        return jsxRuntimeExports.jsx("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            version: "1.1",
            viewBox: "0 0 45 45",
            width: "100%",
            height: "100%",
            style: props === null || props === void 0 ? void 0 : props.svgStyle,
            children: jsxRuntimeExports.jsxs("g", {
                style: {
                    fill: 'none',
                    fillOpacity: '1',
                    fillRule: 'evenodd',
                    stroke: '#000000',
                    strokeWidth: '1.5',
                    strokeLinecap: 'round',
                    strokeLinejoin: 'round',
                    strokeMiterlimit: '4',
                    strokeDasharray: 'none',
                    strokeOpacity: '1'
                },
                children: [
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22.5,11.63 L 22.5,6",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        },
                        id: "path6570"
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 22.5,25 C 22.5,25 27,17.5 25.5,14.5 C 25.5,14.5 24.5,12 22.5,12 C 20.5,12 19.5,14.5 19.5,14.5 C 18,17.5 22.5,25 22.5,25",
                        style: {
                            fill: (_props_fill = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill !== void 0 ? _props_fill : '#000000',
                            fillOpacity: '1',
                            strokeLinecap: 'butt',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,37 C 18,40.5 27,40.5 32.5,37 L 32.5,30 C 32.5,30 41.5,25.5 38.5,19.5 C 34.5,13 25,16 22.5,23.5 L 22.5,27 L 22.5,23.5 C 20,16 10.5,13 6.5,19.5 C 3.5,25.5 12.5,30 12.5,30 L 12.5,37",
                        style: {
                            fill: (_props_fill1 = props === null || props === void 0 ? void 0 : props.fill) !== null && _props_fill1 !== void 0 ? _props_fill1 : '#000000',
                            stroke: '#000000'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 20,8 L 25,8",
                        style: {
                            fill: 'none',
                            stroke: '#000000',
                            strokeLinejoin: 'miter'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 32,29.5 C 32,29.5 40.5,25.5 38.03,19.85 C 34.15,14 25,18 22.5,24.5 L 22.5,26.6 L 22.5,24.5 C 20,18 10.85,14 6.97,19.85 C 4.5,25.5 13,29.5 13,29.5",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff'
                        }
                    }),
                    jsxRuntimeExports.jsx("path", {
                        d: "M 12.5,30 C 18,27 27,27 32.5,30 M 12.5,33.5 C 18,30.5 27,30.5 32.5,33.5 M 12.5,37 C 18,34 27,34 32.5,37",
                        style: {
                            fill: 'none',
                            stroke: '#ffffff'
                        }
                    })
                ]
            })
        });
    }
};
function defaultBoardStyle(chessboardColumns) {
    return {
        display: 'grid',
        gridTemplateColumns: `repeat(${chessboardColumns}, 1fr)`,
        overflow: 'hidden',
        width: '100%',
        height: '100%',
        position: 'relative'
    };
}
const defaultSquareStyle = {
    aspectRatio: '1/1',
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    position: 'relative'
};
const defaultDarkSquareStyle = {
    backgroundColor: '#B58863'
};
const defaultLightSquareStyle = {
    backgroundColor: '#F0D9B5'
};
const defaultDropSquareStyle = {
    boxShadow: 'inset 0px 0px 0px 1px black'
};
const defaultDarkSquareNotationStyle = {
    color: '#F0D9B5'
};
const defaultLightSquareNotationStyle = {
    color: '#B58863'
};
const defaultAlphaNotationStyle = {
    fontSize: '13px',
    position: 'absolute',
    bottom: 1,
    right: 4,
    userSelect: 'none'
};
const defaultNumericNotationStyle = {
    fontSize: '13px',
    position: 'absolute',
    top: 2,
    left: 2,
    userSelect: 'none'
};
const defaultDraggingPieceStyle = {
    transform: 'scale(1.2)'
};
const defaultDraggingPieceGhostStyle = {
    opacity: 0.5
};
const defaultArrowOptions = {
    color: '#ffaa00',
    secondaryColor: '#4caf50',
    tertiaryColor: '#f44336',
    arrowLengthReducerDenominator: 8,
    sameTargetArrowLengthReducerDenominator: 4,
    arrowWidthDenominator: 5,
    activeArrowWidthMultiplier: 0.9,
    opacity: 0.65,
    activeOpacity: 0.5
};
const ChessboardContext = React.createContext(null);
const useChessboardContext = ()=>React.use(ChessboardContext);
function ChessboardProvider({ children, options }) {
    const { // id
    id = 'chessboard', // pieces and position
    pieces = defaultPieces, position = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR', // board dimensions and orientation
    boardOrientation = 'white', chessboardRows = 8, chessboardColumns = 8, // board and squares styles
    boardStyle = defaultBoardStyle(chessboardColumns), squareStyle = defaultSquareStyle, squareStyles = {}, darkSquareStyle = defaultDarkSquareStyle, lightSquareStyle = defaultLightSquareStyle, dropSquareStyle = defaultDropSquareStyle, draggingPieceStyle = defaultDraggingPieceStyle, draggingPieceGhostStyle = defaultDraggingPieceGhostStyle, // notation
    darkSquareNotationStyle = defaultDarkSquareNotationStyle, lightSquareNotationStyle = defaultLightSquareNotationStyle, alphaNotationStyle = defaultAlphaNotationStyle, numericNotationStyle = defaultNumericNotationStyle, showNotation = true, // animation
    animationDurationInMs = 300, showAnimations = true, // drag and drop
    allowDragging = true, allowDragOffBoard = true, allowAutoScroll = false, dragActivationDistance = 1, // arrows
    allowDrawingArrows = true, arrows = [], arrowOptions = defaultArrowOptions, clearArrowsOnClick = true, // handlers
    canDragPiece, onArrowsChange, onMouseOutSquare, onMouseOverSquare, onPieceClick, onPieceDrag, onPieceDrop, onSquareClick, onSquareRightClick, squareRenderer } = options || {};
    // the piece currently being dragged
    const [draggingPiece, setDraggingPiece] = React.useState(null);
    // the current position of pieces on the chessboard
    const [currentPosition, setCurrentPosition] = React.useState(typeof position === 'string' ? fenStringToPositionObject(position, chessboardRows, chessboardColumns) : position);
    // calculated differences between current and incoming positions
    const [positionDifferences, setPositionDifferences] = React.useState({});
    // if the latest move was a manual drop
    const [manuallyDroppedPieceAndSquare, setManuallyDroppedPieceAndSquare] = React.useState(null);
    // arrows
    const [newArrowStartSquare, setNewArrowStartSquare] = React.useState(null);
    const [newArrowOverSquare, setNewArrowOverSquare] = React.useState(null);
    const [internalArrows, setInternalArrows] = React.useState([]);
    // position we are animating to, if a new position comes in before the animation completes, we will use this to set the new position
    const [waitingForAnimationPosition, setWaitingForAnimationPosition] = React.useState(null);
    // the animation timeout whilst waiting for animation to complete
    const animationTimeoutRef = React.useRef(null);
    // if the position changes, we need to recreate the pieces array
    React.useEffect(()=>{
        const newPosition = typeof position === 'string' ? fenStringToPositionObject(position, chessboardRows, chessboardColumns) : position;
        // if no animation, just set the position
        if (!showAnimations) {
            setCurrentPosition(newPosition);
            return;
        }
        // save copy of the waiting for animation position so we can use it later but clear it from state so we don't use it in the next animation
        const currentWaitingForAnimationPosition = waitingForAnimationPosition;
        // if we are waiting for an animation to complete from a previous move, set the saved position to immediately end the animation
        if (currentWaitingForAnimationPosition) {
            setCurrentPosition(currentWaitingForAnimationPosition);
            setWaitingForAnimationPosition(null);
        }
        // get list of position updates as pieces to potentially animate
        const positionUpdates = getPositionUpdates(currentWaitingForAnimationPosition !== null && currentWaitingForAnimationPosition !== void 0 ? currentWaitingForAnimationPosition : currentPosition, newPosition, chessboardColumns, boardOrientation);
        const multiplePiecesMoved = Object.keys(positionUpdates).length > 1;
        // manually dropped piece caused multiple pieces to move (e.g. castling)
        if (manuallyDroppedPieceAndSquare && multiplePiecesMoved) {
            // create a new position with just the dropped piece moved
            const intermediatePosition = {
                ...currentPosition
            };
            delete intermediatePosition[manuallyDroppedPieceAndSquare.sourceSquare];
            intermediatePosition[manuallyDroppedPieceAndSquare.targetSquare] = {
                pieceType: manuallyDroppedPieceAndSquare.piece
            };
            setCurrentPosition(intermediatePosition);
            // create position differences with only the other pieces' movements
            const otherPiecesUpdates = {
                ...positionUpdates
            };
            delete otherPiecesUpdates[manuallyDroppedPieceAndSquare.sourceSquare];
            setPositionDifferences(otherPiecesUpdates);
            // animate the other pieces' movements
            const newTimeout = setTimeout(()=>{
                setCurrentPosition(newPosition);
                setPositionDifferences({});
                setManuallyDroppedPieceAndSquare(null);
            }, animationDurationInMs);
            animationTimeoutRef.current = newTimeout;
            return;
        }
        // new position was a result of a manual drop
        if (manuallyDroppedPieceAndSquare) {
            // no animation needed, just set the position and reset the flag
            setCurrentPosition(newPosition);
            setManuallyDroppedPieceAndSquare(null);
            return;
        }
        // new position was a result of an external move
        setPositionDifferences(positionUpdates);
        setWaitingForAnimationPosition(newPosition);
        // start animation timeout
        const newTimeout = setTimeout(()=>{
            setCurrentPosition(newPosition);
            setPositionDifferences({});
            setWaitingForAnimationPosition(null);
        }, animationDurationInMs);
        // update the ref to the new timeout
        animationTimeoutRef.current = newTimeout;
        // clear timeout on unmount
        return ()=>{
            if (animationTimeoutRef.current) {
                clearTimeout(animationTimeoutRef.current);
            }
        };
    }, [
        position
    ]);
    // if the dimensions change, we need to recreate the pieces array
    React.useEffect(()=>{
        setCurrentPosition(typeof position === 'string' ? fenStringToPositionObject(position, chessboardRows, chessboardColumns) : position);
    }, [
        chessboardRows,
        chessboardColumns,
        boardOrientation
    ]);
    // if the arrows change, call the onArrowsChange callback
    React.useEffect(()=>{
        onArrowsChange === null || onArrowsChange === void 0 ? void 0 : onArrowsChange({
            arrows: internalArrows
        });
    }, [
        internalArrows
    ]);
    // only redraw the board when the dimensions or board orientation change
    const board = React.useMemo(()=>generateBoard(chessboardRows, chessboardColumns, boardOrientation), [
        chessboardRows,
        chessboardColumns,
        boardOrientation
    ]);
    const drawArrow = React.useCallback((newArrowEndSquare, modifiers)=>{
        if (!allowDrawingArrows) {
            return;
        }
        const arrowExistsIndex = internalArrows.findIndex((arrow)=>arrow.startSquare === newArrowStartSquare && arrow.endSquare === newArrowEndSquare);
        const arrowExistsExternally = arrows.some((arrow)=>arrow.startSquare === newArrowStartSquare && arrow.endSquare === newArrowEndSquare);
        // if the arrow already exists externally, don't add it to the internal arrows
        if (arrowExistsExternally) {
            setNewArrowStartSquare(null);
            setNewArrowOverSquare(null);
            return;
        }
        // new arrow with different start and end square, add to internal arrows or remove if it already exists
        if (newArrowStartSquare && newArrowStartSquare !== newArrowEndSquare) {
            const arrowColor = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.shiftKey) ? arrowOptions.secondaryColor : (modifiers === null || modifiers === void 0 ? void 0 : modifiers.ctrlKey) ? arrowOptions.tertiaryColor : arrowOptions.color;
            setInternalArrows((prevArrows)=>arrowExistsIndex === -1 ? [
                    ...prevArrows,
                    {
                        startSquare: newArrowStartSquare,
                        endSquare: newArrowEndSquare,
                        color: arrowColor
                    }
                ] : prevArrows.filter((_, index)=>index !== arrowExistsIndex));
            setNewArrowStartSquare(null);
            setNewArrowOverSquare(null);
        }
    }, [
        allowDrawingArrows,
        arrows,
        arrowOptions.color,
        arrowOptions.secondaryColor,
        arrowOptions.tertiaryColor,
        internalArrows,
        newArrowStartSquare,
        newArrowOverSquare
    ]);
    const clearArrows = React.useCallback(()=>{
        if (clearArrowsOnClick) {
            setInternalArrows([]);
            setNewArrowStartSquare(null);
            setNewArrowOverSquare(null);
        }
    }, [
        clearArrowsOnClick
    ]);
    const setNewArrowOverSquareWithModifiers = React.useCallback((square, modifiers)=>{
        const color = (modifiers === null || modifiers === void 0 ? void 0 : modifiers.shiftKey) ? arrowOptions.secondaryColor : (modifiers === null || modifiers === void 0 ? void 0 : modifiers.ctrlKey) ? arrowOptions.tertiaryColor : arrowOptions.color;
        setNewArrowOverSquare({
            square,
            color
        });
    }, [
        arrowOptions
    ]);
    const handleDragCancel = React.useCallback(()=>{
        setDraggingPiece(null);
    }, []);
    const handleDragEnd = React.useCallback(function handleDragEnd(event) {
        var _event_over;
        if (!draggingPiece) {
            return;
        }
        const dropSquare = (_event_over = event.over) === null || _event_over === void 0 ? void 0 : _event_over.id.toString();
        // dropped outside of droppable area (e.g. off board)
        if (!dropSquare) {
            onPieceDrop === null || onPieceDrop === void 0 ? void 0 : onPieceDrop({
                piece: draggingPiece,
                sourceSquare: draggingPiece.position,
                targetSquare: null
            });
            // set as manually dropped piece so that no animation is shown
            setManuallyDroppedPieceAndSquare({
                piece: draggingPiece.pieceType,
                sourceSquare: draggingPiece.position,
                targetSquare: ''
            });
            setDraggingPiece(null);
            return;
        }
        if (event.over) {
            const isDropValid = onPieceDrop === null || onPieceDrop === void 0 ? void 0 : onPieceDrop({
                piece: draggingPiece,
                sourceSquare: draggingPiece.position,
                targetSquare: dropSquare
            });
            // if the drop is valid, set the manually dropped piece and square
            if (isDropValid) {
                setManuallyDroppedPieceAndSquare({
                    piece: draggingPiece.pieceType,
                    sourceSquare: draggingPiece.position,
                    targetSquare: dropSquare
                });
            }
            setDraggingPiece(null);
        }
    }, [
        draggingPiece
    ]);
    const handleDragStart = React.useCallback(// active.id is the id of the piece being dragged
    function handleDragStart({ active }) {
        var _active_data_current;
        // the id is either the position of the piece on the board if it's on the board (e.g. "a1", "b2", etc.), or the type of the piece if it's a spare piece (e.g. "wP", "bN", etc.)
        const isSparePiece = (_active_data_current = active.data.current) === null || _active_data_current === void 0 ? void 0 : _active_data_current.isSparePiece;
        onPieceDrag === null || onPieceDrag === void 0 ? void 0 : onPieceDrag({
            isSparePiece,
            piece: isSparePiece ? {
                pieceType: active.id
            } : currentPosition[active.id],
            square: isSparePiece ? null : active.id
        });
        setDraggingPiece({
            isSparePiece,
            position: active.id,
            pieceType: isSparePiece ? active.id : currentPosition[active.id].pieceType
        });
        return;
    }, [
        currentPosition
    ]);
    const sensors = useSensors(useSensor(PointerSensor, {
        activationConstraint: dragActivationDistance > 0 ? {
            distance: dragActivationDistance
        } : undefined
    }), useSensor(KeyboardSensor), useSensor(TouchSensor), useSensor(MouseSensor));
    // collision detection that first tries pointer-based detection and then falls back to rectangle intersection for keyboards
    function collisionDetection(args) {
        // first try pointer-based collision detection
        const pointerCollisions = pointerWithin(args);
        // if we found collisions with the pointer, return those
        if (pointerCollisions.length > 0) {
            return pointerCollisions;
        }
        // otherwise fall back to rectangle intersection
        return rectIntersection(args);
    }
    return jsxRuntimeExports.jsx(ChessboardContext.Provider, {
        value: {
            // chessboard options
            id,
            pieces,
            boardOrientation,
            chessboardRows,
            chessboardColumns,
            boardStyle,
            squareStyle,
            squareStyles,
            darkSquareStyle,
            lightSquareStyle,
            dropSquareStyle,
            draggingPieceStyle,
            draggingPieceGhostStyle,
            darkSquareNotationStyle,
            lightSquareNotationStyle,
            alphaNotationStyle,
            numericNotationStyle,
            showNotation,
            animationDurationInMs,
            showAnimations,
            allowDragging,
            allowDragOffBoard,
            allowDrawingArrows,
            arrows,
            arrowOptions,
            canDragPiece,
            onMouseOutSquare,
            onMouseOverSquare,
            onPieceClick,
            onSquareClick,
            onSquareRightClick,
            squareRenderer,
            // internal state
            board,
            isWrapped: true,
            draggingPiece,
            currentPosition,
            positionDifferences,
            newArrowStartSquare,
            newArrowOverSquare,
            setNewArrowStartSquare,
            setNewArrowOverSquare: setNewArrowOverSquareWithModifiers,
            internalArrows,
            drawArrow,
            clearArrows
        },
        children: jsxRuntimeExports.jsx(DndContext, {
            autoScroll: allowAutoScroll,
            collisionDetection: collisionDetection,
            onDragStart: handleDragStart,
            onDragEnd: handleDragEnd,
            onDragCancel: handleDragCancel,
            sensors: sensors,
            children: children
        })
    });
}
function Arrows({ boardWidth, boardHeight }) {
    const { id, arrows, arrowOptions, boardOrientation, chessboardColumns, chessboardRows, internalArrows, newArrowStartSquare, newArrowOverSquare } = useChessboardContext();
    if (!boardWidth) {
        return null;
    }
    const currentlyDrawingArrow = newArrowStartSquare && newArrowOverSquare && newArrowStartSquare !== newArrowOverSquare.square ? {
        startSquare: newArrowStartSquare,
        endSquare: newArrowOverSquare.square,
        color: newArrowOverSquare.color
    } : null;
    const arrowsToDraw = currentlyDrawingArrow ? [
        ...arrows,
        ...internalArrows,
        currentlyDrawingArrow
    ] : [
        ...arrows,
        ...internalArrows
    ];
    return jsxRuntimeExports.jsx("svg", {
        width: boardWidth,
        height: boardHeight,
        style: {
            position: 'absolute',
            top: '0',
            left: '0',
            pointerEvents: 'none',
            zIndex: '20'
        },
        children: arrowsToDraw.map((arrow, i)=>{
            const from = getRelativeCoords(boardOrientation, boardWidth, chessboardColumns, chessboardRows, arrow.startSquare);
            const to = getRelativeCoords(boardOrientation, boardWidth, chessboardColumns, chessboardRows, arrow.endSquare);
            // we want to shorten the arrow length so the tip of the arrow is more central to the target square instead of running over the center
            const squareWidth = boardWidth / chessboardColumns;
            let ARROW_LENGTH_REDUCER = squareWidth / arrowOptions.arrowLengthReducerDenominator;
            const isArrowActive = currentlyDrawingArrow && i === arrowsToDraw.length - 1;
            // if there are different arrows targeting the same square make their length a bit shorter
            if (arrowsToDraw.some((restArrow)=>restArrow.startSquare !== arrow.startSquare && restArrow.endSquare === arrow.endSquare) && !isArrowActive) {
                ARROW_LENGTH_REDUCER = squareWidth / arrowOptions.sameTargetArrowLengthReducerDenominator;
            }
            // Calculate the difference in x and y coordinates between start and end points
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            // Calculate the total distance between points using Pythagorean theorem
            // This gives us the length of the arrow if it went from center to center
            const r = Math.hypot(dy, dx);
            // Calculate the new end point for the arrow
            // We subtract ARROW_LENGTH_REDUCER from the total distance to make the arrow
            // stop before reaching the center of the target square
            const end = {
                // Calculate new end x coordinate by:
                // 1. Taking the original x direction (dx)
                // 2. Scaling it by (r - ARROW_LENGTH_REDUCER) / r to shorten it
                // 3. Adding to the starting x coordinate
                x: from.x + dx * (r - ARROW_LENGTH_REDUCER) / r,
                // Same calculation for y coordinate
                y: from.y + dy * (r - ARROW_LENGTH_REDUCER) / r
            };
            return jsxRuntimeExports.jsxs(React.Fragment, {
                children: [
                    jsxRuntimeExports.jsx("marker", {
                        id: `${id}-arrowhead-${i}-${arrow.startSquare}-${arrow.endSquare}`,
                        markerWidth: "2",
                        markerHeight: "2.5",
                        refX: "1.25",
                        refY: "1.25",
                        orient: "auto",
                        children: jsxRuntimeExports.jsx("polygon", {
                            points: "0.3 0, 2 1.25, 0.3 2.5",
                            fill: arrow.color
                        })
                    }),
                    jsxRuntimeExports.jsx("line", {
                        x1: from.x,
                        y1: from.y,
                        x2: end.x,
                        y2: end.y,
                        opacity: isArrowActive ? arrowOptions.activeOpacity : arrowOptions.opacity,
                        stroke: arrow.color,
                        strokeWidth: isArrowActive ? arrowOptions.activeArrowWidthMultiplier * (squareWidth / arrowOptions.arrowWidthDenominator) : squareWidth / arrowOptions.arrowWidthDenominator,
                        markerEnd: `url(#${id}-arrowhead-${i}-${arrow.startSquare}-${arrow.endSquare})`
                    })
                ]
            }, `${id}-arrow-${arrow.startSquare}-${arrow.endSquare}${isArrowActive ? '-active' : ''}`);
        })
    });
}
function Draggable({ children, isSparePiece = false, pieceType, position }) {
    const { allowDragging, canDragPiece } = useChessboardContext();
    const { setNodeRef, attributes, listeners } = useDraggable({
        id: position,
        data: {
            isSparePiece,
            pieceType
        },
        disabled: !allowDragging || canDragPiece && !canDragPiece({
            piece: {
                pieceType
            },
            isSparePiece,
            square: position
        })
    });
    return jsxRuntimeExports.jsx("div", {
        ref: setNodeRef,
        ...attributes,
        ...listeners,
        children: children
    });
}
function Droppable({ children, squareId }) {
    const { isOver, setNodeRef } = useDroppable({
        id: squareId
    });
    return jsxRuntimeExports.jsx("div", {
        ref: setNodeRef,
        children: children({
            isOver
        })
    });
}
const Piece = React.memo(function Piece({ clone, isSparePiece = false, position, pieceType }) {
    const { id, allowDragging, animationDurationInMs, boardOrientation, canDragPiece, draggingPiece, draggingPieceStyle, draggingPieceGhostStyle, pieces, positionDifferences, onPieceClick } = useChessboardContext();
    const [animationStyle, setAnimationStyle] = React.useState({});
    let cursorStyle = clone ? 'grabbing' : 'grab';
    if (!allowDragging || canDragPiece && !canDragPiece({
        piece: {
            pieceType
        },
        isSparePiece,
        square: position
    })) {
        cursorStyle = 'pointer';
    }
    React.useEffect(()=>{
        if (positionDifferences[position]) {
            var _document_querySelector;
            const sourceSquare = position;
            const targetSquare = positionDifferences[position];
            const squareWidth = (_document_querySelector = document.querySelector(`#${id}-square-${sourceSquare}`)) === null || _document_querySelector === void 0 ? void 0 : _document_querySelector.getBoundingClientRect().width;
            if (!squareWidth) {
                throw new Error('Square width not found');
            }
            setAnimationStyle({
                transform: `translate(${(boardOrientation === 'black' ? -1 : 1) * (targetSquare.charCodeAt(0) - sourceSquare.charCodeAt(0)) * squareWidth}px, ${(boardOrientation === 'black' ? -1 : 1) * (Number(sourceSquare[1]) - Number(targetSquare[1])) * squareWidth}px)`,
                transition: `transform ${animationDurationInMs}ms`,
                position: 'relative',
                zIndex: 10
            });
        } else {
            setAnimationStyle({});
        }
    }, [
        positionDifferences
    ]);
    const PieceSvg = pieces[pieceType];
    return jsxRuntimeExports.jsx("div", {
        id: `${id}-piece-${pieceType}-${position}`,
        "data-piece": pieceType,
        style: {
            ...animationStyle,
            ...clone ? {
                ...defaultDraggingPieceStyle,
                ...draggingPieceStyle
            } : {},
            ...!clone && (draggingPiece === null || draggingPiece === void 0 ? void 0 : draggingPiece.position) === position ? {
                ...defaultDraggingPieceGhostStyle,
                ...draggingPieceGhostStyle
            } : {},
            width: '100%',
            height: '100%',
            cursor: cursorStyle,
            touchAction: 'none'
        },
        onClick: ()=>onPieceClick === null || onPieceClick === void 0 ? void 0 : onPieceClick({
                isSparePiece,
                piece: {
                    pieceType
                },
                square: position
            }),
        children: jsxRuntimeExports.jsx(PieceSvg, {})
    });
});
const Square = React.memo(function Square({ children, squareId, isLightSquare, isOver }) {
    var _squareId_match, _squareId_match1;
    const { id, allowDrawingArrows, boardOrientation, chessboardColumns, chessboardRows, currentPosition, squareStyle, squareStyles, darkSquareStyle, lightSquareStyle, dropSquareStyle, darkSquareNotationStyle, lightSquareNotationStyle, alphaNotationStyle, numericNotationStyle, showNotation, onMouseOutSquare, onMouseOverSquare, onSquareClick, onSquareRightClick, squareRenderer, newArrowStartSquare, setNewArrowStartSquare, setNewArrowOverSquare, drawArrow, clearArrows } = useChessboardContext();
    const column = (_squareId_match = squareId.match(/^[a-z]+/)) === null || _squareId_match === void 0 ? void 0 : _squareId_match[0];
    const row = (_squareId_match1 = squareId.match(/\d+$/)) === null || _squareId_match1 === void 0 ? void 0 : _squareId_match1[0];
    var _currentPosition_squareId;
    return jsxRuntimeExports.jsxs("div", {
        id: `${id}-square-${squareId}`,
        style: {
            ...defaultSquareStyle,
            ...squareStyle,
            ...isLightSquare ? {
                ...defaultLightSquareStyle,
                ...lightSquareStyle
            } : {
                ...defaultDarkSquareStyle,
                ...darkSquareStyle
            },
            ...isOver ? {
                ...defaultDropSquareStyle,
                ...dropSquareStyle
            } : {}
        },
        "data-column": column,
        "data-row": row,
        "data-square": squareId,
        onClick: (e)=>{
            if (e.button === 0) {
                var _currentPosition_squareId;
                onSquareClick === null || onSquareClick === void 0 ? void 0 : onSquareClick({
                    piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                    square: squareId
                });
            }
        },
        onTouchEnd: (e)=>{
            // Prevent default to avoid double-firing with onClick on some devices
            e.preventDefault();
            var _currentPosition_squareId;
            onSquareClick === null || onSquareClick === void 0 ? void 0 : onSquareClick({
                piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                square: squareId
            });
        },
        onContextMenu: (e)=>{
            e.preventDefault();
            var _currentPosition_squareId;
            onSquareRightClick === null || onSquareRightClick === void 0 ? void 0 : onSquareRightClick({
                piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                square: squareId
            });
        },
        onMouseDown: (e)=>{
            if (e.button === 0) {
                clearArrows();
            }
            if (e.button === 2 && allowDrawingArrows) {
                setNewArrowStartSquare(squareId);
            }
        },
        onMouseUp: (e)=>{
            if (e.button === 2) {
                if (newArrowStartSquare) {
                    drawArrow(squareId, {
                        shiftKey: e.shiftKey,
                        ctrlKey: e.ctrlKey
                    });
                }
            }
        },
        onMouseOver: (e)=>{
            // right mouse button is held down and we are drawing an arrow
            if (e.buttons === 2 && newArrowStartSquare) {
                setNewArrowOverSquare(squareId, {
                    shiftKey: e.shiftKey,
                    ctrlKey: e.ctrlKey
                });
            }
            var _currentPosition_squareId;
            onMouseOverSquare === null || onMouseOverSquare === void 0 ? void 0 : onMouseOverSquare({
                piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                square: squareId
            });
        },
        onMouseLeave: ()=>{
            var _currentPosition_squareId;
            return onMouseOutSquare === null || onMouseOutSquare === void 0 ? void 0 : onMouseOutSquare({
                piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                square: squareId
            });
        },
        children: [
            showNotation ? jsxRuntimeExports.jsxs("span", {
                style: isLightSquare ? {
                    ...defaultLightSquareNotationStyle,
                    ...lightSquareNotationStyle
                } : {
                    ...defaultDarkSquareNotationStyle,
                    ...darkSquareNotationStyle
                },
                children: [
                    row === (boardOrientation === 'white' ? '1' : chessboardRows.toString()) && jsxRuntimeExports.jsx("span", {
                        style: {
                            ...defaultAlphaNotationStyle,
                            ...alphaNotationStyle
                        },
                        children: column
                    }),
                    column === (boardOrientation === 'white' ? 'a' : columnIndexToChessColumn(0, chessboardColumns, boardOrientation)) && jsxRuntimeExports.jsx("span", {
                        style: {
                            ...defaultNumericNotationStyle,
                            ...numericNotationStyle
                        },
                        children: row
                    })
                ]
            }) : null,
            (squareRenderer === null || squareRenderer === void 0 ? void 0 : squareRenderer({
                piece: (_currentPosition_squareId = currentPosition[squareId]) !== null && _currentPosition_squareId !== void 0 ? _currentPosition_squareId : null,
                square: squareId,
                children
            })) || jsxRuntimeExports.jsx("div", {
                style: {
                    width: '100%',
                    height: '100%',
                    ...squareStyles[squareId]
                },
                children: children
            })
        ]
    });
});
const preventDragOffBoard = (boardId, draggingPiecePosition)=>{
    return ({ transform })=>{
        const boardElement = typeof document !== 'undefined' ? document.getElementById(`${boardId}-board`) : null;
        if (!boardElement) {
            return transform;
        }
        // Get the a1 square to determine square size using data attributes
        const boardRect = boardElement.getBoundingClientRect();
        const a1Square = boardElement.querySelector('[data-column="a"][data-row="1"]');
        if (!a1Square) {
            return transform;
        }
        const squareWidth = a1Square.getBoundingClientRect().width;
        const halfSquareWidth = squareWidth / 2;
        // Extract column and row from position (supports multi-char columns/rows)
        const match = draggingPiecePosition.match(/^([a-zA-Z]+)(\d+)$/);
        if (!match) {
            return transform;
        }
        const [, col, row] = match;
        // Get the starting position of the piece
        const startSquare = boardElement.querySelector(`[data-column="${col}"][data-row="${row}"]`);
        if (!startSquare) {
            return transform;
        }
        const startSquareRect = startSquare.getBoundingClientRect();
        const startX = startSquareRect.left + halfSquareWidth - boardRect.left;
        const startY = startSquareRect.top + halfSquareWidth - boardRect.top;
        // Clamp so the center of the piece can go exactly half a square width outside the board
        const minX = -startX;
        const maxX = boardRect.width - startX;
        const minY = -startY;
        const maxY = boardRect.height - startY;
        const clampedX = Math.min(Math.max(transform.x, minX), maxX);
        const clampedY = Math.min(Math.max(transform.y, minY), maxY);
        return {
            ...transform,
            x: clampedX,
            y: clampedY
        };
    };
};
function Board() {
    var _boardRef_current, _boardRef_current1;
    const { allowDragOffBoard, board, boardStyle, chessboardColumns, currentPosition, draggingPiece, id } = useChessboardContext();
    const boardRef = React.useRef(null);
    const [boardWidth, setBoardWidth] = React.useState((_boardRef_current = boardRef.current) === null || _boardRef_current === void 0 ? void 0 : _boardRef_current.clientWidth);
    const [boardHeight, setBoardHeight] = React.useState((_boardRef_current1 = boardRef.current) === null || _boardRef_current1 === void 0 ? void 0 : _boardRef_current1.clientHeight);
    // if the board dimensions change, update the board width and height
    React.useEffect(()=>{
        if (boardRef.current) {
            const resizeObserver = new ResizeObserver(()=>{
                var _boardRef_current, _boardRef_current1;
                setBoardWidth((_boardRef_current = boardRef.current) === null || _boardRef_current === void 0 ? void 0 : _boardRef_current.clientWidth);
                setBoardHeight((_boardRef_current1 = boardRef.current) === null || _boardRef_current1 === void 0 ? void 0 : _boardRef_current1.clientHeight);
            });
            resizeObserver.observe(boardRef.current);
            return ()=>{
                resizeObserver.disconnect();
            };
        }
    }, [
        boardRef.current
    ]);
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
            jsxRuntimeExports.jsxs("div", {
                id: `${id}-board`,
                ref: boardRef,
                style: {
                    ...defaultBoardStyle(chessboardColumns),
                    ...boardStyle
                },
                children: [
                    board.map((row)=>row.map((square)=>{
                            const piece = currentPosition[square.squareId];
                            return jsxRuntimeExports.jsx(Droppable, {
                                squareId: square.squareId,
                                children: ({ isOver })=>jsxRuntimeExports.jsx(Square, {
                                        isOver: isOver,
                                        ...square,
                                        children: piece ? jsxRuntimeExports.jsx(Draggable, {
                                            isSparePiece: false,
                                            position: square.squareId,
                                            pieceType: piece.pieceType,
                                            children: jsxRuntimeExports.jsx(Piece, {
                                                ...piece,
                                                position: square.squareId
                                            })
                                        }) : null
                                    })
                            }, square.squareId);
                        })),
                    jsxRuntimeExports.jsx(Arrows, {
                        boardWidth: boardWidth,
                        boardHeight: boardHeight
                    })
                ]
            }),
            jsxRuntimeExports.jsx(DragOverlay, {
                dropAnimation: null,
                modifiers: [
                    snapCenterToCursor,
                    ...allowDragOffBoard ? [] : [
                        preventDragOffBoard(id, (draggingPiece === null || draggingPiece === void 0 ? void 0 : draggingPiece.position) || '')
                    ]
                ],
                children: draggingPiece ? jsxRuntimeExports.jsx(Piece, {
                    clone: true,
                    position: draggingPiece.position,
                    pieceType: draggingPiece.pieceType
                }) : null
            })
        ]
    });
}
function Chessboard({ options }) {
    var _useChessboardContext;
    const { isWrapped } = (_useChessboardContext = useChessboardContext()) !== null && _useChessboardContext !== void 0 ? _useChessboardContext : {
        isWrapped: false
    };
    if (isWrapped) {
        return jsxRuntimeExports.jsx(Board, {});
    }
    return jsxRuntimeExports.jsx(ChessboardProvider, {
        options: options,
        children: jsxRuntimeExports.jsx(Board, {})
    });
}
function SparePiece({ pieceType }) {
    return jsxRuntimeExports.jsx(Draggable, {
        isSparePiece: true,
        position: pieceType,
        pieceType: pieceType,
        children: jsxRuntimeExports.jsx(Piece, {
            isSparePiece: true,
            pieceType: pieceType,
            position: pieceType
        })
    });
}
exports.Chessboard = Chessboard;
exports.ChessboardProvider = ChessboardProvider;
exports.SparePiece = SparePiece;
exports.chessColumnToColumnIndex = chessColumnToColumnIndex;
exports.chessRowToRowIndex = chessRowToRowIndex;
exports.columnIndexToChessColumn = columnIndexToChessColumn;
exports.defaultAlphaNotationStyle = defaultAlphaNotationStyle;
exports.defaultArrowOptions = defaultArrowOptions;
exports.defaultBoardStyle = defaultBoardStyle;
exports.defaultDarkSquareNotationStyle = defaultDarkSquareNotationStyle;
exports.defaultDarkSquareStyle = defaultDarkSquareStyle;
exports.defaultDraggingPieceGhostStyle = defaultDraggingPieceGhostStyle;
exports.defaultDraggingPieceStyle = defaultDraggingPieceStyle;
exports.defaultDropSquareStyle = defaultDropSquareStyle;
exports.defaultLightSquareNotationStyle = defaultLightSquareNotationStyle;
exports.defaultLightSquareStyle = defaultLightSquareStyle;
exports.defaultNumericNotationStyle = defaultNumericNotationStyle;
exports.defaultPieces = defaultPieces;
exports.defaultSquareStyle = defaultSquareStyle;
exports.fenStringToPositionObject = fenStringToPositionObject;
exports.generateBoard = generateBoard;
exports.getPositionUpdates = getPositionUpdates;
exports.getRelativeCoords = getRelativeCoords;
exports.rowIndexToChessRow = rowIndexToChessRow;
exports.useChessboardContext = useChessboardContext;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9ub2RlX21vZHVsZXMvcmVhY3QtY2hlc3Nib2FyZC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG52YXIganN4UnVudGltZSA9IHtleHBvcnRzOiB7fX07XG5cbnZhciByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbjtcblxuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb24pIHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbjtcblx0aGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiA9IDE7XG5cdHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG5cdCAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcblx0ZnVuY3Rpb24ganN4UHJvZCh0eXBlLCBjb25maWcsIG1heWJlS2V5KSB7XG5cdCAgdmFyIGtleSA9IG51bGw7XG5cdCAgdm9pZCAwICE9PSBtYXliZUtleSAmJiAoa2V5ID0gXCJcIiArIG1heWJlS2V5KTtcblx0ICB2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KTtcblx0ICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcblx0ICAgIG1heWJlS2V5ID0ge307XG5cdCAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjb25maWcpXG5cdCAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcblx0ICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG5cdCAgY29uZmlnID0gbWF5YmVLZXkucmVmO1xuXHQgIHJldHVybiB7XG5cdCAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXHQgICAgdHlwZTogdHlwZSxcblx0ICAgIGtleToga2V5LFxuXHQgICAgcmVmOiB2b2lkIDAgIT09IGNvbmZpZyA/IGNvbmZpZyA6IG51bGwsXG5cdCAgICBwcm9wczogbWF5YmVLZXlcblx0ICB9O1xuXHR9XG5cdHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcblx0cmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb24uanN4ID0ganN4UHJvZDtcblx0cmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb24uanN4cyA9IGpzeFByb2Q7XG5cdHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbjtcbn1cblxudmFyIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCA9IHt9O1xuXG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50KSByZXR1cm4gcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCA9IDE7XG5cdFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJlxuXHQgIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuXHQgICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gbnVsbDtcblx0ICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG5cdCAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMlxuXHQgICAgICAgICAgPyBudWxsXG5cdCAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG5cdCAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG5cdCAgICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG5cdCAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG5cdCAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuXHQgICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuXHQgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG5cdCAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG5cdCAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG5cdCAgICAgICAgc3dpdGNoIChcblx0ICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcblx0ICAgICAgICAgICAgY29uc29sZS5lcnJvcihcblx0ICAgICAgICAgICAgICBcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCJcblx0ICAgICAgICAgICAgKSxcblx0ICAgICAgICAgIHR5cGUuJCR0eXBlb2YpXG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcblx0ICAgICAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG5cdCAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG5cdCAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuXHQgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuXHQgICAgICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG5cdCAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuXHQgICAgICAgICAgICB0eXBlIHx8XG5cdCAgICAgICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuXHQgICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG5cdCAgICAgICAgICAgIHJldHVybiAoXG5cdCAgICAgICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG5cdCAgICAgICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG5cdCAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuXHQgICAgICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG5cdCAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cblx0ICAgICAgICB9XG5cdCAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG5cdCAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcblx0ICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG5cdCAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpIHtcblx0ICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuXHQgICAgICAgIHZhciBKU0NvbXBpbGVyX3RlbXBfY29uc3QgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZXJyb3I7XG5cdCAgICAgICAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9XG5cdCAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG5cdCAgICAgICAgICAgIFN5bWJvbC50b1N0cmluZ1RhZyAmJlxuXHQgICAgICAgICAgICB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddKSB8fFxuXHQgICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuXHQgICAgICAgICAgXCJPYmplY3RcIjtcblx0ICAgICAgICBKU0NvbXBpbGVyX3RlbXBfY29uc3QuY2FsbChcblx0ICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcblx0ICAgICAgICAgIFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIixcblx0ICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuXHQgICAgICAgICk7XG5cdCAgICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblx0ICAgIGZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuXHQgICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuXHQgICAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcblx0ICAgICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcblx0ICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2Fybjtcblx0ICAgICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuXHQgICAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG5cdCAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcblx0ICAgICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kO1xuXHQgICAgICAgIHZhciBwcm9wcyA9IHtcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG5cdCAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuXHQgICAgICAgICAgaW5mbzogcHJvcHMsXG5cdCAgICAgICAgICBsb2c6IHByb3BzLFxuXHQgICAgICAgICAgd2FybjogcHJvcHMsXG5cdCAgICAgICAgICBlcnJvcjogcHJvcHMsXG5cdCAgICAgICAgICBncm91cDogcHJvcHMsXG5cdCAgICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG5cdCAgICAgICAgICBncm91cEVuZDogcHJvcHNcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgICBkaXNhYmxlZERlcHRoKys7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG5cdCAgICAgIGRpc2FibGVkRGVwdGgtLTtcblx0ICAgICAgaWYgKDAgPT09IGRpc2FibGVkRGVwdGgpIHtcblx0ICAgICAgICB2YXIgcHJvcHMgPSB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfTtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG5cdCAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZMb2cgfSksXG5cdCAgICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2SW5mbyB9KSxcblx0ICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuXHQgICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZFcnJvciB9KSxcblx0ICAgICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXAgfSksXG5cdCAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuXHQgICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cEVuZCB9KVxuXHQgICAgICAgIH0pO1xuXHQgICAgICB9XG5cdCAgICAgIDAgPiBkaXNhYmxlZERlcHRoICYmXG5cdCAgICAgICAgY29uc29sZS5lcnJvcihcblx0ICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG5cdCAgICAgICAgKTtcblx0ICAgIH1cblx0ICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcblx0ICAgICAgaWYgKHZvaWQgMCA9PT0gcHJlZml4KVxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuXHQgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG5cdCAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG5cdCAgICAgICAgICBzdWZmaXggPVxuXHQgICAgICAgICAgICAtMSA8IHguc3RhY2suaW5kZXhPZihcIlxcbiAgICBhdFwiKVxuXHQgICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG5cdCAgICAgICAgICAgICAgOiAtMSA8IHguc3RhY2suaW5kZXhPZihcIkBcIilcblx0ICAgICAgICAgICAgICAgID8gXCJAdW5rbm93bjowOjBcIlxuXHQgICAgICAgICAgICAgICAgOiBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgcmV0dXJuIFwiXFxuXCIgKyBwcmVmaXggKyBuYW1lICsgc3VmZml4O1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG5cdCAgICAgIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG5cdCAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblx0ICAgICAgaWYgKHZvaWQgMCAhPT0gZnJhbWUpIHJldHVybiBmcmFtZTtcblx0ICAgICAgcmVlbnRyeSA9IHRydWU7XG5cdCAgICAgIGZyYW1lID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG5cdCAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuXHQgICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcblx0ICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcblx0ICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IG51bGw7XG5cdCAgICAgIGRpc2FibGVMb2dzKCk7XG5cdCAgICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuXHQgICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcblx0ICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcblx0ICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG5cdCAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG5cdCAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcblx0ICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcblx0ICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuXHQgICAgICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcblx0ICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuXHQgICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG5cdCAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuXHQgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcblx0ICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcblx0ICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcblx0ICAgICAgICAgIFwibmFtZVwiXG5cdCAgICAgICAgKTtcblx0ICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcblx0ICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcblx0ICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcblx0ICAgICAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuXHQgICAgICAgICAgICBcIm5hbWVcIixcblx0ICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG5cdCAgICAgICAgICApO1xuXHQgICAgICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPVxuXHQgICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcblx0ICAgICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuXHQgICAgICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuXHQgICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcblx0ICAgICAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuXHQgICAgICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG5cdCAgICAgICAgICBmb3IgKFxuXHQgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBuYW1lUHJvcERlc2NyaXB0b3IgPSAwO1xuXHQgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiZcblx0ICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG5cdCAgICAgICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuXHQgICAgICAgICAgICApO1xuXG5cdCAgICAgICAgICApXG5cdCAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuXHQgICAgICAgICAgZm9yIChcblx0ICAgICAgICAgICAgO1xuXHQgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPCBjb250cm9sTGluZXMubGVuZ3RoICYmXG5cdCAgICAgICAgICAgICFjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXS5pbmNsdWRlcyhcblx0ICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgIClcblx0ICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG5cdCAgICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG5cdCAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuXHQgICAgICAgICAgKVxuXHQgICAgICAgICAgICBmb3IgKFxuXHQgICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG5cdCAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblx0ICAgICAgICAgICAgICAxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuXHQgICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG5cdCAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cblx0ICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdO1xuXG5cdCAgICAgICAgICAgIClcblx0ICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLTtcblx0ICAgICAgICAgIGZvciAoXG5cdCAgICAgICAgICAgIDtcblx0ICAgICAgICAgICAgMSA8PSBuYW1lUHJvcERlc2NyaXB0b3IgJiYgMCA8PSBfUnVuSW5Sb290RnJhbWUkRGV0ZXI7XG5cdCAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tLCBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLVxuXHQgICAgICAgICAgKVxuXHQgICAgICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgICAgc2FtcGxlTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSAhPT1cblx0ICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuXHQgICAgICAgICAgICApIHtcblx0ICAgICAgICAgICAgICBpZiAoMSAhPT0gbmFtZVByb3BEZXNjcmlwdG9yIHx8IDEgIT09IF9SdW5JblJvb3RGcmFtZSREZXRlcikge1xuXHQgICAgICAgICAgICAgICAgZG9cblx0ICAgICAgICAgICAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICAgICAgICAgIChuYW1lUHJvcERlc2NyaXB0b3ItLSxcblx0ICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcblx0ICAgICAgICAgICAgICAgICAgICAwID4gX1J1bkluUm9vdEZyYW1lJERldGVyIHx8XG5cdCAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcblx0ICAgICAgICAgICAgICAgICAgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9XG5cdCAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcblx0ICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0ucmVwbGFjZShcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCIgYXQgbmV3IFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuXHQgICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcblx0ICAgICAgICAgICAgICAgICAgICAgIChfZnJhbWUgPSBfZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZm4gJiZcblx0ICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG5cdCAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG5cdCAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICB9IGZpbmFsbHkge1xuXHQgICAgICAgIChyZWVudHJ5ID0gZmFsc2UpLFxuXHQgICAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXIpLFxuXHQgICAgICAgICAgcmVlbmFibGVMb2dzKCksXG5cdCAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG5cdCAgICAgIH1cblx0ICAgICAgc2FtcGxlTGluZXMgPSAoc2FtcGxlTGluZXMgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuXHQgICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG5cdCAgICAgICAgOiBcIlwiO1xuXHQgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJiBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc2FtcGxlTGluZXMpO1xuXHQgICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSkge1xuXHQgICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcblx0ICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpIHtcblx0ICAgICAgICB2YXIgcHJvdG90eXBlID0gdHlwZS5wcm90b3R5cGU7XG5cdCAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG5cdCAgICAgICAgICB0eXBlLFxuXHQgICAgICAgICAgISghcHJvdG90eXBlIHx8ICFwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudClcblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuXHQgICAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG5cdCAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZVwiKTtcblx0ICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcblx0ICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcblx0ICAgICAgfVxuXHQgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG5cdCAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG5cdCAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG5cdCAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsIGZhbHNlKSksIHR5cGU7XG5cdCAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUpO1xuXHQgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG5cdCAgICAgICAgICAgIHByb3RvdHlwZSA9IHR5cGUuX3BheWxvYWQ7XG5cdCAgICAgICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZShwcm90b3R5cGUpKTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cblx0ICAgICAgICB9XG5cdCAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG5cdCAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcblx0ICAgICAgcmV0dXJuIG51bGwgPT09IGRpc3BhdGNoZXIgPyBudWxsIDogZGlzcGF0Y2hlci5nZXRPd25lcigpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG5cdCAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcblx0ICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcblx0ICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcblx0ICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuXHQgICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG5cdCAgICAgICAgICAoKHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZSksXG5cdCAgICAgICAgICBjb25zb2xlLmVycm9yKFxuXHQgICAgICAgICAgICBcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zcGVjaWFsLXByb3BzKVwiLFxuXHQgICAgICAgICAgICBkaXNwbGF5TmFtZVxuXHQgICAgICAgICAgKSk7XG5cdCAgICAgIH1cblx0ICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCBcImtleVwiLCB7XG5cdCAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmcoKSB7XG5cdCAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG5cdCAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcblx0ICAgICAgICAoKGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gPSB0cnVlKSxcblx0ICAgICAgICBjb25zb2xlLmVycm9yKFxuXHQgICAgICAgICAgXCJBY2Nlc3NpbmcgZWxlbWVudC5yZWYgd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuIHJlZiBpcyBub3cgYSByZWd1bGFyIHByb3AuIEl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBKU1ggRWxlbWVudCB0eXBlIGluIGEgZnV0dXJlIHJlbGVhc2UuXCJcblx0ICAgICAgICApKTtcblx0ICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuXHQgICAgICByZXR1cm4gdm9pZCAwICE9PSBjb21wb25lbnROYW1lID8gY29tcG9uZW50TmFtZSA6IG51bGw7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuXHQgICAgICBzZWxmID0gcHJvcHMucmVmO1xuXHQgICAgICB0eXBlID0ge1xuXHQgICAgICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cdCAgICAgICAgdHlwZTogdHlwZSxcblx0ICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICBwcm9wczogcHJvcHMsXG5cdCAgICAgICAgX293bmVyOiBvd25lclxuXHQgICAgICB9O1xuXHQgICAgICBudWxsICE9PSAodm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwpXG5cdCAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuXHQgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICAgICAgZ2V0OiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZ1xuXHQgICAgICAgICAgfSlcblx0ICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6IGZhbHNlLCB2YWx1ZTogbnVsbCB9KTtcblx0ICAgICAgdHlwZS5fc3RvcmUgPSB7fTtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICB2YWx1ZTogMFxuXHQgICAgICB9KTtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG5cdCAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblx0ICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICB2YWx1ZTogbnVsbFxuXHQgICAgICB9KTtcblx0ICAgICAgT2JqZWN0LmZyZWV6ZSAmJiAoT2JqZWN0LmZyZWV6ZSh0eXBlLnByb3BzKSwgT2JqZWN0LmZyZWV6ZSh0eXBlKSk7XG5cdCAgICAgIHJldHVybiB0eXBlO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24ganN4REVWSW1wbChcblx0ICAgICAgdHlwZSxcblx0ICAgICAgY29uZmlnLFxuXHQgICAgICBtYXliZUtleSxcblx0ICAgICAgaXNTdGF0aWNDaGlsZHJlbixcblx0ICAgICAgc291cmNlLFxuXHQgICAgICBzZWxmXG5cdCAgICApIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlIHx8XG5cdCAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSB8fFxuXHQgICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcblx0ICAgICAgICB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8XG5cdCAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fFxuXHQgICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcblx0ICAgICAgICB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHxcblx0ICAgICAgICB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fFxuXHQgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuXHQgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuXHQgICAgICAgICAgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fFxuXHQgICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcblx0ICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8XG5cdCAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlNVTUVSX1RZUEUgfHxcblx0ICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuXHQgICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHxcblx0ICAgICAgICAgICAgdm9pZCAwICE9PSB0eXBlLmdldE1vZHVsZUlkKSlcblx0ICAgICAgKSB7XG5cdCAgICAgICAgdmFyIGNoaWxkcmVuID0gY29uZmlnLmNoaWxkcmVuO1xuXHQgICAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuXHQgICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG5cdCAgICAgICAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcblx0ICAgICAgICAgICAgICBmb3IgKFxuXHQgICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG5cdCAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuIDwgY2hpbGRyZW4ubGVuZ3RoO1xuXHQgICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG5cdCAgICAgICAgICAgICAgKVxuXHQgICAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baXNTdGF0aWNDaGlsZHJlbl0sIHR5cGUpO1xuXHQgICAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG5cdCAgICAgICAgICAgIH0gZWxzZVxuXHQgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG5cdCAgICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuXHQgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICBlbHNlIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgdm9pZCAwID09PSB0eXBlIHx8XG5cdCAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcblx0ICAgICAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuXHQgICAgICAgICAgICAwID09PSBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGgpXG5cdCAgICAgICAgKVxuXHQgICAgICAgICAgY2hpbGRyZW4gKz1cblx0ICAgICAgICAgICAgXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuXHQgICAgICAgIG51bGwgPT09IHR5cGVcblx0ICAgICAgICAgID8gKGlzU3RhdGljQ2hpbGRyZW4gPSBcIm51bGxcIilcblx0ICAgICAgICAgIDogaXNBcnJheUltcGwodHlwZSlcblx0ICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcblx0ICAgICAgICAgICAgOiB2b2lkIDAgIT09IHR5cGUgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG5cdCAgICAgICAgICAgICAgPyAoKGlzU3RhdGljQ2hpbGRyZW4gPVxuXHQgICAgICAgICAgICAgICAgICBcIjxcIiArXG5cdCAgICAgICAgICAgICAgICAgIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIlVua25vd25cIikgK1xuXHQgICAgICAgICAgICAgICAgICBcIiAvPlwiKSxcblx0ICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG5cdCAgICAgICAgICAgICAgICAgIFwiIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/XCIpKVxuXHQgICAgICAgICAgICAgIDogKGlzU3RhdGljQ2hpbGRyZW4gPSB0eXBlb2YgdHlwZSk7XG5cdCAgICAgICAgY29uc29sZS5lcnJvcihcblx0ICAgICAgICAgIFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsXG5cdCAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuXHQgICAgICAgICAgY2hpbGRyZW5cblx0ICAgICAgICApO1xuXHQgICAgICB9XG5cdCAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcblx0ICAgICAgICBjaGlsZHJlbiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG5cdCAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cblx0ICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuXHQgICAgICAgICAgICA/IFwie2tleTogc29tZUtleSwgXCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIlxuXHQgICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcblx0ICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuXHQgICAgICAgICAgKChrZXlzID1cblx0ICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG5cdCAgICAgICAgICBjb25zb2xlLmVycm9yKFxuXHQgICAgICAgICAgICAnQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyB7Li4ucHJvcHN9IC8+XFxuUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuICBsZXQgcHJvcHMgPSAlcztcXG4gIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLFxuXHQgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuXHQgICAgICAgICAgICBjaGlsZHJlbixcblx0ICAgICAgICAgICAga2V5cyxcblx0ICAgICAgICAgICAgY2hpbGRyZW5cblx0ICAgICAgICAgICksXG5cdCAgICAgICAgICAoZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gPSB0cnVlKSk7XG5cdCAgICAgIH1cblx0ICAgICAgY2hpbGRyZW4gPSBudWxsO1xuXHQgICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG5cdCAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcblx0ICAgICAgaGFzVmFsaWRLZXkoY29uZmlnKSAmJlxuXHQgICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuXHQgICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcblx0ICAgICAgICBtYXliZUtleSA9IHt9O1xuXHQgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcblx0ICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcblx0ICAgICAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuXHQgICAgICBjaGlsZHJlbiAmJlxuXHQgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuXHQgICAgICAgICAgbWF5YmVLZXksXG5cdCAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG5cdCAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcblx0ICAgICAgICAgICAgOiB0eXBlXG5cdCAgICAgICAgKTtcblx0ICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG5cdCAgICAgIGlmIChcblx0ICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygbm9kZSAmJlxuXHQgICAgICAgIG5vZGUgJiZcblx0ICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG5cdCAgICAgIClcblx0ICAgICAgICBpZiAoaXNBcnJheUltcGwobm9kZSkpXG5cdCAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblx0ICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQoY2hpbGQpICYmIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKVxuXHQgICAgICAgICAgbm9kZS5fc3RvcmUgJiYgKG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IDEpO1xuXHQgICAgICAgIGVsc2UgaWYgKFxuXHQgICAgICAgICAgKG51bGwgPT09IG5vZGUgfHwgXCJvYmplY3RcIiAhPT0gdHlwZW9mIG5vZGVcblx0ICAgICAgICAgICAgPyAoaSA9IG51bGwpXG5cdCAgICAgICAgICAgIDogKChpID1cblx0ICAgICAgICAgICAgICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbm9kZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuXHQgICAgICAgICAgICAgICAgbm9kZVtcIkBAaXRlcmF0b3JcIl0pLFxuXHQgICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG5cdCAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpICYmXG5cdCAgICAgICAgICAgIGkgIT09IG5vZGUuZW50cmllcyAmJlxuXHQgICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcblx0ICAgICAgICApXG5cdCAgICAgICAgICBmb3IgKDsgIShub2RlID0gaS5uZXh0KCkpLmRvbmU7IClcblx0ICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcblx0ICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KG5vZGUudmFsdWUsIHBhcmVudFR5cGUpO1xuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG5cdCAgICAgIHJldHVybiAoXG5cdCAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9iamVjdCAmJlxuXHQgICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuXHQgICAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG5cdCAgICAgICk7XG5cdCAgICB9XG5cdCAgICBmdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcblx0ICAgICAgaWYgKFxuXHQgICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG5cdCAgICAgICAgIWVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCAmJlxuXHQgICAgICAgIG51bGwgPT0gZWxlbWVudC5rZXkgJiZcblx0ICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuXHQgICAgICAgIChwYXJlbnRUeXBlID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSksXG5cdCAgICAgICAgIW93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSlcblx0ICAgICAgKSB7XG5cdCAgICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdID0gdHJ1ZTtcblx0ICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG5cdCAgICAgICAgZWxlbWVudCAmJlxuXHQgICAgICAgICAgbnVsbCAhPSBlbGVtZW50Ll9vd25lciAmJlxuXHQgICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcblx0ICAgICAgICAgICgoY2hpbGRPd25lciA9IG51bGwpLFxuXHQgICAgICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIGVsZW1lbnQuX293bmVyLnRhZ1xuXHQgICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuXHQgICAgICAgICAgICA6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlbGVtZW50Ll9vd25lci5uYW1lICYmXG5cdCAgICAgICAgICAgICAgKGNoaWxkT3duZXIgPSBlbGVtZW50Ll9vd25lci5uYW1lKSxcblx0ICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcblx0ICAgICAgICB2YXIgcHJldkdldEN1cnJlbnRTdGFjayA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaztcblx0ICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcblx0ICAgICAgICAgIHByZXZHZXRDdXJyZW50U3RhY2sgJiYgKHN0YWNrICs9IHByZXZHZXRDdXJyZW50U3RhY2soKSB8fCBcIlwiKTtcblx0ICAgICAgICAgIHJldHVybiBzdGFjaztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGNvbnNvbGUuZXJyb3IoXG5cdCAgICAgICAgICAnRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsXG5cdCAgICAgICAgICBwYXJlbnRUeXBlLFxuXHQgICAgICAgICAgY2hpbGRPd25lclxuXHQgICAgICAgICk7XG5cdCAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG5cdCAgICAgIHZhciBpbmZvID0gXCJcIixcblx0ICAgICAgICBvd25lciA9IGdldE93bmVyKCk7XG5cdCAgICAgIG93bmVyICYmXG5cdCAgICAgICAgKG93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKG93bmVyLnR5cGUpKSAmJlxuXHQgICAgICAgIChpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgXCIgKyBvd25lciArIFwiYC5cIik7XG5cdCAgICAgIGluZm8gfHxcblx0ICAgICAgICAoKHBhcmVudFR5cGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSkpICYmXG5cdCAgICAgICAgICAoaW5mbyA9XG5cdCAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG5cdCAgICAgIHJldHVybiBpbmZvO1xuXHQgICAgfVxuXHQgICAgdmFyIFJlYWN0JDEgPSBSZWFjdCxcblx0ICAgICAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50XCIpLFxuXHQgICAgICBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksXG5cdCAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG5cdCAgICAgIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksXG5cdCAgICAgIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG5cdCAgICB2YXIgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcblx0ICAgICAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG5cdCAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG5cdCAgICAgIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG5cdCAgICAgIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuXHQgICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcblx0ICAgICAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksXG5cdCAgICAgIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSxcblx0ICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuXHQgICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcblx0ICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuXHQgICAgICAgIFJlYWN0JDEuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFLFxuXHQgICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG5cdCAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG5cdCAgICAgIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuXHQgICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG5cdCAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuXHQgICAgICBwcmV2TG9nLFxuXHQgICAgICBwcmV2SW5mbyxcblx0ICAgICAgcHJldldhcm4sXG5cdCAgICAgIHByZXZFcnJvcixcblx0ICAgICAgcHJldkdyb3VwLFxuXHQgICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG5cdCAgICAgIHByZXZHcm91cEVuZDtcblx0ICAgIGRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5cdCAgICB2YXIgcHJlZml4LFxuXHQgICAgICBzdWZmaXgsXG5cdCAgICAgIHJlZW50cnkgPSBmYWxzZTtcblx0ICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IChcblx0ICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXBcblx0ICAgICkoKTtcblx0ICAgIHZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG5cdCAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xuXHQgICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcblx0ICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fSxcblx0ICAgICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cdCAgICByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuXHQgICAgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50LmpzeCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcblx0ICAgICAgcmV0dXJuIGpzeERFVkltcGwodHlwZSwgY29uZmlnLCBtYXliZUtleSwgZmFsc2UsIHNvdXJjZSwgc2VsZik7XG5cdCAgICB9O1xuXHQgICAgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50LmpzeHMgPSBmdW5jdGlvbiAodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG5cdCAgICAgIHJldHVybiBqc3hERVZJbXBsKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHRydWUsIHNvdXJjZSwgc2VsZik7XG5cdCAgICB9O1xuXHQgIH0pKCk7XG5cdHJldHVybiByZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQ7XG59XG5cbnZhciBoYXNSZXF1aXJlZEpzeFJ1bnRpbWU7XG5cbmZ1bmN0aW9uIHJlcXVpcmVKc3hSdW50aW1lICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkSnN4UnVudGltZSkgcmV0dXJuIGpzeFJ1bnRpbWUuZXhwb3J0cztcblx0aGFzUmVxdWlyZWRKc3hSdW50aW1lID0gMTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuXHQgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbigpO1xuXHR9IGVsc2Uge1xuXHQgIGpzeFJ1bnRpbWUuZXhwb3J0cyA9IHJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQoKTtcblx0fVxuXHRyZXR1cm4ganN4UnVudGltZS5leHBvcnRzO1xufVxuXG52YXIganN4UnVudGltZUV4cG9ydHMgPSByZXF1aXJlSnN4UnVudGltZSgpO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYXN0ZXIvcGFja2FnZXMvc2hhcmVkL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzXG5jb25zdCBjYW5Vc2VET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpc1dpbmRvdyhlbGVtZW50KSB7XG4gIGNvbnN0IGVsZW1lbnRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudCk7XG4gIHJldHVybiBlbGVtZW50U3RyaW5nID09PSAnW29iamVjdCBXaW5kb3ddJyB8fCAvLyBJbiBFbGVjdHJvbiBjb250ZXh0IHRoZSBXaW5kb3cgb2JqZWN0IHNlcmlhbGl6ZXMgdG8gW29iamVjdCBnbG9iYWxdXG4gIGVsZW1lbnRTdHJpbmcgPT09ICdbb2JqZWN0IGdsb2JhbF0nO1xufVxuXG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICByZXR1cm4gJ25vZGVUeXBlJyBpbiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3codGFyZ2V0KSB7XG4gIHZhciBfdGFyZ2V0JG93bmVyRG9jdW1lbnQsIF90YXJnZXQkb3duZXJEb2N1bWVudDI7XG5cbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKGlzV2luZG93KHRhcmdldCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgaWYgKCFpc05vZGUodGFyZ2V0KSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gKF90YXJnZXQkb3duZXJEb2N1bWVudCA9IChfdGFyZ2V0JG93bmVyRG9jdW1lbnQyID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGFyZ2V0JG93bmVyRG9jdW1lbnQyLmRlZmF1bHRWaWV3KSAhPSBudWxsID8gX3RhcmdldCRvd25lckRvY3VtZW50IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBpc0RvY3VtZW50KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIERvY3VtZW50XG4gIH0gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICBpZiAoaXNXaW5kb3cobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTVkdFbGVtZW50KG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBnZXRXaW5kb3cobm9kZSkuU1ZHRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpIHtcbiAgaWYgKCF0YXJnZXQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoaXNXaW5kb3codGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQuZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZSh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50O1xuICB9XG5cbiAgaWYgKGlzRG9jdW1lbnQodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudCh0YXJnZXQpIHx8IGlzU1ZHRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldC5vd25lckRvY3VtZW50O1xuICB9XG5cbiAgcmV0dXJuIGRvY3VtZW50O1xufVxuXG4vKipcclxuICogQSBob29rIHRoYXQgcmVzb2x2ZXMgdG8gdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgYW5kIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgY2xpZW50XHJcbiAqIEBwYXJhbSBjYWxsYmFjayB7ZnVuY3Rpb259IENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBkZXBlbmRlbmNpZXMgb2YgdGhlIGhvb2sgY2hhbmdlXHJcbiAqL1xuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gY2FuVXNlRE9NID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG5mdW5jdGlvbiB1c2VFdmVudChoYW5kbGVyKSB7XG4gIGNvbnN0IGhhbmRsZXJSZWYgPSBSZWFjdC51c2VSZWYoaGFuZGxlcik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IGhhbmRsZXI7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFuZGxlclJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVyUmVmLmN1cnJlbnQoLi4uYXJncyk7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gdXNlSW50ZXJ2YWwoKSB7XG4gIGNvbnN0IGludGVydmFsUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXQgPSBSZWFjdC51c2VDYWxsYmFjaygobGlzdGVuZXIsIGR1cmF0aW9uKSA9PiB7XG4gICAgaW50ZXJ2YWxSZWYuY3VycmVudCA9IHNldEludGVydmFsKGxpc3RlbmVyLCBkdXJhdGlvbik7XG4gIH0sIFtdKTtcbiAgY29uc3QgY2xlYXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGludGVydmFsUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxSZWYuY3VycmVudCk7XG4gICAgICBpbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIFtzZXQsIGNsZWFyXTtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0VmFsdWUodmFsdWUsIGRlcGVuZGVuY2llcykge1xuICBpZiAoZGVwZW5kZW5jaWVzID09PSB2b2lkIDApIHtcbiAgICBkZXBlbmRlbmNpZXMgPSBbdmFsdWVdO1xuICB9XG5cbiAgY29uc3QgdmFsdWVSZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAodmFsdWVSZWYuY3VycmVudCAhPT0gdmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICB9XG4gIH0sIGRlcGVuZGVuY2llcyk7XG4gIHJldHVybiB2YWx1ZVJlZjtcbn1cblxuZnVuY3Rpb24gdXNlTGF6eU1lbW8oY2FsbGJhY2ssIGRlcGVuZGVuY2llcykge1xuICBjb25zdCB2YWx1ZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBjYWxsYmFjayh2YWx1ZVJlZi5jdXJyZW50KTtcbiAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV3VmFsdWU7XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFsuLi5kZXBlbmRlbmNpZXNdKTtcbn1cblxuZnVuY3Rpb24gdXNlTm9kZVJlZihvbkNoYW5nZSkge1xuICBjb25zdCBvbkNoYW5nZUhhbmRsZXIgPSB1c2VFdmVudChvbkNoYW5nZSk7XG4gIGNvbnN0IG5vZGUgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHNldE5vZGVSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhlbGVtZW50ID0+IHtcbiAgICBpZiAoZWxlbWVudCAhPT0gbm9kZS5jdXJyZW50KSB7XG4gICAgICBvbkNoYW5nZUhhbmRsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2hhbmdlSGFuZGxlcihlbGVtZW50LCBub2RlLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIG5vZGUuY3VycmVudCA9IGVsZW1lbnQ7XG4gIH0sIC8vZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gIFtdKTtcbiAgcmV0dXJuIFtub2RlLCBzZXROb2RlUmVmXTtcbn1cblxuZnVuY3Rpb24gdXNlUHJldmlvdXModmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSwgW3ZhbHVlXSk7XG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxubGV0IGlkcyA9IHt9O1xuZnVuY3Rpb24gdXNlVW5pcXVlSWQocHJlZml4LCB2YWx1ZSkge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3QgaWQgPSBpZHNbcHJlZml4XSA9PSBudWxsID8gMCA6IGlkc1twcmVmaXhdICsgMTtcbiAgICBpZHNbcHJlZml4XSA9IGlkO1xuICAgIHJldHVybiBwcmVmaXggKyBcIi1cIiArIGlkO1xuICB9LCBbcHJlZml4LCB2YWx1ZV0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBZGp1c3RtZW50Rm4obW9kaWZpZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYWRqdXN0bWVudHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYWRqdXN0bWVudHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhZGp1c3RtZW50cy5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBhZGp1c3RtZW50KSA9PiB7XG4gICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoYWRqdXN0bWVudCk7XG5cbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVBZGp1c3RtZW50XSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYWNjdW11bGF0b3Jba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yW2tleV0gPSB2YWx1ZSArIG1vZGlmaWVyICogdmFsdWVBZGp1c3RtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICB9LCB7IC4uLm9iamVjdFxuICAgIH0pO1xuICB9O1xufVxuXG5jb25zdCBhZGQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQWRqdXN0bWVudEZuKDEpO1xuY29uc3Qgc3VidHJhY3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlQWRqdXN0bWVudEZuKC0xKTtcblxuZnVuY3Rpb24gaGFzVmlld3BvcnRSZWxhdGl2ZUNvb3JkaW5hdGVzKGV2ZW50KSB7XG4gIHJldHVybiAnY2xpZW50WCcgaW4gZXZlbnQgJiYgJ2NsaWVudFknIGluIGV2ZW50O1xufVxuXG5mdW5jdGlvbiBpc0tleWJvYXJkRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFldmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBLZXlib2FyZEV2ZW50XG4gIH0gPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KTtcbiAgcmV0dXJuIEtleWJvYXJkRXZlbnQgJiYgZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50O1xufVxuXG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFldmVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBUb3VjaEV2ZW50XG4gIH0gPSBnZXRXaW5kb3coZXZlbnQudGFyZ2V0KTtcbiAgcmV0dXJuIFRvdWNoRXZlbnQgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50O1xufVxuXG4vKipcclxuICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCB4IGFuZCB5IGNvb3JkaW5hdGVzIGZvciBtb3VzZSBhbmQgdG91Y2ggZXZlbnRzLlxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCkge1xuICBpZiAoaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xuICAgIGlmIChldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFg6IHgsXG4gICAgICAgIGNsaWVudFk6IHlcbiAgICAgIH0gPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjbGllbnRYOiB4LFxuICAgICAgICBjbGllbnRZOiB5XG4gICAgICB9ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMoZXZlbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5jb25zdCBDU1MgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIFRyYW5zbGF0ZToge1xuICAgIHRvU3RyaW5nKHRyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0cmFuc2Zvcm07XG4gICAgICByZXR1cm4gXCJ0cmFuc2xhdGUzZChcIiArICh4ID8gTWF0aC5yb3VuZCh4KSA6IDApICsgXCJweCwgXCIgKyAoeSA/IE1hdGgucm91bmQoeSkgOiAwKSArIFwicHgsIDApXCI7XG4gICAgfVxuXG4gIH0sXG4gIFNjYWxlOiB7XG4gICAgdG9TdHJpbmcodHJhbnNmb3JtKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVlcbiAgICAgIH0gPSB0cmFuc2Zvcm07XG4gICAgICByZXR1cm4gXCJzY2FsZVgoXCIgKyBzY2FsZVggKyBcIikgc2NhbGVZKFwiICsgc2NhbGVZICsgXCIpXCI7XG4gICAgfVxuXG4gIH0sXG4gIFRyYW5zZm9ybToge1xuICAgIHRvU3RyaW5nKHRyYW5zZm9ybSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW0NTUy5UcmFuc2xhdGUudG9TdHJpbmcodHJhbnNmb3JtKSwgQ1NTLlNjYWxlLnRvU3RyaW5nKHRyYW5zZm9ybSldLmpvaW4oJyAnKTtcbiAgICB9XG5cbiAgfSxcbiAgVHJhbnNpdGlvbjoge1xuICAgIHRvU3RyaW5nKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBwcm9wZXJ0eSArIFwiIFwiICsgZHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nO1xuICAgIH1cblxuICB9XG59KTtcblxuY29uc3QgU0VMRUNUT1IgPSAnYSxmcmFtZSxpZnJhbWUsaW5wdXQ6bm90KFt0eXBlPWhpZGRlbl0pOm5vdCg6ZGlzYWJsZWQpLHNlbGVjdDpub3QoOmRpc2FibGVkKSx0ZXh0YXJlYTpub3QoOmRpc2FibGVkKSxidXR0b246bm90KDpkaXNhYmxlZCksKlt0YWJpbmRleF0nO1xuZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlTm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm1hdGNoZXMoU0VMRUNUT1IpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SKTtcbn1cblxuY29uc3QgaGlkZGVuU3R5bGVzID0ge1xuICBkaXNwbGF5OiAnbm9uZSdcbn07XG5mdW5jdGlvbiBIaWRkZW5UZXh0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBpZCxcbiAgICB2YWx1ZVxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGlkOiBpZCxcbiAgICBzdHlsZTogaGlkZGVuU3R5bGVzXG4gIH0sIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gTGl2ZVJlZ2lvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgaWQsXG4gICAgYW5ub3VuY2VtZW50LFxuICAgIGFyaWFMaXZlVHlwZSA9IFwiYXNzZXJ0aXZlXCJcbiAgfSA9IF9yZWY7XG4gIC8vIEhpZGUgZWxlbWVudCB2aXN1YWxseSBidXQga2VlcCBpdCByZWFkYWJsZSBieSBzY3JlZW4gcmVhZGVyc1xuICBjb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICB3aWR0aDogMSxcbiAgICBoZWlnaHQ6IDEsXG4gICAgbWFyZ2luOiAtMSxcbiAgICBib3JkZXI6IDAsXG4gICAgcGFkZGluZzogMCxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgY2xpcDogJ3JlY3QoMCAwIDAgMCknLFxuICAgIGNsaXBQYXRoOiAnaW5zZXQoMTAwJSknLFxuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBpZDogaWQsXG4gICAgc3R5bGU6IHZpc3VhbGx5SGlkZGVuLFxuICAgIHJvbGU6IFwic3RhdHVzXCIsXG4gICAgXCJhcmlhLWxpdmVcIjogYXJpYUxpdmVUeXBlLFxuICAgIFwiYXJpYS1hdG9taWNcIjogdHJ1ZVxuICB9LCBhbm5vdW5jZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB1c2VBbm5vdW5jZW1lbnQoKSB7XG4gIGNvbnN0IFthbm5vdW5jZW1lbnQsIHNldEFubm91bmNlbWVudF0gPSBSZWFjdC51c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IGFubm91bmNlID0gUmVhY3QudXNlQ2FsbGJhY2sodmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXRBbm5vdW5jZW1lbnQodmFsdWUpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGFubm91bmNlLFxuICAgIGFubm91bmNlbWVudFxuICB9O1xufVxuXG5jb25zdCBEbmRNb25pdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiB1c2VEbmRNb25pdG9yKGxpc3RlbmVyKSB7XG4gIGNvbnN0IHJlZ2lzdGVyTGlzdGVuZXIgPSBSZWFjdC51c2VDb250ZXh0KERuZE1vbml0b3JDb250ZXh0KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJlZ2lzdGVyTGlzdGVuZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXNlRG5kTW9uaXRvciBtdXN0IGJlIHVzZWQgd2l0aGluIGEgY2hpbGRyZW4gb2YgPERuZENvbnRleHQ+Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5zdWJzY3JpYmUgPSByZWdpc3Rlckxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH0sIFtsaXN0ZW5lciwgcmVnaXN0ZXJMaXN0ZW5lcl0pO1xufVxuXG5mdW5jdGlvbiB1c2VEbmRNb25pdG9yUHJvdmlkZXIoKSB7XG4gIGNvbnN0IFtsaXN0ZW5lcnNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNldCgpKTtcbiAgY29uc3QgcmVnaXN0ZXJMaXN0ZW5lciA9IFJlYWN0LnVzZUNhbGxiYWNrKGxpc3RlbmVyID0+IHtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH0sIFtsaXN0ZW5lcnNdKTtcbiAgY29uc3QgZGlzcGF0Y2ggPSBSZWFjdC51c2VDYWxsYmFjayhfcmVmID0+IHtcbiAgICBsZXQge1xuICAgICAgdHlwZSxcbiAgICAgIGV2ZW50XG4gICAgfSA9IF9yZWY7XG4gICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgdmFyIF9saXN0ZW5lciR0eXBlO1xuXG4gICAgICByZXR1cm4gKF9saXN0ZW5lciR0eXBlID0gbGlzdGVuZXJbdHlwZV0pID09IG51bGwgPyB2b2lkIDAgOiBfbGlzdGVuZXIkdHlwZS5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gICAgfSk7XG4gIH0sIFtsaXN0ZW5lcnNdKTtcbiAgcmV0dXJuIFtkaXNwYXRjaCwgcmVnaXN0ZXJMaXN0ZW5lcl07XG59XG5cbmNvbnN0IGRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMgPSB7XG4gIGRyYWdnYWJsZTogXCJcXG4gICAgVG8gcGljayB1cCBhIGRyYWdnYWJsZSBpdGVtLCBwcmVzcyB0aGUgc3BhY2UgYmFyLlxcbiAgICBXaGlsZSBkcmFnZ2luZywgdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIGl0ZW0uXFxuICAgIFByZXNzIHNwYWNlIGFnYWluIHRvIGRyb3AgdGhlIGl0ZW0gaW4gaXRzIG5ldyBwb3NpdGlvbiwgb3IgcHJlc3MgZXNjYXBlIHRvIGNhbmNlbC5cXG4gIFwiXG59O1xuY29uc3QgZGVmYXVsdEFubm91bmNlbWVudHMgPSB7XG4gIG9uRHJhZ1N0YXJ0KF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlXG4gICAgfSA9IF9yZWY7XG4gICAgcmV0dXJuIFwiUGlja2VkIHVwIGRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIuXCI7XG4gIH0sXG5cbiAgb25EcmFnT3ZlcihfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBvdmVyXG4gICAgfSA9IF9yZWYyO1xuXG4gICAgaWYgKG92ZXIpIHtcbiAgICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgd2FzIG1vdmVkIG92ZXIgZHJvcHBhYmxlIGFyZWEgXCIgKyBvdmVyLmlkICsgXCIuXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiBpcyBubyBsb25nZXIgb3ZlciBhIGRyb3BwYWJsZSBhcmVhLlwiO1xuICB9LFxuXG4gIG9uRHJhZ0VuZChfcmVmMykge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBvdmVyXG4gICAgfSA9IF9yZWYzO1xuXG4gICAgaWYgKG92ZXIpIHtcbiAgICAgIHJldHVybiBcIkRyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgd2FzIGRyb3BwZWQgb3ZlciBkcm9wcGFibGUgYXJlYSBcIiArIG92ZXIuaWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiRHJhZ2dhYmxlIGl0ZW0gXCIgKyBhY3RpdmUuaWQgKyBcIiB3YXMgZHJvcHBlZC5cIjtcbiAgfSxcblxuICBvbkRyYWdDYW5jZWwoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlXG4gICAgfSA9IF9yZWY0O1xuICAgIHJldHVybiBcIkRyYWdnaW5nIHdhcyBjYW5jZWxsZWQuIERyYWdnYWJsZSBpdGVtIFwiICsgYWN0aXZlLmlkICsgXCIgd2FzIGRyb3BwZWQuXCI7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gQWNjZXNzaWJpbGl0eShfcmVmKSB7XG4gIGxldCB7XG4gICAgYW5ub3VuY2VtZW50cyA9IGRlZmF1bHRBbm5vdW5jZW1lbnRzLFxuICAgIGNvbnRhaW5lcixcbiAgICBoaWRkZW5UZXh0RGVzY3JpYmVkQnlJZCxcbiAgICBzY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMgPSBkZWZhdWx0U2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYW5ub3VuY2UsXG4gICAgYW5ub3VuY2VtZW50XG4gIH0gPSB1c2VBbm5vdW5jZW1lbnQoKTtcbiAgY29uc3QgbGl2ZVJlZ2lvbklkID0gdXNlVW5pcXVlSWQoXCJEbmRMaXZlUmVnaW9uXCIpO1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgfSwgW10pO1xuICB1c2VEbmRNb25pdG9yKFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbkRyYWdTdGFydChfcmVmMikge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aXZlXG4gICAgICB9ID0gX3JlZjI7XG4gICAgICBhbm5vdW5jZShhbm5vdW5jZW1lbnRzLm9uRHJhZ1N0YXJ0KHtcbiAgICAgICAgYWN0aXZlXG4gICAgICB9KSk7XG4gICAgfSxcblxuICAgIG9uRHJhZ01vdmUoX3JlZjMpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWYzO1xuXG4gICAgICBpZiAoYW5ub3VuY2VtZW50cy5vbkRyYWdNb3ZlKSB7XG4gICAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnTW92ZSh7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIG92ZXJcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkRyYWdPdmVyKF9yZWY0KSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmNDtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnT3Zlcih7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICBvbkRyYWdFbmQoX3JlZjUpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGFjdGl2ZSxcbiAgICAgICAgb3ZlclxuICAgICAgfSA9IF9yZWY1O1xuICAgICAgYW5ub3VuY2UoYW5ub3VuY2VtZW50cy5vbkRyYWdFbmQoe1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgb25EcmFnQ2FuY2VsKF9yZWY2KSB7XG4gICAgICBsZXQge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIG92ZXJcbiAgICAgIH0gPSBfcmVmNjtcbiAgICAgIGFubm91bmNlKGFubm91bmNlbWVudHMub25EcmFnQ2FuY2VsKHtcbiAgICAgICAgYWN0aXZlLFxuICAgICAgICBvdmVyXG4gICAgICB9KSk7XG4gICAgfVxuXG4gIH0pLCBbYW5ub3VuY2UsIGFubm91bmNlbWVudHNdKSk7XG5cbiAgaWYgKCFtb3VudGVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBtYXJrdXAgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBSZWFjdC5jcmVhdGVFbGVtZW50KEhpZGRlblRleHQsIHtcbiAgICBpZDogaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQsXG4gICAgdmFsdWU6IHNjcmVlblJlYWRlckluc3RydWN0aW9ucy5kcmFnZ2FibGVcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGl2ZVJlZ2lvbiwge1xuICAgIGlkOiBsaXZlUmVnaW9uSWQsXG4gICAgYW5ub3VuY2VtZW50OiBhbm5vdW5jZW1lbnRcbiAgfSkpO1xuICByZXR1cm4gY29udGFpbmVyID8gcmVhY3REb20uY3JlYXRlUG9ydGFsKG1hcmt1cCwgY29udGFpbmVyKSA6IG1hcmt1cDtcbn1cblxudmFyIEFjdGlvbjtcblxuKGZ1bmN0aW9uIChBY3Rpb24pIHtcbiAgQWN0aW9uW1wiRHJhZ1N0YXJ0XCJdID0gXCJkcmFnU3RhcnRcIjtcbiAgQWN0aW9uW1wiRHJhZ01vdmVcIl0gPSBcImRyYWdNb3ZlXCI7XG4gIEFjdGlvbltcIkRyYWdFbmRcIl0gPSBcImRyYWdFbmRcIjtcbiAgQWN0aW9uW1wiRHJhZ0NhbmNlbFwiXSA9IFwiZHJhZ0NhbmNlbFwiO1xuICBBY3Rpb25bXCJEcmFnT3ZlclwiXSA9IFwiZHJhZ092ZXJcIjtcbiAgQWN0aW9uW1wiUmVnaXN0ZXJEcm9wcGFibGVcIl0gPSBcInJlZ2lzdGVyRHJvcHBhYmxlXCI7XG4gIEFjdGlvbltcIlNldERyb3BwYWJsZURpc2FibGVkXCJdID0gXCJzZXREcm9wcGFibGVEaXNhYmxlZFwiO1xuICBBY3Rpb25bXCJVbnJlZ2lzdGVyRHJvcHBhYmxlXCJdID0gXCJ1bnJlZ2lzdGVyRHJvcHBhYmxlXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiB1c2VTZW5zb3Ioc2Vuc29yLCBvcHRpb25zKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2Vuc29yLFxuICAgIG9wdGlvbnM6IG9wdGlvbnMgIT0gbnVsbCA/IG9wdGlvbnMgOiB7fVxuICB9KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc2Vuc29yLCBvcHRpb25zXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNlbnNvcnMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzZW5zb3JzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHNlbnNvcnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBbLi4uc2Vuc29yc10uZmlsdGVyKHNlbnNvciA9PiBzZW5zb3IgIT0gbnVsbCksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy4uLnNlbnNvcnNdKTtcbn1cblxuY29uc3QgZGVmYXVsdENvb3JkaW5hdGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICB4OiAwLFxuICB5OiAwXG59KTtcblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xyXG4gKi9cbmZ1bmN0aW9uIGRpc3RhbmNlQmV0d2VlbihwMSwgcDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwMS54IC0gcDIueCwgMikgKyBNYXRoLnBvdyhwMS55IC0gcDIueSwgMikpO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbihldmVudCwgcmVjdCkge1xuICBjb25zdCBldmVudENvb3JkaW5hdGVzID0gZ2V0RXZlbnRDb29yZGluYXRlcyhldmVudCk7XG5cbiAgaWYgKCFldmVudENvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuICcwIDAnO1xuICB9XG5cbiAgY29uc3QgdHJhbnNmb3JtT3JpZ2luID0ge1xuICAgIHg6IChldmVudENvb3JkaW5hdGVzLnggLSByZWN0LmxlZnQpIC8gcmVjdC53aWR0aCAqIDEwMCxcbiAgICB5OiAoZXZlbnRDb29yZGluYXRlcy55IC0gcmVjdC50b3ApIC8gcmVjdC5oZWlnaHQgKiAxMDBcbiAgfTtcbiAgcmV0dXJuIHRyYW5zZm9ybU9yaWdpbi54ICsgXCIlIFwiICsgdHJhbnNmb3JtT3JpZ2luLnkgKyBcIiVcIjtcbn1cblxuLyoqXHJcbiAqIFNvcnQgY29sbGlzaW9ucyBmcm9tIHNtYWxsZXN0IHRvIGdyZWF0ZXN0IHZhbHVlXHJcbiAqL1xuZnVuY3Rpb24gc29ydENvbGxpc2lvbnNBc2MoX3JlZiwgX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYVxuICAgIH1cbiAgfSA9IF9yZWY7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGJcbiAgICB9XG4gIH0gPSBfcmVmMjtcbiAgcmV0dXJuIGEgLSBiO1xufVxuLyoqXHJcbiAqIFNvcnQgY29sbGlzaW9ucyBmcm9tIGdyZWF0ZXN0IHRvIHNtYWxsZXN0IHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBzb3J0Q29sbGlzaW9uc0Rlc2MoX3JlZjMsIF9yZWY0KSB7XG4gIGxldCB7XG4gICAgZGF0YToge1xuICAgICAgdmFsdWU6IGFcbiAgICB9XG4gIH0gPSBfcmVmMztcbiAgbGV0IHtcbiAgICBkYXRhOiB7XG4gICAgICB2YWx1ZTogYlxuICAgIH1cbiAgfSA9IF9yZWY0O1xuICByZXR1cm4gYiAtIGE7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNvcm5lcnMgb2YgYSBnaXZlbiByZWN0YW5nbGU6XHJcbiAqIFtUb3BMZWZ0IHt4LCB5fSwgVG9wUmlnaHQge3gsIHl9LCBCb3R0b21MZWZ0IHt4LCB5fSwgQm90dG9tUmlnaHQge3gsIHl9XVxyXG4gKi9cblxuZnVuY3Rpb24gY29ybmVyc09mUmVjdGFuZ2xlKF9yZWY1KSB7XG4gIGxldCB7XG4gICAgbGVmdCxcbiAgICB0b3AsXG4gICAgaGVpZ2h0LFxuICAgIHdpZHRoXG4gIH0gPSBfcmVmNTtcbiAgcmV0dXJuIFt7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3BcbiAgfSwge1xuICAgIHg6IGxlZnQgKyB3aWR0aCxcbiAgICB5OiB0b3BcbiAgfSwge1xuICAgIHg6IGxlZnQsXG4gICAgeTogdG9wICsgaGVpZ2h0XG4gIH0sIHtcbiAgICB4OiBsZWZ0ICsgd2lkdGgsXG4gICAgeTogdG9wICsgaGVpZ2h0XG4gIH1dO1xufVxuZnVuY3Rpb24gZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlzaW9ucywgcHJvcGVydHkpIHtcbiAgaWYgKCFjb2xsaXNpb25zIHx8IGNvbGxpc2lvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBbZmlyc3RDb2xsaXNpb25dID0gY29sbGlzaW9ucztcbiAgcmV0dXJuIGZpcnN0Q29sbGlzaW9uW3Byb3BlcnR5XSA7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnRlcnNlY3RpbmcgcmVjdGFuZ2xlIGFyZWEgYmV0d2VlbiB0d28gcmVjdGFuZ2xlc1xyXG4gKi9cblxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uUmF0aW8oZW50cnksIHRhcmdldCkge1xuICBjb25zdCB0b3AgPSBNYXRoLm1heCh0YXJnZXQudG9wLCBlbnRyeS50b3ApO1xuICBjb25zdCBsZWZ0ID0gTWF0aC5tYXgodGFyZ2V0LmxlZnQsIGVudHJ5LmxlZnQpO1xuICBjb25zdCByaWdodCA9IE1hdGgubWluKHRhcmdldC5sZWZ0ICsgdGFyZ2V0LndpZHRoLCBlbnRyeS5sZWZ0ICsgZW50cnkud2lkdGgpO1xuICBjb25zdCBib3R0b20gPSBNYXRoLm1pbih0YXJnZXQudG9wICsgdGFyZ2V0LmhlaWdodCwgZW50cnkudG9wICsgZW50cnkuaGVpZ2h0KTtcbiAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcblxuICBpZiAobGVmdCA8IHJpZ2h0ICYmIHRvcCA8IGJvdHRvbSkge1xuICAgIGNvbnN0IHRhcmdldEFyZWEgPSB0YXJnZXQud2lkdGggKiB0YXJnZXQuaGVpZ2h0O1xuICAgIGNvbnN0IGVudHJ5QXJlYSA9IGVudHJ5LndpZHRoICogZW50cnkuaGVpZ2h0O1xuICAgIGNvbnN0IGludGVyc2VjdGlvbkFyZWEgPSB3aWR0aCAqIGhlaWdodDtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbkFyZWEgLyAodGFyZ2V0QXJlYSArIGVudHJ5QXJlYSAtIGludGVyc2VjdGlvbkFyZWEpO1xuICAgIHJldHVybiBOdW1iZXIoaW50ZXJzZWN0aW9uUmF0aW8udG9GaXhlZCg0KSk7XG4gIH0gLy8gUmVjdGFuZ2xlcyBkbyBub3Qgb3ZlcmxhcCwgb3Igb3ZlcmxhcCBoYXMgYW4gYXJlYSBvZiB6ZXJvIChlZGdlL2Nvcm5lciBvdmVybGFwKVxuXG5cbiAgcmV0dXJuIDA7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgcmVjdGFuZ2xlcyB0aGF0IGhhcyB0aGUgZ3JlYXRlc3QgaW50ZXJzZWN0aW9uIGFyZWEgd2l0aCBhIGdpdmVuXHJcbiAqIHJlY3RhbmdsZSBpbiBhbiBhcnJheSBvZiByZWN0YW5nbGVzLlxyXG4gKi9cblxuY29uc3QgcmVjdEludGVyc2VjdGlvbiA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29sbGlzaW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZHJvcHBhYmxlQ29udGFpbmVyIG9mIGRyb3BwYWJsZUNvbnRhaW5lcnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZFxuICAgIH0gPSBkcm9wcGFibGVDb250YWluZXI7XG4gICAgY29uc3QgcmVjdCA9IGRyb3BwYWJsZVJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uUmF0aW8gPSBnZXRJbnRlcnNlY3Rpb25SYXRpbyhyZWN0LCBjb2xsaXNpb25SZWN0KTtcblxuICAgICAgaWYgKGludGVyc2VjdGlvblJhdGlvID4gMCkge1xuICAgICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICAgIHZhbHVlOiBpbnRlcnNlY3Rpb25SYXRpb1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0Rlc2MpO1xufTtcblxuLyoqXHJcbiAqIENoZWNrIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBhIGJvdW5kaW5nIHJlY3RhbmdsZVxyXG4gKi9cblxuZnVuY3Rpb24gaXNQb2ludFdpdGhpblJlY3QocG9pbnQsIHJlY3QpIHtcbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHRvcCA8PSBwb2ludC55ICYmIHBvaW50LnkgPD0gYm90dG9tICYmIGxlZnQgPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IHJpZ2h0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJlY3RhbmdsZXMgdGhhdCB0aGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyXHJcbiAqL1xuXG5cbmNvbnN0IHBvaW50ZXJXaXRoaW4gPSBfcmVmID0+IHtcbiAgbGV0IHtcbiAgICBkcm9wcGFibGVDb250YWluZXJzLFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIHBvaW50ZXJDb29yZGluYXRlc1xuICB9ID0gX3JlZjtcblxuICBpZiAoIXBvaW50ZXJDb29yZGluYXRlcykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGRyb3BwYWJsZUNvbnRhaW5lciBvZiBkcm9wcGFibGVDb250YWluZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRcbiAgICB9ID0gZHJvcHBhYmxlQ29udGFpbmVyO1xuICAgIGNvbnN0IHJlY3QgPSBkcm9wcGFibGVSZWN0cy5nZXQoaWQpO1xuXG4gICAgaWYgKHJlY3QgJiYgaXNQb2ludFdpdGhpblJlY3QocG9pbnRlckNvb3JkaW5hdGVzLCByZWN0KSkge1xuICAgICAgLyogVGhlcmUgbWF5IGJlIG1vcmUgdGhhbiBhIHNpbmdsZSByZWN0YW5nbGUgaW50ZXJzZWN0aW5nXHJcbiAgICAgICAqIHdpdGggdGhlIHBvaW50ZXIgY29vcmRpbmF0ZXMuIEluIG9yZGVyIHRvIHNvcnQgdGhlXHJcbiAgICAgICAqIGNvbGxpZGluZyByZWN0YW5nbGVzLCB3ZSBtZWFzdXJlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuXHJcbiAgICAgICAqIHRoZSBwb2ludGVyIGFuZCB0aGUgY29ybmVycyBvZiB0aGUgaW50ZXJzZWN0aW5nIHJlY3RhbmdsZVxyXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNvcm5lcnMgPSBjb3JuZXJzT2ZSZWN0YW5nbGUocmVjdCk7XG4gICAgICBjb25zdCBkaXN0YW5jZXMgPSBjb3JuZXJzLnJlZHVjZSgoYWNjdW11bGF0b3IsIGNvcm5lcikgPT4ge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyBkaXN0YW5jZUJldHdlZW4ocG9pbnRlckNvb3JkaW5hdGVzLCBjb3JuZXIpO1xuICAgICAgfSwgMCk7XG4gICAgICBjb25zdCBlZmZlY3RpdmVEaXN0YW5jZSA9IE51bWJlcigoZGlzdGFuY2VzIC8gNCkudG9GaXhlZCg0KSk7XG4gICAgICBjb2xsaXNpb25zLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcixcbiAgICAgICAgICB2YWx1ZTogZWZmZWN0aXZlRGlzdGFuY2VcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbGxpc2lvbnMuc29ydChzb3J0Q29sbGlzaW9uc0FzYyk7XG59O1xuXG5mdW5jdGlvbiBhZGp1c3RTY2FsZSh0cmFuc2Zvcm0sIHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4geyAuLi50cmFuc2Zvcm0sXG4gICAgc2NhbGVYOiByZWN0MSAmJiByZWN0MiA/IHJlY3QxLndpZHRoIC8gcmVjdDIud2lkdGggOiAxLFxuICAgIHNjYWxlWTogcmVjdDEgJiYgcmVjdDIgPyByZWN0MS5oZWlnaHQgLyByZWN0Mi5oZWlnaHQgOiAxXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFJlY3REZWx0YShyZWN0MSwgcmVjdDIpIHtcbiAgcmV0dXJuIHJlY3QxICYmIHJlY3QyID8ge1xuICAgIHg6IHJlY3QxLmxlZnQgLSByZWN0Mi5sZWZ0LFxuICAgIHk6IHJlY3QxLnRvcCAtIHJlY3QyLnRvcFxuICB9IDogZGVmYXVsdENvb3JkaW5hdGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSZWN0QWRqdXN0bWVudEZuKG1vZGlmaWVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiBhZGp1c3RDbGllbnRSZWN0KHJlY3QpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYWRqdXN0bWVudHMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYWRqdXN0bWVudHNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHJldHVybiBhZGp1c3RtZW50cy5yZWR1Y2UoKGFjYywgYWRqdXN0bWVudCkgPT4gKHsgLi4uYWNjLFxuICAgICAgdG9wOiBhY2MudG9wICsgbW9kaWZpZXIgKiBhZGp1c3RtZW50LnksXG4gICAgICBib3R0b206IGFjYy5ib3R0b20gKyBtb2RpZmllciAqIGFkanVzdG1lbnQueSxcbiAgICAgIGxlZnQ6IGFjYy5sZWZ0ICsgbW9kaWZpZXIgKiBhZGp1c3RtZW50LngsXG4gICAgICByaWdodDogYWNjLnJpZ2h0ICsgbW9kaWZpZXIgKiBhZGp1c3RtZW50LnhcbiAgICB9KSwgeyAuLi5yZWN0XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCBnZXRBZGp1c3RlZFJlY3QgPSAvKiNfX1BVUkVfXyovY3JlYXRlUmVjdEFkanVzdG1lbnRGbigxKTtcblxuZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gIGlmICh0cmFuc2Zvcm0uc3RhcnRzV2l0aCgnbWF0cml4M2QoJykpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1BcnJheSA9IHRyYW5zZm9ybS5zbGljZSg5LCAtMSkuc3BsaXQoLywgLyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICt0cmFuc2Zvcm1BcnJheVsxMl0sXG4gICAgICB5OiArdHJhbnNmb3JtQXJyYXlbMTNdLFxuICAgICAgc2NhbGVYOiArdHJhbnNmb3JtQXJyYXlbMF0sXG4gICAgICBzY2FsZVk6ICt0cmFuc2Zvcm1BcnJheVs1XVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHJhbnNmb3JtLnN0YXJ0c1dpdGgoJ21hdHJpeCgnKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybUFycmF5ID0gdHJhbnNmb3JtLnNsaWNlKDcsIC0xKS5zcGxpdCgvLCAvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogK3RyYW5zZm9ybUFycmF5WzRdLFxuICAgICAgeTogK3RyYW5zZm9ybUFycmF5WzVdLFxuICAgICAgc2NhbGVYOiArdHJhbnNmb3JtQXJyYXlbMF0sXG4gICAgICBzY2FsZVk6ICt0cmFuc2Zvcm1BcnJheVszXVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW52ZXJzZVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0sIHRyYW5zZm9ybU9yaWdpbikge1xuICBjb25zdCBwYXJzZWRUcmFuc2Zvcm0gPSBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gIGlmICghcGFyc2VkVHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuIHJlY3Q7XG4gIH1cblxuICBjb25zdCB7XG4gICAgc2NhbGVYLFxuICAgIHNjYWxlWSxcbiAgICB4OiB0cmFuc2xhdGVYLFxuICAgIHk6IHRyYW5zbGF0ZVlcbiAgfSA9IHBhcnNlZFRyYW5zZm9ybTtcbiAgY29uc3QgeCA9IHJlY3QubGVmdCAtIHRyYW5zbGF0ZVggLSAoMSAtIHNjYWxlWCkgKiBwYXJzZUZsb2F0KHRyYW5zZm9ybU9yaWdpbik7XG4gIGNvbnN0IHkgPSByZWN0LnRvcCAtIHRyYW5zbGF0ZVkgLSAoMSAtIHNjYWxlWSkgKiBwYXJzZUZsb2F0KHRyYW5zZm9ybU9yaWdpbi5zbGljZSh0cmFuc2Zvcm1PcmlnaW4uaW5kZXhPZignICcpICsgMSkpO1xuICBjb25zdCB3ID0gc2NhbGVYID8gcmVjdC53aWR0aCAvIHNjYWxlWCA6IHJlY3Qud2lkdGg7XG4gIGNvbnN0IGggPSBzY2FsZVkgPyByZWN0LmhlaWdodCAvIHNjYWxlWSA6IHJlY3QuaGVpZ2h0O1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiB3LFxuICAgIGhlaWdodDogaCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3LFxuICAgIGJvdHRvbTogeSArIGgsXG4gICAgbGVmdDogeFxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgaWdub3JlVHJhbnNmb3JtOiBmYWxzZVxufTtcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydC5cclxuICovXG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3QoZWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICB9XG5cbiAgbGV0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIGlmIChvcHRpb25zLmlnbm9yZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHRyYW5zZm9ybU9yaWdpblxuICAgIH0gPSBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHJlY3QgPSBpbnZlcnNlVHJhbnNmb3JtKHJlY3QsIHRyYW5zZm9ybSwgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICByaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgYm90dG9tLFxuICAgIHJpZ2h0XG4gIH07XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQuXHJcbiAqXHJcbiAqIEByZW1hcmtzXHJcbiAqIFRoZSBDbGllbnRSZWN0IHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kIGRvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXNcclxuICogYXBwbGllZCB0byB0aGUgZWxlbWVudCBpdCBtZWFzdXJlcy5cclxuICpcclxuICovXG5cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybUFnbm9zdGljQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDbGllbnRSZWN0KGVsZW1lbnQsIHtcbiAgICBpZ25vcmVUcmFuc2Zvcm06IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd0NsaWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuaW5uZXJXaWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gZWxlbWVudC5pbm5lckhlaWdodDtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogd2lkdGgsXG4gICAgYm90dG9tOiBoZWlnaHQsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRml4ZWQobm9kZSwgY29tcHV0ZWRTdHlsZSkge1xuICBpZiAoY29tcHV0ZWRTdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgY29tcHV0ZWRTdHlsZSA9IGdldFdpbmRvdyhub2RlKS5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCc7XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbGVtZW50LCBjb21wdXRlZFN0eWxlKSB7XG4gIGlmIChjb21wdXRlZFN0eWxlID09PSB2b2lkIDApIHtcbiAgICBjb21wdXRlZFN0eWxlID0gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIH1cblxuICBjb25zdCBvdmVyZmxvd1JlZ2V4ID0gLyhhdXRvfHNjcm9sbHxvdmVybGF5KS87XG4gIGNvbnN0IHByb3BlcnRpZXMgPSBbJ292ZXJmbG93JywgJ292ZXJmbG93WCcsICdvdmVyZmxvd1knXTtcbiAgcmV0dXJuIHByb3BlcnRpZXMuc29tZShwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBjb21wdXRlZFN0eWxlW3Byb3BlcnR5XTtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG92ZXJmbG93UmVnZXgudGVzdCh2YWx1ZSkgOiBmYWxzZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbGFibGVBbmNlc3RvcnMoZWxlbWVudCwgbGltaXQpIHtcbiAgY29uc3Qgc2Nyb2xsUGFyZW50cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGZpbmRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgICBpZiAobGltaXQgIT0gbnVsbCAmJiBzY3JvbGxQYXJlbnRzLmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gICAgfVxuXG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBpZiAoaXNEb2N1bWVudChub2RlKSAmJiBub2RlLnNjcm9sbGluZ0VsZW1lbnQgIT0gbnVsbCAmJiAhc2Nyb2xsUGFyZW50cy5pbmNsdWRlcyhub2RlLnNjcm9sbGluZ0VsZW1lbnQpKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLnB1c2gobm9kZS5zY3JvbGxpbmdFbGVtZW50KTtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmICghaXNIVE1MRWxlbWVudChub2RlKSB8fCBpc1NWR0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIGlmIChzY3JvbGxQYXJlbnRzLmluY2x1ZGVzKG5vZGUpKSB7XG4gICAgICByZXR1cm4gc2Nyb2xsUGFyZW50cztcbiAgICB9XG5cbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICBpZiAobm9kZSAhPT0gZWxlbWVudCkge1xuICAgICAgaWYgKGlzU2Nyb2xsYWJsZShub2RlLCBjb21wdXRlZFN0eWxlKSkge1xuICAgICAgICBzY3JvbGxQYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRml4ZWQobm9kZSwgY29tcHV0ZWRTdHlsZSkpIHtcbiAgICAgIHJldHVybiBzY3JvbGxQYXJlbnRzO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyhub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIHNjcm9sbFBhcmVudHM7XG4gIH1cblxuICByZXR1cm4gZmluZFNjcm9sbGFibGVBbmNlc3RvcnMoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IFtmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcl0gPSBnZXRTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUsIDEpO1xuICByZXR1cm4gZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgIT0gbnVsbCA/IGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICBpZiAoIWNhblVzZURPTSB8fCAhZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBpZiAoIWlzTm9kZShlbGVtZW50KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGlzRG9jdW1lbnQoZWxlbWVudCkgfHwgZWxlbWVudCA9PT0gZ2V0T3duZXJEb2N1bWVudChlbGVtZW50KS5zY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsWENvb3JkaW5hdGUoZWxlbWVudCkge1xuICBpZiAoaXNXaW5kb3coZWxlbWVudCkpIHtcbiAgICByZXR1cm4gZWxlbWVudC5zY3JvbGxYO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsTGVmdDtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbFlDb29yZGluYXRlKGVsZW1lbnQpIHtcbiAgaWYgKGlzV2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc2Nyb2xsWTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50LnNjcm9sbFRvcDtcbn1cbmZ1bmN0aW9uIGdldFNjcm9sbENvb3JkaW5hdGVzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBnZXRTY3JvbGxYQ29vcmRpbmF0ZShlbGVtZW50KSxcbiAgICB5OiBnZXRTY3JvbGxZQ29vcmRpbmF0ZShlbGVtZW50KVxuICB9O1xufVxuXG52YXIgRGlyZWN0aW9uO1xuXG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xuICBEaXJlY3Rpb25bRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IDFdID0gXCJGb3J3YXJkXCI7XG4gIERpcmVjdGlvbltEaXJlY3Rpb25bXCJCYWNrd2FyZFwiXSA9IC0xXSA9IFwiQmFja3dhcmRcIjtcbn0pKERpcmVjdGlvbiB8fCAoRGlyZWN0aW9uID0ge30pKTtcblxuZnVuY3Rpb24gaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICBpZiAoIWNhblVzZURPTSB8fCAhZWxlbWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50ID09PSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxpbmdDb250YWluZXIpIHtcbiAgY29uc3QgbWluU2Nyb2xsID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBjb25zdCBkaW1lbnNpb25zID0gaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQoc2Nyb2xsaW5nQ29udGFpbmVyKSA/IHtcbiAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGhcbiAgfSA6IHtcbiAgICBoZWlnaHQ6IHNjcm9sbGluZ0NvbnRhaW5lci5jbGllbnRIZWlnaHQsXG4gICAgd2lkdGg6IHNjcm9sbGluZ0NvbnRhaW5lci5jbGllbnRXaWR0aFxuICB9O1xuICBjb25zdCBtYXhTY3JvbGwgPSB7XG4gICAgeDogc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFdpZHRoIC0gZGltZW5zaW9ucy53aWR0aCxcbiAgICB5OiBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHRcbiAgfTtcbiAgY29uc3QgaXNUb3AgPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wIDw9IG1pblNjcm9sbC55O1xuICBjb25zdCBpc0xlZnQgPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsTGVmdCA8PSBtaW5TY3JvbGwueDtcbiAgY29uc3QgaXNCb3R0b20gPSBzY3JvbGxpbmdDb250YWluZXIuc2Nyb2xsVG9wID49IG1heFNjcm9sbC55O1xuICBjb25zdCBpc1JpZ2h0ID0gc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbExlZnQgPj0gbWF4U2Nyb2xsLng7XG4gIHJldHVybiB7XG4gICAgaXNUb3AsXG4gICAgaXNMZWZ0LFxuICAgIGlzQm90dG9tLFxuICAgIGlzUmlnaHQsXG4gICAgbWF4U2Nyb2xsLFxuICAgIG1pblNjcm9sbFxuICB9O1xufVxuXG5jb25zdCBkZWZhdWx0VGhyZXNob2xkID0ge1xuICB4OiAwLjIsXG4gIHk6IDAuMlxufTtcbmZ1bmN0aW9uIGdldFNjcm9sbERpcmVjdGlvbkFuZFNwZWVkKHNjcm9sbENvbnRhaW5lciwgc2Nyb2xsQ29udGFpbmVyUmVjdCwgX3JlZiwgYWNjZWxlcmF0aW9uLCB0aHJlc2hvbGRQZXJjZW50YWdlKSB7XG4gIGxldCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tXG4gIH0gPSBfcmVmO1xuXG4gIGlmIChhY2NlbGVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgIGFjY2VsZXJhdGlvbiA9IDEwO1xuICB9XG5cbiAgaWYgKHRocmVzaG9sZFBlcmNlbnRhZ2UgPT09IHZvaWQgMCkge1xuICAgIHRocmVzaG9sZFBlcmNlbnRhZ2UgPSBkZWZhdWx0VGhyZXNob2xkO1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGlzVG9wLFxuICAgIGlzQm90dG9tLFxuICAgIGlzTGVmdCxcbiAgICBpc1JpZ2h0XG4gIH0gPSBnZXRTY3JvbGxQb3NpdGlvbihzY3JvbGxDb250YWluZXIpO1xuICBjb25zdCBkaXJlY3Rpb24gPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG4gIGNvbnN0IHNwZWVkID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBjb25zdCB0aHJlc2hvbGQgPSB7XG4gICAgaGVpZ2h0OiBzY3JvbGxDb250YWluZXJSZWN0LmhlaWdodCAqIHRocmVzaG9sZFBlcmNlbnRhZ2UueSxcbiAgICB3aWR0aDogc2Nyb2xsQ29udGFpbmVyUmVjdC53aWR0aCAqIHRocmVzaG9sZFBlcmNlbnRhZ2UueFxuICB9O1xuXG4gIGlmICghaXNUb3AgJiYgdG9wIDw9IHNjcm9sbENvbnRhaW5lclJlY3QudG9wICsgdGhyZXNob2xkLmhlaWdodCkge1xuICAgIC8vIFNjcm9sbCBVcFxuICAgIGRpcmVjdGlvbi55ID0gRGlyZWN0aW9uLkJhY2t3YXJkO1xuICAgIHNwZWVkLnkgPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicygoc2Nyb2xsQ29udGFpbmVyUmVjdC50b3AgKyB0aHJlc2hvbGQuaGVpZ2h0IC0gdG9wKSAvIHRocmVzaG9sZC5oZWlnaHQpO1xuICB9IGVsc2UgaWYgKCFpc0JvdHRvbSAmJiBib3R0b20gPj0gc2Nyb2xsQ29udGFpbmVyUmVjdC5ib3R0b20gLSB0aHJlc2hvbGQuaGVpZ2h0KSB7XG4gICAgLy8gU2Nyb2xsIERvd25cbiAgICBkaXJlY3Rpb24ueSA9IERpcmVjdGlvbi5Gb3J3YXJkO1xuICAgIHNwZWVkLnkgPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicygoc2Nyb2xsQ29udGFpbmVyUmVjdC5ib3R0b20gLSB0aHJlc2hvbGQuaGVpZ2h0IC0gYm90dG9tKSAvIHRocmVzaG9sZC5oZWlnaHQpO1xuICB9XG5cbiAgaWYgKCFpc1JpZ2h0ICYmIHJpZ2h0ID49IHNjcm9sbENvbnRhaW5lclJlY3QucmlnaHQgLSB0aHJlc2hvbGQud2lkdGgpIHtcbiAgICAvLyBTY3JvbGwgUmlnaHRcbiAgICBkaXJlY3Rpb24ueCA9IERpcmVjdGlvbi5Gb3J3YXJkO1xuICAgIHNwZWVkLnggPSBhY2NlbGVyYXRpb24gKiBNYXRoLmFicygoc2Nyb2xsQ29udGFpbmVyUmVjdC5yaWdodCAtIHRocmVzaG9sZC53aWR0aCAtIHJpZ2h0KSAvIHRocmVzaG9sZC53aWR0aCk7XG4gIH0gZWxzZSBpZiAoIWlzTGVmdCAmJiBsZWZ0IDw9IHNjcm9sbENvbnRhaW5lclJlY3QubGVmdCArIHRocmVzaG9sZC53aWR0aCkge1xuICAgIC8vIFNjcm9sbCBMZWZ0XG4gICAgZGlyZWN0aW9uLnggPSBEaXJlY3Rpb24uQmFja3dhcmQ7XG4gICAgc3BlZWQueCA9IGFjY2VsZXJhdGlvbiAqIE1hdGguYWJzKChzY3JvbGxDb250YWluZXJSZWN0LmxlZnQgKyB0aHJlc2hvbGQud2lkdGggLSBsZWZ0KSAvIHRocmVzaG9sZC53aWR0aCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRpcmVjdGlvbixcbiAgICBzcGVlZFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRTY3JvbGxFbGVtZW50UmVjdChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJXaWR0aCxcbiAgICAgIGlubmVySGVpZ2h0XG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBpbm5lcldpZHRoLFxuICAgICAgYm90dG9tOiBpbm5lckhlaWdodCxcbiAgICAgIHdpZHRoOiBpbm5lcldpZHRoLFxuICAgICAgaGVpZ2h0OiBpbm5lckhlaWdodFxuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgdG9wLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm90dG9tXG4gIH0gPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHRvcCxcbiAgICBsZWZ0LFxuICAgIHJpZ2h0LFxuICAgIGJvdHRvbSxcbiAgICB3aWR0aDogZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICBoZWlnaHQ6IGVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICByZXR1cm4gc2Nyb2xsYWJsZUFuY2VzdG9ycy5yZWR1Y2UoKGFjYywgbm9kZSkgPT4ge1xuICAgIHJldHVybiBhZGQoYWNjLCBnZXRTY3JvbGxDb29yZGluYXRlcyhub2RlKSk7XG4gIH0sIGRlZmF1bHRDb29yZGluYXRlcyk7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxYT2Zmc2V0KHNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVBbmNlc3RvcnMucmVkdWNlKChhY2MsIG5vZGUpID0+IHtcbiAgICByZXR1cm4gYWNjICsgZ2V0U2Nyb2xsWENvb3JkaW5hdGUobm9kZSk7XG4gIH0sIDApO1xufVxuZnVuY3Rpb24gZ2V0U2Nyb2xsWU9mZnNldChzY3JvbGxhYmxlQW5jZXN0b3JzKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlQW5jZXN0b3JzLnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgcmV0dXJuIGFjYyArIGdldFNjcm9sbFlDb29yZGluYXRlKG5vZGUpO1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZChlbGVtZW50LCBtZWFzdXJlKSB7XG4gIGlmIChtZWFzdXJlID09PSB2b2lkIDApIHtcbiAgICBtZWFzdXJlID0gZ2V0Q2xpZW50UmVjdDtcbiAgfVxuXG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICB0b3AsXG4gICAgbGVmdCxcbiAgICBib3R0b20sXG4gICAgcmlnaHRcbiAgfSA9IG1lYXN1cmUoZWxlbWVudCk7XG4gIGNvbnN0IGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yID0gZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IoZWxlbWVudCk7XG5cbiAgaWYgKCFmaXJzdFNjcm9sbGFibGVBbmNlc3Rvcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChib3R0b20gPD0gMCB8fCByaWdodCA8PSAwIHx8IHRvcCA+PSB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgbGVmdCA+PSB3aW5kb3cuaW5uZXJXaWR0aCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6ICdjZW50ZXInLFxuICAgICAgaW5saW5lOiAnY2VudGVyJ1xuICAgIH0pO1xuICB9XG59XG5cbmNvbnN0IHByb3BlcnRpZXMgPSBbWyd4JywgWydsZWZ0JywgJ3JpZ2h0J10sIGdldFNjcm9sbFhPZmZzZXRdLCBbJ3knLCBbJ3RvcCcsICdib3R0b20nXSwgZ2V0U2Nyb2xsWU9mZnNldF1dO1xuY2xhc3MgUmVjdCB7XG4gIGNvbnN0cnVjdG9yKHJlY3QsIGVsZW1lbnQpIHtcbiAgICB0aGlzLnJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy53aWR0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmhlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLnRvcCA9IHZvaWQgMDtcbiAgICB0aGlzLmJvdHRvbSA9IHZvaWQgMDtcbiAgICB0aGlzLnJpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMubGVmdCA9IHZvaWQgMDtcbiAgICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JzID0gZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyhlbGVtZW50KTtcbiAgICBjb25zdCBzY3JvbGxPZmZzZXRzID0gZ2V0U2Nyb2xsT2Zmc2V0cyhzY3JvbGxhYmxlQW5jZXN0b3JzKTtcbiAgICB0aGlzLnJlY3QgPSB7IC4uLnJlY3RcbiAgICB9O1xuICAgIHRoaXMud2lkdGggPSByZWN0LndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICBmb3IgKGNvbnN0IFtheGlzLCBrZXlzLCBnZXRTY3JvbGxPZmZzZXRdIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE9mZnNldHMgPSBnZXRTY3JvbGxPZmZzZXQoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXRzRGVsdGxhID0gc2Nyb2xsT2Zmc2V0c1theGlzXSAtIGN1cnJlbnRPZmZzZXRzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVjdFtrZXldICsgc2Nyb2xsT2Zmc2V0c0RlbHRsYTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdyZWN0Jywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNsYXNzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgIHRoaXMudGFyZ2V0ID0gdm9pZCAwO1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG5cbiAgICB0aGlzLnJlbW92ZUFsbCA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgICB2YXIgX3RoaXMkdGFyZ2V0O1xuXG4gICAgICAgIHJldHVybiAoX3RoaXMkdGFyZ2V0ID0gdGhpcy50YXJnZXQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciguLi5saXN0ZW5lcik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBhZGQoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJHRhcmdldDI7XG5cbiAgICAoX3RoaXMkdGFyZ2V0MiA9IHRoaXMudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkdGFyZ2V0Mi5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChbZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zXSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBnZXRFdmVudExpc3RlbmVyVGFyZ2V0KHRhcmdldCkge1xuICAvLyBJZiB0aGUgYGV2ZW50LnRhcmdldGAgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50IGV2ZW50cyB3aWxsIHN0aWxsIGJlIHRhcmdldGVkXG4gIC8vIGF0IGl0LCBhbmQgaGVuY2Ugd29uJ3QgYWx3YXlzIGJ1YmJsZSB1cCB0byB0aGUgd2luZG93IG9yIGRvY3VtZW50IGFueW1vcmUuXG4gIC8vIElmIHRoZXJlIGlzIGFueSByaXNrIG9mIGFuIGVsZW1lbnQgYmVpbmcgcmVtb3ZlZCB3aGlsZSBpdCBpcyBiZWluZyBkcmFnZ2VkLFxuICAvLyB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBhdHRhY2ggdGhlIGV2ZW50IGxpc3RlbmVycyBkaXJlY3RseSB0byB0aGUgdGFyZ2V0LlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXRcbiAgY29uc3Qge1xuICAgIEV2ZW50VGFyZ2V0XG4gIH0gPSBnZXRXaW5kb3codGFyZ2V0KTtcbiAgcmV0dXJuIHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50VGFyZ2V0ID8gdGFyZ2V0IDogZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBtZWFzdXJlbWVudCkge1xuICBjb25zdCBkeCA9IE1hdGguYWJzKGRlbHRhLngpO1xuICBjb25zdCBkeSA9IE1hdGguYWJzKGRlbHRhLnkpO1xuXG4gIGlmICh0eXBlb2YgbWVhc3VyZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChkeCAqKiAyICsgZHkgKiogMikgPiBtZWFzdXJlbWVudDtcbiAgfVxuXG4gIGlmICgneCcgaW4gbWVhc3VyZW1lbnQgJiYgJ3knIGluIG1lYXN1cmVtZW50KSB7XG4gICAgcmV0dXJuIGR4ID4gbWVhc3VyZW1lbnQueCAmJiBkeSA+IG1lYXN1cmVtZW50Lnk7XG4gIH1cblxuICBpZiAoJ3gnIGluIG1lYXN1cmVtZW50KSB7XG4gICAgcmV0dXJuIGR4ID4gbWVhc3VyZW1lbnQueDtcbiAgfVxuXG4gIGlmICgneScgaW4gbWVhc3VyZW1lbnQpIHtcbiAgICByZXR1cm4gZHkgPiBtZWFzdXJlbWVudC55O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgRXZlbnROYW1lO1xuXG4oZnVuY3Rpb24gKEV2ZW50TmFtZSkge1xuICBFdmVudE5hbWVbXCJDbGlja1wiXSA9IFwiY2xpY2tcIjtcbiAgRXZlbnROYW1lW1wiRHJhZ1N0YXJ0XCJdID0gXCJkcmFnc3RhcnRcIjtcbiAgRXZlbnROYW1lW1wiS2V5ZG93blwiXSA9IFwia2V5ZG93blwiO1xuICBFdmVudE5hbWVbXCJDb250ZXh0TWVudVwiXSA9IFwiY29udGV4dG1lbnVcIjtcbiAgRXZlbnROYW1lW1wiUmVzaXplXCJdID0gXCJyZXNpemVcIjtcbiAgRXZlbnROYW1lW1wiU2VsZWN0aW9uQ2hhbmdlXCJdID0gXCJzZWxlY3Rpb25jaGFuZ2VcIjtcbiAgRXZlbnROYW1lW1wiVmlzaWJpbGl0eUNoYW5nZVwiXSA9IFwidmlzaWJpbGl0eWNoYW5nZVwiO1xufSkoRXZlbnROYW1lIHx8IChFdmVudE5hbWUgPSB7fSkpO1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgS2V5Ym9hcmRDb2RlO1xuXG4oZnVuY3Rpb24gKEtleWJvYXJkQ29kZSkge1xuICBLZXlib2FyZENvZGVbXCJTcGFjZVwiXSA9IFwiU3BhY2VcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiRG93blwiXSA9IFwiQXJyb3dEb3duXCI7XG4gIEtleWJvYXJkQ29kZVtcIlJpZ2h0XCJdID0gXCJBcnJvd1JpZ2h0XCI7XG4gIEtleWJvYXJkQ29kZVtcIkxlZnRcIl0gPSBcIkFycm93TGVmdFwiO1xuICBLZXlib2FyZENvZGVbXCJVcFwiXSA9IFwiQXJyb3dVcFwiO1xuICBLZXlib2FyZENvZGVbXCJFc2NcIl0gPSBcIkVzY2FwZVwiO1xuICBLZXlib2FyZENvZGVbXCJFbnRlclwiXSA9IFwiRW50ZXJcIjtcbiAgS2V5Ym9hcmRDb2RlW1wiVGFiXCJdID0gXCJUYWJcIjtcbn0pKEtleWJvYXJkQ29kZSB8fCAoS2V5Ym9hcmRDb2RlID0ge30pKTtcblxuY29uc3QgZGVmYXVsdEtleWJvYXJkQ29kZXMgPSB7XG4gIHN0YXJ0OiBbS2V5Ym9hcmRDb2RlLlNwYWNlLCBLZXlib2FyZENvZGUuRW50ZXJdLFxuICBjYW5jZWw6IFtLZXlib2FyZENvZGUuRXNjXSxcbiAgZW5kOiBbS2V5Ym9hcmRDb2RlLlNwYWNlLCBLZXlib2FyZENvZGUuRW50ZXIsIEtleWJvYXJkQ29kZS5UYWJdXG59O1xuY29uc3QgZGVmYXVsdEtleWJvYXJkQ29vcmRpbmF0ZUdldHRlciA9IChldmVudCwgX3JlZikgPT4ge1xuICBsZXQge1xuICAgIGN1cnJlbnRDb29yZGluYXRlc1xuICB9ID0gX3JlZjtcblxuICBzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcbiAgICBjYXNlIEtleWJvYXJkQ29kZS5SaWdodDpcbiAgICAgIHJldHVybiB7IC4uLmN1cnJlbnRDb29yZGluYXRlcyxcbiAgICAgICAgeDogY3VycmVudENvb3JkaW5hdGVzLnggKyAyNVxuICAgICAgfTtcblxuICAgIGNhc2UgS2V5Ym9hcmRDb2RlLkxlZnQ6XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHg6IGN1cnJlbnRDb29yZGluYXRlcy54IC0gMjVcbiAgICAgIH07XG5cbiAgICBjYXNlIEtleWJvYXJkQ29kZS5Eb3duOlxuICAgICAgcmV0dXJuIHsgLi4uY3VycmVudENvb3JkaW5hdGVzLFxuICAgICAgICB5OiBjdXJyZW50Q29vcmRpbmF0ZXMueSArIDI1XG4gICAgICB9O1xuXG4gICAgY2FzZSBLZXlib2FyZENvZGUuVXA6XG4gICAgICByZXR1cm4geyAuLi5jdXJyZW50Q29vcmRpbmF0ZXMsXG4gICAgICAgIHk6IGN1cnJlbnRDb29yZGluYXRlcy55IC0gMjVcbiAgICAgIH07XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY2xhc3MgS2V5Ym9hcmRTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSB2b2lkIDA7XG4gICAgdGhpcy5hdXRvU2Nyb2xsRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVmZXJlbmNlQ29vcmRpbmF0ZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50OiB7XG4gICAgICAgIHRhcmdldFxuICAgICAgfVxuICAgIH0gPSBwcm9wcztcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKGdldE93bmVyRG9jdW1lbnQodGFyZ2V0KSk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKGdldFdpbmRvdyh0YXJnZXQpKTtcbiAgICB0aGlzLmhhbmRsZUtleURvd24gPSB0aGlzLmhhbmRsZUtleURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUNhbmNlbCA9IHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5hdHRhY2goKTtcbiAgfVxuXG4gIGF0dGFjaCgpIHtcbiAgICB0aGlzLmhhbmRsZVN0YXJ0KCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5SZXNpemUsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLlZpc2liaWxpdHlDaGFuZ2UsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMubGlzdGVuZXJzLmFkZChFdmVudE5hbWUuS2V5ZG93biwgdGhpcy5oYW5kbGVLZXlEb3duKSk7XG4gIH1cblxuICBoYW5kbGVTdGFydCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVOb2RlLFxuICAgICAgb25TdGFydFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IG5vZGUgPSBhY3RpdmVOb2RlLm5vZGUuY3VycmVudDtcblxuICAgIGlmIChub2RlKSB7XG4gICAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKG5vZGUpO1xuICAgIH1cblxuICAgIG9uU3RhcnQoZGVmYXVsdENvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBpZiAoaXNLZXlib2FyZEV2ZW50KGV2ZW50KSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0gPSB0aGlzLnByb3BzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlib2FyZENvZGVzID0gZGVmYXVsdEtleWJvYXJkQ29kZXMsXG4gICAgICAgIGNvb3JkaW5hdGVHZXR0ZXIgPSBkZWZhdWx0S2V5Ym9hcmRDb29yZGluYXRlR2V0dGVyLFxuICAgICAgICBzY3JvbGxCZWhhdmlvciA9ICdzbW9vdGgnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29kZVxuICAgICAgfSA9IGV2ZW50O1xuXG4gICAgICBpZiAoa2V5Ym9hcmRDb2Rlcy5lbmQuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFbmQoZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXlib2FyZENvZGVzLmNhbmNlbC5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICB0aGlzLmhhbmRsZUNhbmNlbChldmVudCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBjb2xsaXNpb25SZWN0XG4gICAgICB9ID0gY29udGV4dC5jdXJyZW50O1xuICAgICAgY29uc3QgY3VycmVudENvb3JkaW5hdGVzID0gY29sbGlzaW9uUmVjdCA/IHtcbiAgICAgICAgeDogY29sbGlzaW9uUmVjdC5sZWZ0LFxuICAgICAgICB5OiBjb2xsaXNpb25SZWN0LnRvcFxuICAgICAgfSA6IGRlZmF1bHRDb29yZGluYXRlcztcblxuICAgICAgaWYgKCF0aGlzLnJlZmVyZW5jZUNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlQ29vcmRpbmF0ZXMgPSBjdXJyZW50Q29vcmRpbmF0ZXM7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZUdldHRlcihldmVudCwge1xuICAgICAgICBhY3RpdmUsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHQuY3VycmVudCxcbiAgICAgICAgY3VycmVudENvb3JkaW5hdGVzXG4gICAgICB9KTtcblxuICAgICAgaWYgKG5ld0Nvb3JkaW5hdGVzKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzRGVsdGEgPSBzdWJ0cmFjdChuZXdDb29yZGluYXRlcywgY3VycmVudENvb3JkaW5hdGVzKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzY3JvbGxhYmxlQW5jZXN0b3JzXG4gICAgICAgIH0gPSBjb250ZXh0LmN1cnJlbnQ7XG5cbiAgICAgICAgZm9yIChjb25zdCBzY3JvbGxDb250YWluZXIgb2Ygc2Nyb2xsYWJsZUFuY2VzdG9ycykge1xuICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGV2ZW50LmNvZGU7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgaXNUb3AsXG4gICAgICAgICAgICBpc1JpZ2h0LFxuICAgICAgICAgICAgaXNMZWZ0LFxuICAgICAgICAgICAgaXNCb3R0b20sXG4gICAgICAgICAgICBtYXhTY3JvbGwsXG4gICAgICAgICAgICBtaW5TY3JvbGxcbiAgICAgICAgICB9ID0gZ2V0U2Nyb2xsUG9zaXRpb24oc2Nyb2xsQ29udGFpbmVyKTtcbiAgICAgICAgICBjb25zdCBzY3JvbGxFbGVtZW50UmVjdCA9IGdldFNjcm9sbEVsZW1lbnRSZWN0KHNjcm9sbENvbnRhaW5lcik7XG4gICAgICAgICAgY29uc3QgY2xhbXBlZENvb3JkaW5hdGVzID0ge1xuICAgICAgICAgICAgeDogTWF0aC5taW4oZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgPyBzY3JvbGxFbGVtZW50UmVjdC5yaWdodCAtIHNjcm9sbEVsZW1lbnRSZWN0LndpZHRoIC8gMiA6IHNjcm9sbEVsZW1lbnRSZWN0LnJpZ2h0LCBNYXRoLm1heChkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCA/IHNjcm9sbEVsZW1lbnRSZWN0LmxlZnQgOiBzY3JvbGxFbGVtZW50UmVjdC5sZWZ0ICsgc2Nyb2xsRWxlbWVudFJlY3Qud2lkdGggLyAyLCBuZXdDb29yZGluYXRlcy54KSksXG4gICAgICAgICAgICB5OiBNYXRoLm1pbihkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5Eb3duID8gc2Nyb2xsRWxlbWVudFJlY3QuYm90dG9tIC0gc2Nyb2xsRWxlbWVudFJlY3QuaGVpZ2h0IC8gMiA6IHNjcm9sbEVsZW1lbnRSZWN0LmJvdHRvbSwgTWF0aC5tYXgoZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biA/IHNjcm9sbEVsZW1lbnRSZWN0LnRvcCA6IHNjcm9sbEVsZW1lbnRSZWN0LnRvcCArIHNjcm9sbEVsZW1lbnRSZWN0LmhlaWdodCAvIDIsIG5ld0Nvb3JkaW5hdGVzLnkpKVxuICAgICAgICAgIH07XG4gICAgICAgICAgY29uc3QgY2FuU2Nyb2xsWCA9IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLlJpZ2h0ICYmICFpc1JpZ2h0IHx8IGRpcmVjdGlvbiA9PT0gS2V5Ym9hcmRDb2RlLkxlZnQgJiYgIWlzTGVmdDtcbiAgICAgICAgICBjb25zdCBjYW5TY3JvbGxZID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biAmJiAhaXNCb3R0b20gfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuVXAgJiYgIWlzVG9wO1xuXG4gICAgICAgICAgaWYgKGNhblNjcm9sbFggJiYgY2xhbXBlZENvb3JkaW5hdGVzLnggIT09IG5ld0Nvb3JkaW5hdGVzLngpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Njcm9sbENvb3JkaW5hdGVzID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKyBjb29yZGluYXRlc0RlbHRhLng7XG4gICAgICAgICAgICBjb25zdCBjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuUmlnaHQgJiYgbmV3U2Nyb2xsQ29vcmRpbmF0ZXMgPD0gbWF4U2Nyb2xsLnggfHwgZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuTGVmdCAmJiBuZXdTY3JvbGxDb29yZGluYXRlcyA+PSBtaW5TY3JvbGwueDtcblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgJiYgIWNvb3JkaW5hdGVzRGVsdGEueSkge1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBjb29yZGluYXRlcywgdGhlIHNjcm9sbCBhZGp1c3RtZW50IGFsb25lIHdpbGwgdHJpZ2dlclxuICAgICAgICAgICAgICAvLyBsb2dpYyB0byBhdXRvLWRldGVjdCB0aGUgbmV3IGNvbnRhaW5lciB3ZSBhcmUgb3ZlclxuICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1Njcm9sbENvb3JkaW5hdGVzLFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FuU2Nyb2xsVG9OZXdDb29yZGluYXRlcykge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS54ID0gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgLSBuZXdTY3JvbGxDb29yZGluYXRlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnggPSBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5SaWdodCA/IHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC0gbWF4U2Nyb2xsLnggOiBzY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCAtIG1pblNjcm9sbC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2Nyb2xsRGVsdGEueCkge1xuICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsQnkoe1xuICAgICAgICAgICAgICAgIGxlZnQ6IC1zY3JvbGxEZWx0YS54LFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChjYW5TY3JvbGxZICYmIGNsYW1wZWRDb29yZGluYXRlcy55ICE9PSBuZXdDb29yZGluYXRlcy55KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTY3JvbGxDb29yZGluYXRlcyA9IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgKyBjb29yZGluYXRlc0RlbHRhLnk7XG4gICAgICAgICAgICBjb25zdCBjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biAmJiBuZXdTY3JvbGxDb29yZGluYXRlcyA8PSBtYXhTY3JvbGwueSB8fCBkaXJlY3Rpb24gPT09IEtleWJvYXJkQ29kZS5VcCAmJiBuZXdTY3JvbGxDb29yZGluYXRlcyA+PSBtaW5TY3JvbGwueTtcblxuICAgICAgICAgICAgaWYgKGNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMgJiYgIWNvb3JkaW5hdGVzRGVsdGEueCkge1xuICAgICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSBjb29yZGluYXRlcywgdGhlIHNjcm9sbCBhZGp1c3RtZW50IGFsb25lIHdpbGwgdHJpZ2dlclxuICAgICAgICAgICAgICAvLyBsb2dpYyB0byBhdXRvLWRldGVjdCB0aGUgbmV3IGNvbnRhaW5lciB3ZSBhcmUgb3ZlclxuICAgICAgICAgICAgICBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICAgIHRvcDogbmV3U2Nyb2xsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgICAgICAgYmVoYXZpb3I6IHNjcm9sbEJlaGF2aW9yXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjYW5TY3JvbGxUb05ld0Nvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgIHNjcm9sbERlbHRhLnkgPSBzY3JvbGxDb250YWluZXIuc2Nyb2xsVG9wIC0gbmV3U2Nyb2xsQ29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY3JvbGxEZWx0YS55ID0gZGlyZWN0aW9uID09PSBLZXlib2FyZENvZGUuRG93biA/IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgLSBtYXhTY3JvbGwueSA6IHNjcm9sbENvbnRhaW5lci5zY3JvbGxUb3AgLSBtaW5TY3JvbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjcm9sbERlbHRhLnkpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KHtcbiAgICAgICAgICAgICAgICB0b3A6IC1zY3JvbGxEZWx0YS55LFxuICAgICAgICAgICAgICAgIGJlaGF2aW9yOiBzY3JvbGxCZWhhdmlvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2ZW50LCBhZGQoc3VidHJhY3QobmV3Q29vcmRpbmF0ZXMsIHRoaXMucmVmZXJlbmNlQ29vcmRpbmF0ZXMpLCBzY3JvbGxEZWx0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1vdmUoZXZlbnQsIGNvb3JkaW5hdGVzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb25Nb3ZlXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBvbk1vdmUoY29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaGFuZGxlRW5kKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgb25FbmRcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgb25FbmQoKTtcbiAgfVxuXG4gIGhhbmRsZUNhbmNlbChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQ2FuY2VsXG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmRldGFjaCgpO1xuICAgIG9uQ2FuY2VsKCk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gIH1cblxufVxuS2V5Ym9hcmRTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uS2V5RG93bicsXG4gIGhhbmRsZXI6IChldmVudCwgX3JlZiwgX3JlZjIpID0+IHtcbiAgICBsZXQge1xuICAgICAga2V5Ym9hcmRDb2RlcyA9IGRlZmF1bHRLZXlib2FyZENvZGVzLFxuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWY7XG4gICAgbGV0IHtcbiAgICAgIGFjdGl2ZVxuICAgIH0gPSBfcmVmMjtcbiAgICBjb25zdCB7XG4gICAgICBjb2RlXG4gICAgfSA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gICAgaWYgKGtleWJvYXJkQ29kZXMuc3RhcnQuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgIGNvbnN0IGFjdGl2YXRvciA9IGFjdGl2ZS5hY3RpdmF0b3JOb2RlLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChhY3RpdmF0b3IgJiYgZXZlbnQudGFyZ2V0ICE9PSBhY3RpdmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgICBldmVudDogZXZlbnQubmF0aXZlRXZlbnRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XTtcblxuZnVuY3Rpb24gaXNEaXN0YW5jZUNvbnN0cmFpbnQoY29uc3RyYWludCkge1xuICByZXR1cm4gQm9vbGVhbihjb25zdHJhaW50ICYmICdkaXN0YW5jZScgaW4gY29uc3RyYWludCk7XG59XG5cbmZ1bmN0aW9uIGlzRGVsYXlDb25zdHJhaW50KGNvbnN0cmFpbnQpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY29uc3RyYWludCAmJiAnZGVsYXknIGluIGNvbnN0cmFpbnQpO1xufVxuXG5jbGFzcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcywgZXZlbnRzLCBsaXN0ZW5lclRhcmdldCkge1xuICAgIHZhciBfZ2V0RXZlbnRDb29yZGluYXRlcztcblxuICAgIGlmIChsaXN0ZW5lclRhcmdldCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ZW5lclRhcmdldCA9IGdldEV2ZW50TGlzdGVuZXJUYXJnZXQocHJvcHMuZXZlbnQudGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzID0gdm9pZCAwO1xuICAgIHRoaXMuZXZlbnRzID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0b1Njcm9sbEVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuZG9jdW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxDb29yZGluYXRlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5kb2N1bWVudExpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycyA9IHZvaWQgMDtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRcbiAgICB9ID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0XG4gICAgfSA9IGV2ZW50O1xuICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cztcbiAgICB0aGlzLmRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudCh0YXJnZXQpO1xuICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKHRoaXMuZG9jdW1lbnQpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycyhsaXN0ZW5lclRhcmdldCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKGdldFdpbmRvdyh0YXJnZXQpKTtcbiAgICB0aGlzLmluaXRpYWxDb29yZGluYXRlcyA9IChfZ2V0RXZlbnRDb29yZGluYXRlcyA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpKSAhPSBudWxsID8gX2dldEV2ZW50Q29vcmRpbmF0ZXMgOiBkZWZhdWx0Q29vcmRpbmF0ZXM7XG4gICAgdGhpcy5oYW5kbGVTdGFydCA9IHRoaXMuaGFuZGxlU3RhcnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZU1vdmUgPSB0aGlzLmhhbmRsZU1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmhhbmRsZUVuZCA9IHRoaXMuaGFuZGxlRW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVDYW5jZWwgPSB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlS2V5ZG93biA9IHRoaXMuaGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVtb3ZlVGV4dFNlbGVjdGlvbiA9IHRoaXMucmVtb3ZlVGV4dFNlbGVjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXR0YWNoKCk7XG4gIH1cblxuICBhdHRhY2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXZlbnRzLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGFjdGl2YXRpb25Db25zdHJhaW50LFxuICAgICAgICAgIGJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmxpc3RlbmVycy5hZGQoZXZlbnRzLm1vdmUubmFtZSwgdGhpcy5oYW5kbGVNb3ZlLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuZXJzLmFkZChldmVudHMuZW5kLm5hbWUsIHRoaXMuaGFuZGxlRW5kKTtcblxuICAgIGlmIChldmVudHMuY2FuY2VsKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5hZGQoZXZlbnRzLmNhbmNlbC5uYW1lLCB0aGlzLmhhbmRsZUNhbmNlbCk7XG4gICAgfVxuXG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5SZXNpemUsIHRoaXMuaGFuZGxlQ2FuY2VsKTtcbiAgICB0aGlzLndpbmRvd0xpc3RlbmVycy5hZGQoRXZlbnROYW1lLkRyYWdTdGFydCwgcHJldmVudERlZmF1bHQpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuVmlzaWJpbGl0eUNoYW5nZSwgdGhpcy5oYW5kbGVDYW5jZWwpO1xuICAgIHRoaXMud2luZG93TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuQ29udGV4dE1lbnUsIHByZXZlbnREZWZhdWx0KTtcbiAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuS2V5ZG93biwgdGhpcy5oYW5kbGVLZXlkb3duKTtcblxuICAgIGlmIChhY3RpdmF0aW9uQ29uc3RyYWludCkge1xuICAgICAgaWYgKGJ5cGFzc0FjdGl2YXRpb25Db25zdHJhaW50ICE9IG51bGwgJiYgYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnQoe1xuICAgICAgICBldmVudDogdGhpcy5wcm9wcy5ldmVudCxcbiAgICAgICAgYWN0aXZlTm9kZTogdGhpcy5wcm9wcy5hY3RpdmVOb2RlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnByb3BzLm9wdGlvbnNcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlbGF5Q29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuaGFuZGxlU3RhcnQsIGFjdGl2YXRpb25Db25zdHJhaW50LmRlbGF5KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQZW5kaW5nKGFjdGl2YXRpb25Db25zdHJhaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXN0YW5jZUNvbnN0cmFpbnQoYWN0aXZhdGlvbkNvbnN0cmFpbnQpKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUGVuZGluZyhhY3RpdmF0aW9uQ29uc3RyYWludCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmhhbmRsZVN0YXJ0KCk7XG4gIH1cblxuICBkZXRhY2goKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucmVtb3ZlQWxsKCk7XG4gICAgdGhpcy53aW5kb3dMaXN0ZW5lcnMucmVtb3ZlQWxsKCk7IC8vIFdhaXQgdW50aWwgdGhlIG5leHQgZXZlbnQgbG9vcCBiZWZvcmUgcmVtb3ZpbmcgZG9jdW1lbnQgbGlzdGVuZXJzXG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBsaXN0ZW4gZm9yIGBjbGlja2AgYW5kIGBzZWxlY3Rpb25gIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcblxuICAgIHNldFRpbWVvdXQodGhpcy5kb2N1bWVudExpc3RlbmVycy5yZW1vdmVBbGwsIDUwKTtcblxuICAgIGlmICh0aGlzLnRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgIHRoaXMudGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVQZW5kaW5nKGNvbnN0cmFpbnQsIG9mZnNldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIG9uUGVuZGluZ1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIG9uUGVuZGluZyhhY3RpdmUsIGNvbnN0cmFpbnQsIHRoaXMuaW5pdGlhbENvb3JkaW5hdGVzLCBvZmZzZXQpO1xuICB9XG5cbiAgaGFuZGxlU3RhcnQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5pdGlhbENvb3JkaW5hdGVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgb25TdGFydFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKGluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlOyAvLyBTdG9wIHByb3BhZ2F0aW9uIG9mIGNsaWNrIGV2ZW50cyBvbmNlIGFjdGl2YXRpb24gY29uc3RyYWludHMgYXJlIG1ldFxuXG4gICAgICB0aGlzLmRvY3VtZW50TGlzdGVuZXJzLmFkZChFdmVudE5hbWUuQ2xpY2ssIHN0b3BQcm9wYWdhdGlvbiwge1xuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTsgLy8gUmVtb3ZlIGFueSB0ZXh0IHNlbGVjdGlvbiBmcm9tIHRoZSBkb2N1bWVudFxuXG4gICAgICB0aGlzLnJlbW92ZVRleHRTZWxlY3Rpb24oKTsgLy8gUHJldmVudCBmdXJ0aGVyIHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nXG5cbiAgICAgIHRoaXMuZG9jdW1lbnRMaXN0ZW5lcnMuYWRkKEV2ZW50TmFtZS5TZWxlY3Rpb25DaGFuZ2UsIHRoaXMucmVtb3ZlVGV4dFNlbGVjdGlvbik7XG4gICAgICBvblN0YXJ0KGluaXRpYWxDb29yZGluYXRlcyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTW92ZShldmVudCkge1xuICAgIHZhciBfZ2V0RXZlbnRDb29yZGluYXRlczI7XG5cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmF0ZWQsXG4gICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICBwcm9wc1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9uTW92ZSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYWN0aXZhdGlvbkNvbnN0cmFpbnRcbiAgICAgIH1cbiAgICB9ID0gcHJvcHM7XG5cbiAgICBpZiAoIWluaXRpYWxDb29yZGluYXRlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gKF9nZXRFdmVudENvb3JkaW5hdGVzMiA9IGdldEV2ZW50Q29vcmRpbmF0ZXMoZXZlbnQpKSAhPSBudWxsID8gX2dldEV2ZW50Q29vcmRpbmF0ZXMyIDogZGVmYXVsdENvb3JkaW5hdGVzO1xuICAgIGNvbnN0IGRlbHRhID0gc3VidHJhY3QoaW5pdGlhbENvb3JkaW5hdGVzLCBjb29yZGluYXRlcyk7IC8vIENvbnN0cmFpbnQgdmFsaWRhdGlvblxuXG4gICAgaWYgKCFhY3RpdmF0ZWQgJiYgYWN0aXZhdGlvbkNvbnN0cmFpbnQpIHtcbiAgICAgIGlmIChpc0Rpc3RhbmNlQ29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSAhPSBudWxsICYmIGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNFeGNlZWRlZERpc3RhbmNlKGRlbHRhLCBhY3RpdmF0aW9uQ29uc3RyYWludC5kaXN0YW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlbGF5Q29uc3RyYWludChhY3RpdmF0aW9uQ29uc3RyYWludCkpIHtcbiAgICAgICAgaWYgKGhhc0V4Y2VlZGVkRGlzdGFuY2UoZGVsdGEsIGFjdGl2YXRpb25Db25zdHJhaW50LnRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVDYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbmRsZVBlbmRpbmcoYWN0aXZhdGlvbkNvbnN0cmFpbnQsIGRlbHRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBvbk1vdmUoY29vcmRpbmF0ZXMpO1xuICB9XG5cbiAgaGFuZGxlRW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQWJvcnQsXG4gICAgICBvbkVuZFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKSB7XG4gICAgICBvbkFib3J0KHRoaXMucHJvcHMuYWN0aXZlKTtcbiAgICB9XG5cbiAgICBvbkVuZCgpO1xuICB9XG5cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uQWJvcnQsXG4gICAgICBvbkNhbmNlbFxuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuZGV0YWNoKCk7XG5cbiAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKSB7XG4gICAgICBvbkFib3J0KHRoaXMucHJvcHMuYWN0aXZlKTtcbiAgICB9XG5cbiAgICBvbkNhbmNlbCgpO1xuICB9XG5cbiAgaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5jb2RlID09PSBLZXlib2FyZENvZGUuRXNjKSB7XG4gICAgICB0aGlzLmhhbmRsZUNhbmNlbCgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVRleHRTZWxlY3Rpb24oKSB7XG4gICAgdmFyIF90aGlzJGRvY3VtZW50JGdldFNlbDtcblxuICAgIChfdGhpcyRkb2N1bWVudCRnZXRTZWwgPSB0aGlzLmRvY3VtZW50LmdldFNlbGVjdGlvbigpKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkZG9jdW1lbnQkZ2V0U2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICB9XG5cbn1cblxuY29uc3QgZXZlbnRzID0ge1xuICBjYW5jZWw6IHtcbiAgICBuYW1lOiAncG9pbnRlcmNhbmNlbCdcbiAgfSxcbiAgbW92ZToge1xuICAgIG5hbWU6ICdwb2ludGVybW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ3BvaW50ZXJ1cCdcbiAgfVxufTtcbmNsYXNzIFBvaW50ZXJTZW5zb3IgZXh0ZW5kcyBBYnN0cmFjdFBvaW50ZXJTZW5zb3Ige1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGV2ZW50XG4gICAgfSA9IHByb3BzOyAvLyBQb2ludGVyIGV2ZW50cyBzdG9wIGZpcmluZyBpZiB0aGUgdGFyZ2V0IGlzIHVubW91bnRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoZXJlZm9yZSB3ZSBhdHRhY2ggbGlzdGVuZXJzIHRvIHRoZSBvd25lciBkb2N1bWVudCBpbnN0ZWFkXG5cbiAgICBjb25zdCBsaXN0ZW5lclRhcmdldCA9IGdldE93bmVyRG9jdW1lbnQoZXZlbnQudGFyZ2V0KTtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzLCBsaXN0ZW5lclRhcmdldCk7XG4gIH1cblxufVxuUG9pbnRlclNlbnNvci5hY3RpdmF0b3JzID0gW3tcbiAgZXZlbnROYW1lOiAnb25Qb2ludGVyRG93bicsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuXG4gICAgaWYgKCFldmVudC5pc1ByaW1hcnkgfHwgZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQxID0ge1xuICBtb3ZlOiB7XG4gICAgbmFtZTogJ21vdXNlbW92ZSdcbiAgfSxcbiAgZW5kOiB7XG4gICAgbmFtZTogJ21vdXNldXAnXG4gIH1cbn07XG52YXIgTW91c2VCdXR0b247XG5cbihmdW5jdGlvbiAoTW91c2VCdXR0b24pIHtcbiAgTW91c2VCdXR0b25bTW91c2VCdXR0b25bXCJSaWdodENsaWNrXCJdID0gMl0gPSBcIlJpZ2h0Q2xpY2tcIjtcbn0pKE1vdXNlQnV0dG9uIHx8IChNb3VzZUJ1dHRvbiA9IHt9KSk7XG5cbmNsYXNzIE1vdXNlU2Vuc29yIGV4dGVuZHMgQWJzdHJhY3RQb2ludGVyU2Vuc29yIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcywgZXZlbnRzJDEsIGdldE93bmVyRG9jdW1lbnQocHJvcHMuZXZlbnQudGFyZ2V0KSk7XG4gIH1cblxufVxuTW91c2VTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uTW91c2VEb3duJyxcbiAgaGFuZGxlcjogKF9yZWYsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgIH0gPSBfcmVmO1xuICAgIGxldCB7XG4gICAgICBvbkFjdGl2YXRpb25cbiAgICB9ID0gX3JlZjI7XG5cbiAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBNb3VzZUJ1dHRvbi5SaWdodENsaWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbmNvbnN0IGV2ZW50cyQyID0ge1xuICBjYW5jZWw6IHtcbiAgICBuYW1lOiAndG91Y2hjYW5jZWwnXG4gIH0sXG4gIG1vdmU6IHtcbiAgICBuYW1lOiAndG91Y2htb3ZlJ1xuICB9LFxuICBlbmQ6IHtcbiAgICBuYW1lOiAndG91Y2hlbmQnXG4gIH1cbn07XG5jbGFzcyBUb3VjaFNlbnNvciBleHRlbmRzIEFic3RyYWN0UG9pbnRlclNlbnNvciB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMsIGV2ZW50cyQyKTtcbiAgfVxuXG4gIHN0YXRpYyBzZXR1cCgpIHtcbiAgICAvLyBBZGRpbmcgYSBub24tY2FwdHVyZSBhbmQgbm9uLXBhc3NpdmUgYHRvdWNobW92ZWAgbGlzdGVuZXIgaW4gb3JkZXJcbiAgICAvLyB0byBmb3JjZSBgZXZlbnQucHJldmVudERlZmF1bHQoKWAgY2FsbHMgdG8gd29yayBpbiBkeW5hbWljYWxseSBhZGRlZFxuICAgIC8vIHRvdWNobW92ZSBldmVudCBoYW5kbGVycy4gVGhpcyBpcyByZXF1aXJlZCBmb3IgaU9TIFNhZmFyaS5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudHMkMi5tb3ZlLm5hbWUsIG5vb3AsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdGVhcmRvd24oKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudHMkMi5tb3ZlLm5hbWUsIG5vb3ApO1xuICAgIH07IC8vIFdlIGNyZWF0ZSBhIG5ldyBoYW5kbGVyIGJlY2F1c2UgdGhlIHRlYXJkb3duIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2Vuc29yXG4gICAgLy8gY291bGQgcmVtb3ZlIG91ciBldmVudCBsaXN0ZW5lciBpZiB3ZSB1c2UgYSByZWZlcmVudGlhbGx5IGVxdWFsIGxpc3RlbmVyLlxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHt9XG4gIH1cblxufVxuVG91Y2hTZW5zb3IuYWN0aXZhdG9ycyA9IFt7XG4gIGV2ZW50TmFtZTogJ29uVG91Y2hTdGFydCcsXG4gIGhhbmRsZXI6IChfcmVmLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBuYXRpdmVFdmVudDogZXZlbnRcbiAgICB9ID0gX3JlZjtcbiAgICBsZXQge1xuICAgICAgb25BY3RpdmF0aW9uXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IHtcbiAgICAgIHRvdWNoZXNcbiAgICB9ID0gZXZlbnQ7XG5cbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb25BY3RpdmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBvbkFjdGl2YXRpb24oe1xuICAgICAgZXZlbnRcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufV07XG5cbnZhciBBdXRvU2Nyb2xsQWN0aXZhdG9yO1xuXG4oZnVuY3Rpb24gKEF1dG9TY3JvbGxBY3RpdmF0b3IpIHtcbiAgQXV0b1Njcm9sbEFjdGl2YXRvcltBdXRvU2Nyb2xsQWN0aXZhdG9yW1wiUG9pbnRlclwiXSA9IDBdID0gXCJQb2ludGVyXCI7XG4gIEF1dG9TY3JvbGxBY3RpdmF0b3JbQXV0b1Njcm9sbEFjdGl2YXRvcltcIkRyYWdnYWJsZVJlY3RcIl0gPSAxXSA9IFwiRHJhZ2dhYmxlUmVjdFwiO1xufSkoQXV0b1Njcm9sbEFjdGl2YXRvciB8fCAoQXV0b1Njcm9sbEFjdGl2YXRvciA9IHt9KSk7XG5cbnZhciBUcmF2ZXJzYWxPcmRlcjtcblxuKGZ1bmN0aW9uIChUcmF2ZXJzYWxPcmRlcikge1xuICBUcmF2ZXJzYWxPcmRlcltUcmF2ZXJzYWxPcmRlcltcIlRyZWVPcmRlclwiXSA9IDBdID0gXCJUcmVlT3JkZXJcIjtcbiAgVHJhdmVyc2FsT3JkZXJbVHJhdmVyc2FsT3JkZXJbXCJSZXZlcnNlZFRyZWVPcmRlclwiXSA9IDFdID0gXCJSZXZlcnNlZFRyZWVPcmRlclwiO1xufSkoVHJhdmVyc2FsT3JkZXIgfHwgKFRyYXZlcnNhbE9yZGVyID0ge30pKTtcblxuZnVuY3Rpb24gdXNlQXV0b1Njcm9sbGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBhY2NlbGVyYXRpb24sXG4gICAgYWN0aXZhdG9yID0gQXV0b1Njcm9sbEFjdGl2YXRvci5Qb2ludGVyLFxuICAgIGNhblNjcm9sbCxcbiAgICBkcmFnZ2luZ1JlY3QsXG4gICAgZW5hYmxlZCxcbiAgICBpbnRlcnZhbCA9IDUsXG4gICAgb3JkZXIgPSBUcmF2ZXJzYWxPcmRlci5UcmVlT3JkZXIsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsXG4gICAgZGVsdGEsXG4gICAgdGhyZXNob2xkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzY3JvbGxJbnRlbnQgPSB1c2VTY3JvbGxJbnRlbnQoe1xuICAgIGRlbHRhLFxuICAgIGRpc2FibGVkOiAhZW5hYmxlZFxuICB9KTtcbiAgY29uc3QgW3NldEF1dG9TY3JvbGxJbnRlcnZhbCwgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWxdID0gdXNlSW50ZXJ2YWwoKTtcbiAgY29uc3Qgc2Nyb2xsU3BlZWQgPSBSZWFjdC51c2VSZWYoe1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9KTtcbiAgY29uc3Qgc2Nyb2xsRGlyZWN0aW9uID0gUmVhY3QudXNlUmVmKHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfSk7XG4gIGNvbnN0IHJlY3QgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBzd2l0Y2ggKGFjdGl2YXRvcikge1xuICAgICAgY2FzZSBBdXRvU2Nyb2xsQWN0aXZhdG9yLlBvaW50ZXI6XG4gICAgICAgIHJldHVybiBwb2ludGVyQ29vcmRpbmF0ZXMgPyB7XG4gICAgICAgICAgdG9wOiBwb2ludGVyQ29vcmRpbmF0ZXMueSxcbiAgICAgICAgICBib3R0b206IHBvaW50ZXJDb29yZGluYXRlcy55LFxuICAgICAgICAgIGxlZnQ6IHBvaW50ZXJDb29yZGluYXRlcy54LFxuICAgICAgICAgIHJpZ2h0OiBwb2ludGVyQ29vcmRpbmF0ZXMueFxuICAgICAgICB9IDogbnVsbDtcblxuICAgICAgY2FzZSBBdXRvU2Nyb2xsQWN0aXZhdG9yLkRyYWdnYWJsZVJlY3Q6XG4gICAgICAgIHJldHVybiBkcmFnZ2luZ1JlY3Q7XG4gICAgfVxuICB9LCBbYWN0aXZhdG9yLCBkcmFnZ2luZ1JlY3QsIHBvaW50ZXJDb29yZGluYXRlc10pO1xuICBjb25zdCBzY3JvbGxDb250YWluZXJSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGF1dG9TY3JvbGwgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyID0gc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoIXNjcm9sbENvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbExlZnQgPSBzY3JvbGxTcGVlZC5jdXJyZW50LnggKiBzY3JvbGxEaXJlY3Rpb24uY3VycmVudC54O1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHNjcm9sbFNwZWVkLmN1cnJlbnQueSAqIHNjcm9sbERpcmVjdGlvbi5jdXJyZW50Lnk7XG4gICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEJ5KHNjcm9sbExlZnQsIHNjcm9sbFRvcCk7XG4gIH0sIFtdKTtcbiAgY29uc3Qgc29ydGVkU2Nyb2xsYWJsZUFuY2VzdG9ycyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gb3JkZXIgPT09IFRyYXZlcnNhbE9yZGVyLlRyZWVPcmRlciA/IFsuLi5zY3JvbGxhYmxlQW5jZXN0b3JzXS5yZXZlcnNlKCkgOiBzY3JvbGxhYmxlQW5jZXN0b3JzLCBbb3JkZXIsIHNjcm9sbGFibGVBbmNlc3RvcnNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQgfHwgIXNjcm9sbGFibGVBbmNlc3RvcnMubGVuZ3RoIHx8ICFyZWN0KSB7XG4gICAgICBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc2Nyb2xsQ29udGFpbmVyIG9mIHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMpIHtcbiAgICAgIGlmICgoY2FuU2Nyb2xsID09IG51bGwgPyB2b2lkIDAgOiBjYW5TY3JvbGwoc2Nyb2xsQ29udGFpbmVyKSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbmRleCA9IHNjcm9sbGFibGVBbmNlc3RvcnMuaW5kZXhPZihzY3JvbGxDb250YWluZXIpO1xuICAgICAgY29uc3Qgc2Nyb2xsQ29udGFpbmVyUmVjdCA9IHNjcm9sbGFibGVBbmNlc3RvclJlY3RzW2luZGV4XTtcblxuICAgICAgaWYgKCFzY3JvbGxDb250YWluZXJSZWN0KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc3BlZWRcbiAgICAgIH0gPSBnZXRTY3JvbGxEaXJlY3Rpb25BbmRTcGVlZChzY3JvbGxDb250YWluZXIsIHNjcm9sbENvbnRhaW5lclJlY3QsIHJlY3QsIGFjY2VsZXJhdGlvbiwgdGhyZXNob2xkKTtcblxuICAgICAgZm9yIChjb25zdCBheGlzIG9mIFsneCcsICd5J10pIHtcbiAgICAgICAgaWYgKCFzY3JvbGxJbnRlbnRbYXhpc11bZGlyZWN0aW9uW2F4aXNdXSkge1xuICAgICAgICAgIHNwZWVkW2F4aXNdID0gMDtcbiAgICAgICAgICBkaXJlY3Rpb25bYXhpc10gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGVlZC54ID4gMCB8fCBzcGVlZC55ID4gMCkge1xuICAgICAgICBjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCgpO1xuICAgICAgICBzY3JvbGxDb250YWluZXJSZWYuY3VycmVudCA9IHNjcm9sbENvbnRhaW5lcjtcbiAgICAgICAgc2V0QXV0b1Njcm9sbEludGVydmFsKGF1dG9TY3JvbGwsIGludGVydmFsKTtcbiAgICAgICAgc2Nyb2xsU3BlZWQuY3VycmVudCA9IHNwZWVkO1xuICAgICAgICBzY3JvbGxEaXJlY3Rpb24uY3VycmVudCA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNjcm9sbFNwZWVkLmN1cnJlbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgc2Nyb2xsRGlyZWN0aW9uLmN1cnJlbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgY2xlYXJBdXRvU2Nyb2xsSW50ZXJ2YWwoKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbYWNjZWxlcmF0aW9uLCBhdXRvU2Nyb2xsLCBjYW5TY3JvbGwsIGNsZWFyQXV0b1Njcm9sbEludGVydmFsLCBlbmFibGVkLCBpbnRlcnZhbCwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeShyZWN0KSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBKU09OLnN0cmluZ2lmeShzY3JvbGxJbnRlbnQpLCBzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwsIHNjcm9sbGFibGVBbmNlc3RvcnMsIHNvcnRlZFNjcm9sbGFibGVBbmNlc3RvcnMsIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIEpTT04uc3RyaW5naWZ5KHRocmVzaG9sZCldKTtcbn1cbmNvbnN0IGRlZmF1bHRTY3JvbGxJbnRlbnQgPSB7XG4gIHg6IHtcbiAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogZmFsc2UsXG4gICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogZmFsc2VcbiAgfSxcbiAgeToge1xuICAgIFtEaXJlY3Rpb24uQmFja3dhcmRdOiBmYWxzZSxcbiAgICBbRGlyZWN0aW9uLkZvcndhcmRdOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiB1c2VTY3JvbGxJbnRlbnQoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBkZWx0YSxcbiAgICBkaXNhYmxlZFxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHByZXZpb3VzRGVsdGEgPSB1c2VQcmV2aW91cyhkZWx0YSk7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhwcmV2aW91c0ludGVudCA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICFwcmV2aW91c0RlbHRhIHx8ICFwcmV2aW91c0ludGVudCkge1xuICAgICAgLy8gUmVzZXQgc2Nyb2xsIGludGVudCB0cmFja2luZyB3aGVuIGF1dG8tc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG4gICAgICByZXR1cm4gZGVmYXVsdFNjcm9sbEludGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB7XG4gICAgICB4OiBNYXRoLnNpZ24oZGVsdGEueCAtIHByZXZpb3VzRGVsdGEueCksXG4gICAgICB5OiBNYXRoLnNpZ24oZGVsdGEueSAtIHByZXZpb3VzRGVsdGEueSlcbiAgICB9OyAvLyBLZWVwIHRyYWNrIG9mIHRoZSB1c2VyIGludGVudCB0byBzY3JvbGwgaW4gZWFjaCBkaXJlY3Rpb24gZm9yIGJvdGggYXhpc1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgW0RpcmVjdGlvbi5CYWNrd2FyZF06IHByZXZpb3VzSW50ZW50LnhbRGlyZWN0aW9uLkJhY2t3YXJkXSB8fCBkaXJlY3Rpb24ueCA9PT0gLTEsXG4gICAgICAgIFtEaXJlY3Rpb24uRm9yd2FyZF06IHByZXZpb3VzSW50ZW50LnhbRGlyZWN0aW9uLkZvcndhcmRdIHx8IGRpcmVjdGlvbi54ID09PSAxXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBbRGlyZWN0aW9uLkJhY2t3YXJkXTogcHJldmlvdXNJbnRlbnQueVtEaXJlY3Rpb24uQmFja3dhcmRdIHx8IGRpcmVjdGlvbi55ID09PSAtMSxcbiAgICAgICAgW0RpcmVjdGlvbi5Gb3J3YXJkXTogcHJldmlvdXNJbnRlbnQueVtEaXJlY3Rpb24uRm9yd2FyZF0gfHwgZGlyZWN0aW9uLnkgPT09IDFcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGRlbHRhLCBwcmV2aW91c0RlbHRhXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUNhY2hlZE5vZGUoZHJhZ2dhYmxlTm9kZXMsIGlkKSB7XG4gIGNvbnN0IGRyYWdnYWJsZU5vZGUgPSBpZCAhPSBudWxsID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKSA6IHVuZGVmaW5lZDtcbiAgY29uc3Qgbm9kZSA9IGRyYWdnYWJsZU5vZGUgPyBkcmFnZ2FibGVOb2RlLm5vZGUuY3VycmVudCA6IG51bGw7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhjYWNoZWROb2RlID0+IHtcbiAgICB2YXIgX3JlZjtcblxuICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEluIHNvbWUgY2FzZXMsIHRoZSBkcmFnZ2FibGUgbm9kZSBjYW4gdW5tb3VudCB3aGlsZSBkcmFnZ2luZ1xuICAgIC8vIFRoaXMgaXMgdGhlIGNhc2UgZm9yIHZpcnR1YWxpemVkIGxpc3RzLiBJbiB0aG9zZSBzaXR1YXRpb25zLFxuICAgIC8vIHdlIGZhbGwgYmFjayB0byB0aGUgbGFzdCBrbm93biB2YWx1ZSBmb3IgdGhhdCBub2RlLlxuXG5cbiAgICByZXR1cm4gKF9yZWYgPSBub2RlICE9IG51bGwgPyBub2RlIDogY2FjaGVkTm9kZSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICB9LCBbbm9kZSwgaWRdKTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZUFjdGl2YXRvcnMoc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcikge1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBzZW5zb3JzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHNlbnNvcikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlbnNvcjogU2Vuc29yXG4gICAgfSA9IHNlbnNvcjtcbiAgICBjb25zdCBzZW5zb3JBY3RpdmF0b3JzID0gU2Vuc29yLmFjdGl2YXRvcnMubWFwKGFjdGl2YXRvciA9PiAoe1xuICAgICAgZXZlbnROYW1lOiBhY3RpdmF0b3IuZXZlbnROYW1lLFxuICAgICAgaGFuZGxlcjogZ2V0U3ludGhldGljSGFuZGxlcihhY3RpdmF0b3IuaGFuZGxlciwgc2Vuc29yKVxuICAgIH0pKTtcbiAgICByZXR1cm4gWy4uLmFjY3VtdWxhdG9yLCAuLi5zZW5zb3JBY3RpdmF0b3JzXTtcbiAgfSwgW10pLCBbc2Vuc29ycywgZ2V0U3ludGhldGljSGFuZGxlcl0pO1xufVxuXG52YXIgTWVhc3VyaW5nU3RyYXRlZ3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nU3RyYXRlZ3kpIHtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJBbHdheXNcIl0gPSAwXSA9IFwiQWx3YXlzXCI7XG4gIE1lYXN1cmluZ1N0cmF0ZWd5W01lYXN1cmluZ1N0cmF0ZWd5W1wiQmVmb3JlRHJhZ2dpbmdcIl0gPSAxXSA9IFwiQmVmb3JlRHJhZ2dpbmdcIjtcbiAgTWVhc3VyaW5nU3RyYXRlZ3lbTWVhc3VyaW5nU3RyYXRlZ3lbXCJXaGlsZURyYWdnaW5nXCJdID0gMl0gPSBcIldoaWxlRHJhZ2dpbmdcIjtcbn0pKE1lYXN1cmluZ1N0cmF0ZWd5IHx8IChNZWFzdXJpbmdTdHJhdGVneSA9IHt9KSk7XG5cbnZhciBNZWFzdXJpbmdGcmVxdWVuY3k7XG5cbihmdW5jdGlvbiAoTWVhc3VyaW5nRnJlcXVlbmN5KSB7XG4gIE1lYXN1cmluZ0ZyZXF1ZW5jeVtcIk9wdGltaXplZFwiXSA9IFwib3B0aW1pemVkXCI7XG59KShNZWFzdXJpbmdGcmVxdWVuY3kgfHwgKE1lYXN1cmluZ0ZyZXF1ZW5jeSA9IHt9KSk7XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSA9IC8qI19fUFVSRV9fKi9uZXcgTWFwKCk7XG5mdW5jdGlvbiB1c2VEcm9wcGFibGVNZWFzdXJpbmcoY29udGFpbmVycywgX3JlZikge1xuICBsZXQge1xuICAgIGRyYWdnaW5nLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBjb25maWdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtxdWV1ZSwgc2V0UXVldWVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHtcbiAgICBmcmVxdWVuY3ksXG4gICAgbWVhc3VyZSxcbiAgICBzdHJhdGVneVxuICB9ID0gY29uZmlnO1xuICBjb25zdCBjb250YWluZXJzUmVmID0gUmVhY3QudXNlUmVmKGNvbnRhaW5lcnMpO1xuICBjb25zdCBkaXNhYmxlZCA9IGlzRGlzYWJsZWQoKTtcbiAgY29uc3QgZGlzYWJsZWRSZWYgPSB1c2VMYXRlc3RWYWx1ZShkaXNhYmxlZCk7XG4gIGNvbnN0IG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKGlkcykge1xuICAgIGlmIChpZHMgPT09IHZvaWQgMCkge1xuICAgICAgaWRzID0gW107XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRRdWV1ZSh2YWx1ZSA9PiB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlLmNvbmNhdChpZHMuZmlsdGVyKGlkID0+ICF2YWx1ZS5pbmNsdWRlcyhpZCkpKTtcbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkUmVmXSk7XG4gIGNvbnN0IHRpbWVvdXRJZCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZHJvcHBhYmxlUmVjdHMgPSB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgJiYgIWRyYWdnaW5nKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIGlmICghcHJldmlvdXNWYWx1ZSB8fCBwcmV2aW91c1ZhbHVlID09PSBkZWZhdWx0VmFsdWUgfHwgY29udGFpbmVyc1JlZi5jdXJyZW50ICE9PSBjb250YWluZXJzIHx8IHF1ZXVlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcblxuICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChxdWV1ZSAmJiBxdWV1ZS5sZW5ndGggPiAwICYmICFxdWV1ZS5pbmNsdWRlcyhjb250YWluZXIuaWQpICYmIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbnRhaW5lciBkb2VzIG5vdCBuZWVkIHRvIGJlIHJlLW1lYXN1cmVkXG4gICAgICAgICAgbWFwLnNldChjb250YWluZXIuaWQsIGNvbnRhaW5lci5yZWN0LmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm9kZSA9IGNvbnRhaW5lci5ub2RlLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBub2RlID8gbmV3IFJlY3QobWVhc3VyZShub2RlKSwgbm9kZSkgOiBudWxsO1xuICAgICAgICBjb250YWluZXIucmVjdC5jdXJyZW50ID0gcmVjdDtcblxuICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgIG1hcC5zZXQoY29udGFpbmVyLmlkLCByZWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFwO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICB9LCBbY29udGFpbmVycywgcXVldWUsIGRyYWdnaW5nLCBkaXNhYmxlZCwgbWVhc3VyZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnRhaW5lcnNSZWYuY3VycmVudCA9IGNvbnRhaW5lcnM7XG4gIH0sIFtjb250YWluZXJzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dpbmcsIGRpc2FibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHF1ZXVlICYmIHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHNldFF1ZXVlKG51bGwpO1xuICAgIH1cbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtKU09OLnN0cmluZ2lmeShxdWV1ZSldKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgdHlwZW9mIGZyZXF1ZW5jeSAhPT0gJ251bWJlcicgfHwgdGltZW91dElkLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lb3V0SWQuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMoKTtcbiAgICAgIHRpbWVvdXRJZC5jdXJyZW50ID0gbnVsbDtcbiAgICB9LCBmcmVxdWVuY3kpO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtmcmVxdWVuY3ksIGRpc2FibGVkLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgLi4uZGVwZW5kZW5jaWVzXSk7XG4gIHJldHVybiB7XG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nU2NoZWR1bGVkOiBxdWV1ZSAhPSBudWxsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEaXNhYmxlZCgpIHtcbiAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkFsd2F5czpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBjYXNlIE1lYXN1cmluZ1N0cmF0ZWd5LkJlZm9yZURyYWdnaW5nOlxuICAgICAgICByZXR1cm4gZHJhZ2dpbmc7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAhZHJhZ2dpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxWYWx1ZSh2YWx1ZSwgY29tcHV0ZUZuKSB7XG4gIHJldHVybiB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGVvZiBjb21wdXRlRm4gPT09ICdmdW5jdGlvbicgPyBjb21wdXRlRm4odmFsdWUpIDogdmFsdWU7XG4gIH0sIFtjb21wdXRlRm4sIHZhbHVlXSk7XG59XG5cbmZ1bmN0aW9uIHVzZUluaXRpYWxSZWN0KG5vZGUsIG1lYXN1cmUpIHtcbiAgcmV0dXJuIHVzZUluaXRpYWxWYWx1ZShub2RlLCBtZWFzdXJlKTtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgYSBuZXcgTXV0YXRpb25PYnNlcnZlciBpbnN0YW5jZS5cclxuICogSWYgYE11dGF0aW9uT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2ssXG4gICAgZGlzYWJsZWRcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGhhbmRsZU11dGF0aW9ucyA9IHVzZUV2ZW50KGNhbGxiYWNrKTtcbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIE11dGF0aW9uT2JzZXJ2ZXJcbiAgICB9ID0gd2luZG93O1xuICAgIHJldHVybiBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVNdXRhdGlvbnMpO1xuICB9LCBbaGFuZGxlTXV0YXRpb25zLCBkaXNhYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfSwgW211dGF0aW9uT2JzZXJ2ZXJdKTtcbiAgcmV0dXJuIG11dGF0aW9uT2JzZXJ2ZXI7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIGEgbmV3IFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIGJvdW5kIHRvIHRoZSBgb25SZXNpemVgIGNhbGxiYWNrLlxyXG4gKiBJZiBgUmVzaXplT2JzZXJ2ZXJgIGlzIHVuZGVmaW5lZCBpbiB0aGUgZXhlY3V0aW9uIGVudmlyb25tZW50LCByZXR1cm5zIGB1bmRlZmluZWRgLlxyXG4gKi9cblxuZnVuY3Rpb24gdXNlUmVzaXplT2JzZXJ2ZXIoX3JlZikge1xuICBsZXQge1xuICAgIGNhbGxiYWNrLFxuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSB1c2VFdmVudChjYWxsYmFjayk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGRpc2FibGVkIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuUmVzaXplT2JzZXJ2ZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIFJlc2l6ZU9ic2VydmVyXG4gICAgfSA9IHdpbmRvdztcbiAgICByZXR1cm4gbmV3IFJlc2l6ZU9ic2VydmVyKGhhbmRsZVJlc2l6ZSk7XG4gIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2Rpc2FibGVkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRNZWFzdXJlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBSZWN0KGdldENsaWVudFJlY3QoZWxlbWVudCksIGVsZW1lbnQpO1xufVxuXG5mdW5jdGlvbiB1c2VSZWN0KGVsZW1lbnQsIG1lYXN1cmUsIGZhbGxiYWNrUmVjdCkge1xuICBpZiAobWVhc3VyZSA9PT0gdm9pZCAwKSB7XG4gICAgbWVhc3VyZSA9IGRlZmF1bHRNZWFzdXJlO1xuICB9XG5cbiAgY29uc3QgW3JlY3QsIHNldFJlY3RdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG5cbiAgZnVuY3Rpb24gbWVhc3VyZVJlY3QoKSB7XG4gICAgc2V0UmVjdChjdXJyZW50UmVjdCA9PiB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LmlzQ29ubmVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgX3JlZjtcblxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gbGFzdCByZWN0IHdlIG1lYXN1cmVkIGlmIHRoZSBlbGVtZW50IGlzXG4gICAgICAgIC8vIG5vIGxvbmdlciBjb25uZWN0ZWQgdG8gdGhlIERPTS5cbiAgICAgICAgcmV0dXJuIChfcmVmID0gY3VycmVudFJlY3QgIT0gbnVsbCA/IGN1cnJlbnRSZWN0IDogZmFsbGJhY2tSZWN0KSAhPSBudWxsID8gX3JlZiA6IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1JlY3QgPSBtZWFzdXJlKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoY3VycmVudFJlY3QpID09PSBKU09OLnN0cmluZ2lmeShuZXdSZWN0KSkge1xuICAgICAgICByZXR1cm4gY3VycmVudFJlY3Q7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdSZWN0O1xuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbXV0YXRpb25PYnNlcnZlciA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrKHJlY29yZHMpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHJlY29yZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0gPSByZWNvcmQ7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaGlsZExpc3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIHRhcmdldC5jb250YWlucyhlbGVtZW50KSkge1xuICAgICAgICAgIG1lYXN1cmVSZWN0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gdXNlUmVzaXplT2JzZXJ2ZXIoe1xuICAgIGNhbGxiYWNrOiBtZWFzdXJlUmVjdFxuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgbWVhc3VyZVJlY3QoKTtcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG11dGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudC5ib2R5LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBtdXRhdGlvbk9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiBtdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH0sIFtlbGVtZW50XSk7XG4gIHJldHVybiByZWN0O1xufVxuXG5mdW5jdGlvbiB1c2VSZWN0RGVsdGEocmVjdCkge1xuICBjb25zdCBpbml0aWFsUmVjdCA9IHVzZUluaXRpYWxWYWx1ZShyZWN0KTtcbiAgcmV0dXJuIGdldFJlY3REZWx0YShyZWN0LCBpbml0aWFsUmVjdCk7XG59XG5cbmNvbnN0IGRlZmF1bHRWYWx1ZSQxID0gW107XG5mdW5jdGlvbiB1c2VTY3JvbGxhYmxlQW5jZXN0b3JzKG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNOb2RlID0gUmVhY3QudXNlUmVmKG5vZGUpO1xuICBjb25zdCBhbmNlc3RvcnMgPSB1c2VMYXp5TWVtbyhwcmV2aW91c1ZhbHVlID0+IHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWUkMTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNWYWx1ZSAmJiBwcmV2aW91c1ZhbHVlICE9PSBkZWZhdWx0VmFsdWUkMSAmJiBub2RlICYmIHByZXZpb3VzTm9kZS5jdXJyZW50ICYmIG5vZGUucGFyZW50Tm9kZSA9PT0gcHJldmlvdXNOb2RlLmN1cnJlbnQucGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFNjcm9sbGFibGVBbmNlc3RvcnMobm9kZSk7XG4gIH0sIFtub2RlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJldmlvdXNOb2RlLmN1cnJlbnQgPSBub2RlO1xuICB9LCBbbm9kZV0pO1xuICByZXR1cm4gYW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiB1c2VTY3JvbGxPZmZzZXRzKGVsZW1lbnRzKSB7XG4gIGNvbnN0IFtzY3JvbGxDb29yZGluYXRlcywgc2V0U2Nyb2xsQ29vcmRpbmF0ZXNdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHByZXZFbGVtZW50cyA9IFJlYWN0LnVzZVJlZihlbGVtZW50cyk7IC8vIFRvLWRvOiBUaHJvdHRsZSB0aGUgaGFuZGxlU2Nyb2xsIGNhbGxiYWNrXG5cbiAgY29uc3QgaGFuZGxlU2Nyb2xsID0gUmVhY3QudXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNjcm9sbGluZ0VsZW1lbnQgPSBnZXRTY3JvbGxhYmxlRWxlbWVudChldmVudC50YXJnZXQpO1xuXG4gICAgaWYgKCFzY3JvbGxpbmdFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0U2Nyb2xsQ29vcmRpbmF0ZXMoc2Nyb2xsQ29vcmRpbmF0ZXMgPT4ge1xuICAgICAgaWYgKCFzY3JvbGxDb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsQ29vcmRpbmF0ZXMuc2V0KHNjcm9sbGluZ0VsZW1lbnQsIGdldFNjcm9sbENvb3JkaW5hdGVzKHNjcm9sbGluZ0VsZW1lbnQpKTtcbiAgICAgIHJldHVybiBuZXcgTWFwKHNjcm9sbENvb3JkaW5hdGVzKTtcbiAgICB9KTtcbiAgfSwgW10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzRWxlbWVudHMgPSBwcmV2RWxlbWVudHMuY3VycmVudDtcblxuICAgIGlmIChlbGVtZW50cyAhPT0gcHJldmlvdXNFbGVtZW50cykge1xuICAgICAgY2xlYW51cChwcmV2aW91c0VsZW1lbnRzKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKHNjcm9sbGFibGVFbGVtZW50KSB7XG4gICAgICAgICAgc2Nyb2xsYWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlU2Nyb2xsLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIFtzY3JvbGxhYmxlRWxlbWVudCwgZ2V0U2Nyb2xsQ29vcmRpbmF0ZXMoc2Nyb2xsYWJsZUVsZW1lbnQpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSkuZmlsdGVyKGVudHJ5ID0+IGVudHJ5ICE9IG51bGwpO1xuICAgICAgc2V0U2Nyb2xsQ29vcmRpbmF0ZXMoZW50cmllcy5sZW5ndGggPyBuZXcgTWFwKGVudHJpZXMpIDogbnVsbCk7XG4gICAgICBwcmV2RWxlbWVudHMuY3VycmVudCA9IGVsZW1lbnRzO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwKGVsZW1lbnRzKTtcbiAgICAgIGNsZWFudXAocHJldmlvdXNFbGVtZW50cyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNsZWFudXAoZWxlbWVudHMpIHtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHNjcm9sbGFibGVFbGVtZW50ID0gZ2V0U2Nyb2xsYWJsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIHNjcm9sbGFibGVFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxhYmxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVTY3JvbGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbaGFuZGxlU2Nyb2xsLCBlbGVtZW50c10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNjcm9sbENvb3JkaW5hdGVzID8gQXJyYXkuZnJvbShzY3JvbGxDb29yZGluYXRlcy52YWx1ZXMoKSkucmVkdWNlKChhY2MsIGNvb3JkaW5hdGVzKSA9PiBhZGQoYWNjLCBjb29yZGluYXRlcyksIGRlZmF1bHRDb29yZGluYXRlcykgOiBnZXRTY3JvbGxPZmZzZXRzKGVsZW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdENvb3JkaW5hdGVzO1xuICB9LCBbZWxlbWVudHMsIHNjcm9sbENvb3JkaW5hdGVzXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzLCBkZXBlbmRlbmNpZXMpIHtcbiAgaWYgKGRlcGVuZGVuY2llcyA9PT0gdm9pZCAwKSB7XG4gICAgZGVwZW5kZW5jaWVzID0gW107XG4gIH1cblxuICBjb25zdCBpbml0aWFsU2Nyb2xsT2Zmc2V0cyA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50ID0gbnVsbDtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBkZXBlbmRlbmNpZXMpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhc1Njcm9sbE9mZnNldHMgPSBzY3JvbGxPZmZzZXRzICE9PSBkZWZhdWx0Q29vcmRpbmF0ZXM7XG5cbiAgICBpZiAoaGFzU2Nyb2xsT2Zmc2V0cyAmJiAhaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCkge1xuICAgICAgaW5pdGlhbFNjcm9sbE9mZnNldHMuY3VycmVudCA9IHNjcm9sbE9mZnNldHM7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNTY3JvbGxPZmZzZXRzICYmIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQpIHtcbiAgICAgIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW3Njcm9sbE9mZnNldHNdKTtcbiAgcmV0dXJuIGluaXRpYWxTY3JvbGxPZmZzZXRzLmN1cnJlbnQgPyBzdWJ0cmFjdChzY3JvbGxPZmZzZXRzLCBpbml0aWFsU2Nyb2xsT2Zmc2V0cy5jdXJyZW50KSA6IGRlZmF1bHRDb29yZGluYXRlcztcbn1cblxuZnVuY3Rpb24gdXNlU2Vuc29yU2V0dXAoc2Vuc29ycykge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY2FuVXNlRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGVhcmRvd25GbnMgPSBzZW5zb3JzLm1hcChfcmVmID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIHNlbnNvclxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gc2Vuc29yLnNldHVwID09IG51bGwgPyB2b2lkIDAgOiBzZW5zb3Iuc2V0dXAoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCB0ZWFyZG93biBvZiB0ZWFyZG93bkZucykge1xuICAgICAgICB0ZWFyZG93biA9PSBudWxsID8gdm9pZCAwIDogdGVhcmRvd24oKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBUTy1ETzogU2Vuc29ycyBsZW5ndGggY291bGQgdGhlb3JldGljYWxseSBjaGFuZ2Ugd2hpY2ggd291bGQgbm90IGJlIGEgdmFsaWQgZGVwZW5kZW5jeVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIHNlbnNvcnMubWFwKF9yZWYyID0+IHtcbiAgICBsZXQge1xuICAgICAgc2Vuc29yXG4gICAgfSA9IF9yZWYyO1xuICAgIHJldHVybiBzZW5zb3I7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gdXNlU3ludGhldGljTGlzdGVuZXJzKGxpc3RlbmVycywgaWQpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBsaXN0ZW5lcnMucmVkdWNlKChhY2MsIF9yZWYpID0+IHtcbiAgICAgIGxldCB7XG4gICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgaGFuZGxlclxuICAgICAgfSA9IF9yZWY7XG5cbiAgICAgIGFjY1tldmVudE5hbWVdID0gZXZlbnQgPT4ge1xuICAgICAgICBoYW5kbGVyKGV2ZW50LCBpZCk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgfSwgW2xpc3RlbmVycywgaWRdKTtcbn1cblxuZnVuY3Rpb24gdXNlV2luZG93UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVsZW1lbnQgPyBnZXRXaW5kb3dDbGllbnRSZWN0KGVsZW1lbnQpIDogbnVsbCwgW2VsZW1lbnRdKTtcbn1cblxuY29uc3QgZGVmYXVsdFZhbHVlJDIgPSBbXTtcbmZ1bmN0aW9uIHVzZVJlY3RzKGVsZW1lbnRzLCBtZWFzdXJlKSB7XG4gIGlmIChtZWFzdXJlID09PSB2b2lkIDApIHtcbiAgICBtZWFzdXJlID0gZ2V0Q2xpZW50UmVjdDtcbiAgfVxuXG4gIGNvbnN0IFtmaXJzdEVsZW1lbnRdID0gZWxlbWVudHM7XG4gIGNvbnN0IHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZWN0KGZpcnN0RWxlbWVudCA/IGdldFdpbmRvdyhmaXJzdEVsZW1lbnQpIDogbnVsbCk7XG4gIGNvbnN0IFtyZWN0cywgc2V0UmVjdHNdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFZhbHVlJDIpO1xuXG4gIGZ1bmN0aW9uIG1lYXN1cmVSZWN0cygpIHtcbiAgICBzZXRSZWN0cygoKSA9PiB7XG4gICAgICBpZiAoIWVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlJDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbGVtZW50cy5tYXAoZWxlbWVudCA9PiBpc0RvY3VtZW50U2Nyb2xsaW5nRWxlbWVudChlbGVtZW50KSA/IHdpbmRvd1JlY3QgOiBuZXcgUmVjdChtZWFzdXJlKGVsZW1lbnQpLCBlbGVtZW50KSk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCByZXNpemVPYnNlcnZlciA9IHVzZVJlc2l6ZU9ic2VydmVyKHtcbiAgICBjYWxsYmFjazogbWVhc3VyZVJlY3RzXG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIG1lYXN1cmVSZWN0cygpO1xuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gIH0sIFtlbGVtZW50c10pO1xuICByZXR1cm4gcmVjdHM7XG59XG5cbmZ1bmN0aW9uIGdldE1lYXN1cmFibGVOb2RlKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZmlyc3RDaGlsZCkgPyBmaXJzdENoaWxkIDogbm9kZTtcbn1cblxuZnVuY3Rpb24gdXNlRHJhZ092ZXJsYXlNZWFzdXJpbmcoX3JlZikge1xuICBsZXQge1xuICAgIG1lYXN1cmVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IFtyZWN0LCBzZXRSZWN0XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjayhlbnRyaWVzID0+IHtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gb2YgZW50cmllcykge1xuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICBzZXRSZWN0KHJlY3QgPT4ge1xuICAgICAgICAgIGNvbnN0IG5ld1JlY3QgPSBtZWFzdXJlKHRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHJlY3QgPyB7IC4uLnJlY3QsXG4gICAgICAgICAgICB3aWR0aDogbmV3UmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogbmV3UmVjdC5oZWlnaHRcbiAgICAgICAgICB9IDogbmV3UmVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW21lYXN1cmVdKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IGhhbmRsZVJlc2l6ZVxuICB9KTtcbiAgY29uc3QgaGFuZGxlTm9kZUNoYW5nZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IG5vZGUgPSBnZXRNZWFzdXJhYmxlTm9kZShlbGVtZW50KTtcbiAgICByZXNpemVPYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJlc2l6ZU9ic2VydmVyID09IG51bGwgPyB2b2lkIDAgOiByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGUpO1xuICAgIH1cblxuICAgIHNldFJlY3Qobm9kZSA/IG1lYXN1cmUobm9kZSkgOiBudWxsKTtcbiAgfSwgW21lYXN1cmUsIHJlc2l6ZU9ic2VydmVyXSk7XG4gIGNvbnN0IFtub2RlUmVmLCBzZXRSZWZdID0gdXNlTm9kZVJlZihoYW5kbGVOb2RlQ2hhbmdlKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBub2RlUmVmLFxuICAgIHJlY3QsXG4gICAgc2V0UmVmXG4gIH0pLCBbcmVjdCwgbm9kZVJlZiwgc2V0UmVmXSk7XG59XG5cbmNvbnN0IGRlZmF1bHRTZW5zb3JzID0gW3tcbiAgc2Vuc29yOiBQb2ludGVyU2Vuc29yLFxuICBvcHRpb25zOiB7fVxufSwge1xuICBzZW5zb3I6IEtleWJvYXJkU2Vuc29yLFxuICBvcHRpb25zOiB7fVxufV07XG5jb25zdCBkZWZhdWx0RGF0YSA9IHtcbiAgY3VycmVudDoge31cbn07XG5jb25zdCBkZWZhdWx0TWVhc3VyaW5nQ29uZmlndXJhdGlvbiA9IHtcbiAgZHJhZ2dhYmxlOiB7XG4gICAgbWVhc3VyZTogZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0XG4gIH0sXG4gIGRyb3BwYWJsZToge1xuICAgIG1lYXN1cmU6IGdldFRyYW5zZm9ybUFnbm9zdGljQ2xpZW50UmVjdCxcbiAgICBzdHJhdGVneTogTWVhc3VyaW5nU3RyYXRlZ3kuV2hpbGVEcmFnZ2luZyxcbiAgICBmcmVxdWVuY3k6IE1lYXN1cmluZ0ZyZXF1ZW5jeS5PcHRpbWl6ZWRcbiAgfSxcbiAgZHJhZ092ZXJsYXk6IHtcbiAgICBtZWFzdXJlOiBnZXRDbGllbnRSZWN0XG4gIH1cbn07XG5cbmNsYXNzIERyb3BwYWJsZUNvbnRhaW5lcnNNYXAgZXh0ZW5kcyBNYXAge1xuICBnZXQoaWQpIHtcbiAgICB2YXIgX3N1cGVyJGdldDtcblxuICAgIHJldHVybiBpZCAhPSBudWxsID8gKF9zdXBlciRnZXQgPSBzdXBlci5nZXQoaWQpKSAhPSBudWxsID8gX3N1cGVyJGdldCA6IHVuZGVmaW5lZCA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRvQXJyYXkoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXMoKSk7XG4gIH1cblxuICBnZXRFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKS5maWx0ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBkaXNhYmxlZFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gIWRpc2FibGVkO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Tm9kZUZvcihpZCkge1xuICAgIHZhciBfdGhpcyRnZXQkbm9kZSRjdXJyZW4sIF90aGlzJGdldDtcblxuICAgIHJldHVybiAoX3RoaXMkZ2V0JG5vZGUkY3VycmVuID0gKF90aGlzJGdldCA9IHRoaXMuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldC5ub2RlLmN1cnJlbnQpICE9IG51bGwgPyBfdGhpcyRnZXQkbm9kZSRjdXJyZW4gOiB1bmRlZmluZWQ7XG4gIH1cblxufVxuXG5jb25zdCBkZWZhdWx0UHVibGljQ29udGV4dCA9IHtcbiAgYWN0aXZhdG9yRXZlbnQ6IG51bGwsXG4gIGFjdGl2ZTogbnVsbCxcbiAgYWN0aXZlTm9kZTogbnVsbCxcbiAgYWN0aXZlTm9kZVJlY3Q6IG51bGwsXG4gIGNvbGxpc2lvbnM6IG51bGwsXG4gIGNvbnRhaW5lck5vZGVSZWN0OiBudWxsLFxuICBkcmFnZ2FibGVOb2RlczogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgZHJvcHBhYmxlUmVjdHM6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGRyb3BwYWJsZUNvbnRhaW5lcnM6IC8qI19fUFVSRV9fKi9uZXcgRHJvcHBhYmxlQ29udGFpbmVyc01hcCgpLFxuICBvdmVyOiBudWxsLFxuICBkcmFnT3ZlcmxheToge1xuICAgIG5vZGVSZWY6IHtcbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9LFxuICAgIHJlY3Q6IG51bGwsXG4gICAgc2V0UmVmOiBub29wXG4gIH0sXG4gIHNjcm9sbGFibGVBbmNlc3RvcnM6IFtdLFxuICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0czogW10sXG4gIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb246IGRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyczogbm9vcCxcbiAgd2luZG93UmVjdDogbnVsbCxcbiAgbWVhc3VyaW5nU2NoZWR1bGVkOiBmYWxzZVxufTtcbmNvbnN0IGRlZmF1bHRJbnRlcm5hbENvbnRleHQgPSB7XG4gIGFjdGl2YXRvckV2ZW50OiBudWxsLFxuICBhY3RpdmF0b3JzOiBbXSxcbiAgYWN0aXZlOiBudWxsLFxuICBhY3RpdmVOb2RlUmVjdDogbnVsbCxcbiAgYXJpYURlc2NyaWJlZEJ5SWQ6IHtcbiAgICBkcmFnZ2FibGU6ICcnXG4gIH0sXG4gIGRpc3BhdGNoOiBub29wLFxuICBkcmFnZ2FibGVOb2RlczogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgb3ZlcjogbnVsbCxcbiAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnM6IG5vb3Bcbn07XG5jb25zdCBJbnRlcm5hbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0SW50ZXJuYWxDb250ZXh0KTtcbmNvbnN0IFB1YmxpY0NvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChkZWZhdWx0UHVibGljQ29udGV4dCk7XG5cbmZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkcmFnZ2FibGU6IHtcbiAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgIGluaXRpYWxDb29yZGluYXRlczoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LFxuICAgICAgbm9kZXM6IG5ldyBNYXAoKSxcbiAgICAgIHRyYW5zbGF0ZToge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHtcbiAgICAgIGNvbnRhaW5lcnM6IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKClcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgQWN0aW9uLkRyYWdTdGFydDpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBkcmFnZ2FibGU6IHsgLi4uc3RhdGUuZHJhZ2dhYmxlLFxuICAgICAgICAgIGluaXRpYWxDb29yZGluYXRlczogYWN0aW9uLmluaXRpYWxDb29yZGluYXRlcyxcbiAgICAgICAgICBhY3RpdmU6IGFjdGlvbi5hY3RpdmVcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLkRyYWdNb3ZlOlxuICAgICAgaWYgKHN0YXRlLmRyYWdnYWJsZS5hY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBkcmFnZ2FibGU6IHsgLi4uc3RhdGUuZHJhZ2dhYmxlLFxuICAgICAgICAgIHRyYW5zbGF0ZToge1xuICAgICAgICAgICAgeDogYWN0aW9uLmNvb3JkaW5hdGVzLnggLSBzdGF0ZS5kcmFnZ2FibGUuaW5pdGlhbENvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICB5OiBhY3Rpb24uY29vcmRpbmF0ZXMueSAtIHN0YXRlLmRyYWdnYWJsZS5pbml0aWFsQ29vcmRpbmF0ZXMueVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgQWN0aW9uLkRyYWdFbmQ6XG4gICAgY2FzZSBBY3Rpb24uRHJhZ0NhbmNlbDpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLFxuICAgICAgICBkcmFnZ2FibGU6IHsgLi4uc3RhdGUuZHJhZ2dhYmxlLFxuICAgICAgICAgIGFjdGl2ZTogbnVsbCxcbiAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXM6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2xhdGU6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBBY3Rpb24uUmVnaXN0ZXJEcm9wcGFibGU6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBlbGVtZW50XG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5zZXQoaWQsIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICBkcm9wcGFibGU6IHsgLi4uc3RhdGUuZHJvcHBhYmxlLFxuICAgICAgICAgICAgY29udGFpbmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGNhc2UgQWN0aW9uLlNldERyb3BwYWJsZURpc2FibGVkOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZWxlbWVudCB8fCBrZXkgIT09IGVsZW1lbnQua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5zZXQoaWQsIHsgLi4uZWxlbWVudCxcbiAgICAgICAgICBkaXNhYmxlZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsXG4gICAgICAgICAgZHJvcHBhYmxlOiB7IC4uLnN0YXRlLmRyb3BwYWJsZSxcbiAgICAgICAgICAgIGNvbnRhaW5lcnNcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlIEFjdGlvbi5VbnJlZ2lzdGVyRHJvcHBhYmxlOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAga2V5XG4gICAgICAgIH0gPSBhY3Rpb247XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGF0ZS5kcm9wcGFibGUuY29udGFpbmVycy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZWxlbWVudCB8fCBrZXkgIT09IGVsZW1lbnQua2V5KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVycyA9IG5ldyBEcm9wcGFibGVDb250YWluZXJzTWFwKHN0YXRlLmRyb3BwYWJsZS5jb250YWluZXJzKTtcbiAgICAgICAgY29udGFpbmVycy5kZWxldGUoaWQpO1xuICAgICAgICByZXR1cm4geyAuLi5zdGF0ZSxcbiAgICAgICAgICBkcm9wcGFibGU6IHsgLi4uc3RhdGUuZHJvcHBhYmxlLFxuICAgICAgICAgICAgY29udGFpbmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBSZXN0b3JlRm9jdXMoX3JlZikge1xuICBsZXQge1xuICAgIGRpc2FibGVkXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGRyYWdnYWJsZU5vZGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KEludGVybmFsQ29udGV4dCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZhdG9yRXZlbnQgPSB1c2VQcmV2aW91cyhhY3RpdmF0b3JFdmVudCk7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlSWQgPSB1c2VQcmV2aW91cyhhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZCk7IC8vIFJlc3RvcmUga2V5Ym9hcmQgZm9jdXMgb24gdGhlIGFjdGl2YXRvciBub2RlXG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWFjdGl2YXRvckV2ZW50ICYmIHByZXZpb3VzQWN0aXZhdG9yRXZlbnQgJiYgcHJldmlvdXNBY3RpdmVJZCAhPSBudWxsKSB7XG4gICAgICBpZiAoIWlzS2V5Ym9hcmRFdmVudChwcmV2aW91c0FjdGl2YXRvckV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBwcmV2aW91c0FjdGl2YXRvckV2ZW50LnRhcmdldCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHJlc3RvcmUgZm9jdXNcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KHByZXZpb3VzQWN0aXZlSWQpO1xuXG4gICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2YXRvck5vZGUsXG4gICAgICAgIG5vZGVcbiAgICAgIH0gPSBkcmFnZ2FibGVOb2RlO1xuXG4gICAgICBpZiAoIWFjdGl2YXRvck5vZGUuY3VycmVudCAmJiAhbm9kZS5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFthY3RpdmF0b3JOb2RlLmN1cnJlbnQsIG5vZGUuY3VycmVudF0pIHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZvY3VzYWJsZU5vZGUgPSBmaW5kRmlyc3RGb2N1c2FibGVOb2RlKGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKGZvY3VzYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIGZvY3VzYWJsZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYWN0aXZhdG9yRXZlbnQsIGRpc2FibGVkLCBkcmFnZ2FibGVOb2RlcywgcHJldmlvdXNBY3RpdmVJZCwgcHJldmlvdXNBY3RpdmF0b3JFdmVudF0pO1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCBfcmVmKSB7XG4gIGxldCB7XG4gICAgdHJhbnNmb3JtLFxuICAgIC4uLmFyZ3NcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBtb2RpZmllcnMgIT0gbnVsbCAmJiBtb2RpZmllcnMubGVuZ3RoID8gbW9kaWZpZXJzLnJlZHVjZSgoYWNjdW11bGF0b3IsIG1vZGlmaWVyKSA9PiB7XG4gICAgcmV0dXJuIG1vZGlmaWVyKHtcbiAgICAgIHRyYW5zZm9ybTogYWNjdW11bGF0b3IsXG4gICAgICAuLi5hcmdzXG4gICAgfSk7XG4gIH0sIHRyYW5zZm9ybSkgOiB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIHVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24oY29uZmlnKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZHJhZ2dhYmxlOiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZSxcbiAgICAgIC4uLihjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnZ2FibGUpXG4gICAgfSxcbiAgICBkcm9wcGFibGU6IHsgLi4uZGVmYXVsdE1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJvcHBhYmxlLFxuICAgICAgLi4uKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyb3BwYWJsZSlcbiAgICB9LFxuICAgIGRyYWdPdmVybGF5OiB7IC4uLmRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdPdmVybGF5LFxuICAgICAgLi4uKGNvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyYWdPdmVybGF5KVxuICAgIH1cbiAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW2NvbmZpZyA9PSBudWxsID8gdm9pZCAwIDogY29uZmlnLmRyYWdnYWJsZSwgY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcuZHJvcHBhYmxlLCBjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy5kcmFnT3ZlcmxheV0pO1xufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbihfcmVmKSB7XG4gIGxldCB7XG4gICAgYWN0aXZlTm9kZSxcbiAgICBtZWFzdXJlLFxuICAgIGluaXRpYWxSZWN0LFxuICAgIGNvbmZpZyA9IHRydWVcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGluaXRpYWxpemVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIHgsXG4gICAgeVxuICB9ID0gdHlwZW9mIGNvbmZpZyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgIHg6IGNvbmZpZyxcbiAgICB5OiBjb25maWdcbiAgfSA6IGNvbmZpZztcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZGlzYWJsZWQgPSAheCAmJiAheTtcblxuICAgIGlmIChkaXNhYmxlZCB8fCAhYWN0aXZlTm9kZSkge1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsaXplZC5jdXJyZW50IHx8ICFpbml0aWFsUmVjdCkge1xuICAgICAgLy8gUmV0dXJuIGVhcmx5IGlmIGxheW91dCBzaGlmdCBzY3JvbGwgY29tcGVuc2F0aW9uIHdhcyBhbHJlYWR5IGF0dGVtcHRlZFxuICAgICAgLy8gb3IgaWYgdGhlcmUgaXMgbm8gaW5pdGlhbFJlY3QgdG8gY29tcGFyZSB0by5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEdldCB0aGUgbW9zdCB1cCB0byBkYXRlIG5vZGUgcmVmIGZvciB0aGUgYWN0aXZlIGRyYWdnYWJsZVxuXG5cbiAgICBjb25zdCBub2RlID0gYWN0aXZlTm9kZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlTm9kZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAoIW5vZGUgfHwgbm9kZS5pc0Nvbm5lY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIFJldHVybiBlYXJseSBpZiB0aGVyZSBpcyBubyBhdHRhY2hlZCBub2RlIHJlZiBvciBpZiB0aGUgbm9kZSBpc1xuICAgICAgLy8gZGlzY29ubmVjdGVkIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlY3QgPSBtZWFzdXJlKG5vZGUpO1xuICAgIGNvbnN0IHJlY3REZWx0YSA9IGdldFJlY3REZWx0YShyZWN0LCBpbml0aWFsUmVjdCk7XG5cbiAgICBpZiAoIXgpIHtcbiAgICAgIHJlY3REZWx0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIXkpIHtcbiAgICAgIHJlY3REZWx0YS55ID0gMDtcbiAgICB9IC8vIE9ubHkgcGVyZm9ybSBsYXlvdXQgc2hpZnQgc2Nyb2xsIGNvbXBlbnNhdGlvbiBvbmNlXG5cblxuICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuXG4gICAgaWYgKE1hdGguYWJzKHJlY3REZWx0YS54KSA+IDAgfHwgTWF0aC5hYnMocmVjdERlbHRhLnkpID4gMCkge1xuICAgICAgY29uc3QgZmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXRGaXJzdFNjcm9sbGFibGVBbmNlc3Rvcihub2RlKTtcblxuICAgICAgaWYgKGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yKSB7XG4gICAgICAgIGZpcnN0U2Nyb2xsYWJsZUFuY2VzdG9yLnNjcm9sbEJ5KHtcbiAgICAgICAgICB0b3A6IHJlY3REZWx0YS55LFxuICAgICAgICAgIGxlZnQ6IHJlY3REZWx0YS54XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW2FjdGl2ZU5vZGUsIHgsIHksIGluaXRpYWxSZWN0LCBtZWFzdXJlXSk7XG59XG5cbmNvbnN0IEFjdGl2ZURyYWdnYWJsZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7IC4uLmRlZmF1bHRDb29yZGluYXRlcyxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn0pO1xudmFyIFN0YXR1cztcblxuKGZ1bmN0aW9uIChTdGF0dXMpIHtcbiAgU3RhdHVzW1N0YXR1c1tcIlVuaW5pdGlhbGl6ZWRcIl0gPSAwXSA9IFwiVW5pbml0aWFsaXplZFwiO1xuICBTdGF0dXNbU3RhdHVzW1wiSW5pdGlhbGl6aW5nXCJdID0gMV0gPSBcIkluaXRpYWxpemluZ1wiO1xuICBTdGF0dXNbU3RhdHVzW1wiSW5pdGlhbGl6ZWRcIl0gPSAyXSA9IFwiSW5pdGlhbGl6ZWRcIjtcbn0pKFN0YXR1cyB8fCAoU3RhdHVzID0ge30pKTtcblxuY29uc3QgRG5kQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKGZ1bmN0aW9uIERuZENvbnRleHQoX3JlZikge1xuICB2YXIgX3NlbnNvckNvbnRleHQkY3VycmVuLCBfZHJhZ092ZXJsYXkkbm9kZVJlZiQsIF9kcmFnT3ZlcmxheSRyZWN0LCBfb3ZlciRyZWN0O1xuXG4gIGxldCB7XG4gICAgaWQsXG4gICAgYWNjZXNzaWJpbGl0eSxcbiAgICBhdXRvU2Nyb2xsID0gdHJ1ZSxcbiAgICBjaGlsZHJlbixcbiAgICBzZW5zb3JzID0gZGVmYXVsdFNlbnNvcnMsXG4gICAgY29sbGlzaW9uRGV0ZWN0aW9uID0gcmVjdEludGVyc2VjdGlvbixcbiAgICBtZWFzdXJpbmcsXG4gICAgbW9kaWZpZXJzLFxuICAgIC4uLnByb3BzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzdG9yZSA9IFJlYWN0LnVzZVJlZHVjZXIocmVkdWNlciwgdW5kZWZpbmVkLCBnZXRJbml0aWFsU3RhdGUpO1xuICBjb25zdCBbc3RhdGUsIGRpc3BhdGNoXSA9IHN0b3JlO1xuICBjb25zdCBbZGlzcGF0Y2hNb25pdG9yRXZlbnQsIHJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyXSA9IHVzZURuZE1vbml0b3JQcm92aWRlcigpO1xuICBjb25zdCBbc3RhdHVzLCBzZXRTdGF0dXNdID0gUmVhY3QudXNlU3RhdGUoU3RhdHVzLlVuaW5pdGlhbGl6ZWQpO1xuICBjb25zdCBpc0luaXRpYWxpemVkID0gc3RhdHVzID09PSBTdGF0dXMuSW5pdGlhbGl6ZWQ7XG4gIGNvbnN0IHtcbiAgICBkcmFnZ2FibGU6IHtcbiAgICAgIGFjdGl2ZTogYWN0aXZlSWQsXG4gICAgICBub2RlczogZHJhZ2dhYmxlTm9kZXMsXG4gICAgICB0cmFuc2xhdGVcbiAgICB9LFxuICAgIGRyb3BwYWJsZToge1xuICAgICAgY29udGFpbmVyczogZHJvcHBhYmxlQ29udGFpbmVyc1xuICAgIH1cbiAgfSA9IHN0YXRlO1xuICBjb25zdCBub2RlID0gYWN0aXZlSWQgIT0gbnVsbCA/IGRyYWdnYWJsZU5vZGVzLmdldChhY3RpdmVJZCkgOiBudWxsO1xuICBjb25zdCBhY3RpdmVSZWN0cyA9IFJlYWN0LnVzZVJlZih7XG4gICAgaW5pdGlhbDogbnVsbCxcbiAgICB0cmFuc2xhdGVkOiBudWxsXG4gIH0pO1xuICBjb25zdCBhY3RpdmUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX25vZGUkZGF0YTtcblxuICAgIHJldHVybiBhY3RpdmVJZCAhPSBudWxsID8ge1xuICAgICAgaWQ6IGFjdGl2ZUlkLFxuICAgICAgLy8gSXQncyBwb3NzaWJsZSBmb3IgdGhlIGFjdGl2ZSBub2RlIHRvIHVubW91bnQgd2hpbGUgZHJhZ2dpbmdcbiAgICAgIGRhdGE6IChfbm9kZSRkYXRhID0gbm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5kYXRhKSAhPSBudWxsID8gX25vZGUkZGF0YSA6IGRlZmF1bHREYXRhLFxuICAgICAgcmVjdDogYWN0aXZlUmVjdHNcbiAgICB9IDogbnVsbDtcbiAgfSwgW2FjdGl2ZUlkLCBub2RlXSk7XG4gIGNvbnN0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW2FjdGl2ZVNlbnNvciwgc2V0QWN0aXZlU2Vuc29yXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbYWN0aXZhdG9yRXZlbnQsIHNldEFjdGl2YXRvckV2ZW50XSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBsYXRlc3RQcm9wcyA9IHVzZUxhdGVzdFZhbHVlKHByb3BzLCBPYmplY3QudmFsdWVzKHByb3BzKSk7XG4gIGNvbnN0IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWQgPSB1c2VVbmlxdWVJZChcIkRuZERlc2NyaWJlZEJ5XCIsIGlkKTtcbiAgY29uc3QgZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0RW5hYmxlZCgpLCBbZHJvcHBhYmxlQ29udGFpbmVyc10pO1xuICBjb25zdCBtZWFzdXJpbmdDb25maWd1cmF0aW9uID0gdXNlTWVhc3VyaW5nQ29uZmlndXJhdGlvbihtZWFzdXJpbmcpO1xuICBjb25zdCB7XG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nU2NoZWR1bGVkXG4gIH0gPSB1c2VEcm9wcGFibGVNZWFzdXJpbmcoZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMsIHtcbiAgICBkcmFnZ2luZzogaXNJbml0aWFsaXplZCxcbiAgICBkZXBlbmRlbmNpZXM6IFt0cmFuc2xhdGUueCwgdHJhbnNsYXRlLnldLFxuICAgIGNvbmZpZzogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcm9wcGFibGVcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZU5vZGUgPSB1c2VDYWNoZWROb2RlKGRyYWdnYWJsZU5vZGVzLCBhY3RpdmVJZCk7XG4gIGNvbnN0IGFjdGl2YXRpb25Db29yZGluYXRlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gYWN0aXZhdG9yRXZlbnQgPyBnZXRFdmVudENvb3JkaW5hdGVzKGFjdGl2YXRvckV2ZW50KSA6IG51bGwsIFthY3RpdmF0b3JFdmVudF0pO1xuICBjb25zdCBhdXRvU2Nyb2xsT3B0aW9ucyA9IGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKTtcbiAgY29uc3QgaW5pdGlhbEFjdGl2ZU5vZGVSZWN0ID0gdXNlSW5pdGlhbFJlY3QoYWN0aXZlTm9kZSwgbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUubWVhc3VyZSk7XG4gIHVzZUxheW91dFNoaWZ0U2Nyb2xsQ29tcGVuc2F0aW9uKHtcbiAgICBhY3RpdmVOb2RlOiBhY3RpdmVJZCAhPSBudWxsID8gZHJhZ2dhYmxlTm9kZXMuZ2V0KGFjdGl2ZUlkKSA6IG51bGwsXG4gICAgY29uZmlnOiBhdXRvU2Nyb2xsT3B0aW9ucy5sYXlvdXRTaGlmdENvbXBlbnNhdGlvbixcbiAgICBpbml0aWFsUmVjdDogaW5pdGlhbEFjdGl2ZU5vZGVSZWN0LFxuICAgIG1lYXN1cmU6IG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmVcbiAgfSk7XG4gIGNvbnN0IGFjdGl2ZU5vZGVSZWN0ID0gdXNlUmVjdChhY3RpdmVOb2RlLCBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdnYWJsZS5tZWFzdXJlLCBpbml0aWFsQWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBjb250YWluZXJOb2RlUmVjdCA9IHVzZVJlY3QoYWN0aXZlTm9kZSA/IGFjdGl2ZU5vZGUucGFyZW50RWxlbWVudCA6IG51bGwpO1xuICBjb25zdCBzZW5zb3JDb250ZXh0ID0gUmVhY3QudXNlUmVmKHtcbiAgICBhY3RpdmF0b3JFdmVudDogbnVsbCxcbiAgICBhY3RpdmU6IG51bGwsXG4gICAgYWN0aXZlTm9kZSxcbiAgICBjb2xsaXNpb25SZWN0OiBudWxsLFxuICAgIGNvbGxpc2lvbnM6IG51bGwsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgZHJhZ2dpbmdOb2RlOiBudWxsLFxuICAgIGRyYWdnaW5nTm9kZVJlY3Q6IG51bGwsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBvdmVyOiBudWxsLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnM6IFtdLFxuICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlOiBudWxsXG4gIH0pO1xuICBjb25zdCBvdmVyTm9kZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0Tm9kZUZvcigoX3NlbnNvckNvbnRleHQkY3VycmVuID0gc2Vuc29yQ29udGV4dC5jdXJyZW50Lm92ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfc2Vuc29yQ29udGV4dCRjdXJyZW4uaWQpO1xuICBjb25zdCBkcmFnT3ZlcmxheSA9IHVzZURyYWdPdmVybGF5TWVhc3VyaW5nKHtcbiAgICBtZWFzdXJlOiBtZWFzdXJpbmdDb25maWd1cmF0aW9uLmRyYWdPdmVybGF5Lm1lYXN1cmVcbiAgfSk7IC8vIFVzZSB0aGUgcmVjdCBvZiB0aGUgZHJhZyBvdmVybGF5IGlmIGl0IGlzIG1vdW50ZWRcblxuICBjb25zdCBkcmFnZ2luZ05vZGUgPSAoX2RyYWdPdmVybGF5JG5vZGVSZWYkID0gZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JG5vZGVSZWYkIDogYWN0aXZlTm9kZTtcbiAgY29uc3QgZHJhZ2dpbmdOb2RlUmVjdCA9IGlzSW5pdGlhbGl6ZWQgPyAoX2RyYWdPdmVybGF5JHJlY3QgPSBkcmFnT3ZlcmxheS5yZWN0KSAhPSBudWxsID8gX2RyYWdPdmVybGF5JHJlY3QgOiBhY3RpdmVOb2RlUmVjdCA6IG51bGw7XG4gIGNvbnN0IHVzZXNEcmFnT3ZlcmxheSA9IEJvb2xlYW4oZHJhZ092ZXJsYXkubm9kZVJlZi5jdXJyZW50ICYmIGRyYWdPdmVybGF5LnJlY3QpOyAvLyBUaGUgZGVsdGEgYmV0d2VlbiB0aGUgcHJldmlvdXMgYW5kIG5ldyBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dhYmxlIG5vZGVcbiAgLy8gaXMgb25seSByZWxldmFudCB3aGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheVxuXG4gIGNvbnN0IG5vZGVSZWN0RGVsdGEgPSB1c2VSZWN0RGVsdGEodXNlc0RyYWdPdmVybGF5ID8gbnVsbCA6IGFjdGl2ZU5vZGVSZWN0KTsgLy8gR2V0IHRoZSB3aW5kb3cgcmVjdCBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHdpbmRvd1JlY3QgPSB1c2VXaW5kb3dSZWN0KGRyYWdnaW5nTm9kZSA/IGdldFdpbmRvdyhkcmFnZ2luZ05vZGUpIDogbnVsbCk7IC8vIEdldCBzY3JvbGxhYmxlIGFuY2VzdG9ycyBvZiB0aGUgZHJhZ2dpbmcgbm9kZVxuXG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvcnMgPSB1c2VTY3JvbGxhYmxlQW5jZXN0b3JzKGlzSW5pdGlhbGl6ZWQgPyBvdmVyTm9kZSAhPSBudWxsID8gb3Zlck5vZGUgOiBhY3RpdmVOb2RlIDogbnVsbCk7XG4gIGNvbnN0IHNjcm9sbGFibGVBbmNlc3RvclJlY3RzID0gdXNlUmVjdHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIEFwcGx5IG1vZGlmaWVyc1xuXG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNsYXRlID0gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCB7XG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICB4OiB0cmFuc2xhdGUueCAtIG5vZGVSZWN0RGVsdGEueCxcbiAgICAgIHk6IHRyYW5zbGF0ZS55IC0gbm9kZVJlY3REZWx0YS55LFxuICAgICAgc2NhbGVYOiAxLFxuICAgICAgc2NhbGVZOiAxXG4gICAgfSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICBvdmVyOiBzZW5zb3JDb250ZXh0LmN1cnJlbnQub3ZlcixcbiAgICBvdmVybGF5Tm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB3aW5kb3dSZWN0XG4gIH0pO1xuICBjb25zdCBwb2ludGVyQ29vcmRpbmF0ZXMgPSBhY3RpdmF0aW9uQ29vcmRpbmF0ZXMgPyBhZGQoYWN0aXZhdGlvbkNvb3JkaW5hdGVzLCB0cmFuc2xhdGUpIDogbnVsbDtcbiAgY29uc3Qgc2Nyb2xsT2Zmc2V0cyA9IHVzZVNjcm9sbE9mZnNldHMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7IC8vIFJlcHJlc2VudHMgdGhlIHNjcm9sbCBkZWx0YSBzaW5jZSBkcmFnZ2luZyB3YXMgaW5pdGlhdGVkXG5cbiAgY29uc3Qgc2Nyb2xsQWRqdXN0bWVudCA9IHVzZVNjcm9sbE9mZnNldHNEZWx0YShzY3JvbGxPZmZzZXRzKTsgLy8gUmVwcmVzZW50cyB0aGUgc2Nyb2xsIGRlbHRhIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGFjdGl2ZSBub2RlIHJlY3Qgd2FzIG1lYXN1cmVkXG5cbiAgY29uc3QgYWN0aXZlTm9kZVNjcm9sbERlbHRhID0gdXNlU2Nyb2xsT2Zmc2V0c0RlbHRhKHNjcm9sbE9mZnNldHMsIFthY3RpdmVOb2RlUmVjdF0pO1xuICBjb25zdCBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSA9IGFkZChtb2RpZmllZFRyYW5zbGF0ZSwgc2Nyb2xsQWRqdXN0bWVudCk7XG4gIGNvbnN0IGNvbGxpc2lvblJlY3QgPSBkcmFnZ2luZ05vZGVSZWN0ID8gZ2V0QWRqdXN0ZWRSZWN0KGRyYWdnaW5nTm9kZVJlY3QsIG1vZGlmaWVkVHJhbnNsYXRlKSA6IG51bGw7XG4gIGNvbnN0IGNvbGxpc2lvbnMgPSBhY3RpdmUgJiYgY29sbGlzaW9uUmVjdCA/IGNvbGxpc2lvbkRldGVjdGlvbih7XG4gICAgYWN0aXZlLFxuICAgIGNvbGxpc2lvblJlY3QsXG4gICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVyczogZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzXG4gIH0pIDogbnVsbDtcbiAgY29uc3Qgb3ZlcklkID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlzaW9ucywgJ2lkJyk7XG4gIGNvbnN0IFtvdmVyLCBzZXRPdmVyXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpOyAvLyBXaGVuIHRoZXJlIGlzIG5vIGRyYWcgb3ZlcmxheSB1c2VkLCB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoZVxuICAvLyB3aW5kb3cgc2Nyb2xsIGRlbHRhXG5cbiAgY29uc3QgYXBwbGllZFRyYW5zbGF0ZSA9IHVzZXNEcmFnT3ZlcmxheSA/IG1vZGlmaWVkVHJhbnNsYXRlIDogYWRkKG1vZGlmaWVkVHJhbnNsYXRlLCBhY3RpdmVOb2RlU2Nyb2xsRGVsdGEpO1xuICBjb25zdCB0cmFuc2Zvcm0gPSBhZGp1c3RTY2FsZShhcHBsaWVkVHJhbnNsYXRlLCAoX292ZXIkcmVjdCA9IG92ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXIucmVjdCkgIT0gbnVsbCA/IF9vdmVyJHJlY3QgOiBudWxsLCBhY3RpdmVOb2RlUmVjdCk7XG4gIGNvbnN0IGFjdGl2ZVNlbnNvclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5zdGFudGlhdGVTZW5zb3IgPSBSZWFjdC51c2VDYWxsYmFjaygoZXZlbnQsIF9yZWYyKSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHNlbnNvcjogU2Vuc29yLFxuICAgICAgb3B0aW9uc1xuICAgIH0gPSBfcmVmMjtcblxuICAgIGlmIChhY3RpdmVSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlTm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChhY3RpdmVSZWYuY3VycmVudCk7XG5cbiAgICBpZiAoIWFjdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0b3JFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIGNvbnN0IHNlbnNvckluc3RhbmNlID0gbmV3IFNlbnNvcih7XG4gICAgICBhY3RpdmU6IGFjdGl2ZVJlZi5jdXJyZW50LFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGV2ZW50OiBhY3RpdmF0b3JFdmVudCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICAvLyBTZW5zb3JzIG5lZWQgdG8gYmUgaW5zdGFudGlhdGVkIHdpdGggcmVmcyBmb3IgYXJndW1lbnRzIHRoYXQgY2hhbmdlIG92ZXIgdGltZVxuICAgICAgLy8gb3RoZXJ3aXNlIHRoZXkgYXJlIGZyb3plbiBpbiB0aW1lIHdpdGggdGhlIHN0YWxlIGFyZ3VtZW50c1xuICAgICAgY29udGV4dDogc2Vuc29yQ29udGV4dCxcblxuICAgICAgb25BYm9ydChpZCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb25EcmFnQWJvcnRcbiAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGlkXG4gICAgICAgIH07XG4gICAgICAgIG9uRHJhZ0Fib3J0ID09IG51bGwgPyB2b2lkIDAgOiBvbkRyYWdBYm9ydChldmVudCk7XG4gICAgICAgIGRpc3BhdGNoTW9uaXRvckV2ZW50KHtcbiAgICAgICAgICB0eXBlOiAnb25EcmFnQWJvcnQnLFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgb25QZW5kaW5nKGlkLCBjb25zdHJhaW50LCBpbml0aWFsQ29vcmRpbmF0ZXMsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBkcmFnZ2FibGVOb2RlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgICAgICBpZiAoIWRyYWdnYWJsZU5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgb25EcmFnUGVuZGluZ1xuICAgICAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY29uc3RyYWludCxcbiAgICAgICAgICBpbml0aWFsQ29vcmRpbmF0ZXMsXG4gICAgICAgICAgb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIG9uRHJhZ1BlbmRpbmcgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ1BlbmRpbmcoZXZlbnQpO1xuICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ29uRHJhZ1BlbmRpbmcnLFxuICAgICAgICAgIGV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgb25TdGFydChpbml0aWFsQ29vcmRpbmF0ZXMpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhY3RpdmVSZWYuY3VycmVudDtcblxuICAgICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRyYWdnYWJsZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoaWQpO1xuXG4gICAgICAgIGlmICghZHJhZ2dhYmxlTm9kZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvbkRyYWdTdGFydFxuICAgICAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICAgICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRhdGE6IGRyYWdnYWJsZU5vZGUuZGF0YSxcbiAgICAgICAgICAgIHJlY3Q6IGFjdGl2ZVJlY3RzXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWFjdERvbS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgb25EcmFnU3RhcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ1N0YXJ0KGV2ZW50KTtcbiAgICAgICAgICBzZXRTdGF0dXMoU3RhdHVzLkluaXRpYWxpemluZyk7XG4gICAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogQWN0aW9uLkRyYWdTdGFydCxcbiAgICAgICAgICAgIGluaXRpYWxDb29yZGluYXRlcyxcbiAgICAgICAgICAgIGFjdGl2ZTogaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgICB0eXBlOiAnb25EcmFnU3RhcnQnLFxuICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRBY3RpdmVTZW5zb3IoYWN0aXZlU2Vuc29yUmVmLmN1cnJlbnQpO1xuICAgICAgICAgIHNldEFjdGl2YXRvckV2ZW50KGFjdGl2YXRvckV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvbk1vdmUoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgZGlzcGF0Y2goe1xuICAgICAgICAgIHR5cGU6IEFjdGlvbi5EcmFnTW92ZSxcbiAgICAgICAgICBjb29yZGluYXRlc1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIG9uRW5kOiBjcmVhdGVIYW5kbGVyKEFjdGlvbi5EcmFnRW5kKSxcbiAgICAgIG9uQ2FuY2VsOiBjcmVhdGVIYW5kbGVyKEFjdGlvbi5EcmFnQ2FuY2VsKVxuICAgIH0pO1xuICAgIGFjdGl2ZVNlbnNvclJlZi5jdXJyZW50ID0gc2Vuc29ySW5zdGFuY2U7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIYW5kbGVyKHR5cGUpIHtcbiAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgIGNvbGxpc2lvbnMsXG4gICAgICAgICAgb3ZlcixcbiAgICAgICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgICAgICB9ID0gc2Vuc29yQ29udGV4dC5jdXJyZW50O1xuICAgICAgICBsZXQgZXZlbnQgPSBudWxsO1xuXG4gICAgICAgIGlmIChhY3RpdmUgJiYgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYW5jZWxEcm9wXG4gICAgICAgICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgICAgICAgZXZlbnQgPSB7XG4gICAgICAgICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgICAgICAgIGFjdGl2ZTogYWN0aXZlLFxuICAgICAgICAgICAgY29sbGlzaW9ucyxcbiAgICAgICAgICAgIGRlbHRhOiBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZSxcbiAgICAgICAgICAgIG92ZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT09IEFjdGlvbi5EcmFnRW5kICYmIHR5cGVvZiBjYW5jZWxEcm9wID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRDYW5jZWwgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoY2FuY2VsRHJvcChldmVudCkpO1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkQ2FuY2VsKSB7XG4gICAgICAgICAgICAgIHR5cGUgPSBBY3Rpb24uRHJhZ0NhbmNlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhY3RpdmVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJlYWN0RG9tLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICBkaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0U3RhdHVzKFN0YXR1cy5VbmluaXRpYWxpemVkKTtcbiAgICAgICAgICBzZXRPdmVyKG51bGwpO1xuICAgICAgICAgIHNldEFjdGl2ZVNlbnNvcihudWxsKTtcbiAgICAgICAgICBzZXRBY3RpdmF0b3JFdmVudChudWxsKTtcbiAgICAgICAgICBhY3RpdmVTZW5zb3JSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgZXZlbnROYW1lID0gdHlwZSA9PT0gQWN0aW9uLkRyYWdFbmQgPyAnb25EcmFnRW5kJyA6ICdvbkRyYWdDYW5jZWwnO1xuXG4gICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gbGF0ZXN0UHJvcHMuY3VycmVudFtldmVudE5hbWVdO1xuICAgICAgICAgICAgaGFuZGxlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcihldmVudCk7XG4gICAgICAgICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgICAgICAgIHR5cGU6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbZHJhZ2dhYmxlTm9kZXNdKTtcbiAgY29uc3QgYmluZEFjdGl2YXRvclRvU2Vuc29ySW5zdGFudGlhdG9yID0gUmVhY3QudXNlQ2FsbGJhY2soKGhhbmRsZXIsIHNlbnNvcikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQsIGFjdGl2ZSkgPT4ge1xuICAgICAgY29uc3QgbmF0aXZlRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICAgIGNvbnN0IGFjdGl2ZURyYWdnYWJsZU5vZGUgPSBkcmFnZ2FibGVOb2Rlcy5nZXQoYWN0aXZlKTtcblxuICAgICAgaWYgKCAvLyBBbm90aGVyIHNlbnNvciBpcyBhbHJlYWR5IGluc3RhbnRpYXRpbmdcbiAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ICE9PSBudWxsIHx8IC8vIE5vIGFjdGl2ZSBkcmFnZ2FibGVcbiAgICAgICFhY3RpdmVEcmFnZ2FibGVOb2RlIHx8IC8vIEV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gY2FwdHVyZWRcbiAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCB8fCBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYWN0aXZhdGlvbkNvbnRleHQgPSB7XG4gICAgICAgIGFjdGl2ZTogYWN0aXZlRHJhZ2dhYmxlTm9kZVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNob3VsZEFjdGl2YXRlID0gaGFuZGxlcihldmVudCwgc2Vuc29yLm9wdGlvbnMsIGFjdGl2YXRpb25Db250ZXh0KTtcblxuICAgICAgaWYgKHNob3VsZEFjdGl2YXRlID09PSB0cnVlKSB7XG4gICAgICAgIG5hdGl2ZUV2ZW50LmRuZEtpdCA9IHtcbiAgICAgICAgICBjYXB0dXJlZEJ5OiBzZW5zb3Iuc2Vuc29yXG4gICAgICAgIH07XG4gICAgICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gYWN0aXZlO1xuICAgICAgICBpbnN0YW50aWF0ZVNlbnNvcihldmVudCwgc2Vuc29yKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZHJhZ2dhYmxlTm9kZXMsIGluc3RhbnRpYXRlU2Vuc29yXSk7XG4gIGNvbnN0IGFjdGl2YXRvcnMgPSB1c2VDb21iaW5lQWN0aXZhdG9ycyhzZW5zb3JzLCBiaW5kQWN0aXZhdG9yVG9TZW5zb3JJbnN0YW50aWF0b3IpO1xuICB1c2VTZW5zb3JTZXR1cChzZW5zb3JzKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZU5vZGVSZWN0ICYmIHN0YXR1cyA9PT0gU3RhdHVzLkluaXRpYWxpemluZykge1xuICAgICAgc2V0U3RhdHVzKFN0YXR1cy5Jbml0aWFsaXplZCk7XG4gICAgfVxuICB9LCBbYWN0aXZlTm9kZVJlY3QsIHN0YXR1c10pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG9uRHJhZ01vdmVcbiAgICB9ID0gbGF0ZXN0UHJvcHMuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmF0b3JFdmVudCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBvdmVyXG4gICAgfSA9IHNlbnNvckNvbnRleHQuY3VycmVudDtcblxuICAgIGlmICghYWN0aXZlIHx8ICFhY3RpdmF0b3JFdmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgZGVsdGE6IHtcbiAgICAgICAgeDogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCxcbiAgICAgICAgeTogc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueVxuICAgICAgfSxcbiAgICAgIG92ZXJcbiAgICB9O1xuICAgIHJlYWN0RG9tLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIG9uRHJhZ01vdmUgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRHJhZ01vdmUoZXZlbnQpO1xuICAgICAgZGlzcGF0Y2hNb25pdG9yRXZlbnQoe1xuICAgICAgICB0eXBlOiAnb25EcmFnTW92ZScsXG4gICAgICAgIGV2ZW50XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBbc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueCwgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUueV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBzY3JvbGxBZGp1c3RlZFRyYW5zbGF0ZVxuICAgIH0gPSBzZW5zb3JDb250ZXh0LmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZSB8fCBhY3RpdmVSZWYuY3VycmVudCA9PSBudWxsIHx8ICFhY3RpdmF0b3JFdmVudCB8fCAhc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBvbkRyYWdPdmVyXG4gICAgfSA9IGxhdGVzdFByb3BzLmN1cnJlbnQ7XG4gICAgY29uc3Qgb3ZlckNvbnRhaW5lciA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KG92ZXJJZCk7XG4gICAgY29uc3Qgb3ZlciA9IG92ZXJDb250YWluZXIgJiYgb3ZlckNvbnRhaW5lci5yZWN0LmN1cnJlbnQgPyB7XG4gICAgICBpZDogb3ZlckNvbnRhaW5lci5pZCxcbiAgICAgIHJlY3Q6IG92ZXJDb250YWluZXIucmVjdC5jdXJyZW50LFxuICAgICAgZGF0YTogb3ZlckNvbnRhaW5lci5kYXRhLFxuICAgICAgZGlzYWJsZWQ6IG92ZXJDb250YWluZXIuZGlzYWJsZWRcbiAgICB9IDogbnVsbDtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGFjdGl2YXRvckV2ZW50LFxuICAgICAgY29sbGlzaW9ucyxcbiAgICAgIGRlbHRhOiB7XG4gICAgICAgIHg6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLngsXG4gICAgICAgIHk6IHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlLnlcbiAgICAgIH0sXG4gICAgICBvdmVyXG4gICAgfTtcbiAgICByZWFjdERvbS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICBzZXRPdmVyKG92ZXIpO1xuICAgICAgb25EcmFnT3ZlciA9PSBudWxsID8gdm9pZCAwIDogb25EcmFnT3ZlcihldmVudCk7XG4gICAgICBkaXNwYXRjaE1vbml0b3JFdmVudCh7XG4gICAgICAgIHR5cGU6ICdvbkRyYWdPdmVyJyxcbiAgICAgICAgZXZlbnRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtvdmVySWRdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2Vuc29yQ29udGV4dC5jdXJyZW50ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmUsXG4gICAgICBhY3RpdmVOb2RlLFxuICAgICAgY29sbGlzaW9uUmVjdCxcbiAgICAgIGNvbGxpc2lvbnMsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJhZ2dpbmdOb2RlLFxuICAgICAgZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBvdmVyLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbEFkanVzdGVkVHJhbnNsYXRlXG4gICAgfTtcbiAgICBhY3RpdmVSZWN0cy5jdXJyZW50ID0ge1xuICAgICAgaW5pdGlhbDogZHJhZ2dpbmdOb2RlUmVjdCxcbiAgICAgIHRyYW5zbGF0ZWQ6IGNvbGxpc2lvblJlY3RcbiAgICB9O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBjb2xsaXNpb25zLCBjb2xsaXNpb25SZWN0LCBkcmFnZ2FibGVOb2RlcywgZHJhZ2dpbmdOb2RlLCBkcmFnZ2luZ05vZGVSZWN0LCBkcm9wcGFibGVSZWN0cywgZHJvcHBhYmxlQ29udGFpbmVycywgb3Zlciwgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsQWRqdXN0ZWRUcmFuc2xhdGVdKTtcbiAgdXNlQXV0b1Njcm9sbGVyKHsgLi4uYXV0b1Njcm9sbE9wdGlvbnMsXG4gICAgZGVsdGE6IHRyYW5zbGF0ZSxcbiAgICBkcmFnZ2luZ1JlY3Q6IGNvbGxpc2lvblJlY3QsXG4gICAgcG9pbnRlckNvb3JkaW5hdGVzLFxuICAgIHNjcm9sbGFibGVBbmNlc3RvcnMsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHNcbiAgfSk7XG4gIGNvbnN0IHB1YmxpY0NvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZSxcbiAgICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBjb2xsaXNpb25zLFxuICAgICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgICBkcmFnT3ZlcmxheSxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICAgIHNjcm9sbGFibGVBbmNlc3RvclJlY3RzLFxuICAgICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvbixcbiAgICAgIG1lYXN1cmluZ1NjaGVkdWxlZCxcbiAgICAgIHdpbmRvd1JlY3RcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9LCBbYWN0aXZlLCBhY3RpdmVOb2RlLCBhY3RpdmVOb2RlUmVjdCwgYWN0aXZhdG9yRXZlbnQsIGNvbGxpc2lvbnMsIGNvbnRhaW5lck5vZGVSZWN0LCBkcmFnT3ZlcmxheSwgZHJhZ2dhYmxlTm9kZXMsIGRyb3BwYWJsZUNvbnRhaW5lcnMsIGRyb3BwYWJsZVJlY3RzLCBvdmVyLCBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycywgc2Nyb2xsYWJsZUFuY2VzdG9ycywgc2Nyb2xsYWJsZUFuY2VzdG9yUmVjdHMsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sIG1lYXN1cmluZ1NjaGVkdWxlZCwgd2luZG93UmVjdF0pO1xuICBjb25zdCBpbnRlcm5hbENvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgICBhY3RpdmF0b3JzLFxuICAgICAgYWN0aXZlLFxuICAgICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgICBhcmlhRGVzY3JpYmVkQnlJZDoge1xuICAgICAgICBkcmFnZ2FibGU6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgICAgIH0sXG4gICAgICBkaXNwYXRjaCxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgb3ZlcixcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXG4gICAgfTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfSwgW2FjdGl2YXRvckV2ZW50LCBhY3RpdmF0b3JzLCBhY3RpdmUsIGFjdGl2ZU5vZGVSZWN0LCBkaXNwYXRjaCwgZHJhZ2dhYmxlRGVzY3JpYmVkQnlJZCwgZHJhZ2dhYmxlTm9kZXMsIG92ZXIsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERuZE1vbml0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHJlZ2lzdGVyTW9uaXRvckxpc3RlbmVyXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGludGVybmFsQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFB1YmxpY0NvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcHVibGljQ29udGV4dFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KEFjdGl2ZURyYWdnYWJsZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdHJhbnNmb3JtXG4gIH0sIGNoaWxkcmVuKSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzdG9yZUZvY3VzLCB7XG4gICAgZGlzYWJsZWQ6IChhY2Nlc3NpYmlsaXR5ID09IG51bGwgPyB2b2lkIDAgOiBhY2Nlc3NpYmlsaXR5LnJlc3RvcmVGb2N1cykgPT09IGZhbHNlXG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY2Nlc3NpYmlsaXR5LCB7IC4uLmFjY2Vzc2liaWxpdHksXG4gICAgaGlkZGVuVGV4dERlc2NyaWJlZEJ5SWQ6IGRyYWdnYWJsZURlc2NyaWJlZEJ5SWRcbiAgfSkpO1xuXG4gIGZ1bmN0aW9uIGdldEF1dG9TY3JvbGxlck9wdGlvbnMoKSB7XG4gICAgY29uc3QgYWN0aXZlU2Vuc29yRGlzYWJsZXNBdXRvc2Nyb2xsID0gKGFjdGl2ZVNlbnNvciA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlU2Vuc29yLmF1dG9TY3JvbGxFbmFibGVkKSA9PT0gZmFsc2U7XG4gICAgY29uc3QgYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQgPSB0eXBlb2YgYXV0b1Njcm9sbCA9PT0gJ29iamVjdCcgPyBhdXRvU2Nyb2xsLmVuYWJsZWQgPT09IGZhbHNlIDogYXV0b1Njcm9sbCA9PT0gZmFsc2U7XG4gICAgY29uc3QgZW5hYmxlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWFjdGl2ZVNlbnNvckRpc2FibGVzQXV0b3Njcm9sbCAmJiAhYXV0b1Njcm9sbEdsb2JhbGx5RGlzYWJsZWQ7XG5cbiAgICBpZiAodHlwZW9mIGF1dG9TY3JvbGwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4geyAuLi5hdXRvU2Nyb2xsLFxuICAgICAgICBlbmFibGVkXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlbmFibGVkXG4gICAgfTtcbiAgfVxufSk7XG5cbmNvbnN0IE51bGxDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBkZWZhdWx0Um9sZSA9ICdidXR0b24nO1xuY29uc3QgSURfUFJFRklYID0gJ0RyYWdnYWJsZSc7XG5mdW5jdGlvbiB1c2VEcmFnZ2FibGUoX3JlZikge1xuICBsZXQge1xuICAgIGlkLFxuICAgIGRhdGEsXG4gICAgZGlzYWJsZWQgPSBmYWxzZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgpO1xuICBjb25zdCB7XG4gICAgYWN0aXZhdG9ycyxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgYXJpYURlc2NyaWJlZEJ5SWQsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgb3ZlclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCB7XG4gICAgcm9sZSA9IGRlZmF1bHRSb2xlLFxuICAgIHJvbGVEZXNjcmlwdGlvbiA9ICdkcmFnZ2FibGUnLFxuICAgIHRhYkluZGV4ID0gMFxuICB9ID0gYXR0cmlidXRlcyAhPSBudWxsID8gYXR0cmlidXRlcyA6IHt9O1xuICBjb25zdCBpc0RyYWdnaW5nID0gKGFjdGl2ZSA9PSBudWxsID8gdm9pZCAwIDogYWN0aXZlLmlkKSA9PT0gaWQ7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IFJlYWN0LnVzZUNvbnRleHQoaXNEcmFnZ2luZyA/IEFjdGl2ZURyYWdnYWJsZUNvbnRleHQgOiBOdWxsQ29udGV4dCk7XG4gIGNvbnN0IFtub2RlLCBzZXROb2RlUmVmXSA9IHVzZU5vZGVSZWYoKTtcbiAgY29uc3QgW2FjdGl2YXRvck5vZGUsIHNldEFjdGl2YXRvck5vZGVSZWZdID0gdXNlTm9kZVJlZigpO1xuICBjb25zdCBsaXN0ZW5lcnMgPSB1c2VTeW50aGV0aWNMaXN0ZW5lcnMoYWN0aXZhdG9ycywgaWQpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGRyYWdnYWJsZU5vZGVzLnNldChpZCwge1xuICAgICAgaWQsXG4gICAgICBrZXksXG4gICAgICBub2RlLFxuICAgICAgYWN0aXZhdG9yTm9kZSxcbiAgICAgIGRhdGE6IGRhdGFSZWZcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IGRyYWdnYWJsZU5vZGVzLmdldChpZCk7XG5cbiAgICAgIGlmIChub2RlICYmIG5vZGUua2V5ID09PSBrZXkpIHtcbiAgICAgICAgZHJhZ2dhYmxlTm9kZXMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtkcmFnZ2FibGVOb2RlcywgaWRdKTtcbiAgY29uc3QgbWVtb2l6ZWRBdHRyaWJ1dGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJvbGUsXG4gICAgdGFiSW5kZXgsXG4gICAgJ2FyaWEtZGlzYWJsZWQnOiBkaXNhYmxlZCxcbiAgICAnYXJpYS1wcmVzc2VkJzogaXNEcmFnZ2luZyAmJiByb2xlID09PSBkZWZhdWx0Um9sZSA/IHRydWUgOiB1bmRlZmluZWQsXG4gICAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogcm9sZURlc2NyaXB0aW9uLFxuICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogYXJpYURlc2NyaWJlZEJ5SWQuZHJhZ2dhYmxlXG4gIH0pLCBbZGlzYWJsZWQsIHJvbGUsIHRhYkluZGV4LCBpc0RyYWdnaW5nLCByb2xlRGVzY3JpcHRpb24sIGFyaWFEZXNjcmliZWRCeUlkLmRyYWdnYWJsZV0pO1xuICByZXR1cm4ge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmVOb2RlUmVjdCxcbiAgICBhdHRyaWJ1dGVzOiBtZW1vaXplZEF0dHJpYnV0ZXMsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBsaXN0ZW5lcnM6IGRpc2FibGVkID8gdW5kZWZpbmVkIDogbGlzdGVuZXJzLFxuICAgIG5vZGUsXG4gICAgb3ZlcixcbiAgICBzZXROb2RlUmVmLFxuICAgIHNldEFjdGl2YXRvck5vZGVSZWYsXG4gICAgdHJhbnNmb3JtXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZURuZENvbnRleHQoKSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFB1YmxpY0NvbnRleHQpO1xufVxuXG5jb25zdCBJRF9QUkVGSVgkMSA9ICdEcm9wcGFibGUnO1xuY29uc3QgZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnID0ge1xuICB0aW1lb3V0OiAyNVxufTtcbmZ1bmN0aW9uIHVzZURyb3BwYWJsZShfcmVmKSB7XG4gIGxldCB7XG4gICAgZGF0YSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGlkLFxuICAgIHJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH0gPSBfcmVmO1xuICBjb25zdCBrZXkgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgkMSk7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmUsXG4gICAgZGlzcGF0Y2gsXG4gICAgb3ZlcixcbiAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVyc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChJbnRlcm5hbENvbnRleHQpO1xuICBjb25zdCBwcmV2aW91cyA9IFJlYWN0LnVzZVJlZih7XG4gICAgZGlzYWJsZWRcbiAgfSk7XG4gIGNvbnN0IHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVjdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FsbGJhY2tJZCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qge1xuICAgIGRpc2FibGVkOiByZXNpemVPYnNlcnZlckRpc2FibGVkLFxuICAgIHVwZGF0ZU1lYXN1cmVtZW50c0ZvcixcbiAgICB0aW1lb3V0OiByZXNpemVPYnNlcnZlclRpbWVvdXRcbiAgfSA9IHsgLi4uZGVmYXVsdFJlc2l6ZU9ic2VydmVyQ29uZmlnLFxuICAgIC4uLnJlc2l6ZU9ic2VydmVyQ29uZmlnXG4gIH07XG4gIGNvbnN0IGlkcyA9IHVzZUxhdGVzdFZhbHVlKHVwZGF0ZU1lYXN1cmVtZW50c0ZvciAhPSBudWxsID8gdXBkYXRlTWVhc3VyZW1lbnRzRm9yIDogaWQpO1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlckNvbm5lY3RlZC5jdXJyZW50KSB7XG4gICAgICAvLyBSZXNpemVPYnNlcnZlciBpbnZva2VzIHRoZSBgaGFuZGxlUmVzaXplYCBjYWxsYmFjayBhcyBzb29uIGFzIGBvYnNlcnZlYCBpcyBjYWxsZWQsXG4gICAgICAvLyBhc3N1bWluZyB0aGUgZWxlbWVudCBpcyByZW5kZXJlZCBhbmQgZGlzcGxheWVkLlxuICAgICAgcmVzaXplT2JzZXJ2ZXJDb25uZWN0ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNhbGxiYWNrSWQuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQoY2FsbGJhY2tJZC5jdXJyZW50KTtcbiAgICB9XG5cbiAgICBjYWxsYmFja0lkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzKEFycmF5LmlzQXJyYXkoaWRzLmN1cnJlbnQpID8gaWRzLmN1cnJlbnQgOiBbaWRzLmN1cnJlbnRdKTtcbiAgICAgIGNhbGxiYWNrSWQuY3VycmVudCA9IG51bGw7XG4gICAgfSwgcmVzaXplT2JzZXJ2ZXJUaW1lb3V0KTtcbiAgfSwgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtyZXNpemVPYnNlcnZlclRpbWVvdXRdKTtcbiAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcih7XG4gICAgY2FsbGJhY2s6IGhhbmRsZVJlc2l6ZSxcbiAgICBkaXNhYmxlZDogcmVzaXplT2JzZXJ2ZXJEaXNhYmxlZCB8fCAhYWN0aXZlXG4gIH0pO1xuICBjb25zdCBoYW5kbGVOb2RlQ2hhbmdlID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld0VsZW1lbnQsIHByZXZpb3VzRWxlbWVudCkgPT4ge1xuICAgIGlmICghcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICByZXNpemVPYnNlcnZlci51bm9ic2VydmUocHJldmlvdXNFbGVtZW50KTtcbiAgICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShuZXdFbGVtZW50KTtcbiAgICB9XG4gIH0sIFtyZXNpemVPYnNlcnZlcl0pO1xuICBjb25zdCBbbm9kZVJlZiwgc2V0Tm9kZVJlZl0gPSB1c2VOb2RlUmVmKGhhbmRsZU5vZGVDaGFuZ2UpO1xuICBjb25zdCBkYXRhUmVmID0gdXNlTGF0ZXN0VmFsdWUoZGF0YSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFyZXNpemVPYnNlcnZlciB8fCAhbm9kZVJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gIH0sIFtub2RlUmVmLCByZXNpemVPYnNlcnZlcl0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IEFjdGlvbi5SZWdpc3RlckRyb3BwYWJsZSxcbiAgICAgIGVsZW1lbnQ6IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGtleSxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIG5vZGU6IG5vZGVSZWYsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIGRhdGE6IGRhdGFSZWZcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uLlVucmVnaXN0ZXJEcm9wcGFibGUsXG4gICAgICBrZXksXG4gICAgICBpZFxuICAgIH0pO1xuICB9LCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtpZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCAhPT0gcHJldmlvdXMuY3VycmVudC5kaXNhYmxlZCkge1xuICAgICAgZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBBY3Rpb24uU2V0RHJvcHBhYmxlRGlzYWJsZWQsXG4gICAgICAgIGlkLFxuICAgICAgICBrZXksXG4gICAgICAgIGRpc2FibGVkXG4gICAgICB9KTtcbiAgICAgIHByZXZpb3VzLmN1cnJlbnQuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gIH0sIFtpZCwga2V5LCBkaXNhYmxlZCwgZGlzcGF0Y2hdKTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgcmVjdCxcbiAgICBpc092ZXI6IChvdmVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVyLmlkKSA9PT0gaWQsXG4gICAgbm9kZTogbm9kZVJlZixcbiAgICBvdmVyLFxuICAgIHNldE5vZGVSZWZcbiAgfTtcbn1cblxuZnVuY3Rpb24gQW5pbWF0aW9uTWFuYWdlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgYW5pbWF0aW9uLFxuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmO1xuICBjb25zdCBbY2xvbmVkQ2hpbGRyZW4sIHNldENsb25lZENoaWxkcmVuXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbZWxlbWVudCwgc2V0RWxlbWVudF0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcHJldmlvdXNDaGlsZHJlbiA9IHVzZVByZXZpb3VzKGNoaWxkcmVuKTtcblxuICBpZiAoIWNoaWxkcmVuICYmICFjbG9uZWRDaGlsZHJlbiAmJiBwcmV2aW91c0NoaWxkcmVuKSB7XG4gICAgc2V0Q2xvbmVkQ2hpbGRyZW4ocHJldmlvdXNDaGlsZHJlbik7XG4gIH1cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBrZXkgPSBjbG9uZWRDaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2xvbmVkQ2hpbGRyZW4ua2V5O1xuICAgIGNvbnN0IGlkID0gY2xvbmVkQ2hpbGRyZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGNsb25lZENoaWxkcmVuLnByb3BzLmlkO1xuXG4gICAgaWYgKGtleSA9PSBudWxsIHx8IGlkID09IG51bGwpIHtcbiAgICAgIHNldENsb25lZENoaWxkcmVuKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIFByb21pc2UucmVzb2x2ZShhbmltYXRpb24oaWQsIGVsZW1lbnQpKS50aGVuKCgpID0+IHtcbiAgICAgIHNldENsb25lZENoaWxkcmVuKG51bGwpO1xuICAgIH0pO1xuICB9LCBbYW5pbWF0aW9uLCBjbG9uZWRDaGlsZHJlbiwgZWxlbWVudF0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIGNsb25lZENoaWxkcmVuID8gUmVhY3QuY2xvbmVFbGVtZW50KGNsb25lZENoaWxkcmVuLCB7XG4gICAgcmVmOiBzZXRFbGVtZW50XG4gIH0pIDogbnVsbCk7XG59XG5cbmNvbnN0IGRlZmF1bHRUcmFuc2Zvcm0gPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHNjYWxlWDogMSxcbiAgc2NhbGVZOiAxXG59O1xuZnVuY3Rpb24gTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRJbnRlcm5hbENvbnRleHRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChBY3RpdmVEcmFnZ2FibGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlZmF1bHRUcmFuc2Zvcm1cbiAgfSwgY2hpbGRyZW4pKTtcbn1cblxuY29uc3QgYmFzZVN0eWxlcyA9IHtcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZSdcbn07XG5cbmNvbnN0IGRlZmF1bHRUcmFuc2l0aW9uID0gYWN0aXZhdG9yRXZlbnQgPT4ge1xuICBjb25zdCBpc0tleWJvYXJkQWN0aXZhdG9yID0gaXNLZXlib2FyZEV2ZW50KGFjdGl2YXRvckV2ZW50KTtcbiAgcmV0dXJuIGlzS2V5Ym9hcmRBY3RpdmF0b3IgPyAndHJhbnNmb3JtIDI1MG1zIGVhc2UnIDogdW5kZWZpbmVkO1xufTtcblxuY29uc3QgUG9zaXRpb25lZE92ZXJsYXkgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoX3JlZiwgcmVmKSA9PiB7XG4gIGxldCB7XG4gICAgYXMsXG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWRqdXN0U2NhbGUsXG4gICAgY2hpbGRyZW4sXG4gICAgY2xhc3NOYW1lLFxuICAgIHJlY3QsXG4gICAgc3R5bGUsXG4gICAgdHJhbnNmb3JtLFxuICAgIHRyYW5zaXRpb24gPSBkZWZhdWx0VHJhbnNpdGlvblxuICB9ID0gX3JlZjtcblxuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHNjYWxlQWRqdXN0ZWRUcmFuc2Zvcm0gPSBhZGp1c3RTY2FsZSA/IHRyYW5zZm9ybSA6IHsgLi4udHJhbnNmb3JtLFxuICAgIHNjYWxlWDogMSxcbiAgICBzY2FsZVk6IDFcbiAgfTtcbiAgY29uc3Qgc3R5bGVzID0geyAuLi5iYXNlU3R5bGVzLFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdHJhbnNmb3JtOiBDU1MuVHJhbnNmb3JtLnRvU3RyaW5nKHNjYWxlQWRqdXN0ZWRUcmFuc2Zvcm0pLFxuICAgIHRyYW5zZm9ybU9yaWdpbjogYWRqdXN0U2NhbGUgJiYgYWN0aXZhdG9yRXZlbnQgPyBnZXRSZWxhdGl2ZVRyYW5zZm9ybU9yaWdpbihhY3RpdmF0b3JFdmVudCwgcmVjdCkgOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbjogdHlwZW9mIHRyYW5zaXRpb24gPT09ICdmdW5jdGlvbicgPyB0cmFuc2l0aW9uKGFjdGl2YXRvckV2ZW50KSA6IHRyYW5zaXRpb24sXG4gICAgLi4uc3R5bGVcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYXMsIHtcbiAgICBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlcyxcbiAgICByZWZcbiAgfSwgY2hpbGRyZW4pO1xufSk7XG5cbmNvbnN0IGRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMgPSBvcHRpb25zID0+IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFjdGl2ZSxcbiAgICBkcmFnT3ZlcmxheVxuICB9ID0gX3JlZjtcbiAgY29uc3Qgb3JpZ2luYWxTdHlsZXMgPSB7fTtcbiAgY29uc3Qge1xuICAgIHN0eWxlcyxcbiAgICBjbGFzc05hbWVcbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKHN0eWxlcyAhPSBudWxsICYmIHN0eWxlcy5hY3RpdmUpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzdHlsZXMuYWN0aXZlKSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG9yaWdpbmFsU3R5bGVzW2tleV0gPSBhY3RpdmUubm9kZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSk7XG4gICAgICBhY3RpdmUubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3R5bGVzICE9IG51bGwgJiYgc3R5bGVzLmRyYWdPdmVybGF5KSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzLmRyYWdPdmVybGF5KSkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRyYWdPdmVybGF5Lm5vZGUuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5hY3RpdmUpIHtcbiAgICBhY3RpdmUubm9kZS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZS5hY3RpdmUpO1xuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSAhPSBudWxsICYmIGNsYXNzTmFtZS5kcmFnT3ZlcmxheSkge1xuICAgIGRyYWdPdmVybGF5Lm5vZGUuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUuZHJhZ092ZXJsYXkpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMob3JpZ2luYWxTdHlsZXMpKSB7XG4gICAgICBhY3RpdmUubm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoY2xhc3NOYW1lICE9IG51bGwgJiYgY2xhc3NOYW1lLmFjdGl2ZSkge1xuICAgICAgYWN0aXZlLm5vZGUuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUuYWN0aXZlKTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBkZWZhdWx0S2V5ZnJhbWVSZXNvbHZlciA9IF9yZWYyID0+IHtcbiAgbGV0IHtcbiAgICB0cmFuc2Zvcm06IHtcbiAgICAgIGluaXRpYWwsXG4gICAgICBmaW5hbFxuICAgIH1cbiAgfSA9IF9yZWYyO1xuICByZXR1cm4gW3tcbiAgICB0cmFuc2Zvcm06IENTUy5UcmFuc2Zvcm0udG9TdHJpbmcoaW5pdGlhbClcbiAgfSwge1xuICAgIHRyYW5zZm9ybTogQ1NTLlRyYW5zZm9ybS50b1N0cmluZyhmaW5hbClcbiAgfV07XG59O1xuXG5jb25zdCBkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24gPSB7XG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2luZzogJ2Vhc2UnLFxuICBrZXlmcmFtZXM6IGRlZmF1bHRLZXlmcmFtZVJlc29sdmVyLFxuICBzaWRlRWZmZWN0czogLyojX19QVVJFX18qL2RlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMoe1xuICAgIHN0eWxlczoge1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIG9wYWNpdHk6ICcwJ1xuICAgICAgfVxuICAgIH1cbiAgfSlcbn07XG5mdW5jdGlvbiB1c2VEcm9wQW5pbWF0aW9uKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY29uZmlnLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvblxuICB9ID0gX3JlZjM7XG4gIHJldHVybiB1c2VFdmVudCgoaWQsIG5vZGUpID0+IHtcbiAgICBpZiAoY29uZmlnID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlRHJhZ2dhYmxlID0gZHJhZ2dhYmxlTm9kZXMuZ2V0KGlkKTtcblxuICAgIGlmICghYWN0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZlTm9kZSA9IGFjdGl2ZURyYWdnYWJsZS5ub2RlLmN1cnJlbnQ7XG5cbiAgICBpZiAoIWFjdGl2ZU5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZWFzdXJhYmxlTm9kZSA9IGdldE1lYXN1cmFibGVOb2RlKG5vZGUpO1xuXG4gICAgaWYgKCFtZWFzdXJhYmxlTm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zZm9ybVxuICAgIH0gPSBnZXRXaW5kb3cobm9kZSkuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBwYXJzZWRUcmFuc2Zvcm0gPSBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xuXG4gICAgaWYgKCFwYXJzZWRUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhbmltYXRpb24gPSB0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nID8gY29uZmlnIDogY3JlYXRlRGVmYXVsdERyb3BBbmltYXRpb24oY29uZmlnKTtcbiAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGFjdGl2ZU5vZGUsIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24uZHJhZ2dhYmxlLm1lYXN1cmUpO1xuICAgIHJldHVybiBhbmltYXRpb24oe1xuICAgICAgYWN0aXZlOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBkYXRhOiBhY3RpdmVEcmFnZ2FibGUuZGF0YSxcbiAgICAgICAgbm9kZTogYWN0aXZlTm9kZSxcbiAgICAgICAgcmVjdDogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnZ2FibGUubWVhc3VyZShhY3RpdmVOb2RlKVxuICAgICAgfSxcbiAgICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgICAgZHJhZ092ZXJsYXk6IHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAgcmVjdDogbWVhc3VyaW5nQ29uZmlndXJhdGlvbi5kcmFnT3ZlcmxheS5tZWFzdXJlKG1lYXN1cmFibGVOb2RlKVxuICAgICAgfSxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBtZWFzdXJpbmdDb25maWd1cmF0aW9uLFxuICAgICAgdHJhbnNmb3JtOiBwYXJzZWRUcmFuc2Zvcm1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHREcm9wQW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIGR1cmF0aW9uLFxuICAgIGVhc2luZyxcbiAgICBzaWRlRWZmZWN0cyxcbiAgICBrZXlmcmFtZXNcbiAgfSA9IHsgLi4uZGVmYXVsdERyb3BBbmltYXRpb25Db25maWd1cmF0aW9uLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgcmV0dXJuIF9yZWY0ID0+IHtcbiAgICBsZXQge1xuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IF9yZWY0O1xuXG4gICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgLy8gRG8gbm90IGFuaW1hdGUgaWYgYW5pbWF0aW9uIGR1cmF0aW9uIGlzIHplcm8uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICB4OiBkcmFnT3ZlcmxheS5yZWN0LmxlZnQgLSBhY3RpdmUucmVjdC5sZWZ0LFxuICAgICAgeTogZHJhZ092ZXJsYXkucmVjdC50b3AgLSBhY3RpdmUucmVjdC50b3BcbiAgICB9O1xuICAgIGNvbnN0IHNjYWxlID0ge1xuICAgICAgc2NhbGVYOiB0cmFuc2Zvcm0uc2NhbGVYICE9PSAxID8gYWN0aXZlLnJlY3Qud2lkdGggKiB0cmFuc2Zvcm0uc2NhbGVYIC8gZHJhZ092ZXJsYXkucmVjdC53aWR0aCA6IDEsXG4gICAgICBzY2FsZVk6IHRyYW5zZm9ybS5zY2FsZVkgIT09IDEgPyBhY3RpdmUucmVjdC5oZWlnaHQgKiB0cmFuc2Zvcm0uc2NhbGVZIC8gZHJhZ092ZXJsYXkucmVjdC5oZWlnaHQgOiAxXG4gICAgfTtcbiAgICBjb25zdCBmaW5hbFRyYW5zZm9ybSA9IHtcbiAgICAgIHg6IHRyYW5zZm9ybS54IC0gZGVsdGEueCxcbiAgICAgIHk6IHRyYW5zZm9ybS55IC0gZGVsdGEueSxcbiAgICAgIC4uLnNjYWxlXG4gICAgfTtcbiAgICBjb25zdCBhbmltYXRpb25LZXlmcmFtZXMgPSBrZXlmcmFtZXMoeyAuLi5yZXN0LFxuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgaW5pdGlhbDogdHJhbnNmb3JtLFxuICAgICAgICBmaW5hbDogZmluYWxUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBbZmlyc3RLZXlmcmFtZV0gPSBhbmltYXRpb25LZXlmcmFtZXM7XG4gICAgY29uc3QgbGFzdEtleWZyYW1lID0gYW5pbWF0aW9uS2V5ZnJhbWVzW2FuaW1hdGlvbktleWZyYW1lcy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChKU09OLnN0cmluZ2lmeShmaXJzdEtleWZyYW1lKSA9PT0gSlNPTi5zdHJpbmdpZnkobGFzdEtleWZyYW1lKSkge1xuICAgICAgLy8gVGhlIHN0YXJ0IGFuZCBlbmQga2V5ZnJhbWVzIGFyZSB0aGUgc2FtZSwgaW5mZXIgdGhhdCB0aGVyZSBpcyBubyBhbmltYXRpb24gbmVlZGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNsZWFudXAgPSBzaWRlRWZmZWN0cyA9PSBudWxsID8gdm9pZCAwIDogc2lkZUVmZmVjdHMoe1xuICAgICAgYWN0aXZlLFxuICAgICAgZHJhZ092ZXJsYXksXG4gICAgICAuLi5yZXN0XG4gICAgfSk7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gZHJhZ092ZXJsYXkubm9kZS5hbmltYXRlKGFuaW1hdGlvbktleWZyYW1lcywge1xuICAgICAgZHVyYXRpb24sXG4gICAgICBlYXNpbmcsXG4gICAgICBmaWxsOiAnZm9yd2FyZHMnXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgYW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICBjbGVhbnVwID09IG51bGwgPyB2b2lkIDAgOiBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG59XG5cbmxldCBrZXkgPSAwO1xuZnVuY3Rpb24gdXNlS2V5KGlkKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGtleSsrO1xuICAgIHJldHVybiBrZXk7XG4gIH0sIFtpZF0pO1xufVxuXG5jb25zdCBEcmFnT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFkanVzdFNjYWxlID0gZmFsc2UsXG4gICAgY2hpbGRyZW4sXG4gICAgZHJvcEFuaW1hdGlvbjogZHJvcEFuaW1hdGlvbkNvbmZpZyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uLFxuICAgIG1vZGlmaWVycyxcbiAgICB3cmFwcGVyRWxlbWVudCA9ICdkaXYnLFxuICAgIGNsYXNzTmFtZSxcbiAgICB6SW5kZXggPSA5OTlcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHtcbiAgICBhY3RpdmF0b3JFdmVudCxcbiAgICBhY3RpdmUsXG4gICAgYWN0aXZlTm9kZVJlY3QsXG4gICAgY29udGFpbmVyTm9kZVJlY3QsXG4gICAgZHJhZ2dhYmxlTm9kZXMsXG4gICAgZHJvcHBhYmxlQ29udGFpbmVycyxcbiAgICBkcmFnT3ZlcmxheSxcbiAgICBvdmVyLFxuICAgIG1lYXN1cmluZ0NvbmZpZ3VyYXRpb24sXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB3aW5kb3dSZWN0XG4gIH0gPSB1c2VEbmRDb250ZXh0KCk7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IFJlYWN0LnVzZUNvbnRleHQoQWN0aXZlRHJhZ2dhYmxlQ29udGV4dCk7XG4gIGNvbnN0IGtleSA9IHVzZUtleShhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZCk7XG4gIGNvbnN0IG1vZGlmaWVkVHJhbnNmb3JtID0gYXBwbHlNb2RpZmllcnMobW9kaWZpZXJzLCB7XG4gICAgYWN0aXZhdG9yRXZlbnQsXG4gICAgYWN0aXZlLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGNvbnRhaW5lck5vZGVSZWN0LFxuICAgIGRyYWdnaW5nTm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgb3ZlcixcbiAgICBvdmVybGF5Tm9kZVJlY3Q6IGRyYWdPdmVybGF5LnJlY3QsXG4gICAgc2Nyb2xsYWJsZUFuY2VzdG9ycyxcbiAgICBzY3JvbGxhYmxlQW5jZXN0b3JSZWN0cyxcbiAgICB0cmFuc2Zvcm0sXG4gICAgd2luZG93UmVjdFxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFJlY3QgPSB1c2VJbml0aWFsVmFsdWUoYWN0aXZlTm9kZVJlY3QpO1xuICBjb25zdCBkcm9wQW5pbWF0aW9uID0gdXNlRHJvcEFuaW1hdGlvbih7XG4gICAgY29uZmlnOiBkcm9wQW5pbWF0aW9uQ29uZmlnLFxuICAgIGRyYWdnYWJsZU5vZGVzLFxuICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgbWVhc3VyaW5nQ29uZmlndXJhdGlvblxuICB9KTsgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgYWN0aXZlIG5vZGUgdG8gYmUgbWVhc3VyZWQgYmVmb3JlIGNvbm5lY3RpbmcgdGhlIGRyYWcgb3ZlcmxheSByZWZcbiAgLy8gb3RoZXJ3aXNlIGNvbGxpc2lvbnMgY2FuIGJlIGNvbXB1dGVkIGFnYWluc3QgYSBtaXNwb3NpdGlvbmVkIGRyYWcgb3ZlcmxheVxuXG4gIGNvbnN0IHJlZiA9IGluaXRpYWxSZWN0ID8gZHJhZ092ZXJsYXkuc2V0UmVmIDogdW5kZWZpbmVkO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChOdWxsaWZpZWRDb250ZXh0UHJvdmlkZXIsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQW5pbWF0aW9uTWFuYWdlciwge1xuICAgIGFuaW1hdGlvbjogZHJvcEFuaW1hdGlvblxuICB9LCBhY3RpdmUgJiYga2V5ID8gUmVhY3QuY3JlYXRlRWxlbWVudChQb3NpdGlvbmVkT3ZlcmxheSwge1xuICAgIGtleToga2V5LFxuICAgIGlkOiBhY3RpdmUuaWQsXG4gICAgcmVmOiByZWYsXG4gICAgYXM6IHdyYXBwZXJFbGVtZW50LFxuICAgIGFjdGl2YXRvckV2ZW50OiBhY3RpdmF0b3JFdmVudCxcbiAgICBhZGp1c3RTY2FsZTogYWRqdXN0U2NhbGUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICByZWN0OiBpbml0aWFsUmVjdCxcbiAgICBzdHlsZToge1xuICAgICAgekluZGV4LFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIHRyYW5zZm9ybTogbW9kaWZpZWRUcmFuc2Zvcm1cbiAgfSwgY2hpbGRyZW4pIDogbnVsbCkpO1xufSk7XG5cbmNvbnN0IHNuYXBDZW50ZXJUb0N1cnNvciA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGRyYWdnaW5nTm9kZVJlY3QsXG4gICAgdHJhbnNmb3JtXG4gIH0gPSBfcmVmO1xuXG4gIGlmIChkcmFnZ2luZ05vZGVSZWN0ICYmIGFjdGl2YXRvckV2ZW50KSB7XG4gICAgY29uc3QgYWN0aXZhdG9yQ29vcmRpbmF0ZXMgPSBnZXRFdmVudENvb3JkaW5hdGVzKGFjdGl2YXRvckV2ZW50KTtcblxuICAgIGlmICghYWN0aXZhdG9yQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgfVxuXG4gICAgY29uc3Qgb2Zmc2V0WCA9IGFjdGl2YXRvckNvb3JkaW5hdGVzLnggLSBkcmFnZ2luZ05vZGVSZWN0LmxlZnQ7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IGFjdGl2YXRvckNvb3JkaW5hdGVzLnkgLSBkcmFnZ2luZ05vZGVSZWN0LnRvcDtcbiAgICByZXR1cm4geyAuLi50cmFuc2Zvcm0sXG4gICAgICB4OiB0cmFuc2Zvcm0ueCArIG9mZnNldFggLSBkcmFnZ2luZ05vZGVSZWN0LndpZHRoIC8gMixcbiAgICAgIHk6IHRyYW5zZm9ybS55ICsgb2Zmc2V0WSAtIGRyYWdnaW5nTm9kZVJlY3QuaGVpZ2h0IC8gMlxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdHJhbnNmb3JtO1xufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVCb2FyZChub09mUm93cywgbm9PZkNvbHVtbnMsIGJvYXJkT3JpZW50YXRpb24pIHtcbiAgICBjb25zdCBib2FyZCA9IEFycmF5LmZyb20oQXJyYXkobm9PZlJvd3MpLCAoKSA9PiBuZXcgQXJyYXkobm9PZkNvbHVtbnMpKTtcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBub09mUm93czsgcm93KyspIHtcbiAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgbm9PZkNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBib2FyZFtyb3ddW2NvbHVtbl0gPSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlSWQ6IGAke2NvbHVtbkluZGV4VG9DaGVzc0NvbHVtbihjb2x1bW4sIG5vT2ZDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKX0ke3Jvd0luZGV4VG9DaGVzc1Jvdyhyb3csIG5vT2ZSb3dzLCBib2FyZE9yaWVudGF0aW9uKX1gLCAvLyBlLmcuIFwiYThcIiBmb3Igcm93IDAsIGNvbHVtbiAwIGluIHdoaXRlIG9yaWVudGF0aW9uXG4gICAgICAgICAgICAgICAgaXNMaWdodFNxdWFyZTogKHJvdyArIGNvbHVtbikgJSAyID09PSAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm9hcmQ7XG59XG5mdW5jdGlvbiByb3dJbmRleFRvQ2hlc3NSb3cocm93LCBub09mUm93cywgYm9hcmRPcmllbnRhdGlvbikge1xuICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSAnd2hpdGUnXG4gICAgICAgID8gKG5vT2ZSb3dzIC0gcm93KS50b1N0cmluZygpXG4gICAgICAgIDogKHJvdyArIDEpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBjb2x1bW5JbmRleFRvQ2hlc3NDb2x1bW4oY29sdW1uLCBub09mQ29sdW1ucywgYm9hcmRPcmllbnRhdGlvbikge1xuICAgIHJldHVybiBib2FyZE9yaWVudGF0aW9uID09PSAnd2hpdGUnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIGNvbHVtbilcbiAgICAgICAgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgbm9PZkNvbHVtbnMgLSBjb2x1bW4gLSAxKTtcbn1cbmZ1bmN0aW9uIGNoZXNzQ29sdW1uVG9Db2x1bW5JbmRleChjb2x1bW4sIG5vT2ZDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKSB7XG4gICAgcmV0dXJuIGJvYXJkT3JpZW50YXRpb24gPT09ICd3aGl0ZSdcbiAgICAgICAgPyBjb2x1bW4uY2hhckNvZGVBdCgwKSAtIDk3XG4gICAgICAgIDogbm9PZkNvbHVtbnMgLSAoY29sdW1uLmNoYXJDb2RlQXQoMCkgLSA5NykgLSAxO1xufVxuZnVuY3Rpb24gY2hlc3NSb3dUb1Jvd0luZGV4KHJvdywgbm9PZlJvd3MsIGJvYXJkT3JpZW50YXRpb24pIHtcbiAgICByZXR1cm4gYm9hcmRPcmllbnRhdGlvbiA9PT0gJ3doaXRlJ1xuICAgICAgICA/IG5vT2ZSb3dzIC0gTnVtYmVyKHJvdylcbiAgICAgICAgOiBOdW1iZXIocm93KSAtIDE7XG59XG5mdW5jdGlvbiBmZW5TdHJpbmdUb1Bvc2l0aW9uT2JqZWN0KGZlbiwgbm9PZlJvd3MsIG5vT2ZDb2x1bW5zKSB7XG4gICAgY29uc3QgcG9zaXRpb25PYmplY3QgPSB7fTtcbiAgICBjb25zdCByb3dzID0gZmVuLnNwbGl0KCcgJylbMF0uc3BsaXQoJy8nKTtcbiAgICAvLyByb3dzIHN0YXJ0IGZyb20gdG9wIG9mIHRoZSBib2FyZCAoYmxhY2sgcmFuaykgaW4gd2hpdGUgb3JpZW50YXRpb24sIGFuZCBib3R0b20gb2YgdGhlIGJvYXJkICh3aGl0ZSByYW5rKSBpbiBibGFjayBvcmllbnRhdGlvblxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd3MubGVuZ3RoOyByb3crKykge1xuICAgICAgICBsZXQgY29sdW1uID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjaGFyIG9mIHJvd3Nbcm93XSkge1xuICAgICAgICAgICAgLy8gaWYgY2hhciBpcyBhIGxldHRlciwgaXQgaXMgYSBwaWVjZVxuICAgICAgICAgICAgaWYgKGlzTmFOKE51bWJlcihjaGFyKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSBvcmllbnRhdGlvbiB0byBmbGlwIGZlbiBzdHJpbmcgd2hlbiBibGFjayBvcmllbnRhdGlvbiB1c2VkXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBgJHtjb2x1bW5JbmRleFRvQ2hlc3NDb2x1bW4oY29sdW1uLCBub09mQ29sdW1ucywgJ3doaXRlJyl9JHtyb3dJbmRleFRvQ2hlc3NSb3cocm93LCBub09mUm93cywgJ3doaXRlJyl9YDtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcGllY2UgYXQgcG9zaXRpb24gKGUuZy4gMC0wIGZvciBhOCBvbiBhIG5vcm1hbCBib2FyZClcbiAgICAgICAgICAgICAgICBwb3NpdGlvbk9iamVjdFtwb3NpdGlvbl0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlVHlwZTogZmVuVG9QaWVjZUNvZGUoY2hhciksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgY29sdW1uIGZvciBuZXh0IHBpZWNlXG4gICAgICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBjaGFyIGlzIGEgbnVtYmVyLCBpdCBpcyBlbXB0eSBzcXVhcmVzLCBza2lwIHRoYXQgbWFueSBjb2x1bW5zXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IE51bWJlcihjaGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25PYmplY3Q7XG59XG4vKipcbiAqIENvbnZlcnQgZmVuIHBpZWNlIGNvZGUgKGUuZy4gcCwgTikgdG8gY2FtZWwgY2FzZSBub3RhdGlvbiAoZS5nLiBiUCwgd0spLlxuICovXG5mdW5jdGlvbiBmZW5Ub1BpZWNlQ29kZShwaWVjZSkge1xuICAgIC8vIGxvd2VyIGNhc2UgaXMgYmxhY2sgcGllY2VcbiAgICBpZiAocGllY2UudG9Mb3dlckNhc2UoKSA9PT0gcGllY2UpIHtcbiAgICAgICAgcmV0dXJuICdiJyArIHBpZWNlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIC8vIHVwcGVyIGNhc2UgaXMgd2hpdGUgcGllY2VcbiAgICByZXR1cm4gJ3cnICsgcGllY2UudG9VcHBlckNhc2UoKTtcbn1cbi8vIHRvZG86IGlmIGFscmVhZHkgaW4gdXBkYXRlcywgZmluZCBuZXh0IGNhbmRpZGF0ZVxuLyoqXG4gKiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdGhlIHBpZWNlcyB0aGF0IGhhdmUgbW92ZWQgZnJvbSB0aGUgb2xkIHBvc2l0aW9uIHRvIHRoZSBuZXcgcG9zaXRpb24uXG4gKiBUaGUga2V5cyBhcmUgdGhlIHNvdXJjZSBzcXVhcmUgbmFtZXMgKGUuZy4gXCJlMlwiKSBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlIG5ldyBzcXVhcmUgcG9zaXRpb25zIChlLmcuIFwiZTRcIiksIGluZGljYXRpbmcgdGhhdCB0aGUgcGllY2UgaW4gc3F1YXJlIFwiZTJcIiBoYXMgbW92ZWQgdG8gc3F1YXJlIFwiZTRcIi5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25VcGRhdGVzKG9sZFBvc2l0aW9uLCBuZXdQb3NpdGlvbiwgbm9PZkNvbHVtbnMsIGJvYXJkT3JpZW50YXRpb24pIHtcbiAgICBjb25zdCB1cGRhdGVzID0ge307XG4gICAgZm9yIChjb25zdCBuZXdTcXVhcmUgaW4gbmV3UG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlU3F1YXJlcyA9IFtdO1xuICAgICAgICAvLyB0aGUgcGllY2UgaGFzbid0IG1vdmVkLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIGlmIChvbGRQb3NpdGlvbltuZXdTcXVhcmVdPy5waWVjZVR5cGUgPT09IG5ld1Bvc2l0aW9uW25ld1NxdWFyZV0ucGllY2VUeXBlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IG9sZFNxdWFyZSBpbiBvbGRQb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBpZWNlIHR5cGUgaXMgdGhlIHNhbWUsIGFuZCB0aGUgbmV3IHNxdWFyZSBpcyBub3QgdGhlIG9sZCBzcXVhcmUsIGFuZCB0aGUgcGllY2UgaGFzIG1vdmVkLCB0aGVuIHdlIGhhdmUgZm91bmQgYSBjYW5kaWRhdGUgZm9yIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgICAgICAgIGlmIChvbGRQb3NpdGlvbltvbGRTcXVhcmVdLnBpZWNlVHlwZSA9PT0gbmV3UG9zaXRpb25bbmV3U3F1YXJlXS5waWVjZVR5cGUgJiZcbiAgICAgICAgICAgICAgICBvbGRTcXVhcmUgIT09IG5ld1NxdWFyZSAmJlxuICAgICAgICAgICAgICAgIG9sZFBvc2l0aW9uW29sZFNxdWFyZV0ucGllY2VUeXBlICE9PSBuZXdQb3NpdGlvbltvbGRTcXVhcmVdPy5waWVjZVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVTcXVhcmVzLnB1c2gob2xkU3F1YXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuZGlkYXRlU3F1YXJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNhbmRpZGF0ZSwgd2UgY2FuIGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICB1cGRhdGVzW2NhbmRpZGF0ZVNxdWFyZXNbMF1dID0gbmV3U3F1YXJlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMsIHdlIG5lZWQgdG8gZmluZCB0aGUgb25lIHRoYXQgaXMgY29ycmVjdCB0byB0aGUgYmVzdCBvZiBvdXIgYWJpbGl0eSBieSBzdGFuZGFyZCBjaGVzcyBydWxlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGVTcXVhcmUgb2YgY2FuZGlkYXRlU3F1YXJlcykge1xuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgcGllY2UgdHlwZSBvZiB0aGUgY2FuZGlkYXRlIGUuZy4gJ1AnLCAnTicsICdCJywgJ1InLCAnUScsICdLJ1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZVBpZWNlVHlwZSA9IG9sZFBvc2l0aW9uW2NhbmRpZGF0ZVNxdWFyZV0ucGllY2VUeXBlWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbkRpZmZlcmVuY2UgPSBNYXRoLmFicyhjaGVzc0NvbHVtblRvQ29sdW1uSW5kZXgoY2FuZGlkYXRlU3F1YXJlLm1hdGNoKC9eW2Etel0rLyk/LlswXSA/PyAnJywgbm9PZkNvbHVtbnMsIGJvYXJkT3JpZW50YXRpb24pIC1cbiAgICAgICAgICAgICAgICAgICAgY2hlc3NDb2x1bW5Ub0NvbHVtbkluZGV4KG5ld1NxdWFyZS5tYXRjaCgvXlthLXpdKy8pPy5bMF0gPz8gJycsIG5vT2ZDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93RGlmZmVyZW5jZSA9IE1hdGguYWJzKE51bWJlcihjYW5kaWRhdGVTcXVhcmUubWF0Y2goL1xcZCskLyk/LlswXSA/PyAnJykgLVxuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobmV3U3F1YXJlLm1hdGNoKC9cXGQrJC8pPy5bMF0gPz8gJycpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc09sZFNxdWFyZUxpZ2h0ID0gKGNoZXNzQ29sdW1uVG9Db2x1bW5JbmRleChjYW5kaWRhdGVTcXVhcmUubWF0Y2goL15bYS16XSsvKT8uWzBdID8/ICcnLCBub09mQ29sdW1ucywgYm9hcmRPcmllbnRhdGlvbikgK1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXIoY2FuZGlkYXRlU3F1YXJlLm1hdGNoKC9cXGQrJC8pPy5bMF0gPz8gJycpKSAlXG4gICAgICAgICAgICAgICAgICAgIDIgPT09XG4gICAgICAgICAgICAgICAgICAgIDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNOZXdTcXVhcmVMaWdodCA9IChjaGVzc0NvbHVtblRvQ29sdW1uSW5kZXgobmV3U3F1YXJlLm1hdGNoKC9eW2Etel0rLyk/LlswXSA/PyAnJywgbm9PZkNvbHVtbnMsIGJvYXJkT3JpZW50YXRpb24pICtcbiAgICAgICAgICAgICAgICAgICAgTnVtYmVyKG5ld1NxdWFyZS5tYXRjaCgvXFxkKyQvKT8uWzBdID8/ICcnKSkgJVxuICAgICAgICAgICAgICAgICAgICAyID09PVxuICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICAgICAgICAgIC8vIHByaW9yaXRpc2UgcGF3bnMgb24gc2FtZSBmaWxlXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVBpZWNlVHlwZSA9PT0gJ1AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVTcXVhcmUubWF0Y2goL15bYS16XSsvKT8uWzBdID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U3F1YXJlLm1hdGNoKC9eW2Etel0rLyk/LlswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlc1tjYW5kaWRhdGVTcXVhcmVdID0gbmV3U3F1YXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJpb3JpdGlzZSBrbmlnaHRzIGJ5IGV1Y2xpZGVhbiBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVQaWVjZVR5cGUgPT09ICdOJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbHVtbkRpZmZlcmVuY2UgPT09IDIgJiYgcm93RGlmZmVyZW5jZSA9PT0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2x1bW5EaWZmZXJlbmNlID09PSAxICYmIHJvd0RpZmZlcmVuY2UgPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzW2NhbmRpZGF0ZVNxdWFyZV0gPSBuZXdTcXVhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0aXNlIGJpc2hvcHMgdGhhdCBoYXZlIG1vdmVkIGRpYWdvbmFsbHkgYW5kIGFyZSBvbiB0aGUgc2FtZSBjb2xvciBzcXVhcmVcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlUGllY2VUeXBlID09PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbkRpZmZlcmVuY2UgPT09IHJvd0RpZmZlcmVuY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT2xkU3F1YXJlTGlnaHQgPT09IGlzTmV3U3F1YXJlTGlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXNbY2FuZGlkYXRlU3F1YXJlXSA9IG5ld1NxdWFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByaW9yaXRpc2Ugcm9va3MgdGhhdCBoYXZlIG1vdmVkIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVBpZWNlVHlwZSA9PT0gJ1InKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5EaWZmZXJlbmNlID09PSAwIHx8IHJvd0RpZmZlcmVuY2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXNbY2FuZGlkYXRlU3F1YXJlXSA9IG5ld1NxdWFyZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByaW9yaXRpc2UgcXVlZW5zIHRoYXQgaGF2ZSBtb3ZlZCBkaWFnb25hbGx5LCBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVQaWVjZVR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uRGlmZmVyZW5jZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcm93RGlmZmVyZW5jZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uRGlmZmVyZW5jZSA9PT0gcm93RGlmZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlc1tjYW5kaWRhdGVTcXVhcmVdID0gbmV3U3F1YXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcHJpb3JpdGlzZSBraW5ncyB0aGF0IGhhdmUgbW92ZWQgb25lIHNxdWFyZSBpbiBhbnkgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZVBpZWNlVHlwZSA9PT0gJ0snKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW5EaWZmZXJlbmNlIDw9IDEgJiYgcm93RGlmZmVyZW5jZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzW2NhbmRpZGF0ZVNxdWFyZV0gPSBuZXdTcXVhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBjYW5kaWRhdGUsIHVzZSB0aGUgZmlyc3QgY2FuZGlkYXRlIHRoYXQgaGFzIG5vdCBiZWVuIHVzZWQgeWV0XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXModXBkYXRlcykuaW5jbHVkZXMobmV3U3F1YXJlKSAmJlxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZVNxdWFyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlU3F1YXJlIG9mIGNhbmRpZGF0ZVNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyh1cGRhdGVzKS5pbmNsdWRlcyhjYW5kaWRhdGVTcXVhcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzW2NhbmRpZGF0ZVNxdWFyZV0gPSBuZXdTcXVhcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlcztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb29yZGluYXRlcyBhdCB0aGUgY2VudHJlIG9mIHRoZSByZXF1ZXN0ZWQgc3F1YXJlLCByZWxhdGl2ZSB0byB0aGUgdG9wIGxlZnQgb2YgdGhlIGJvYXJkICgwLCAwKS5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVsYXRpdmVDb29yZHMoYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgY2hlc3Nib2FyZENvbHVtbnMsIGNoZXNzYm9hcmRSb3dzLCBzcXVhcmUpIHtcbiAgICBjb25zdCBzcXVhcmVXaWR0aCA9IGJvYXJkV2lkdGggLyBjaGVzc2JvYXJkQ29sdW1ucztcbiAgICBjb25zdCB4ID0gY2hlc3NDb2x1bW5Ub0NvbHVtbkluZGV4KHNxdWFyZS5tYXRjaCgvXlthLXpdKy8pPy5bMF0gPz8gJycsIGNoZXNzYm9hcmRDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKSAqXG4gICAgICAgIHNxdWFyZVdpZHRoICtcbiAgICAgICAgc3F1YXJlV2lkdGggLyAyO1xuICAgIGNvbnN0IHkgPSBjaGVzc1Jvd1RvUm93SW5kZXgoc3F1YXJlLm1hdGNoKC9cXGQrJC8pPy5bMF0gPz8gJycsIGNoZXNzYm9hcmRSb3dzLCBib2FyZE9yaWVudGF0aW9uKSAqXG4gICAgICAgIHNxdWFyZVdpZHRoICtcbiAgICAgICAgc3F1YXJlV2lkdGggLyAyO1xuICAgIHJldHVybiB7IHgsIHkgfTtcbn1cblxuY29uc3QgZGVmYXVsdFBpZWNlcyA9IHtcbiAgICB3UDogKHByb3BzKSA9PiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgNDUgNDVcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBzdHlsZTogcHJvcHM/LnN2Z1N0eWxlLCBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwibSAyMi41LDkgYyAtMi4yMSwwIC00LDEuNzkgLTQsNCAwLDAuODkgMC4yOSwxLjcxIDAuNzgsMi4zOCBDIDE3LjMzLDE2LjUgMTYsMTguNTkgMTYsMjEgYyAwLDIuMDMgMC45NCwzLjg0IDIuNDEsNS4wMyBDIDE1LjQxLDI3LjA5IDExLDMxLjU4IDExLDM5LjUgSCAzNCBDIDM0LDMxLjU4IDI5LjU5LDI3LjA5IDI2LjU5LDI2LjAzIDI4LjA2LDI0Ljg0IDI5LDIzLjAzIDI5LDIxIDI5LDE4LjU5IDI3LjY3LDE2LjUgMjUuNzIsMTUuMzggMjYuMjEsMTQuNzEgMjYuNSwxMy44OSAyNi41LDEzIGMgMCwtMi4yMSAtMS43OSwtNCAtNCwtNCB6XCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgICAgIGZpbGw6IHByb3BzPy5maWxsID8/ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiAnbm9uemVybycsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxLjUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogJzQnLFxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgIH0gfSkgfSkpLFxuICAgIHdSOiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgICAgIGZpbGw6IHByb3BzPy5maWxsID8/ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiAnZXZlbm9kZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxLjUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogJzQnLFxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDM5IEwgMzYsMzkgTCAzNiwzNiBMIDksMzYgTCA5LDM5IHogXCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6ICdidXR0JyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLDM2IEwgMTIsMzIgTCAzMywzMiBMIDMzLDM2IEwgMTIsMzYgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogJ2J1dHQnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEsMTQgTCAxMSw5IEwgMTUsOSBMIDE1LDExIEwgMjAsMTEgTCAyMCw5IEwgMjUsOSBMIDI1LDExIEwgMzAsMTEgTCAzMCw5IEwgMzQsOSBMIDM0LDE0XCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6ICdidXR0JyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDM0LDE0IEwgMzEsMTcgTCAxNCwxNyBMIDExLDE0XCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMzEsMTcgTCAzMSwyOS41IEwgMTQsMjkuNSBMIDE0LDE3XCIsIHN0eWxlOiB7IHN0cm9rZUxpbmVjYXA6ICdidXR0Jywgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAzMSwyOS41IEwgMzIuNSwzMiBMIDEyLjUsMzIgTCAxNCwyOS41XCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEsMTQgTCAzNCwxNFwiLCBzdHlsZTogeyBmaWxsOiAnbm9uZScsIHN0cm9rZTogJyMwMDAwMDAnLCBzdHJva2VMaW5lam9pbjogJ21pdGVyJyB9IH0pXSB9KSB9KSksXG4gICAgd046IChwcm9wcykgPT4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIDQ1IDQ1XCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgc3R5bGU6IHByb3BzPy5zdmdTdHlsZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJnXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdldmVub2RkJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsIHN0eWxlOiB7IGZpbGw6IHByb3BzPy5maWxsID8/ICcjZmZmZmZmJywgc3Ryb2tlOiAnIzAwMDAwMCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNCwxOCBDIDI0LjM4LDIwLjkxIDE4LjQ1LDI1LjM3IDE2LDI3IEMgMTMsMjkgMTMuMTgsMzEuMzQgMTEsMzEgQyA5Ljk1OCwzMC4wNiAxMi40MSwyNy45NiAxMSwyOCBDIDEwLDI4IDExLjE5LDI5LjIzIDEwLDMwIEMgOSwzMCA1Ljk5NywzMSA2LDI2IEMgNiwyNCAxMiwxNCAxMiwxNCBDIDEyLDE0IDEzLjg5LDEyLjEgMTQsMTAuNSBDIDEzLjI3LDkuNTA2IDEzLjUsOC41IDEzLjUsNy41IEMgMTQuNSw2LjUgMTYuNSwxMCAxNi41LDEwIEwgMTguNSwxMCBDIDE4LjUsMTAgMTkuMjgsOC4wMDggMjEsNyBDIDIyLDcgMjIsMTAgMjIsMTBcIiwgc3R5bGU6IHsgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyNmZmZmZmYnLCBzdHJva2U6ICcjMDAwMDAwJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDkuNSAyNS41IEEgMC41IDAuNSAwIDEgMSA4LjUsMjUuNSBBIDAuNSAwLjUgMCAxIDEgOS41IDI1LjUgelwiLCBzdHlsZTogeyBmaWxsOiAnIzAwMDAwMCcsIHN0cm9rZTogJyMwMDAwMDAnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIiwgdHJhbnNmb3JtOiBcIm1hdHJpeCgwLjg2NiwwLjUsLTAuNSwwLjg2Niw5LjY5MywtNS4xNzMpXCIsIHN0eWxlOiB7IGZpbGw6ICcjMDAwMDAwJywgc3Ryb2tlOiAnIzAwMDAwMCcgfSB9KV0gfSkgfSkpLFxuICAgIHdCOiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICBmaWxsUnVsZTogJ2V2ZW5vZGQnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxLjUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTWl0ZXJsaW1pdDogJzQnLFxuICAgICAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogJ25vbmUnLFxuICAgICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4cyhcImdcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiAnYnV0dCcsXG4gICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSA5LDM2IEMgMTIuMzksMzUuMDMgMTkuMTEsMzYuNDMgMjIuNSwzNCBDIDI1Ljg5LDM2LjQzIDMyLjYxLDM1LjAzIDM2LDM2IEMgMzYsMzYgMzcuNjUsMzYuNTQgMzksMzggQyAzOC4zMiwzOC45NyAzNy4zNSwzOC45OSAzNiwzOC41IEMgMzIuNjEsMzcuNTMgMjUuODksMzguOTYgMjIuNSwzNy41IEMgMTkuMTEsMzguOTYgMTIuMzksMzcuNTMgOSwzOC41IEMgNy42NSwzOC45OSA2LjY4LDM4Ljk3IDYsMzggQyA3LjM1LDM2LjU0IDksMzYgOSwzNiB6XCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUsMzIgQyAxNy41LDM0LjUgMjcuNSwzNC41IDMwLDMyIEMgMzAuNSwzMC41IDMwLDMwIDMwLDMwIEMgMzAsMjcuNSAyNy41LDI2IDI3LjUsMjYgQyAzMywyNC41IDMzLjUsMTQuNSAyMi41LDEwLjUgQyAxMS41LDE0LjUgMTIsMjQuNSAxNy41LDI2IEMgMTcuNSwyNiAxNSwyNy41IDE1LDMwIEMgMTUsMzAgMTQuNSwzMC41IDE1LDMyIHpcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNSA4IEEgMi41IDIuNSAwIDEgMSAgMjAsOCBBIDIuNSAyLjUgMCAxIDEgIDI1IDggelwiIH0pXSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNy41LDI2IEwgMjcuNSwyNiBNIDE1LDMwIEwgMzAsMzAgTSAyMi41LDE1LjUgTCAyMi41LDIwLjUgTSAyMCwxOCBMIDI1LDE4XCIsIHN0eWxlOiB7IGZpbGw6ICdub25lJywgc3Ryb2tlOiAnIzAwMDAwMCcsIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInIH0gfSldIH0pIH0pKSxcbiAgICB3UTogKHByb3BzKSA9PiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIHsgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmVyc2lvbjogXCIxLjFcIiwgdmlld0JveDogXCIwIDAgNDUgNDVcIiwgd2lkdGg6IFwiMTAwJVwiLCBoZWlnaHQ6IFwiMTAwJVwiLCBzdHlsZTogcHJvcHM/LnN2Z1N0eWxlLCBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4cyhcImdcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZpbGw6IHByb3BzPy5maWxsID8/ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG4gICAgICAgICAgICB9LCBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gOSwyNiBDIDE3LjUsMjQuNSAzMCwyNC41IDM2LDI2IEwgMzguNSwxMy41IEwgMzEsMjUgTCAzMC43LDEwLjkgTCAyNS41LDI0LjUgTCAyMi41LDEwIEwgMTkuNSwyNC41IEwgMTQuMywxMC45IEwgMTQsMjUgTCA2LjUsMTMuNSBMIDksMjYgelwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMjYgQyA5LDI4IDEwLjUsMjggMTEuNSwzMCBDIDEyLjUsMzEuNSAxMi41LDMxIDEyLDMzLjUgQyAxMC41LDM0LjUgMTEsMzYgMTEsMzYgQyA5LjUsMzcuNSAxMSwzOC41IDExLDM4LjUgQyAxNy41LDM5LjUgMjcuNSwzOS41IDM0LDM4LjUgQyAzNCwzOC41IDM1LjUsMzcuNSAzNCwzNiBDIDM0LDM2IDM0LjUsMzQuNSAzMywzMy41IEMgMzIuNSwzMSAzMi41LDMxLjUgMzMuNSwzMCBDIDM0LjUsMjggMzYsMjggMzYsMjYgQyAyNy41LDI0LjUgMTcuNSwyNC41IDksMjYgelwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLjUsMzAgQyAxNSwyOSAzMCwyOSAzMy41LDMwXCIsIHN0eWxlOiB7IGZpbGw6ICdub25lJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLDMzLjUgQyAxOCwzMi41IDI3LDMyLjUgMzMsMzMuNVwiLCBzdHlsZTogeyBmaWxsOiAnbm9uZScgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiNlwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMTRcIiwgY3k6IFwiOVwiLCByOiBcIjJcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMjIuNVwiLCBjeTogXCI4XCIsIHI6IFwiMlwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzMVwiLCBjeTogXCI5XCIsIHI6IFwiMlwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJjaXJjbGVcIiwgeyBjeDogXCIzOVwiLCBjeTogXCIxMlwiLCByOiBcIjJcIiB9KV0gfSkgfSkpLFxuICAgIHdLOiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdldmVub2RkJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLjUsMTEuNjMgTCAyMi41LDZcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJywgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMCw4IEwgMjUsOFwiLCBzdHlsZTogeyBmaWxsOiAnbm9uZScsIHN0cm9rZTogJyMwMDAwMDAnLCBzdHJva2VMaW5lam9pbjogJ21pdGVyJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLjUsMjUgQyAyMi41LDI1IDI3LDE3LjUgMjUuNSwxNC41IEMgMjUuNSwxNC41IDI0LjUsMTIgMjIuNSwxMiBDIDIwLjUsMTIgMTkuNSwxNC41IDE5LjUsMTQuNSBDIDE4LDE3LjUgMjIuNSwyNSAyMi41LDI1XCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wcz8uZmlsbCA/PyAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdidXR0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzcgQyAxOCw0MC41IDI3LDQwLjUgMzIuNSwzNyBMIDMyLjUsMzAgQyAzMi41LDMwIDQxLjUsMjUuNSAzOC41LDE5LjUgQyAzNC41LDEzIDI1LDE2IDIyLjUsMjMuNSBMIDIyLjUsMjcgTCAyMi41LDIzLjUgQyAyMCwxNiAxMC41LDEzIDYuNSwxOS41IEMgMy41LDI1LjUgMTIuNSwzMCAxMi41LDMwIEwgMTIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBwcm9wcz8uZmlsbCA/PyAnI2ZmZmZmZicsIHN0cm9rZTogJyMwMDAwMDAnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIuNSwzMCBDIDE4LDI3IDI3LDI3IDMyLjUsMzBcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjVcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzcgQyAxOCwzNCAyNywzNCAzMi41LDM3XCIsIHN0eWxlOiB7IGZpbGw6ICdub25lJywgc3Ryb2tlOiAnIzAwMDAwMCcgfSB9KV0gfSkgfSkpLFxuICAgIGJQOiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJtIDIyLjUsOSBjIC0yLjIxLDAgLTQsMS43OSAtNCw0IDAsMC44OSAwLjI5LDEuNzEgMC43OCwyLjM4IEMgMTcuMzMsMTYuNSAxNiwxOC41OSAxNiwyMSBjIDAsMi4wMyAwLjk0LDMuODQgMi40MSw1LjAzIEMgMTUuNDEsMjcuMDkgMTEsMzEuNTggMTEsMzkuNSBIIDM0IEMgMzQsMzEuNTggMjkuNTksMjcuMDkgMjYuNTksMjYuMDMgMjguMDYsMjQuODQgMjksMjMuMDMgMjksMjEgMjksMTguNTkgMjcuNjcsMTYuNSAyNS43MiwxNS4zOCAyNi4yMSwxNC43MSAyNi41LDEzLjg5IDI2LjUsMTMgYyAwLC0yLjIxIC0xLjc5LC00IC00LC00IHpcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdub256ZXJvJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ21pdGVyJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSB9KSB9KSksXG4gICAgYlI6IChwcm9wcykgPT4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIDQ1IDQ1XCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgc3R5bGU6IHByb3BzPy5zdmdTdHlsZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJnXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdldmVub2RkJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMzkgTCAzNiwzOSBMIDM2LDM2IEwgOSwzNiBMIDksMzkgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogJ2J1dHQnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIuNSwzMiBMIDE0LDI5LjUgTCAzMSwyOS41IEwgMzIuNSwzMiBMIDEyLjUsMzIgeiBcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogJ2J1dHQnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTIsMzYgTCAxMiwzMiBMIDMzLDMyIEwgMzMsMzYgTCAxMiwzNiB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiAnYnV0dCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNCwyOS41IEwgMTQsMTYuNSBMIDMxLDE2LjUgTCAzMSwyOS41IEwgMTQsMjkuNSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiAnYnV0dCcsIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMTYuNSBMIDExLDE0IEwgMzQsMTQgTCAzMSwxNi41IEwgMTQsMTYuNSB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiAnYnV0dCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMSwxNCBMIDExLDkgTCAxNSw5IEwgMTUsMTEgTCAyMCwxMSBMIDIwLDkgTCAyNSw5IEwgMjUsMTEgTCAzMCwxMSBMIDMwLDkgTCAzNCw5IEwgMzQsMTQgTCAxMSwxNCB6IFwiLCBzdHlsZTogeyBzdHJva2VMaW5lY2FwOiAnYnV0dCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMiwzNS41IEwgMzMsMzUuNSBMIDMzLDM1LjVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEzLDMxLjUgTCAzMiwzMS41XCIsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAnMScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ21pdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNCwyOS41IEwgMzEsMjkuNVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicsXG4gICAgICAgICAgICAgICAgICAgIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTQsMTYuNSBMIDMxLDE2LjVcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLDE0IEwgMzQsMTRcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICB9IH0pXSB9KSB9KSksXG4gICAgYk46IChwcm9wcykgPT4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIDQ1IDQ1XCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgc3R5bGU6IHByb3BzPy5zdmdTdHlsZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJnXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdldmVub2RkJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLDEwIEMgMzIuNSwxMSAzOC41LDE4IDM4LDM5IEwgMTUsMzkgQyAxNSwzMCAyNSwzMi41IDIzLDE4XCIsIHN0eWxlOiB7IGZpbGw6IHByb3BzPy5maWxsID8/ICcjMDAwMDAwJywgc3Ryb2tlOiAnIzAwMDAwMCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNCwxOCBDIDI0LjM4LDIwLjkxIDE4LjQ1LDI1LjM3IDE2LDI3IEMgMTMsMjkgMTMuMTgsMzEuMzQgMTEsMzEgQyA5Ljk1OCwzMC4wNiAxMi40MSwyNy45NiAxMSwyOCBDIDEwLDI4IDExLjE5LDI5LjIzIDEwLDMwIEMgOSwzMCA1Ljk5NywzMSA2LDI2IEMgNiwyNCAxMiwxNCAxMiwxNCBDIDEyLDE0IDEzLjg5LDEyLjEgMTQsMTAuNSBDIDEzLjI3LDkuNTA2IDEzLjUsOC41IDEzLjUsNy41IEMgMTQuNSw2LjUgMTYuNSwxMCAxNi41LDEwIEwgMTguNSwxMCBDIDE4LjUsMTAgMTkuMjgsOC4wMDggMjEsNyBDIDIyLDcgMjIsMTAgMjIsMTBcIiwgc3R5bGU6IHsgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyMwMDAwMDAnLCBzdHJva2U6ICcjMDAwMDAwJyB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDkuNSAyNS41IEEgMC41IDAuNSAwIDEgMSA4LjUsMjUuNSBBIDAuNSAwLjUgMCAxIDEgOS41IDI1LjUgelwiLCBzdHlsZTogeyBmaWxsOiAnI2ZmZmZmZicsIHN0cm9rZTogJyNmZmZmZmYnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTUgMTUuNSBBIDAuNSAxLjUgMCAxIDEgIDE0LDE1LjUgQSAwLjUgMS41IDAgMSAxICAxNSAxNS41IHpcIiwgdHJhbnNmb3JtOiBcIm1hdHJpeCgwLjg2NiwwLjUsLTAuNSwwLjg2Niw5LjY5MywtNS4xNzMpXCIsIHN0eWxlOiB7IGZpbGw6ICcjZmZmZmZmJywgc3Ryb2tlOiAnI2ZmZmZmZicgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyNC41NSwxMC40IEwgMjQuMSwxMS44NSBMIDI0LjYsMTIgQyAyNy43NSwxMyAzMC4yNSwxNC40OSAzMi41LDE4Ljc1IEMgMzQuNzUsMjMuMDEgMzUuNzUsMjkuMDYgMzUuMjUsMzkgTCAzNS4yLDM5LjUgTCAzNy40NSwzOS41IEwgMzcuNSwzOSBDIDM4LDI4Ljk0IDM2LjYyLDIyLjE1IDM0LjI1LDE3LjY2IEMgMzEuODgsMTMuMTcgMjguNDYsMTEuMDIgMjUuMDYsMTAuNSBMIDI0LjU1LDEwLjQgeiBcIiwgc3R5bGU6IHsgZmlsbDogJyNmZmZmZmYnLCBzdHJva2U6ICdub25lJyB9IH0pXSB9KSB9KSksXG4gICAgYkI6IChwcm9wcykgPT4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInN2Z1wiLCB7IHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIHZlcnNpb246IFwiMS4xXCIsIHZpZXdCb3g6IFwiMCAwIDQ1IDQ1XCIsIHdpZHRoOiBcIjEwMCVcIiwgaGVpZ2h0OiBcIjEwMCVcIiwgc3R5bGU6IHByb3BzPy5zdmdTdHlsZSwgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJnXCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZpbGxSdWxlOiAnZXZlbm9kZCcsXG4gICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsOiBwcm9wcz8uZmlsbCA/PyAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdidXR0JyxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMzYgQyAxMi4zOSwzNS4wMyAxOS4xMSwzNi40MyAyMi41LDM0IEMgMjUuODksMzYuNDMgMzIuNjEsMzUuMDMgMzYsMzYgQyAzNiwzNiAzNy42NSwzNi41NCAzOSwzOCBDIDM4LjMyLDM4Ljk3IDM3LjM1LDM4Ljk5IDM2LDM4LjUgQyAzMi42MSwzNy41MyAyNS44OSwzOC45NiAyMi41LDM3LjUgQyAxOS4xMSwzOC45NiAxMi4zOSwzNy41MyA5LDM4LjUgQyA3LjY1LDM4Ljk5IDYuNjgsMzguOTcgNiwzOCBDIDcuMzUsMzYuNTQgOSwzNiA5LDM2IHpcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxNSwzMiBDIDE3LjUsMzQuNSAyNy41LDM0LjUgMzAsMzIgQyAzMC41LDMwLjUgMzAsMzAgMzAsMzAgQyAzMCwyNy41IDI3LjUsMjYgMjcuNSwyNiBDIDMzLDI0LjUgMzMuNSwxNC41IDIyLjUsMTAuNSBDIDExLjUsMTQuNSAxMiwyNC41IDE3LjUsMjYgQyAxNy41LDI2IDE1LDI3LjUgMTUsMzAgQyAxNSwzMCAxNC41LDMwLjUgMTUsMzIgelwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDI1IDggQSAyLjUgMi41IDAgMSAxICAyMCw4IEEgMi41IDIuNSAwIDEgMSAgMjUgOCB6XCIgfSldIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDE3LjUsMjYgTCAyNy41LDI2IE0gMTUsMzAgTCAzMCwzMCBNIDIyLjUsMTUuNSBMIDIyLjUsMjAuNSBNIDIwLDE4IEwgMjUsMThcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjZmZmZmZmJywgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicgfSB9KV0gfSkgfSkpLFxuICAgIGJROiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAnMS41JyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwOiAncm91bmQnLFxuICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDksMjYgQyAxNy41LDI0LjUgMzAsMjQuNSAzNiwyNiBMIDM4LjUsMTMuNSBMIDMxLDI1IEwgMzAuNywxMC45IEwgMjUuNSwyNC41IEwgMjIuNSwxMCBMIDE5LjUsMjQuNSBMIDE0LjMsMTAuOSBMIDE0LDI1IEwgNi41LDEzLjUgTCA5LDI2IHpcIiwgc3R5bGU6IHsgc3Ryb2tlTGluZWNhcDogJ2J1dHQnLCBmaWxsOiBwcm9wcz8uZmlsbCA/PyAnIzAwMDAwMCcgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwibSA5LDI2IGMgMCwyIDEuNSwyIDIuNSw0IDEsMS41IDEsMSAwLjUsMy41IC0xLjUsMSAtMSwyLjUgLTEsMi41IC0xLjUsMS41IDAsMi41IDAsMi41IDYuNSwxIDE2LjUsMSAyMywwIDAsMCAxLjUsLTEgMCwtMi41IDAsMCAwLjUsLTEuNSAtMSwtMi41IC0wLjUsLTIuNSAtMC41LC0yIDAuNSwtMy41IDEsLTIgMi41LC0yIDIuNSwtNCAtOC41LC0xLjUgLTE4LjUsLTEuNSAtMjcsMCB6XCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEuNSwzMCBDIDE1LDI5IDMwLDI5IDMzLjUsMzBcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwibSAxMiwzMy41IGMgNiwtMSAxNSwtMSAyMSwwXCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjZcIiwgY3k6IFwiMTJcIiwgcjogXCIyXCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjE0XCIsIGN5OiBcIjlcIiwgcjogXCIyXCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImNpcmNsZVwiLCB7IGN4OiBcIjIyLjVcIiwgY3k6IFwiOFwiLCByOiBcIjJcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMzFcIiwgY3k6IFwiOVwiLCByOiBcIjJcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwiY2lyY2xlXCIsIHsgY3g6IFwiMzlcIiwgY3k6IFwiMTJcIiwgcjogXCIyXCIgfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEsMzguNSBBIDM1LDM1IDEgMCAwIDM0LDM4LjVcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJywgc3Ryb2tlTGluZWNhcDogJ2J1dHQnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeHMoXCJnXCIsIHsgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjZmZmZmZmJyB9LCBjaGlsZHJlbjogW2pzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMTEsMjkgQSAzNSwzNSAxIDAgMSAzNCwyOVwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzEuNSBMIDMyLjUsMzEuNVwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDExLjUsMzQuNSBBIDM1LDM1IDEgMCAwIDMzLjUsMzQuNVwiIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEwLjUsMzcuNSBBIDM1LDM1IDEgMCAwIDM0LjUsMzcuNVwiIH0pXSB9KV0gfSkgfSkpLFxuICAgIGJLOiAocHJvcHMpID0+IChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2ZXJzaW9uOiBcIjEuMVwiLCB2aWV3Qm94OiBcIjAgMCA0NSA0NVwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIHN0eWxlOiBwcm9wcz8uc3ZnU3R5bGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZ1wiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiAnMScsXG4gICAgICAgICAgICAgICAgZmlsbFJ1bGU6ICdldmVub2RkJyxcbiAgICAgICAgICAgICAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICAgICBzdHJva2VXaWR0aDogJzEuNScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbjogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICBzdHJva2VNaXRlcmxpbWl0OiAnNCcsXG4gICAgICAgICAgICAgICAgc3Ryb2tlRGFzaGFycmF5OiAnbm9uZScsXG4gICAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogJzEnLFxuICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDIyLjUsMTEuNjMgTCAyMi41LDZcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJywgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicgfSwgaWQ6IFwicGF0aDY1NzBcIiB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAyMi41LDI1IEMgMjIuNSwyNSAyNywxNy41IDI1LjUsMTQuNSBDIDI1LjUsMTQuNSAyNC41LDEyIDIyLjUsMTIgQyAyMC41LDEyIDE5LjUsMTQuNSAxOS41LDE0LjUgQyAxOCwxNy41IDIyLjUsMjUgMjIuNSwyNVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogcHJvcHM/LmZpbGwgPz8gJyMwMDAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6ICcxJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA6ICdidXR0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luOiAnbWl0ZXInLFxuICAgICAgICAgICAgICAgICAgICB9IH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJwYXRoXCIsIHsgZDogXCJNIDEyLjUsMzcgQyAxOCw0MC41IDI3LDQwLjUgMzIuNSwzNyBMIDMyLjUsMzAgQyAzMi41LDMwIDQxLjUsMjUuNSAzOC41LDE5LjUgQyAzNC41LDEzIDI1LDE2IDIyLjUsMjMuNSBMIDIyLjUsMjcgTCAyMi41LDIzLjUgQyAyMCwxNiAxMC41LDEzIDYuNSwxOS41IEMgMy41LDI1LjUgMTIuNSwzMCAxMi41LDMwIEwgMTIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiBwcm9wcz8uZmlsbCA/PyAnIzAwMDAwMCcsIHN0cm9rZTogJyMwMDAwMDAnIH0gfSksIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInBhdGhcIiwgeyBkOiBcIk0gMjAsOCBMIDI1LDhcIiwgc3R5bGU6IHsgZmlsbDogJ25vbmUnLCBzdHJva2U6ICcjMDAwMDAwJywgc3Ryb2tlTGluZWpvaW46ICdtaXRlcicgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAzMiwyOS41IEMgMzIsMjkuNSA0MC41LDI1LjUgMzguMDMsMTkuODUgQyAzNC4xNSwxNCAyNSwxOCAyMi41LDI0LjUgTCAyMi41LDI2LjYgTCAyMi41LDI0LjUgQyAyMCwxOCAxMC44NSwxNCA2Ljk3LDE5Ljg1IEMgNC41LDI1LjUgMTMsMjkuNSAxMywyOS41XCIsIHN0eWxlOiB7IGZpbGw6ICdub25lJywgc3Ryb2tlOiAnI2ZmZmZmZicgfSB9KSwganN4UnVudGltZUV4cG9ydHMuanN4KFwicGF0aFwiLCB7IGQ6IFwiTSAxMi41LDMwIEMgMTgsMjcgMjcsMjcgMzIuNSwzMCBNIDEyLjUsMzMuNSBDIDE4LDMwLjUgMjcsMzAuNSAzMi41LDMzLjUgTSAxMi41LDM3IEMgMTgsMzQgMjcsMzQgMzIuNSwzN1wiLCBzdHlsZTogeyBmaWxsOiAnbm9uZScsIHN0cm9rZTogJyNmZmZmZmYnIH0gfSldIH0pIH0pKSxcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRCb2FyZFN0eWxlKGNoZXNzYm9hcmRDb2x1bW5zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGlzcGxheTogJ2dyaWQnLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBgcmVwZWF0KCR7Y2hlc3Nib2FyZENvbHVtbnN9LCAxZnIpYCxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgfTtcbn1cbmNvbnN0IGRlZmF1bHRTcXVhcmVTdHlsZSA9IHtcbiAgICBhc3BlY3RSYXRpbzogJzEvMScsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbn07XG5jb25zdCBkZWZhdWx0RGFya1NxdWFyZVN0eWxlID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyNCNTg4NjMnLFxufTtcbmNvbnN0IGRlZmF1bHRMaWdodFNxdWFyZVN0eWxlID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogJyNGMEQ5QjUnLFxufTtcbmNvbnN0IGRlZmF1bHREcm9wU3F1YXJlU3R5bGUgPSB7XG4gICAgYm94U2hhZG93OiAnaW5zZXQgMHB4IDBweCAwcHggMXB4IGJsYWNrJyxcbn07XG5jb25zdCBkZWZhdWx0RGFya1NxdWFyZU5vdGF0aW9uU3R5bGUgPSB7XG4gICAgY29sb3I6ICcjRjBEOUI1Jyxcbn07XG5jb25zdCBkZWZhdWx0TGlnaHRTcXVhcmVOb3RhdGlvblN0eWxlID0ge1xuICAgIGNvbG9yOiAnI0I1ODg2MycsXG59O1xuY29uc3QgZGVmYXVsdEFscGhhTm90YXRpb25TdHlsZSA9IHtcbiAgICBmb250U2l6ZTogJzEzcHgnLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGJvdHRvbTogMSxcbiAgICByaWdodDogNCxcbiAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG59O1xuY29uc3QgZGVmYXVsdE51bWVyaWNOb3RhdGlvblN0eWxlID0ge1xuICAgIGZvbnRTaXplOiAnMTNweCcsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgdG9wOiAyLFxuICAgIGxlZnQ6IDIsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxufTtcbmNvbnN0IGRlZmF1bHREcmFnZ2luZ1BpZWNlU3R5bGUgPSB7XG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMS4yKScsXG59O1xuY29uc3QgZGVmYXVsdERyYWdnaW5nUGllY2VHaG9zdFN0eWxlID0ge1xuICAgIG9wYWNpdHk6IDAuNSxcbn07XG5jb25zdCBkZWZhdWx0QXJyb3dPcHRpb25zID0ge1xuICAgIGNvbG9yOiAnI2ZmYWEwMCcsIC8vIGNvbG9yIGlmIG5vIG1vZGlmaWVycyBhcmUgaGVsZCBkb3duIHdoZW4gZHJhd2luZyBhbiBhcnJvd1xuICAgIHNlY29uZGFyeUNvbG9yOiAnIzRjYWY1MCcsIC8vIGNvbG9yIGlmIHNoaWZ0IGlzIGhlbGQgZG93biB3aGVuIGRyYXdpbmcgYW4gYXJyb3dcbiAgICB0ZXJ0aWFyeUNvbG9yOiAnI2Y0NDMzNicsIC8vIGNvbG9yIGlmIGNvbnRyb2wgaXMgaGVsZCBkb3duIHdoZW4gZHJhd2luZyBhbiBhcnJvd1xuICAgIGFycm93TGVuZ3RoUmVkdWNlckRlbm9taW5hdG9yOiA4LCAvLyB0aGUgbG93ZXIgdGhlIGRlbm9taW5hdG9yLCB0aGUgZ3JlYXRlciB0aGUgYXJyb3cgbGVuZ3RoIHJlZHVjdGlvbiAoZS5nLiA4ID0gMS84IG9mIGEgc3F1YXJlIHdpZHRoIHJlbW92ZWQsIDQgPSAxLzQgb2YgYSBzcXVhcmUgd2lkdGggcmVtb3ZlZClcbiAgICBzYW1lVGFyZ2V0QXJyb3dMZW5ndGhSZWR1Y2VyRGVub21pbmF0b3I6IDQsIC8vIGFzIGFib3ZlIGJ1dCBmb3IgYXJyb3dzIHRhcmdldGluZyB0aGUgc2FtZSBzcXVhcmUgKGEgZ3JlYXRlciByZWR1Y3Rpb24gaXMgdXNlZCB0byBhdm9pZCBvdmVybGFwcylcbiAgICBhcnJvd1dpZHRoRGVub21pbmF0b3I6IDUsIC8vIHRoZSBsb3dlciB0aGUgZGVub21pbmF0b3IsIHRoZSBncmVhdGVyIHRoZSBhcnJvdyB3aWR0aCAoZS5nLiA1ID0gMS81IG9mIGEgc3F1YXJlIHdpZHRoLCAxMCA9IDEvMTAgb2YgYSBzcXVhcmUgd2lkdGgpXG4gICAgYWN0aXZlQXJyb3dXaWR0aE11bHRpcGxpZXI6IDAuOSwgLy8gdGhlIG11bHRpcGxpZXIgZm9yIHRoZSBhcnJvdyB3aWR0aCB3aGVuIGl0IGlzIGJlaW5nIGRyYXduXG4gICAgb3BhY2l0eTogMC42NSwgLy8gb3BhY2l0eSBvZiBhcnJvdyB3aGVuIG5vdCBiZWluZyBkcmF3blxuICAgIGFjdGl2ZU9wYWNpdHk6IDAuNSwgLy8gb3BhY2l0eSBvZiBhcnJvdyB3aGVuIGl0IGlzIGJlaW5nIGRyYXduXG59O1xuXG5jb25zdCBDaGVzc2JvYXJkQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCB1c2VDaGVzc2JvYXJkQ29udGV4dCA9ICgpID0+IFJlYWN0LnVzZShDaGVzc2JvYXJkQ29udGV4dCk7XG5mdW5jdGlvbiBDaGVzc2JvYXJkUHJvdmlkZXIoeyBjaGlsZHJlbiwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgXG4gICAgLy8gaWRcbiAgICBpZCA9ICdjaGVzc2JvYXJkJywgXG4gICAgLy8gcGllY2VzIGFuZCBwb3NpdGlvblxuICAgIHBpZWNlcyA9IGRlZmF1bHRQaWVjZXMsIHBvc2l0aW9uID0gJ3JuYnFrYm5yL3BwcHBwcHBwLzgvOC84LzgvUFBQUFBQUFAvUk5CUUtCTlInLCBcbiAgICAvLyBib2FyZCBkaW1lbnNpb25zIGFuZCBvcmllbnRhdGlvblxuICAgIGJvYXJkT3JpZW50YXRpb24gPSAnd2hpdGUnLCBjaGVzc2JvYXJkUm93cyA9IDgsIGNoZXNzYm9hcmRDb2x1bW5zID0gOCwgXG4gICAgLy8gYm9hcmQgYW5kIHNxdWFyZXMgc3R5bGVzXG4gICAgYm9hcmRTdHlsZSA9IGRlZmF1bHRCb2FyZFN0eWxlKGNoZXNzYm9hcmRDb2x1bW5zKSwgc3F1YXJlU3R5bGUgPSBkZWZhdWx0U3F1YXJlU3R5bGUsIHNxdWFyZVN0eWxlcyA9IHt9LCBkYXJrU3F1YXJlU3R5bGUgPSBkZWZhdWx0RGFya1NxdWFyZVN0eWxlLCBsaWdodFNxdWFyZVN0eWxlID0gZGVmYXVsdExpZ2h0U3F1YXJlU3R5bGUsIGRyb3BTcXVhcmVTdHlsZSA9IGRlZmF1bHREcm9wU3F1YXJlU3R5bGUsIGRyYWdnaW5nUGllY2VTdHlsZSA9IGRlZmF1bHREcmFnZ2luZ1BpZWNlU3R5bGUsIGRyYWdnaW5nUGllY2VHaG9zdFN0eWxlID0gZGVmYXVsdERyYWdnaW5nUGllY2VHaG9zdFN0eWxlLCBcbiAgICAvLyBub3RhdGlvblxuICAgIGRhcmtTcXVhcmVOb3RhdGlvblN0eWxlID0gZGVmYXVsdERhcmtTcXVhcmVOb3RhdGlvblN0eWxlLCBsaWdodFNxdWFyZU5vdGF0aW9uU3R5bGUgPSBkZWZhdWx0TGlnaHRTcXVhcmVOb3RhdGlvblN0eWxlLCBhbHBoYU5vdGF0aW9uU3R5bGUgPSBkZWZhdWx0QWxwaGFOb3RhdGlvblN0eWxlLCBudW1lcmljTm90YXRpb25TdHlsZSA9IGRlZmF1bHROdW1lcmljTm90YXRpb25TdHlsZSwgc2hvd05vdGF0aW9uID0gdHJ1ZSwgXG4gICAgLy8gYW5pbWF0aW9uXG4gICAgYW5pbWF0aW9uRHVyYXRpb25Jbk1zID0gMzAwLCBzaG93QW5pbWF0aW9ucyA9IHRydWUsIFxuICAgIC8vIGRyYWcgYW5kIGRyb3BcbiAgICBhbGxvd0RyYWdnaW5nID0gdHJ1ZSwgYWxsb3dEcmFnT2ZmQm9hcmQgPSB0cnVlLCBhbGxvd0F1dG9TY3JvbGwgPSBmYWxzZSwgZHJhZ0FjdGl2YXRpb25EaXN0YW5jZSA9IDEsIFxuICAgIC8vIGFycm93c1xuICAgIGFsbG93RHJhd2luZ0Fycm93cyA9IHRydWUsIGFycm93cyA9IFtdLCBhcnJvd09wdGlvbnMgPSBkZWZhdWx0QXJyb3dPcHRpb25zLCBjbGVhckFycm93c09uQ2xpY2sgPSB0cnVlLCBcbiAgICAvLyBoYW5kbGVyc1xuICAgIGNhbkRyYWdQaWVjZSwgb25BcnJvd3NDaGFuZ2UsIG9uTW91c2VPdXRTcXVhcmUsIG9uTW91c2VPdmVyU3F1YXJlLCBvblBpZWNlQ2xpY2ssIG9uUGllY2VEcmFnLCBvblBpZWNlRHJvcCwgb25TcXVhcmVDbGljaywgb25TcXVhcmVSaWdodENsaWNrLCBzcXVhcmVSZW5kZXJlciwgfSA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gdGhlIHBpZWNlIGN1cnJlbnRseSBiZWluZyBkcmFnZ2VkXG4gICAgY29uc3QgW2RyYWdnaW5nUGllY2UsIHNldERyYWdnaW5nUGllY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgcGllY2VzIG9uIHRoZSBjaGVzc2JvYXJkXG4gICAgY29uc3QgW2N1cnJlbnRQb3NpdGlvbiwgc2V0Q3VycmVudFBvc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKHR5cGVvZiBwb3NpdGlvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBmZW5TdHJpbmdUb1Bvc2l0aW9uT2JqZWN0KHBvc2l0aW9uLCBjaGVzc2JvYXJkUm93cywgY2hlc3Nib2FyZENvbHVtbnMpXG4gICAgICAgIDogcG9zaXRpb24pO1xuICAgIC8vIGNhbGN1bGF0ZWQgZGlmZmVyZW5jZXMgYmV0d2VlbiBjdXJyZW50IGFuZCBpbmNvbWluZyBwb3NpdGlvbnNcbiAgICBjb25zdCBbcG9zaXRpb25EaWZmZXJlbmNlcywgc2V0UG9zaXRpb25EaWZmZXJlbmNlc10gPSBSZWFjdC51c2VTdGF0ZSh7fSk7XG4gICAgLy8gaWYgdGhlIGxhdGVzdCBtb3ZlIHdhcyBhIG1hbnVhbCBkcm9wXG4gICAgY29uc3QgW21hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlLCBzZXRNYW51YWxseURyb3BwZWRQaWVjZUFuZFNxdWFyZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICAvLyBhcnJvd3NcbiAgICBjb25zdCBbbmV3QXJyb3dTdGFydFNxdWFyZSwgc2V0TmV3QXJyb3dTdGFydFNxdWFyZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbbmV3QXJyb3dPdmVyU3F1YXJlLCBzZXROZXdBcnJvd092ZXJTcXVhcmVdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgW2ludGVybmFsQXJyb3dzLCBzZXRJbnRlcm5hbEFycm93c10gPSBSZWFjdC51c2VTdGF0ZShbXSk7XG4gICAgLy8gcG9zaXRpb24gd2UgYXJlIGFuaW1hdGluZyB0bywgaWYgYSBuZXcgcG9zaXRpb24gY29tZXMgaW4gYmVmb3JlIHRoZSBhbmltYXRpb24gY29tcGxldGVzLCB3ZSB3aWxsIHVzZSB0aGlzIHRvIHNldCB0aGUgbmV3IHBvc2l0aW9uXG4gICAgY29uc3QgW3dhaXRpbmdGb3JBbmltYXRpb25Qb3NpdGlvbiwgc2V0V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICAgIC8vIHRoZSBhbmltYXRpb24gdGltZW91dCB3aGlsc3Qgd2FpdGluZyBmb3IgYW5pbWF0aW9uIHRvIGNvbXBsZXRlXG4gICAgY29uc3QgYW5pbWF0aW9uVGltZW91dFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICAvLyBpZiB0aGUgcG9zaXRpb24gY2hhbmdlcywgd2UgbmVlZCB0byByZWNyZWF0ZSB0aGUgcGllY2VzIGFycmF5XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGZlblN0cmluZ1RvUG9zaXRpb25PYmplY3QocG9zaXRpb24sIGNoZXNzYm9hcmRSb3dzLCBjaGVzc2JvYXJkQ29sdW1ucylcbiAgICAgICAgICAgIDogcG9zaXRpb247XG4gICAgICAgIC8vIGlmIG5vIGFuaW1hdGlvbiwganVzdCBzZXQgdGhlIHBvc2l0aW9uXG4gICAgICAgIGlmICghc2hvd0FuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2F2ZSBjb3B5IG9mIHRoZSB3YWl0aW5nIGZvciBhbmltYXRpb24gcG9zaXRpb24gc28gd2UgY2FuIHVzZSBpdCBsYXRlciBidXQgY2xlYXIgaXQgZnJvbSBzdGF0ZSBzbyB3ZSBkb24ndCB1c2UgaXQgaW4gdGhlIG5leHQgYW5pbWF0aW9uXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXYWl0aW5nRm9yQW5pbWF0aW9uUG9zaXRpb24gPSB3YWl0aW5nRm9yQW5pbWF0aW9uUG9zaXRpb247XG4gICAgICAgIC8vIGlmIHdlIGFyZSB3YWl0aW5nIGZvciBhbiBhbmltYXRpb24gdG8gY29tcGxldGUgZnJvbSBhIHByZXZpb3VzIG1vdmUsIHNldCB0aGUgc2F2ZWQgcG9zaXRpb24gdG8gaW1tZWRpYXRlbHkgZW5kIHRoZSBhbmltYXRpb25cbiAgICAgICAgaWYgKGN1cnJlbnRXYWl0aW5nRm9yQW5pbWF0aW9uUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihjdXJyZW50V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uKTtcbiAgICAgICAgICAgIHNldFdhaXRpbmdGb3JBbmltYXRpb25Qb3NpdGlvbihudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgbGlzdCBvZiBwb3NpdGlvbiB1cGRhdGVzIGFzIHBpZWNlcyB0byBwb3RlbnRpYWxseSBhbmltYXRlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uVXBkYXRlcyA9IGdldFBvc2l0aW9uVXBkYXRlcyhjdXJyZW50V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uID8/IGN1cnJlbnRQb3NpdGlvbiwgLy8gdXNlIHRoZSBzYXZlZCBwb3NpdGlvbiBpZiBpdCBleGlzdHMsIG90aGVyd2lzZSB1c2UgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgbmV3UG9zaXRpb24sIGNoZXNzYm9hcmRDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKTtcbiAgICAgICAgY29uc3QgbXVsdGlwbGVQaWVjZXNNb3ZlZCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uVXBkYXRlcykubGVuZ3RoID4gMTtcbiAgICAgICAgLy8gbWFudWFsbHkgZHJvcHBlZCBwaWVjZSBjYXVzZWQgbXVsdGlwbGUgcGllY2VzIHRvIG1vdmUgKGUuZy4gY2FzdGxpbmcpXG4gICAgICAgIGlmIChtYW51YWxseURyb3BwZWRQaWVjZUFuZFNxdWFyZSAmJiBtdWx0aXBsZVBpZWNlc01vdmVkKSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcG9zaXRpb24gd2l0aCBqdXN0IHRoZSBkcm9wcGVkIHBpZWNlIG1vdmVkXG4gICAgICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVQb3NpdGlvbiA9IHsgLi4uY3VycmVudFBvc2l0aW9uIH07XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJtZWRpYXRlUG9zaXRpb25bbWFudWFsbHlEcm9wcGVkUGllY2VBbmRTcXVhcmUuc291cmNlU3F1YXJlXTtcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVBvc2l0aW9uW21hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlLnRhcmdldFNxdWFyZV0gPSB7XG4gICAgICAgICAgICAgICAgcGllY2VUeXBlOiBtYW51YWxseURyb3BwZWRQaWVjZUFuZFNxdWFyZS5waWVjZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24oaW50ZXJtZWRpYXRlUG9zaXRpb24pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHBvc2l0aW9uIGRpZmZlcmVuY2VzIHdpdGggb25seSB0aGUgb3RoZXIgcGllY2VzJyBtb3ZlbWVudHNcbiAgICAgICAgICAgIGNvbnN0IG90aGVyUGllY2VzVXBkYXRlcyA9IHsgLi4ucG9zaXRpb25VcGRhdGVzIH07XG4gICAgICAgICAgICBkZWxldGUgb3RoZXJQaWVjZXNVcGRhdGVzW21hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlLnNvdXJjZVNxdWFyZV07XG4gICAgICAgICAgICBzZXRQb3NpdGlvbkRpZmZlcmVuY2VzKG90aGVyUGllY2VzVXBkYXRlcyk7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBvdGhlciBwaWVjZXMnIG1vdmVtZW50c1xuICAgICAgICAgICAgY29uc3QgbmV3VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQb3NpdGlvbihuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgc2V0UG9zaXRpb25EaWZmZXJlbmNlcyh7fSk7XG4gICAgICAgICAgICAgICAgc2V0TWFudWFsbHlEcm9wcGVkUGllY2VBbmRTcXVhcmUobnVsbCk7XG4gICAgICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbkluTXMpO1xuICAgICAgICAgICAgYW5pbWF0aW9uVGltZW91dFJlZi5jdXJyZW50ID0gbmV3VGltZW91dDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBuZXcgcG9zaXRpb24gd2FzIGEgcmVzdWx0IG9mIGEgbWFudWFsIGRyb3BcbiAgICAgICAgaWYgKG1hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlKSB7XG4gICAgICAgICAgICAvLyBubyBhbmltYXRpb24gbmVlZGVkLCBqdXN0IHNldCB0aGUgcG9zaXRpb24gYW5kIHJlc2V0IHRoZSBmbGFnXG4gICAgICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24obmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgc2V0TWFudWFsbHlEcm9wcGVkUGllY2VBbmRTcXVhcmUobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmV3IHBvc2l0aW9uIHdhcyBhIHJlc3VsdCBvZiBhbiBleHRlcm5hbCBtb3ZlXG4gICAgICAgIHNldFBvc2l0aW9uRGlmZmVyZW5jZXMocG9zaXRpb25VcGRhdGVzKTtcbiAgICAgICAgc2V0V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgLy8gc3RhcnQgYW5pbWF0aW9uIHRpbWVvdXRcbiAgICAgICAgY29uc3QgbmV3VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q3VycmVudFBvc2l0aW9uKG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIHNldFBvc2l0aW9uRGlmZmVyZW5jZXMoe30pO1xuICAgICAgICAgICAgc2V0V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uKG51bGwpO1xuICAgICAgICB9LCBhbmltYXRpb25EdXJhdGlvbkluTXMpO1xuICAgICAgICAvLyB1cGRhdGUgdGhlIHJlZiB0byB0aGUgbmV3IHRpbWVvdXRcbiAgICAgICAgYW5pbWF0aW9uVGltZW91dFJlZi5jdXJyZW50ID0gbmV3VGltZW91dDtcbiAgICAgICAgLy8gY2xlYXIgdGltZW91dCBvbiB1bm1vdW50XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYW5pbWF0aW9uVGltZW91dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvblRpbWVvdXRSZWYuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW3Bvc2l0aW9uXSk7XG4gICAgLy8gaWYgdGhlIGRpbWVuc2lvbnMgY2hhbmdlLCB3ZSBuZWVkIHRvIHJlY3JlYXRlIHRoZSBwaWVjZXMgYXJyYXlcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRDdXJyZW50UG9zaXRpb24odHlwZW9mIHBvc2l0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBmZW5TdHJpbmdUb1Bvc2l0aW9uT2JqZWN0KHBvc2l0aW9uLCBjaGVzc2JvYXJkUm93cywgY2hlc3Nib2FyZENvbHVtbnMpXG4gICAgICAgICAgICA6IHBvc2l0aW9uKTtcbiAgICB9LCBbY2hlc3Nib2FyZFJvd3MsIGNoZXNzYm9hcmRDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uXSk7XG4gICAgLy8gaWYgdGhlIGFycm93cyBjaGFuZ2UsIGNhbGwgdGhlIG9uQXJyb3dzQ2hhbmdlIGNhbGxiYWNrXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgb25BcnJvd3NDaGFuZ2U/Lih7IGFycm93czogaW50ZXJuYWxBcnJvd3MgfSk7XG4gICAgfSwgW2ludGVybmFsQXJyb3dzXSk7XG4gICAgLy8gb25seSByZWRyYXcgdGhlIGJvYXJkIHdoZW4gdGhlIGRpbWVuc2lvbnMgb3IgYm9hcmQgb3JpZW50YXRpb24gY2hhbmdlXG4gICAgY29uc3QgYm9hcmQgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdlbmVyYXRlQm9hcmQoY2hlc3Nib2FyZFJvd3MsIGNoZXNzYm9hcmRDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKSwgW2NoZXNzYm9hcmRSb3dzLCBjaGVzc2JvYXJkQ29sdW1ucywgYm9hcmRPcmllbnRhdGlvbl0pO1xuICAgIGNvbnN0IGRyYXdBcnJvdyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXdBcnJvd0VuZFNxdWFyZSwgbW9kaWZpZXJzKSA9PiB7XG4gICAgICAgIGlmICghYWxsb3dEcmF3aW5nQXJyb3dzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyb3dFeGlzdHNJbmRleCA9IGludGVybmFsQXJyb3dzLmZpbmRJbmRleCgoYXJyb3cpID0+IGFycm93LnN0YXJ0U3F1YXJlID09PSBuZXdBcnJvd1N0YXJ0U3F1YXJlICYmXG4gICAgICAgICAgICBhcnJvdy5lbmRTcXVhcmUgPT09IG5ld0Fycm93RW5kU3F1YXJlKTtcbiAgICAgICAgY29uc3QgYXJyb3dFeGlzdHNFeHRlcm5hbGx5ID0gYXJyb3dzLnNvbWUoKGFycm93KSA9PiBhcnJvdy5zdGFydFNxdWFyZSA9PT0gbmV3QXJyb3dTdGFydFNxdWFyZSAmJlxuICAgICAgICAgICAgYXJyb3cuZW5kU3F1YXJlID09PSBuZXdBcnJvd0VuZFNxdWFyZSk7XG4gICAgICAgIC8vIGlmIHRoZSBhcnJvdyBhbHJlYWR5IGV4aXN0cyBleHRlcm5hbGx5LCBkb24ndCBhZGQgaXQgdG8gdGhlIGludGVybmFsIGFycm93c1xuICAgICAgICBpZiAoYXJyb3dFeGlzdHNFeHRlcm5hbGx5KSB7XG4gICAgICAgICAgICBzZXROZXdBcnJvd1N0YXJ0U3F1YXJlKG51bGwpO1xuICAgICAgICAgICAgc2V0TmV3QXJyb3dPdmVyU3F1YXJlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5ldyBhcnJvdyB3aXRoIGRpZmZlcmVudCBzdGFydCBhbmQgZW5kIHNxdWFyZSwgYWRkIHRvIGludGVybmFsIGFycm93cyBvciByZW1vdmUgaWYgaXQgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgaWYgKG5ld0Fycm93U3RhcnRTcXVhcmUgJiYgbmV3QXJyb3dTdGFydFNxdWFyZSAhPT0gbmV3QXJyb3dFbmRTcXVhcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFycm93Q29sb3IgPSBtb2RpZmllcnM/LnNoaWZ0S2V5XG4gICAgICAgICAgICAgICAgPyBhcnJvd09wdGlvbnMuc2Vjb25kYXJ5Q29sb3JcbiAgICAgICAgICAgICAgICA6IG1vZGlmaWVycz8uY3RybEtleVxuICAgICAgICAgICAgICAgICAgICA/IGFycm93T3B0aW9ucy50ZXJ0aWFyeUNvbG9yXG4gICAgICAgICAgICAgICAgICAgIDogYXJyb3dPcHRpb25zLmNvbG9yO1xuICAgICAgICAgICAgc2V0SW50ZXJuYWxBcnJvd3MoKHByZXZBcnJvd3MpID0+IGFycm93RXhpc3RzSW5kZXggPT09IC0xXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnByZXZBcnJvd3MsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0U3F1YXJlOiBuZXdBcnJvd1N0YXJ0U3F1YXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kU3F1YXJlOiBuZXdBcnJvd0VuZFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBhcnJvd0NvbG9yLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IHByZXZBcnJvd3MuZmlsdGVyKChfLCBpbmRleCkgPT4gaW5kZXggIT09IGFycm93RXhpc3RzSW5kZXgpKTtcbiAgICAgICAgICAgIHNldE5ld0Fycm93U3RhcnRTcXVhcmUobnVsbCk7XG4gICAgICAgICAgICBzZXROZXdBcnJvd092ZXJTcXVhcmUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFsbG93RHJhd2luZ0Fycm93cyxcbiAgICAgICAgYXJyb3dzLFxuICAgICAgICBhcnJvd09wdGlvbnMuY29sb3IsXG4gICAgICAgIGFycm93T3B0aW9ucy5zZWNvbmRhcnlDb2xvcixcbiAgICAgICAgYXJyb3dPcHRpb25zLnRlcnRpYXJ5Q29sb3IsXG4gICAgICAgIGludGVybmFsQXJyb3dzLFxuICAgICAgICBuZXdBcnJvd1N0YXJ0U3F1YXJlLFxuICAgICAgICBuZXdBcnJvd092ZXJTcXVhcmUsXG4gICAgXSk7XG4gICAgY29uc3QgY2xlYXJBcnJvd3MgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChjbGVhckFycm93c09uQ2xpY2spIHtcbiAgICAgICAgICAgIHNldEludGVybmFsQXJyb3dzKFtdKTtcbiAgICAgICAgICAgIHNldE5ld0Fycm93U3RhcnRTcXVhcmUobnVsbCk7XG4gICAgICAgICAgICBzZXROZXdBcnJvd092ZXJTcXVhcmUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbY2xlYXJBcnJvd3NPbkNsaWNrXSk7XG4gICAgY29uc3Qgc2V0TmV3QXJyb3dPdmVyU3F1YXJlV2l0aE1vZGlmaWVycyA9IFJlYWN0LnVzZUNhbGxiYWNrKChzcXVhcmUsIG1vZGlmaWVycykgPT4ge1xuICAgICAgICBjb25zdCBjb2xvciA9IG1vZGlmaWVycz8uc2hpZnRLZXlcbiAgICAgICAgICAgID8gYXJyb3dPcHRpb25zLnNlY29uZGFyeUNvbG9yXG4gICAgICAgICAgICA6IG1vZGlmaWVycz8uY3RybEtleVxuICAgICAgICAgICAgICAgID8gYXJyb3dPcHRpb25zLnRlcnRpYXJ5Q29sb3JcbiAgICAgICAgICAgICAgICA6IGFycm93T3B0aW9ucy5jb2xvcjtcbiAgICAgICAgc2V0TmV3QXJyb3dPdmVyU3F1YXJlKHsgc3F1YXJlLCBjb2xvciB9KTtcbiAgICB9LCBbYXJyb3dPcHRpb25zXSk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0NhbmNlbCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0RHJhZ2dpbmdQaWVjZShudWxsKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIGhhbmRsZURyYWdFbmQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFkcmFnZ2luZ1BpZWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZHJvcFNxdWFyZSA9IGV2ZW50Lm92ZXI/LmlkLnRvU3RyaW5nKCk7XG4gICAgICAgIC8vIGRyb3BwZWQgb3V0c2lkZSBvZiBkcm9wcGFibGUgYXJlYSAoZS5nLiBvZmYgYm9hcmQpXG4gICAgICAgIGlmICghZHJvcFNxdWFyZSkge1xuICAgICAgICAgICAgb25QaWVjZURyb3A/Lih7XG4gICAgICAgICAgICAgICAgcGllY2U6IGRyYWdnaW5nUGllY2UsXG4gICAgICAgICAgICAgICAgc291cmNlU3F1YXJlOiBkcmFnZ2luZ1BpZWNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRhcmdldFNxdWFyZTogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc2V0IGFzIG1hbnVhbGx5IGRyb3BwZWQgcGllY2Ugc28gdGhhdCBubyBhbmltYXRpb24gaXMgc2hvd25cbiAgICAgICAgICAgIHNldE1hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlKHtcbiAgICAgICAgICAgICAgICBwaWVjZTogZHJhZ2dpbmdQaWVjZS5waWVjZVR5cGUsXG4gICAgICAgICAgICAgICAgc291cmNlU3F1YXJlOiBkcmFnZ2luZ1BpZWNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRhcmdldFNxdWFyZTogJycsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldERyYWdnaW5nUGllY2UobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50Lm92ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJvcFZhbGlkID0gb25QaWVjZURyb3A/Lih7XG4gICAgICAgICAgICAgICAgcGllY2U6IGRyYWdnaW5nUGllY2UsXG4gICAgICAgICAgICAgICAgc291cmNlU3F1YXJlOiBkcmFnZ2luZ1BpZWNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHRhcmdldFNxdWFyZTogZHJvcFNxdWFyZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGRyb3AgaXMgdmFsaWQsIHNldCB0aGUgbWFudWFsbHkgZHJvcHBlZCBwaWVjZSBhbmQgc3F1YXJlXG4gICAgICAgICAgICBpZiAoaXNEcm9wVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBzZXRNYW51YWxseURyb3BwZWRQaWVjZUFuZFNxdWFyZSh7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlOiBkcmFnZ2luZ1BpZWNlLnBpZWNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlU3F1YXJlOiBkcmFnZ2luZ1BpZWNlLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRTcXVhcmU6IGRyb3BTcXVhcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXREcmFnZ2luZ1BpZWNlKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW2RyYWdnaW5nUGllY2VdKTtcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAvLyBhY3RpdmUuaWQgaXMgdGhlIGlkIG9mIHRoZSBwaWVjZSBiZWluZyBkcmFnZ2VkXG4gICAgZnVuY3Rpb24gaGFuZGxlRHJhZ1N0YXJ0KHsgYWN0aXZlIH0pIHtcbiAgICAgICAgLy8gdGhlIGlkIGlzIGVpdGhlciB0aGUgcG9zaXRpb24gb2YgdGhlIHBpZWNlIG9uIHRoZSBib2FyZCBpZiBpdCdzIG9uIHRoZSBib2FyZCAoZS5nLiBcImExXCIsIFwiYjJcIiwgZXRjLiksIG9yIHRoZSB0eXBlIG9mIHRoZSBwaWVjZSBpZiBpdCdzIGEgc3BhcmUgcGllY2UgKGUuZy4gXCJ3UFwiLCBcImJOXCIsIGV0Yy4pXG4gICAgICAgIGNvbnN0IGlzU3BhcmVQaWVjZSA9IGFjdGl2ZS5kYXRhLmN1cnJlbnQ/LmlzU3BhcmVQaWVjZTtcbiAgICAgICAgb25QaWVjZURyYWc/Lih7XG4gICAgICAgICAgICBpc1NwYXJlUGllY2UsXG4gICAgICAgICAgICBwaWVjZTogaXNTcGFyZVBpZWNlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlVHlwZTogYWN0aXZlLmlkLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGN1cnJlbnRQb3NpdGlvblthY3RpdmUuaWRdLFxuICAgICAgICAgICAgc3F1YXJlOiBpc1NwYXJlUGllY2UgPyBudWxsIDogYWN0aXZlLmlkLFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0RHJhZ2dpbmdQaWVjZSh7XG4gICAgICAgICAgICBpc1NwYXJlUGllY2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogYWN0aXZlLmlkLFxuICAgICAgICAgICAgcGllY2VUeXBlOiBpc1NwYXJlUGllY2VcbiAgICAgICAgICAgICAgICA/IGFjdGl2ZS5pZFxuICAgICAgICAgICAgICAgIDogY3VycmVudFBvc2l0aW9uW2FjdGl2ZS5pZF0ucGllY2VUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sIFtjdXJyZW50UG9zaXRpb25dKTtcbiAgICBjb25zdCBzZW5zb3JzID0gdXNlU2Vuc29ycyh1c2VTZW5zb3IoUG9pbnRlclNlbnNvciwge1xuICAgICAgICBhY3RpdmF0aW9uQ29uc3RyYWludDogZHJhZ0FjdGl2YXRpb25EaXN0YW5jZSA+IDBcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkcmFnQWN0aXZhdGlvbkRpc3RhbmNlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfSksIHVzZVNlbnNvcihLZXlib2FyZFNlbnNvciksIHVzZVNlbnNvcihUb3VjaFNlbnNvciksIHVzZVNlbnNvcihNb3VzZVNlbnNvcikpO1xuICAgIC8vIGNvbGxpc2lvbiBkZXRlY3Rpb24gdGhhdCBmaXJzdCB0cmllcyBwb2ludGVyLWJhc2VkIGRldGVjdGlvbiBhbmQgdGhlbiBmYWxscyBiYWNrIHRvIHJlY3RhbmdsZSBpbnRlcnNlY3Rpb24gZm9yIGtleWJvYXJkc1xuICAgIGZ1bmN0aW9uIGNvbGxpc2lvbkRldGVjdGlvbihhcmdzKSB7XG4gICAgICAgIC8vIGZpcnN0IHRyeSBwb2ludGVyLWJhc2VkIGNvbGxpc2lvbiBkZXRlY3Rpb25cbiAgICAgICAgY29uc3QgcG9pbnRlckNvbGxpc2lvbnMgPSBwb2ludGVyV2l0aGluKGFyZ3MpO1xuICAgICAgICAvLyBpZiB3ZSBmb3VuZCBjb2xsaXNpb25zIHdpdGggdGhlIHBvaW50ZXIsIHJldHVybiB0aG9zZVxuICAgICAgICBpZiAocG9pbnRlckNvbGxpc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXJDb2xsaXNpb25zO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBmYWxsIGJhY2sgdG8gcmVjdGFuZ2xlIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm4gcmVjdEludGVyc2VjdGlvbihhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goQ2hlc3Nib2FyZENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHtcbiAgICAgICAgICAgIC8vIGNoZXNzYm9hcmQgb3B0aW9uc1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwaWVjZXMsXG4gICAgICAgICAgICBib2FyZE9yaWVudGF0aW9uLFxuICAgICAgICAgICAgY2hlc3Nib2FyZFJvd3MsXG4gICAgICAgICAgICBjaGVzc2JvYXJkQ29sdW1ucyxcbiAgICAgICAgICAgIGJvYXJkU3R5bGUsXG4gICAgICAgICAgICBzcXVhcmVTdHlsZSxcbiAgICAgICAgICAgIHNxdWFyZVN0eWxlcyxcbiAgICAgICAgICAgIGRhcmtTcXVhcmVTdHlsZSxcbiAgICAgICAgICAgIGxpZ2h0U3F1YXJlU3R5bGUsXG4gICAgICAgICAgICBkcm9wU3F1YXJlU3R5bGUsXG4gICAgICAgICAgICBkcmFnZ2luZ1BpZWNlU3R5bGUsXG4gICAgICAgICAgICBkcmFnZ2luZ1BpZWNlR2hvc3RTdHlsZSxcbiAgICAgICAgICAgIGRhcmtTcXVhcmVOb3RhdGlvblN0eWxlLFxuICAgICAgICAgICAgbGlnaHRTcXVhcmVOb3RhdGlvblN0eWxlLFxuICAgICAgICAgICAgYWxwaGFOb3RhdGlvblN0eWxlLFxuICAgICAgICAgICAgbnVtZXJpY05vdGF0aW9uU3R5bGUsXG4gICAgICAgICAgICBzaG93Tm90YXRpb24sXG4gICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvbkluTXMsXG4gICAgICAgICAgICBzaG93QW5pbWF0aW9ucyxcbiAgICAgICAgICAgIGFsbG93RHJhZ2dpbmcsXG4gICAgICAgICAgICBhbGxvd0RyYWdPZmZCb2FyZCxcbiAgICAgICAgICAgIGFsbG93RHJhd2luZ0Fycm93cyxcbiAgICAgICAgICAgIGFycm93cyxcbiAgICAgICAgICAgIGFycm93T3B0aW9ucyxcbiAgICAgICAgICAgIGNhbkRyYWdQaWVjZSxcbiAgICAgICAgICAgIG9uTW91c2VPdXRTcXVhcmUsXG4gICAgICAgICAgICBvbk1vdXNlT3ZlclNxdWFyZSxcbiAgICAgICAgICAgIG9uUGllY2VDbGljayxcbiAgICAgICAgICAgIG9uU3F1YXJlQ2xpY2ssXG4gICAgICAgICAgICBvblNxdWFyZVJpZ2h0Q2xpY2ssXG4gICAgICAgICAgICBzcXVhcmVSZW5kZXJlcixcbiAgICAgICAgICAgIC8vIGludGVybmFsIHN0YXRlXG4gICAgICAgICAgICBib2FyZCxcbiAgICAgICAgICAgIGlzV3JhcHBlZDogdHJ1ZSxcbiAgICAgICAgICAgIGRyYWdnaW5nUGllY2UsXG4gICAgICAgICAgICBjdXJyZW50UG9zaXRpb24sXG4gICAgICAgICAgICBwb3NpdGlvbkRpZmZlcmVuY2VzLFxuICAgICAgICAgICAgbmV3QXJyb3dTdGFydFNxdWFyZSxcbiAgICAgICAgICAgIG5ld0Fycm93T3ZlclNxdWFyZSxcbiAgICAgICAgICAgIHNldE5ld0Fycm93U3RhcnRTcXVhcmUsXG4gICAgICAgICAgICBzZXROZXdBcnJvd092ZXJTcXVhcmU6IHNldE5ld0Fycm93T3ZlclNxdWFyZVdpdGhNb2RpZmllcnMsXG4gICAgICAgICAgICBpbnRlcm5hbEFycm93cyxcbiAgICAgICAgICAgIGRyYXdBcnJvdyxcbiAgICAgICAgICAgIGNsZWFyQXJyb3dzLFxuICAgICAgICB9LCBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KERuZENvbnRleHQsIHsgYXV0b1Njcm9sbDogYWxsb3dBdXRvU2Nyb2xsLCBjb2xsaXNpb25EZXRlY3Rpb246IGNvbGxpc2lvbkRldGVjdGlvbiwgb25EcmFnU3RhcnQ6IGhhbmRsZURyYWdTdGFydCwgb25EcmFnRW5kOiBoYW5kbGVEcmFnRW5kLCBvbkRyYWdDYW5jZWw6IGhhbmRsZURyYWdDYW5jZWwsIHNlbnNvcnM6IHNlbnNvcnMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIEFycm93cyh7IGJvYXJkV2lkdGgsIGJvYXJkSGVpZ2h0IH0pIHtcbiAgICBjb25zdCB7IGlkLCBhcnJvd3MsIGFycm93T3B0aW9ucywgYm9hcmRPcmllbnRhdGlvbiwgY2hlc3Nib2FyZENvbHVtbnMsIGNoZXNzYm9hcmRSb3dzLCBpbnRlcm5hbEFycm93cywgbmV3QXJyb3dTdGFydFNxdWFyZSwgbmV3QXJyb3dPdmVyU3F1YXJlLCB9ID0gdXNlQ2hlc3Nib2FyZENvbnRleHQoKTtcbiAgICBpZiAoIWJvYXJkV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRseURyYXdpbmdBcnJvdyA9IG5ld0Fycm93U3RhcnRTcXVhcmUgJiZcbiAgICAgICAgbmV3QXJyb3dPdmVyU3F1YXJlICYmXG4gICAgICAgIG5ld0Fycm93U3RhcnRTcXVhcmUgIT09IG5ld0Fycm93T3ZlclNxdWFyZS5zcXVhcmVcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzdGFydFNxdWFyZTogbmV3QXJyb3dTdGFydFNxdWFyZSxcbiAgICAgICAgICAgIGVuZFNxdWFyZTogbmV3QXJyb3dPdmVyU3F1YXJlLnNxdWFyZSxcbiAgICAgICAgICAgIGNvbG9yOiBuZXdBcnJvd092ZXJTcXVhcmUuY29sb3IsXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGFycm93c1RvRHJhdyA9IGN1cnJlbnRseURyYXdpbmdBcnJvd1xuICAgICAgICA/IFsuLi5hcnJvd3MsIC4uLmludGVybmFsQXJyb3dzLCBjdXJyZW50bHlEcmF3aW5nQXJyb3ddXG4gICAgICAgIDogWy4uLmFycm93cywgLi4uaW50ZXJuYWxBcnJvd3NdO1xuICAgIHJldHVybiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3ZnXCIsIHsgd2lkdGg6IGJvYXJkV2lkdGgsIGhlaWdodDogYm9hcmRIZWlnaHQsIHN0eWxlOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogJzAnLFxuICAgICAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogJ25vbmUnLFxuICAgICAgICAgICAgekluZGV4OiAnMjAnLCAvLyBwbGFjZSBhYm92ZSBwaWVjZXNcbiAgICAgICAgfSwgY2hpbGRyZW46IGFycm93c1RvRHJhdy5tYXAoKGFycm93LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gZ2V0UmVsYXRpdmVDb29yZHMoYm9hcmRPcmllbnRhdGlvbiwgYm9hcmRXaWR0aCwgY2hlc3Nib2FyZENvbHVtbnMsIGNoZXNzYm9hcmRSb3dzLCBhcnJvdy5zdGFydFNxdWFyZSk7XG4gICAgICAgICAgICBjb25zdCB0byA9IGdldFJlbGF0aXZlQ29vcmRzKGJvYXJkT3JpZW50YXRpb24sIGJvYXJkV2lkdGgsIGNoZXNzYm9hcmRDb2x1bW5zLCBjaGVzc2JvYXJkUm93cywgYXJyb3cuZW5kU3F1YXJlKTtcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gc2hvcnRlbiB0aGUgYXJyb3cgbGVuZ3RoIHNvIHRoZSB0aXAgb2YgdGhlIGFycm93IGlzIG1vcmUgY2VudHJhbCB0byB0aGUgdGFyZ2V0IHNxdWFyZSBpbnN0ZWFkIG9mIHJ1bm5pbmcgb3ZlciB0aGUgY2VudGVyXG4gICAgICAgICAgICBjb25zdCBzcXVhcmVXaWR0aCA9IGJvYXJkV2lkdGggLyBjaGVzc2JvYXJkQ29sdW1ucztcbiAgICAgICAgICAgIGxldCBBUlJPV19MRU5HVEhfUkVEVUNFUiA9IHNxdWFyZVdpZHRoIC8gYXJyb3dPcHRpb25zLmFycm93TGVuZ3RoUmVkdWNlckRlbm9taW5hdG9yO1xuICAgICAgICAgICAgY29uc3QgaXNBcnJvd0FjdGl2ZSA9IGN1cnJlbnRseURyYXdpbmdBcnJvdyAmJiBpID09PSBhcnJvd3NUb0RyYXcubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBkaWZmZXJlbnQgYXJyb3dzIHRhcmdldGluZyB0aGUgc2FtZSBzcXVhcmUgbWFrZSB0aGVpciBsZW5ndGggYSBiaXQgc2hvcnRlclxuICAgICAgICAgICAgaWYgKGFycm93c1RvRHJhdy5zb21lKChyZXN0QXJyb3cpID0+IHJlc3RBcnJvdy5zdGFydFNxdWFyZSAhPT0gYXJyb3cuc3RhcnRTcXVhcmUgJiZcbiAgICAgICAgICAgICAgICByZXN0QXJyb3cuZW5kU3F1YXJlID09PSBhcnJvdy5lbmRTcXVhcmUpICYmXG4gICAgICAgICAgICAgICAgIWlzQXJyb3dBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBBUlJPV19MRU5HVEhfUkVEVUNFUiA9XG4gICAgICAgICAgICAgICAgICAgIHNxdWFyZVdpZHRoIC8gYXJyb3dPcHRpb25zLnNhbWVUYXJnZXRBcnJvd0xlbmd0aFJlZHVjZXJEZW5vbWluYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGlmZmVyZW5jZSBpbiB4IGFuZCB5IGNvb3JkaW5hdGVzIGJldHdlZW4gc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gdG8ueCAtIGZyb20ueDtcbiAgICAgICAgICAgIGNvbnN0IGR5ID0gdG8ueSAtIGZyb20ueTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgdG90YWwgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgdXNpbmcgUHl0aGFnb3JlYW4gdGhlb3JlbVxuICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB1cyB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJvdyBpZiBpdCB3ZW50IGZyb20gY2VudGVyIHRvIGNlbnRlclxuICAgICAgICAgICAgY29uc3QgciA9IE1hdGguaHlwb3QoZHksIGR4KTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGVuZCBwb2ludCBmb3IgdGhlIGFycm93XG4gICAgICAgICAgICAvLyBXZSBzdWJ0cmFjdCBBUlJPV19MRU5HVEhfUkVEVUNFUiBmcm9tIHRoZSB0b3RhbCBkaXN0YW5jZSB0byBtYWtlIHRoZSBhcnJvd1xuICAgICAgICAgICAgLy8gc3RvcCBiZWZvcmUgcmVhY2hpbmcgdGhlIGNlbnRlciBvZiB0aGUgdGFyZ2V0IHNxdWFyZVxuICAgICAgICAgICAgY29uc3QgZW5kID0ge1xuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgZW5kIHggY29vcmRpbmF0ZSBieTpcbiAgICAgICAgICAgICAgICAvLyAxLiBUYWtpbmcgdGhlIG9yaWdpbmFsIHggZGlyZWN0aW9uIChkeClcbiAgICAgICAgICAgICAgICAvLyAyLiBTY2FsaW5nIGl0IGJ5IChyIC0gQVJST1dfTEVOR1RIX1JFRFVDRVIpIC8gciB0byBzaG9ydGVuIGl0XG4gICAgICAgICAgICAgICAgLy8gMy4gQWRkaW5nIHRvIHRoZSBzdGFydGluZyB4IGNvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICB4OiBmcm9tLnggKyAoZHggKiAociAtIEFSUk9XX0xFTkdUSF9SRURVQ0VSKSkgLyByLFxuICAgICAgICAgICAgICAgIC8vIFNhbWUgY2FsY3VsYXRpb24gZm9yIHkgY29vcmRpbmF0ZVxuICAgICAgICAgICAgICAgIHk6IGZyb20ueSArIChkeSAqIChyIC0gQVJST1dfTEVOR1RIX1JFRFVDRVIpKSAvIHIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFJlYWN0LkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4KFwibWFya2VyXCIsIHsgaWQ6IGAke2lkfS1hcnJvd2hlYWQtJHtpfS0ke2Fycm93LnN0YXJ0U3F1YXJlfS0ke2Fycm93LmVuZFNxdWFyZX1gLCBtYXJrZXJXaWR0aDogXCIyXCIsIG1hcmtlckhlaWdodDogXCIyLjVcIiwgcmVmWDogXCIxLjI1XCIsIHJlZlk6IFwiMS4yNVwiLCBvcmllbnQ6IFwiYXV0b1wiLCBjaGlsZHJlbjoganN4UnVudGltZUV4cG9ydHMuanN4KFwicG9seWdvblwiLCB7IHBvaW50czogXCIwLjMgMCwgMiAxLjI1LCAwLjMgMi41XCIsIGZpbGw6IGFycm93LmNvbG9yIH0pIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJsaW5lXCIsIHsgeDE6IGZyb20ueCwgeTE6IGZyb20ueSwgeDI6IGVuZC54LCB5MjogZW5kLnksIG9wYWNpdHk6IGlzQXJyb3dBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFycm93T3B0aW9ucy5hY3RpdmVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhcnJvd09wdGlvbnMub3BhY2l0eSwgc3Ryb2tlOiBhcnJvdy5jb2xvciwgc3Ryb2tlV2lkdGg6IGlzQXJyb3dBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGFycm93T3B0aW9ucy5hY3RpdmVBcnJvd1dpZHRoTXVsdGlwbGllciAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzcXVhcmVXaWR0aCAvIGFycm93T3B0aW9ucy5hcnJvd1dpZHRoRGVub21pbmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzcXVhcmVXaWR0aCAvIGFycm93T3B0aW9ucy5hcnJvd1dpZHRoRGVub21pbmF0b3IsIG1hcmtlckVuZDogYHVybCgjJHtpZH0tYXJyb3doZWFkLSR7aX0tJHthcnJvdy5zdGFydFNxdWFyZX0tJHthcnJvdy5lbmRTcXVhcmV9KWAgfSldIH0sIGAke2lkfS1hcnJvdy0ke2Fycm93LnN0YXJ0U3F1YXJlfS0ke2Fycm93LmVuZFNxdWFyZX0ke2lzQXJyb3dBY3RpdmUgPyAnLWFjdGl2ZScgOiAnJ31gKSk7XG4gICAgICAgIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRHJhZ2dhYmxlKHsgY2hpbGRyZW4sIGlzU3BhcmVQaWVjZSA9IGZhbHNlLCBwaWVjZVR5cGUsIHBvc2l0aW9uLCB9KSB7XG4gICAgY29uc3QgeyBhbGxvd0RyYWdnaW5nLCBjYW5EcmFnUGllY2UgfSA9IHVzZUNoZXNzYm9hcmRDb250ZXh0KCk7XG4gICAgY29uc3QgeyBzZXROb2RlUmVmLCBhdHRyaWJ1dGVzLCBsaXN0ZW5lcnMgfSA9IHVzZURyYWdnYWJsZSh7XG4gICAgICAgIGlkOiBwb3NpdGlvbixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgaXNTcGFyZVBpZWNlLFxuICAgICAgICAgICAgcGllY2VUeXBlLFxuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDogIWFsbG93RHJhZ2dpbmcgfHxcbiAgICAgICAgICAgIChjYW5EcmFnUGllY2UgJiZcbiAgICAgICAgICAgICAgICAhY2FuRHJhZ1BpZWNlKHtcbiAgICAgICAgICAgICAgICAgICAgcGllY2U6IHsgcGllY2VUeXBlIH0sXG4gICAgICAgICAgICAgICAgICAgIGlzU3BhcmVQaWVjZSxcbiAgICAgICAgICAgICAgICAgICAgc3F1YXJlOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgfSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgeyByZWY6IHNldE5vZGVSZWYsIC4uLmF0dHJpYnV0ZXMsIC4uLmxpc3RlbmVycywgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuZnVuY3Rpb24gRHJvcHBhYmxlKHsgY2hpbGRyZW4sIHNxdWFyZUlkIH0pIHtcbiAgICBjb25zdCB7IGlzT3Zlciwgc2V0Tm9kZVJlZiB9ID0gdXNlRHJvcHBhYmxlKHtcbiAgICAgICAgaWQ6IHNxdWFyZUlkLFxuICAgIH0pO1xuICAgIHJldHVybiBqc3hSdW50aW1lRXhwb3J0cy5qc3goXCJkaXZcIiwgeyByZWY6IHNldE5vZGVSZWYsIGNoaWxkcmVuOiBjaGlsZHJlbih7IGlzT3ZlciB9KSB9KTtcbn1cblxuY29uc3QgUGllY2UgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFBpZWNlKHsgY2xvbmUsIGlzU3BhcmVQaWVjZSA9IGZhbHNlLCBwb3NpdGlvbiwgcGllY2VUeXBlLCB9KSB7XG4gICAgY29uc3QgeyBpZCwgYWxsb3dEcmFnZ2luZywgYW5pbWF0aW9uRHVyYXRpb25Jbk1zLCBib2FyZE9yaWVudGF0aW9uLCBjYW5EcmFnUGllY2UsIGRyYWdnaW5nUGllY2UsIGRyYWdnaW5nUGllY2VTdHlsZSwgZHJhZ2dpbmdQaWVjZUdob3N0U3R5bGUsIHBpZWNlcywgcG9zaXRpb25EaWZmZXJlbmNlcywgb25QaWVjZUNsaWNrLCB9ID0gdXNlQ2hlc3Nib2FyZENvbnRleHQoKTtcbiAgICBjb25zdCBbYW5pbWF0aW9uU3R5bGUsIHNldEFuaW1hdGlvblN0eWxlXSA9IFJlYWN0LnVzZVN0YXRlKHt9KTtcbiAgICBsZXQgY3Vyc29yU3R5bGUgPSBjbG9uZSA/ICdncmFiYmluZycgOiAnZ3JhYic7XG4gICAgaWYgKCFhbGxvd0RyYWdnaW5nIHx8XG4gICAgICAgIChjYW5EcmFnUGllY2UgJiZcbiAgICAgICAgICAgICFjYW5EcmFnUGllY2UoeyBwaWVjZTogeyBwaWVjZVR5cGUgfSwgaXNTcGFyZVBpZWNlLCBzcXVhcmU6IHBvc2l0aW9uIH0pKSkge1xuICAgICAgICBjdXJzb3JTdHlsZSA9ICdwb2ludGVyJztcbiAgICB9XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHBvc2l0aW9uRGlmZmVyZW5jZXNbcG9zaXRpb25dKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTcXVhcmUgPSBwb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFNxdWFyZSA9IHBvc2l0aW9uRGlmZmVyZW5jZXNbcG9zaXRpb25dO1xuICAgICAgICAgICAgY29uc3Qgc3F1YXJlV2lkdGggPSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKGAjJHtpZH0tc3F1YXJlLSR7c291cmNlU3F1YXJlfWApXG4gICAgICAgICAgICAgICAgPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgICAgIGlmICghc3F1YXJlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NxdWFyZSB3aWR0aCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEFuaW1hdGlvblN0eWxlKHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gJ2JsYWNrJyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgICAgICAgICAodGFyZ2V0U3F1YXJlLmNoYXJDb2RlQXQoMCkgLSBzb3VyY2VTcXVhcmUuY2hhckNvZGVBdCgwKSkgKlxuICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weCwgJHsoYm9hcmRPcmllbnRhdGlvbiA9PT0gJ2JsYWNrJyA/IC0xIDogMSkgKlxuICAgICAgICAgICAgICAgICAgICAoTnVtYmVyKHNvdXJjZVNxdWFyZVsxXSkgLSBOdW1iZXIodGFyZ2V0U3F1YXJlWzFdKSkgKlxuICAgICAgICAgICAgICAgICAgICBzcXVhcmVXaWR0aH1weClgLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb246IGB0cmFuc2Zvcm0gJHthbmltYXRpb25EdXJhdGlvbkluTXN9bXNgLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLCAvLyBjcmVhdGVzIGEgbmV3IHN0YWNraW5nIGNvbnRleHQgc28gdGhlIHBpZWNlIHN0YXlzIGFib3ZlIHNxdWFyZXMgZHVyaW5nIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldEFuaW1hdGlvblN0eWxlKHt9KTtcbiAgICAgICAgfVxuICAgIH0sIFtwb3NpdGlvbkRpZmZlcmVuY2VzXSk7XG4gICAgY29uc3QgUGllY2VTdmcgPSBwaWVjZXNbcGllY2VUeXBlXTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcImRpdlwiLCB7IGlkOiBgJHtpZH0tcGllY2UtJHtwaWVjZVR5cGV9LSR7cG9zaXRpb259YCwgXCJkYXRhLXBpZWNlXCI6IHBpZWNlVHlwZSwgc3R5bGU6IHtcbiAgICAgICAgICAgIC4uLmFuaW1hdGlvblN0eWxlLFxuICAgICAgICAgICAgLi4uKGNsb25lXG4gICAgICAgICAgICAgICAgPyB7IC4uLmRlZmF1bHREcmFnZ2luZ1BpZWNlU3R5bGUsIC4uLmRyYWdnaW5nUGllY2VTdHlsZSB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi4oIWNsb25lICYmIGRyYWdnaW5nUGllY2U/LnBvc2l0aW9uID09PSBwb3NpdGlvblxuICAgICAgICAgICAgICAgID8geyAuLi5kZWZhdWx0RHJhZ2dpbmdQaWVjZUdob3N0U3R5bGUsIC4uLmRyYWdnaW5nUGllY2VHaG9zdFN0eWxlIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGN1cnNvcjogY3Vyc29yU3R5bGUsXG4gICAgICAgICAgICB0b3VjaEFjdGlvbjogJ25vbmUnLCAvLyBwcmV2ZW50IHpvb21pbmcgYW5kIHNjcm9sbGluZyBvbiB0b3VjaCBkZXZpY2VzXG4gICAgICAgIH0sIG9uQ2xpY2s6ICgpID0+IG9uUGllY2VDbGljaz8uKHsgaXNTcGFyZVBpZWNlLCBwaWVjZTogeyBwaWVjZVR5cGUgfSwgc3F1YXJlOiBwb3NpdGlvbiB9KSwgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChQaWVjZVN2Zywge30pIH0pKTtcbn0pO1xuXG5jb25zdCBTcXVhcmUgPSBSZWFjdC5tZW1vKGZ1bmN0aW9uIFNxdWFyZSh7IGNoaWxkcmVuLCBzcXVhcmVJZCwgaXNMaWdodFNxdWFyZSwgaXNPdmVyLCB9KSB7XG4gICAgY29uc3QgeyBpZCwgYWxsb3dEcmF3aW5nQXJyb3dzLCBib2FyZE9yaWVudGF0aW9uLCBjaGVzc2JvYXJkQ29sdW1ucywgY2hlc3Nib2FyZFJvd3MsIGN1cnJlbnRQb3NpdGlvbiwgc3F1YXJlU3R5bGUsIHNxdWFyZVN0eWxlcywgZGFya1NxdWFyZVN0eWxlLCBsaWdodFNxdWFyZVN0eWxlLCBkcm9wU3F1YXJlU3R5bGUsIGRhcmtTcXVhcmVOb3RhdGlvblN0eWxlLCBsaWdodFNxdWFyZU5vdGF0aW9uU3R5bGUsIGFscGhhTm90YXRpb25TdHlsZSwgbnVtZXJpY05vdGF0aW9uU3R5bGUsIHNob3dOb3RhdGlvbiwgb25Nb3VzZU91dFNxdWFyZSwgb25Nb3VzZU92ZXJTcXVhcmUsIG9uU3F1YXJlQ2xpY2ssIG9uU3F1YXJlUmlnaHRDbGljaywgc3F1YXJlUmVuZGVyZXIsIG5ld0Fycm93U3RhcnRTcXVhcmUsIHNldE5ld0Fycm93U3RhcnRTcXVhcmUsIHNldE5ld0Fycm93T3ZlclNxdWFyZSwgZHJhd0Fycm93LCBjbGVhckFycm93cywgfSA9IHVzZUNoZXNzYm9hcmRDb250ZXh0KCk7XG4gICAgY29uc3QgY29sdW1uID0gc3F1YXJlSWQubWF0Y2goL15bYS16XSsvKT8uWzBdO1xuICAgIGNvbnN0IHJvdyA9IHNxdWFyZUlkLm1hdGNoKC9cXGQrJC8pPy5bMF07XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKFwiZGl2XCIsIHsgaWQ6IGAke2lkfS1zcXVhcmUtJHtzcXVhcmVJZH1gLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uZGVmYXVsdFNxdWFyZVN0eWxlLFxuICAgICAgICAgICAgLi4uc3F1YXJlU3R5bGUsXG4gICAgICAgICAgICAuLi4oaXNMaWdodFNxdWFyZVxuICAgICAgICAgICAgICAgID8geyAuLi5kZWZhdWx0TGlnaHRTcXVhcmVTdHlsZSwgLi4ubGlnaHRTcXVhcmVTdHlsZSB9XG4gICAgICAgICAgICAgICAgOiB7IC4uLmRlZmF1bHREYXJrU3F1YXJlU3R5bGUsIC4uLmRhcmtTcXVhcmVTdHlsZSB9KSxcbiAgICAgICAgICAgIC4uLihpc092ZXIgPyB7IC4uLmRlZmF1bHREcm9wU3F1YXJlU3R5bGUsIC4uLmRyb3BTcXVhcmVTdHlsZSB9IDoge30pLFxuICAgICAgICB9LCBcImRhdGEtY29sdW1uXCI6IGNvbHVtbiwgXCJkYXRhLXJvd1wiOiByb3csIFwiZGF0YS1zcXVhcmVcIjogc3F1YXJlSWQsIG9uQ2xpY2s6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBvblNxdWFyZUNsaWNrPy4oe1xuICAgICAgICAgICAgICAgICAgICBwaWVjZTogY3VycmVudFBvc2l0aW9uW3NxdWFyZUlkXSA/PyBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzcXVhcmU6IHNxdWFyZUlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvblRvdWNoRW5kOiAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIGRvdWJsZS1maXJpbmcgd2l0aCBvbkNsaWNrIG9uIHNvbWUgZGV2aWNlc1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgb25TcXVhcmVDbGljaz8uKHtcbiAgICAgICAgICAgICAgICBwaWVjZTogY3VycmVudFBvc2l0aW9uW3NxdWFyZUlkXSA/PyBudWxsLFxuICAgICAgICAgICAgICAgIHNxdWFyZTogc3F1YXJlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgb25Db250ZXh0TWVudTogKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG9uU3F1YXJlUmlnaHRDbGljaz8uKHtcbiAgICAgICAgICAgICAgICBwaWVjZTogY3VycmVudFBvc2l0aW9uW3NxdWFyZUlkXSA/PyBudWxsLFxuICAgICAgICAgICAgICAgIHNxdWFyZTogc3F1YXJlSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgb25Nb3VzZURvd246IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBjbGVhckFycm93cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAyICYmIGFsbG93RHJhd2luZ0Fycm93cykge1xuICAgICAgICAgICAgICAgIHNldE5ld0Fycm93U3RhcnRTcXVhcmUoc3F1YXJlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvbk1vdXNlVXA6IChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3QXJyb3dTdGFydFNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3QXJyb3coc3F1YXJlSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0S2V5OiBlLnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIG9uTW91c2VPdmVyOiAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gcmlnaHQgbW91c2UgYnV0dG9uIGlzIGhlbGQgZG93biBhbmQgd2UgYXJlIGRyYXdpbmcgYW4gYXJyb3dcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDIgJiYgbmV3QXJyb3dTdGFydFNxdWFyZSkge1xuICAgICAgICAgICAgICAgIHNldE5ld0Fycm93T3ZlclNxdWFyZShzcXVhcmVJZCwge1xuICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgY3RybEtleTogZS5jdHJsS2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25Nb3VzZU92ZXJTcXVhcmU/Lih7XG4gICAgICAgICAgICAgICAgcGllY2U6IGN1cnJlbnRQb3NpdGlvbltzcXVhcmVJZF0gPz8gbnVsbCxcbiAgICAgICAgICAgICAgICBzcXVhcmU6IHNxdWFyZUlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIG9uTW91c2VMZWF2ZTogKCkgPT4gb25Nb3VzZU91dFNxdWFyZT8uKHtcbiAgICAgICAgICAgIHBpZWNlOiBjdXJyZW50UG9zaXRpb25bc3F1YXJlSWRdID8/IG51bGwsXG4gICAgICAgICAgICBzcXVhcmU6IHNxdWFyZUlkLFxuICAgICAgICB9KSwgY2hpbGRyZW46IFtzaG93Tm90YXRpb24gPyAoanN4UnVudGltZUV4cG9ydHMuanN4cyhcInNwYW5cIiwgeyBzdHlsZTogaXNMaWdodFNxdWFyZVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRMaWdodFNxdWFyZU5vdGF0aW9uU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5saWdodFNxdWFyZU5vdGF0aW9uU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0RGFya1NxdWFyZU5vdGF0aW9uU3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXJrU3F1YXJlTm90YXRpb25TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFtyb3cgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAoYm9hcmRPcmllbnRhdGlvbiA9PT0gJ3doaXRlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJzEnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVzc2JvYXJkUm93cy50b1N0cmluZygpKSAmJiAoanN4UnVudGltZUV4cG9ydHMuanN4KFwic3BhblwiLCB7IHN0eWxlOiB7IC4uLmRlZmF1bHRBbHBoYU5vdGF0aW9uU3R5bGUsIC4uLmFscGhhTm90YXRpb25TdHlsZSB9LCBjaGlsZHJlbjogY29sdW1uIH0pKSwgY29sdW1uID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgKGJvYXJkT3JpZW50YXRpb24gPT09ICd3aGl0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdhJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29sdW1uSW5kZXhUb0NoZXNzQ29sdW1uKDAsIGNoZXNzYm9hcmRDb2x1bW5zLCBib2FyZE9yaWVudGF0aW9uKSkgJiYgKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChcInNwYW5cIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRlZmF1bHROdW1lcmljTm90YXRpb25TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5udW1lcmljTm90YXRpb25TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNoaWxkcmVuOiByb3cgfSkpXSB9KSkgOiBudWxsLCBzcXVhcmVSZW5kZXJlcj8uKHtcbiAgICAgICAgICAgICAgICBwaWVjZTogY3VycmVudFBvc2l0aW9uW3NxdWFyZUlkXSA/PyBudWxsLFxuICAgICAgICAgICAgICAgIHNxdWFyZTogc3F1YXJlSWQsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICB9KSB8fCAoanN4UnVudGltZUV4cG9ydHMuanN4KFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIC4uLnNxdWFyZVN0eWxlc1tzcXVhcmVJZF0sXG4gICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKV0gfSkpO1xufSk7XG5cbmNvbnN0IHByZXZlbnREcmFnT2ZmQm9hcmQgPSAoYm9hcmRJZCwgZHJhZ2dpbmdQaWVjZVBvc2l0aW9uKSA9PiB7XG4gICAgcmV0dXJuICh7IHRyYW5zZm9ybSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGJvYXJkRWxlbWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYCR7Ym9hcmRJZH0tYm9hcmRgKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIWJvYXJkRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIGExIHNxdWFyZSB0byBkZXRlcm1pbmUgc3F1YXJlIHNpemUgdXNpbmcgZGF0YSBhdHRyaWJ1dGVzXG4gICAgICAgIGNvbnN0IGJvYXJkUmVjdCA9IGJvYXJkRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgYTFTcXVhcmUgPSBib2FyZEVsZW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY29sdW1uPVwiYVwiXVtkYXRhLXJvdz1cIjFcIl0nKTtcbiAgICAgICAgaWYgKCFhMVNxdWFyZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcXVhcmVXaWR0aCA9IGExU3F1YXJlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjb25zdCBoYWxmU3F1YXJlV2lkdGggPSBzcXVhcmVXaWR0aCAvIDI7XG4gICAgICAgIC8vIEV4dHJhY3QgY29sdW1uIGFuZCByb3cgZnJvbSBwb3NpdGlvbiAoc3VwcG9ydHMgbXVsdGktY2hhciBjb2x1bW5zL3Jvd3MpXG4gICAgICAgIGNvbnN0IG1hdGNoID0gZHJhZ2dpbmdQaWVjZVBvc2l0aW9uLm1hdGNoKC9eKFthLXpBLVpdKykoXFxkKykkLyk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgY29sLCByb3ddID0gbWF0Y2g7XG4gICAgICAgIC8vIEdldCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gb2YgdGhlIHBpZWNlXG4gICAgICAgIGNvbnN0IHN0YXJ0U3F1YXJlID0gYm9hcmRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWNvbHVtbj1cIiR7Y29sfVwiXVtkYXRhLXJvdz1cIiR7cm93fVwiXWApO1xuICAgICAgICBpZiAoIXN0YXJ0U3F1YXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0U3F1YXJlUmVjdCA9IHN0YXJ0U3F1YXJlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCBzdGFydFggPSBzdGFydFNxdWFyZVJlY3QubGVmdCArIGhhbGZTcXVhcmVXaWR0aCAtIGJvYXJkUmVjdC5sZWZ0O1xuICAgICAgICBjb25zdCBzdGFydFkgPSBzdGFydFNxdWFyZVJlY3QudG9wICsgaGFsZlNxdWFyZVdpZHRoIC0gYm9hcmRSZWN0LnRvcDtcbiAgICAgICAgLy8gQ2xhbXAgc28gdGhlIGNlbnRlciBvZiB0aGUgcGllY2UgY2FuIGdvIGV4YWN0bHkgaGFsZiBhIHNxdWFyZSB3aWR0aCBvdXRzaWRlIHRoZSBib2FyZFxuICAgICAgICBjb25zdCBtaW5YID0gLXN0YXJ0WDtcbiAgICAgICAgY29uc3QgbWF4WCA9IGJvYXJkUmVjdC53aWR0aCAtIHN0YXJ0WDtcbiAgICAgICAgY29uc3QgbWluWSA9IC1zdGFydFk7XG4gICAgICAgIGNvbnN0IG1heFkgPSBib2FyZFJlY3QuaGVpZ2h0IC0gc3RhcnRZO1xuICAgICAgICBjb25zdCBjbGFtcGVkWCA9IE1hdGgubWluKE1hdGgubWF4KHRyYW5zZm9ybS54LCBtaW5YKSwgbWF4WCk7XG4gICAgICAgIGNvbnN0IGNsYW1wZWRZID0gTWF0aC5taW4oTWF0aC5tYXgodHJhbnNmb3JtLnksIG1pblkpLCBtYXhZKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIHg6IGNsYW1wZWRYLFxuICAgICAgICAgICAgeTogY2xhbXBlZFksXG4gICAgICAgIH07XG4gICAgfTtcbn07XG5cbmZ1bmN0aW9uIEJvYXJkKCkge1xuICAgIGNvbnN0IHsgYWxsb3dEcmFnT2ZmQm9hcmQsIGJvYXJkLCBib2FyZFN0eWxlLCBjaGVzc2JvYXJkQ29sdW1ucywgY3VycmVudFBvc2l0aW9uLCBkcmFnZ2luZ1BpZWNlLCBpZCwgfSA9IHVzZUNoZXNzYm9hcmRDb250ZXh0KCk7XG4gICAgY29uc3QgYm9hcmRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgW2JvYXJkV2lkdGgsIHNldEJvYXJkV2lkdGhdID0gUmVhY3QudXNlU3RhdGUoYm9hcmRSZWYuY3VycmVudD8uY2xpZW50V2lkdGgpO1xuICAgIGNvbnN0IFtib2FyZEhlaWdodCwgc2V0Qm9hcmRIZWlnaHRdID0gUmVhY3QudXNlU3RhdGUoYm9hcmRSZWYuY3VycmVudD8uY2xpZW50SGVpZ2h0KTtcbiAgICAvLyBpZiB0aGUgYm9hcmQgZGltZW5zaW9ucyBjaGFuZ2UsIHVwZGF0ZSB0aGUgYm9hcmQgd2lkdGggYW5kIGhlaWdodFxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChib2FyZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Qm9hcmRXaWR0aChib2FyZFJlZi5jdXJyZW50Py5jbGllbnRXaWR0aCk7XG4gICAgICAgICAgICAgICAgc2V0Qm9hcmRIZWlnaHQoYm9hcmRSZWYuY3VycmVudD8uY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShib2FyZFJlZi5jdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtib2FyZFJlZi5jdXJyZW50XSk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3hzKGpzeFJ1bnRpbWVFeHBvcnRzLkZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4UnVudGltZUV4cG9ydHMuanN4cyhcImRpdlwiLCB7IGlkOiBgJHtpZH0tYm9hcmRgLCByZWY6IGJvYXJkUmVmLCBzdHlsZTogeyAuLi5kZWZhdWx0Qm9hcmRTdHlsZShjaGVzc2JvYXJkQ29sdW1ucyksIC4uLmJvYXJkU3R5bGUgfSwgY2hpbGRyZW46IFtib2FyZC5tYXAoKHJvdykgPT4gcm93Lm1hcCgoc3F1YXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWVjZSA9IGN1cnJlbnRQb3NpdGlvbltzcXVhcmUuc3F1YXJlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRHJvcHBhYmxlLCB7IHNxdWFyZUlkOiBzcXVhcmUuc3F1YXJlSWQsIGNoaWxkcmVuOiAoeyBpc092ZXIgfSkgPT4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChTcXVhcmUsIHsgaXNPdmVyOiBpc092ZXIsIC4uLnNxdWFyZSwgY2hpbGRyZW46IHBpZWNlID8gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChEcmFnZ2FibGUsIHsgaXNTcGFyZVBpZWNlOiBmYWxzZSwgcG9zaXRpb246IHNxdWFyZS5zcXVhcmVJZCwgcGllY2VUeXBlOiBwaWVjZS5waWVjZVR5cGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goUGllY2UsIHsgLi4ucGllY2UsIHBvc2l0aW9uOiBzcXVhcmUuc3F1YXJlSWQgfSkgfSkpIDogbnVsbCB9KSkgfSwgc3F1YXJlLnNxdWFyZUlkKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKSwganN4UnVudGltZUV4cG9ydHMuanN4KEFycm93cywgeyBib2FyZFdpZHRoOiBib2FyZFdpZHRoLCBib2FyZEhlaWdodDogYm9hcmRIZWlnaHQgfSldIH0pLCBqc3hSdW50aW1lRXhwb3J0cy5qc3goRHJhZ092ZXJsYXksIHsgZHJvcEFuaW1hdGlvbjogbnVsbCwgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHNuYXBDZW50ZXJUb0N1cnNvcixcbiAgICAgICAgICAgICAgICAgICAgLi4uKGFsbG93RHJhZ09mZkJvYXJkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtwcmV2ZW50RHJhZ09mZkJvYXJkKGlkLCBkcmFnZ2luZ1BpZWNlPy5wb3NpdGlvbiB8fCAnJyldKSxcbiAgICAgICAgICAgICAgICBdLCBjaGlsZHJlbjogZHJhZ2dpbmdQaWVjZSA/IChqc3hSdW50aW1lRXhwb3J0cy5qc3goUGllY2UsIHsgY2xvbmU6IHRydWUsIHBvc2l0aW9uOiBkcmFnZ2luZ1BpZWNlLnBvc2l0aW9uLCBwaWVjZVR5cGU6IGRyYWdnaW5nUGllY2UucGllY2VUeXBlIH0pKSA6IG51bGwgfSldIH0pKTtcbn1cblxuZnVuY3Rpb24gQ2hlc3Nib2FyZCh7IG9wdGlvbnMgfSkge1xuICAgIGNvbnN0IHsgaXNXcmFwcGVkIH0gPSB1c2VDaGVzc2JvYXJkQ29udGV4dCgpID8/IHsgaXNXcmFwcGVkOiBmYWxzZSB9O1xuICAgIGlmIChpc1dyYXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCb2FyZCwge30pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChDaGVzc2JvYXJkUHJvdmlkZXIsIHsgb3B0aW9uczogb3B0aW9ucywgY2hpbGRyZW46IGpzeFJ1bnRpbWVFeHBvcnRzLmpzeChCb2FyZCwge30pIH0pKTtcbn1cblxuZnVuY3Rpb24gU3BhcmVQaWVjZSh7IHBpZWNlVHlwZSB9KSB7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lRXhwb3J0cy5qc3goRHJhZ2dhYmxlLCB7IGlzU3BhcmVQaWVjZTogdHJ1ZSwgcG9zaXRpb246IHBpZWNlVHlwZSwgcGllY2VUeXBlOiBwaWVjZVR5cGUsIGNoaWxkcmVuOiBqc3hSdW50aW1lRXhwb3J0cy5qc3goUGllY2UsIHsgaXNTcGFyZVBpZWNlOiB0cnVlLCBwaWVjZVR5cGU6IHBpZWNlVHlwZSwgcG9zaXRpb246IHBpZWNlVHlwZSB9KSB9KSk7XG59XG5cbmV4cG9ydHMuQ2hlc3Nib2FyZCA9IENoZXNzYm9hcmQ7XG5leHBvcnRzLkNoZXNzYm9hcmRQcm92aWRlciA9IENoZXNzYm9hcmRQcm92aWRlcjtcbmV4cG9ydHMuU3BhcmVQaWVjZSA9IFNwYXJlUGllY2U7XG5leHBvcnRzLmNoZXNzQ29sdW1uVG9Db2x1bW5JbmRleCA9IGNoZXNzQ29sdW1uVG9Db2x1bW5JbmRleDtcbmV4cG9ydHMuY2hlc3NSb3dUb1Jvd0luZGV4ID0gY2hlc3NSb3dUb1Jvd0luZGV4O1xuZXhwb3J0cy5jb2x1bW5JbmRleFRvQ2hlc3NDb2x1bW4gPSBjb2x1bW5JbmRleFRvQ2hlc3NDb2x1bW47XG5leHBvcnRzLmRlZmF1bHRBbHBoYU5vdGF0aW9uU3R5bGUgPSBkZWZhdWx0QWxwaGFOb3RhdGlvblN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0QXJyb3dPcHRpb25zID0gZGVmYXVsdEFycm93T3B0aW9ucztcbmV4cG9ydHMuZGVmYXVsdEJvYXJkU3R5bGUgPSBkZWZhdWx0Qm9hcmRTdHlsZTtcbmV4cG9ydHMuZGVmYXVsdERhcmtTcXVhcmVOb3RhdGlvblN0eWxlID0gZGVmYXVsdERhcmtTcXVhcmVOb3RhdGlvblN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0RGFya1NxdWFyZVN0eWxlID0gZGVmYXVsdERhcmtTcXVhcmVTdHlsZTtcbmV4cG9ydHMuZGVmYXVsdERyYWdnaW5nUGllY2VHaG9zdFN0eWxlID0gZGVmYXVsdERyYWdnaW5nUGllY2VHaG9zdFN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0RHJhZ2dpbmdQaWVjZVN0eWxlID0gZGVmYXVsdERyYWdnaW5nUGllY2VTdHlsZTtcbmV4cG9ydHMuZGVmYXVsdERyb3BTcXVhcmVTdHlsZSA9IGRlZmF1bHREcm9wU3F1YXJlU3R5bGU7XG5leHBvcnRzLmRlZmF1bHRMaWdodFNxdWFyZU5vdGF0aW9uU3R5bGUgPSBkZWZhdWx0TGlnaHRTcXVhcmVOb3RhdGlvblN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0TGlnaHRTcXVhcmVTdHlsZSA9IGRlZmF1bHRMaWdodFNxdWFyZVN0eWxlO1xuZXhwb3J0cy5kZWZhdWx0TnVtZXJpY05vdGF0aW9uU3R5bGUgPSBkZWZhdWx0TnVtZXJpY05vdGF0aW9uU3R5bGU7XG5leHBvcnRzLmRlZmF1bHRQaWVjZXMgPSBkZWZhdWx0UGllY2VzO1xuZXhwb3J0cy5kZWZhdWx0U3F1YXJlU3R5bGUgPSBkZWZhdWx0U3F1YXJlU3R5bGU7XG5leHBvcnRzLmZlblN0cmluZ1RvUG9zaXRpb25PYmplY3QgPSBmZW5TdHJpbmdUb1Bvc2l0aW9uT2JqZWN0O1xuZXhwb3J0cy5nZW5lcmF0ZUJvYXJkID0gZ2VuZXJhdGVCb2FyZDtcbmV4cG9ydHMuZ2V0UG9zaXRpb25VcGRhdGVzID0gZ2V0UG9zaXRpb25VcGRhdGVzO1xuZXhwb3J0cy5nZXRSZWxhdGl2ZUNvb3JkcyA9IGdldFJlbGF0aXZlQ29vcmRzO1xuZXhwb3J0cy5yb3dJbmRleFRvQ2hlc3NSb3cgPSByb3dJbmRleFRvQ2hlc3NSb3c7XG5leHBvcnRzLnVzZUNoZXNzYm9hcmRDb250ZXh0ID0gdXNlQ2hlc3Nib2FyZENvbnRleHQ7XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwicmVhY3REb20iLCJqc3hSdW50aW1lIiwiZXhwb3J0cyIsInJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uIiwiaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiIsInJlcXVpcmVSZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbiIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJqc3hQcm9kIiwidHlwZSIsImNvbmZpZyIsIm1heWJlS2V5Iiwia2V5IiwicHJvcE5hbWUiLCJyZWYiLCIkJHR5cGVvZiIsInByb3BzIiwiRnJhZ21lbnQiLCJqc3giLCJqc3hzIiwicmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50IiwiaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQiLCJyZXF1aXJlUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50IiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJ0YWciLCJjb25zb2xlIiwiZXJyb3IiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiX2NvbnRleHQiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiaW5uZXJUeXBlIiwicmVuZGVyIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiX3BheWxvYWQiLCJfaW5pdCIsIngiLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJ2YWx1ZSIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQiLCJlIiwiSlNDb21waWxlcl90ZW1wX2NvbnN0IiwiSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwIiwidG9TdHJpbmdUYWciLCJjYWxsIiwiZGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImRpc2FibGVkRGVwdGgiLCJwcmV2TG9nIiwibG9nIiwicHJldkluZm8iLCJpbmZvIiwicHJldldhcm4iLCJ3YXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwiZ3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJncm91cENvbGxhcHNlZCIsInByZXZHcm91cEVuZCIsImdyb3VwRW5kIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsImFzc2lnbiIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwicHJlZml4IiwiRXJyb3IiLCJtYXRjaCIsInN0YWNrIiwidHJpbSIsInN1ZmZpeCIsImluZGV4T2YiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJyZWVudHJ5IiwiZnJhbWUiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiZ2V0IiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIkgiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvdHlwZSIsInNldCIsIlJlZmxlY3QiLCJjb250cm9sIiwieCQwIiwieCQxIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJsZW5ndGgiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYiLCJpc1JlYWN0Q29tcG9uZW50IiwiZ2V0T3duZXIiLCJkaXNwYXRjaGVyIiwiQSIsImhhc1ZhbGlkS2V5IiwiaGFzT3duUHJvcGVydHkiLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5Iiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZyIsImNvbXBvbmVudE5hbWUiLCJkaWRXYXJuQWJvdXRFbGVtZW50UmVmIiwiUmVhY3RFbGVtZW50Iiwic2VsZiIsInNvdXJjZSIsIm93bmVyIiwiX293bmVyIiwiX3N0b3JlIiwiZnJlZXplIiwianN4REVWSW1wbCIsImlzU3RhdGljQ2hpbGRyZW4iLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldE1vZHVsZUlkIiwiY2hpbGRyZW4iLCJpc0FycmF5SW1wbCIsInZhbGlkYXRlQ2hpbGRLZXlzIiwia2V5cyIsImZpbHRlciIsImsiLCJqb2luIiwiZGlkV2FybkFib3V0S2V5U3ByZWFkIiwibm9kZSIsInBhcmVudFR5cGUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiaSIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiZW50cmllcyIsIm5leHQiLCJkb25lIiwib2JqZWN0IiwiZWxlbWVudCIsImdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJjaGlsZE93bmVyIiwicHJldkdldEN1cnJlbnRTdGFjayIsImdldEN1cnJlbnRTdGFjayIsIlJlYWN0JDEiLCJpdGVyYXRvciIsIl9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSIsIkFycmF5IiwiaXNBcnJheSIsIl9fcmVhY3REaXNhYmxlZExvZyIsIldlYWtNYXAiLCJNYXAiLCJoYXNSZXF1aXJlZEpzeFJ1bnRpbWUiLCJyZXF1aXJlSnN4UnVudGltZSIsImpzeFJ1bnRpbWVFeHBvcnRzIiwiY2FuVXNlRE9NIiwid2luZG93IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaXNXaW5kb3ciLCJlbGVtZW50U3RyaW5nIiwidG9TdHJpbmciLCJpc05vZGUiLCJnZXRXaW5kb3ciLCJ0YXJnZXQiLCJfdGFyZ2V0JG93bmVyRG9jdW1lbnQiLCJfdGFyZ2V0JG93bmVyRG9jdW1lbnQyIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNEb2N1bWVudCIsIkRvY3VtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTVkdFbGVtZW50IiwiU1ZHRWxlbWVudCIsImdldE93bmVyRG9jdW1lbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlRXZlbnQiLCJoYW5kbGVyIiwiaGFuZGxlclJlZiIsInVzZVJlZiIsImN1cnJlbnQiLCJ1c2VDYWxsYmFjayIsIl9sZW4iLCJhcmd1bWVudHMiLCJhcmdzIiwiX2tleSIsInVzZUludGVydmFsIiwiaW50ZXJ2YWxSZWYiLCJsaXN0ZW5lciIsImR1cmF0aW9uIiwic2V0SW50ZXJ2YWwiLCJjbGVhciIsImNsZWFySW50ZXJ2YWwiLCJ1c2VMYXRlc3RWYWx1ZSIsImRlcGVuZGVuY2llcyIsInZhbHVlUmVmIiwidXNlTGF6eU1lbW8iLCJjYWxsYmFjayIsInVzZU1lbW8iLCJuZXdWYWx1ZSIsInVzZU5vZGVSZWYiLCJvbkNoYW5nZSIsIm9uQ2hhbmdlSGFuZGxlciIsInNldE5vZGVSZWYiLCJ1c2VQcmV2aW91cyIsImlkcyIsInVzZVVuaXF1ZUlkIiwiaWQiLCJjcmVhdGVBZGp1c3RtZW50Rm4iLCJtb2RpZmllciIsImFkanVzdG1lbnRzIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJhZGp1c3RtZW50IiwidmFsdWVBZGp1c3RtZW50IiwiYWRkIiwic3VidHJhY3QiLCJoYXNWaWV3cG9ydFJlbGF0aXZlQ29vcmRpbmF0ZXMiLCJldmVudCIsImlzS2V5Ym9hcmRFdmVudCIsIktleWJvYXJkRXZlbnQiLCJpc1RvdWNoRXZlbnQiLCJUb3VjaEV2ZW50IiwiZ2V0RXZlbnRDb29yZGluYXRlcyIsInRvdWNoZXMiLCJjbGllbnRYIiwiY2xpZW50WSIsInkiLCJjaGFuZ2VkVG91Y2hlcyIsIkNTUyIsIlRyYW5zbGF0ZSIsInRyYW5zZm9ybSIsIk1hdGgiLCJyb3VuZCIsIlNjYWxlIiwic2NhbGVYIiwic2NhbGVZIiwiVHJhbnNmb3JtIiwiVHJhbnNpdGlvbiIsIl9yZWYiLCJwcm9wZXJ0eSIsImVhc2luZyIsIlNFTEVDVE9SIiwiZmluZEZpcnN0Rm9jdXNhYmxlTm9kZSIsIm1hdGNoZXMiLCJxdWVyeVNlbGVjdG9yIiwiaGlkZGVuU3R5bGVzIiwiZGlzcGxheSIsIkhpZGRlblRleHQiLCJzdHlsZSIsIkxpdmVSZWdpb24iLCJhbm5vdW5jZW1lbnQiLCJhcmlhTGl2ZVR5cGUiLCJ2aXN1YWxseUhpZGRlbiIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwid2hpdGVTcGFjZSIsInJvbGUiLCJ1c2VBbm5vdW5jZW1lbnQiLCJzZXRBbm5vdW5jZW1lbnQiLCJ1c2VTdGF0ZSIsImFubm91bmNlIiwiRG5kTW9uaXRvckNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlRG5kTW9uaXRvciIsInJlZ2lzdGVyTGlzdGVuZXIiLCJ1c2VDb250ZXh0IiwidW5zdWJzY3JpYmUiLCJ1c2VEbmRNb25pdG9yUHJvdmlkZXIiLCJsaXN0ZW5lcnMiLCJTZXQiLCJkZWxldGUiLCJkaXNwYXRjaCIsImZvckVhY2giLCJfbGlzdGVuZXIkdHlwZSIsImRlZmF1bHRTY3JlZW5SZWFkZXJJbnN0cnVjdGlvbnMiLCJkcmFnZ2FibGUiLCJkZWZhdWx0QW5ub3VuY2VtZW50cyIsIm9uRHJhZ1N0YXJ0IiwiYWN0aXZlIiwib25EcmFnT3ZlciIsIl9yZWYyIiwib3ZlciIsIm9uRHJhZ0VuZCIsIl9yZWYzIiwib25EcmFnQ2FuY2VsIiwiX3JlZjQiLCJBY2Nlc3NpYmlsaXR5IiwiYW5ub3VuY2VtZW50cyIsImNvbnRhaW5lciIsImhpZGRlblRleHREZXNjcmliZWRCeUlkIiwic2NyZWVuUmVhZGVySW5zdHJ1Y3Rpb25zIiwibGl2ZVJlZ2lvbklkIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJvbkRyYWdNb3ZlIiwiX3JlZjUiLCJfcmVmNiIsIm1hcmt1cCIsImNyZWF0ZVBvcnRhbCIsIkFjdGlvbiIsIm5vb3AiLCJ1c2VTZW5zb3IiLCJzZW5zb3IiLCJvcHRpb25zIiwidXNlU2Vuc29ycyIsInNlbnNvcnMiLCJkZWZhdWx0Q29vcmRpbmF0ZXMiLCJkaXN0YW5jZUJldHdlZW4iLCJwMSIsInAyIiwic3FydCIsInBvdyIsImdldFJlbGF0aXZlVHJhbnNmb3JtT3JpZ2luIiwicmVjdCIsImV2ZW50Q29vcmRpbmF0ZXMiLCJ0cmFuc2Zvcm1PcmlnaW4iLCJzb3J0Q29sbGlzaW9uc0FzYyIsImRhdGEiLCJhIiwiYiIsInNvcnRDb2xsaXNpb25zRGVzYyIsImNvcm5lcnNPZlJlY3RhbmdsZSIsImdldEZpcnN0Q29sbGlzaW9uIiwiY29sbGlzaW9ucyIsImZpcnN0Q29sbGlzaW9uIiwiZ2V0SW50ZXJzZWN0aW9uUmF0aW8iLCJlbnRyeSIsIm1heCIsInJpZ2h0IiwibWluIiwiYm90dG9tIiwidGFyZ2V0QXJlYSIsImVudHJ5QXJlYSIsImludGVyc2VjdGlvbkFyZWEiLCJpbnRlcnNlY3Rpb25SYXRpbyIsIk51bWJlciIsInRvRml4ZWQiLCJyZWN0SW50ZXJzZWN0aW9uIiwiY29sbGlzaW9uUmVjdCIsImRyb3BwYWJsZVJlY3RzIiwiZHJvcHBhYmxlQ29udGFpbmVycyIsImRyb3BwYWJsZUNvbnRhaW5lciIsInB1c2giLCJzb3J0IiwiaXNQb2ludFdpdGhpblJlY3QiLCJwb2ludCIsInBvaW50ZXJXaXRoaW4iLCJwb2ludGVyQ29vcmRpbmF0ZXMiLCJjb3JuZXJzIiwiZGlzdGFuY2VzIiwiY29ybmVyIiwiZWZmZWN0aXZlRGlzdGFuY2UiLCJhZGp1c3RTY2FsZSIsInJlY3QxIiwicmVjdDIiLCJnZXRSZWN0RGVsdGEiLCJjcmVhdGVSZWN0QWRqdXN0bWVudEZuIiwiYWRqdXN0Q2xpZW50UmVjdCIsImFjYyIsImdldEFkanVzdGVkUmVjdCIsInBhcnNlVHJhbnNmb3JtIiwic3RhcnRzV2l0aCIsInRyYW5zZm9ybUFycmF5Iiwic2xpY2UiLCJpbnZlcnNlVHJhbnNmb3JtIiwicGFyc2VkVHJhbnNmb3JtIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJwYXJzZUZsb2F0IiwidyIsImgiLCJkZWZhdWx0T3B0aW9ucyIsImlnbm9yZVRyYW5zZm9ybSIsImdldENsaWVudFJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0VHJhbnNmb3JtQWdub3N0aWNDbGllbnRSZWN0IiwiZ2V0V2luZG93Q2xpZW50UmVjdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsImlzRml4ZWQiLCJjb21wdXRlZFN0eWxlIiwiaXNTY3JvbGxhYmxlIiwib3ZlcmZsb3dSZWdleCIsInByb3BlcnRpZXMiLCJzb21lIiwidGVzdCIsImdldFNjcm9sbGFibGVBbmNlc3RvcnMiLCJsaW1pdCIsInNjcm9sbFBhcmVudHMiLCJmaW5kU2Nyb2xsYWJsZUFuY2VzdG9ycyIsInNjcm9sbGluZ0VsZW1lbnQiLCJwYXJlbnROb2RlIiwiZ2V0Rmlyc3RTY3JvbGxhYmxlQW5jZXN0b3IiLCJmaXJzdFNjcm9sbGFibGVBbmNlc3RvciIsImdldFNjcm9sbGFibGVFbGVtZW50IiwiZ2V0U2Nyb2xsWENvb3JkaW5hdGUiLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsImdldFNjcm9sbFlDb29yZGluYXRlIiwic2Nyb2xsWSIsInNjcm9sbFRvcCIsImdldFNjcm9sbENvb3JkaW5hdGVzIiwiRGlyZWN0aW9uIiwiaXNEb2N1bWVudFNjcm9sbGluZ0VsZW1lbnQiLCJnZXRTY3JvbGxQb3NpdGlvbiIsInNjcm9sbGluZ0NvbnRhaW5lciIsIm1pblNjcm9sbCIsImRpbWVuc2lvbnMiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsIm1heFNjcm9sbCIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiaXNUb3AiLCJpc0xlZnQiLCJpc0JvdHRvbSIsImlzUmlnaHQiLCJkZWZhdWx0VGhyZXNob2xkIiwiZ2V0U2Nyb2xsRGlyZWN0aW9uQW5kU3BlZWQiLCJzY3JvbGxDb250YWluZXIiLCJzY3JvbGxDb250YWluZXJSZWN0IiwiYWNjZWxlcmF0aW9uIiwidGhyZXNob2xkUGVyY2VudGFnZSIsImRpcmVjdGlvbiIsInNwZWVkIiwidGhyZXNob2xkIiwiQmFja3dhcmQiLCJhYnMiLCJGb3J3YXJkIiwiZ2V0U2Nyb2xsRWxlbWVudFJlY3QiLCJnZXRTY3JvbGxPZmZzZXRzIiwic2Nyb2xsYWJsZUFuY2VzdG9ycyIsImdldFNjcm9sbFhPZmZzZXQiLCJnZXRTY3JvbGxZT2Zmc2V0Iiwic2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCIsIm1lYXN1cmUiLCJzY3JvbGxJbnRvVmlldyIsImJsb2NrIiwiaW5saW5lIiwiUmVjdCIsInNjcm9sbE9mZnNldHMiLCJheGlzIiwiZ2V0U2Nyb2xsT2Zmc2V0IiwiY3VycmVudE9mZnNldHMiLCJzY3JvbGxPZmZzZXRzRGVsdGxhIiwiTGlzdGVuZXJzIiwiZXZlbnROYW1lIiwiX3RoaXMkdGFyZ2V0MiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVBbGwiLCJfdGhpcyR0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RXZlbnRMaXN0ZW5lclRhcmdldCIsIkV2ZW50VGFyZ2V0IiwiaGFzRXhjZWVkZWREaXN0YW5jZSIsImRlbHRhIiwibWVhc3VyZW1lbnQiLCJkeCIsImR5IiwiRXZlbnROYW1lIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJLZXlib2FyZENvZGUiLCJkZWZhdWx0S2V5Ym9hcmRDb2RlcyIsInN0YXJ0IiwiU3BhY2UiLCJFbnRlciIsImNhbmNlbCIsIkVzYyIsImVuZCIsIlRhYiIsImRlZmF1bHRLZXlib2FyZENvb3JkaW5hdGVHZXR0ZXIiLCJjdXJyZW50Q29vcmRpbmF0ZXMiLCJjb2RlIiwiUmlnaHQiLCJMZWZ0IiwiRG93biIsIlVwIiwidW5kZWZpbmVkIiwiS2V5Ym9hcmRTZW5zb3IiLCJhdHRhY2giLCJoYW5kbGVTdGFydCIsIndpbmRvd0xpc3RlbmVycyIsIlJlc2l6ZSIsImhhbmRsZUNhbmNlbCIsIlZpc2liaWxpdHlDaGFuZ2UiLCJzZXRUaW1lb3V0IiwiS2V5ZG93biIsImhhbmRsZUtleURvd24iLCJhY3RpdmVOb2RlIiwib25TdGFydCIsImNvbnRleHQiLCJrZXlib2FyZENvZGVzIiwiY29vcmRpbmF0ZUdldHRlciIsInNjcm9sbEJlaGF2aW9yIiwiaGFuZGxlRW5kIiwicmVmZXJlbmNlQ29vcmRpbmF0ZXMiLCJuZXdDb29yZGluYXRlcyIsImNvb3JkaW5hdGVzRGVsdGEiLCJzY3JvbGxEZWx0YSIsInNjcm9sbEVsZW1lbnRSZWN0IiwiY2xhbXBlZENvb3JkaW5hdGVzIiwiY2FuU2Nyb2xsWCIsImNhblNjcm9sbFkiLCJuZXdTY3JvbGxDb29yZGluYXRlcyIsImNhblNjcm9sbFRvTmV3Q29vcmRpbmF0ZXMiLCJzY3JvbGxUbyIsImJlaGF2aW9yIiwic2Nyb2xsQnkiLCJoYW5kbGVNb3ZlIiwiY29vcmRpbmF0ZXMiLCJvbk1vdmUiLCJvbkVuZCIsImRldGFjaCIsIm9uQ2FuY2VsIiwiYXV0b1Njcm9sbEVuYWJsZWQiLCJiaW5kIiwiYWN0aXZhdG9ycyIsIm9uQWN0aXZhdGlvbiIsIm5hdGl2ZUV2ZW50IiwiYWN0aXZhdG9yIiwiYWN0aXZhdG9yTm9kZSIsImlzRGlzdGFuY2VDb25zdHJhaW50IiwiY29uc3RyYWludCIsIkJvb2xlYW4iLCJpc0RlbGF5Q29uc3RyYWludCIsIkFic3RyYWN0UG9pbnRlclNlbnNvciIsImV2ZW50cyIsImFjdGl2YXRpb25Db25zdHJhaW50IiwiYnlwYXNzQWN0aXZhdGlvbkNvbnN0cmFpbnQiLCJtb3ZlIiwicGFzc2l2ZSIsIkRyYWdTdGFydCIsIkNvbnRleHRNZW51IiwiZG9jdW1lbnRMaXN0ZW5lcnMiLCJoYW5kbGVLZXlkb3duIiwidGltZW91dElkIiwiZGVsYXkiLCJoYW5kbGVQZW5kaW5nIiwiY2xlYXJUaW1lb3V0Iiwib2Zmc2V0Iiwib25QZW5kaW5nIiwiaW5pdGlhbENvb3JkaW5hdGVzIiwiYWN0aXZhdGVkIiwiQ2xpY2siLCJjYXB0dXJlIiwicmVtb3ZlVGV4dFNlbGVjdGlvbiIsIlNlbGVjdGlvbkNoYW5nZSIsIl9nZXRFdmVudENvb3JkaW5hdGVzMiIsInRvbGVyYW5jZSIsImRpc3RhbmNlIiwiY2FuY2VsYWJsZSIsIm9uQWJvcnQiLCJfdGhpcyRkb2N1bWVudCRnZXRTZWwiLCJnZXRTZWxlY3Rpb24iLCJyZW1vdmVBbGxSYW5nZXMiLCJsaXN0ZW5lclRhcmdldCIsIl9nZXRFdmVudENvb3JkaW5hdGVzIiwiUG9pbnRlclNlbnNvciIsImlzUHJpbWFyeSIsImJ1dHRvbiIsImV2ZW50cyQxIiwiTW91c2VCdXR0b24iLCJNb3VzZVNlbnNvciIsIlJpZ2h0Q2xpY2siLCJldmVudHMkMiIsIlRvdWNoU2Vuc29yIiwic2V0dXAiLCJ0ZWFyZG93biIsIkF1dG9TY3JvbGxBY3RpdmF0b3IiLCJUcmF2ZXJzYWxPcmRlciIsInVzZUF1dG9TY3JvbGxlciIsIlBvaW50ZXIiLCJjYW5TY3JvbGwiLCJkcmFnZ2luZ1JlY3QiLCJlbmFibGVkIiwiaW50ZXJ2YWwiLCJvcmRlciIsIlRyZWVPcmRlciIsInNjcm9sbGFibGVBbmNlc3RvclJlY3RzIiwic2Nyb2xsSW50ZW50IiwidXNlU2Nyb2xsSW50ZW50IiwiZGlzYWJsZWQiLCJzZXRBdXRvU2Nyb2xsSW50ZXJ2YWwiLCJjbGVhckF1dG9TY3JvbGxJbnRlcnZhbCIsInNjcm9sbFNwZWVkIiwic2Nyb2xsRGlyZWN0aW9uIiwiRHJhZ2dhYmxlUmVjdCIsInNjcm9sbENvbnRhaW5lclJlZiIsImF1dG9TY3JvbGwiLCJzb3J0ZWRTY3JvbGxhYmxlQW5jZXN0b3JzIiwicmV2ZXJzZSIsImluZGV4IiwiSlNPTiIsInN0cmluZ2lmeSIsImRlZmF1bHRTY3JvbGxJbnRlbnQiLCJwcmV2aW91c0RlbHRhIiwicHJldmlvdXNJbnRlbnQiLCJzaWduIiwidXNlQ2FjaGVkTm9kZSIsImRyYWdnYWJsZU5vZGVzIiwiZHJhZ2dhYmxlTm9kZSIsImNhY2hlZE5vZGUiLCJ1c2VDb21iaW5lQWN0aXZhdG9ycyIsImdldFN5bnRoZXRpY0hhbmRsZXIiLCJTZW5zb3IiLCJzZW5zb3JBY3RpdmF0b3JzIiwibWFwIiwiTWVhc3VyaW5nU3RyYXRlZ3kiLCJNZWFzdXJpbmdGcmVxdWVuY3kiLCJkZWZhdWx0VmFsdWUiLCJ1c2VEcm9wcGFibGVNZWFzdXJpbmciLCJjb250YWluZXJzIiwiZHJhZ2dpbmciLCJxdWV1ZSIsInNldFF1ZXVlIiwiZnJlcXVlbmN5Iiwic3RyYXRlZ3kiLCJjb250YWluZXJzUmVmIiwiaXNEaXNhYmxlZCIsImRpc2FibGVkUmVmIiwibWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnMiLCJjb25jYXQiLCJwcmV2aW91c1ZhbHVlIiwibWVhc3VyaW5nU2NoZWR1bGVkIiwiQWx3YXlzIiwiQmVmb3JlRHJhZ2dpbmciLCJ1c2VJbml0aWFsVmFsdWUiLCJjb21wdXRlRm4iLCJ1c2VJbml0aWFsUmVjdCIsInVzZU11dGF0aW9uT2JzZXJ2ZXIiLCJoYW5kbGVNdXRhdGlvbnMiLCJtdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJ1c2VSZXNpemVPYnNlcnZlciIsImhhbmRsZVJlc2l6ZSIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJkZWZhdWx0TWVhc3VyZSIsInVzZVJlY3QiLCJmYWxsYmFja1JlY3QiLCJzZXRSZWN0IiwibWVhc3VyZVJlY3QiLCJjdXJyZW50UmVjdCIsImlzQ29ubmVjdGVkIiwibmV3UmVjdCIsInJlY29yZHMiLCJyZWNvcmQiLCJjb250YWlucyIsIm9ic2VydmUiLCJib2R5IiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInVzZVJlY3REZWx0YSIsImluaXRpYWxSZWN0IiwiZGVmYXVsdFZhbHVlJDEiLCJ1c2VTY3JvbGxhYmxlQW5jZXN0b3JzIiwicHJldmlvdXNOb2RlIiwiYW5jZXN0b3JzIiwidXNlU2Nyb2xsT2Zmc2V0cyIsImVsZW1lbnRzIiwic2Nyb2xsQ29vcmRpbmF0ZXMiLCJzZXRTY3JvbGxDb29yZGluYXRlcyIsInByZXZFbGVtZW50cyIsImhhbmRsZVNjcm9sbCIsInByZXZpb3VzRWxlbWVudHMiLCJjbGVhbnVwIiwic2Nyb2xsYWJsZUVsZW1lbnQiLCJmcm9tIiwidmFsdWVzIiwidXNlU2Nyb2xsT2Zmc2V0c0RlbHRhIiwiaW5pdGlhbFNjcm9sbE9mZnNldHMiLCJoYXNTY3JvbGxPZmZzZXRzIiwidXNlU2Vuc29yU2V0dXAiLCJ0ZWFyZG93bkZucyIsInVzZVN5bnRoZXRpY0xpc3RlbmVycyIsInVzZVdpbmRvd1JlY3QiLCJkZWZhdWx0VmFsdWUkMiIsInVzZVJlY3RzIiwiZmlyc3RFbGVtZW50Iiwid2luZG93UmVjdCIsInJlY3RzIiwic2V0UmVjdHMiLCJtZWFzdXJlUmVjdHMiLCJnZXRNZWFzdXJhYmxlTm9kZSIsImZpcnN0Q2hpbGQiLCJ1c2VEcmFnT3ZlcmxheU1lYXN1cmluZyIsImhhbmRsZU5vZGVDaGFuZ2UiLCJub2RlUmVmIiwic2V0UmVmIiwiZGVmYXVsdFNlbnNvcnMiLCJkZWZhdWx0RGF0YSIsImRlZmF1bHRNZWFzdXJpbmdDb25maWd1cmF0aW9uIiwiZHJvcHBhYmxlIiwiV2hpbGVEcmFnZ2luZyIsIk9wdGltaXplZCIsImRyYWdPdmVybGF5IiwiRHJvcHBhYmxlQ29udGFpbmVyc01hcCIsIl9zdXBlciRnZXQiLCJ0b0FycmF5IiwiZ2V0RW5hYmxlZCIsImdldE5vZGVGb3IiLCJfdGhpcyRnZXQkbm9kZSRjdXJyZW4iLCJfdGhpcyRnZXQiLCJkZWZhdWx0UHVibGljQ29udGV4dCIsImFjdGl2YXRvckV2ZW50IiwiYWN0aXZlTm9kZVJlY3QiLCJjb250YWluZXJOb2RlUmVjdCIsIm1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJkZWZhdWx0SW50ZXJuYWxDb250ZXh0IiwiYXJpYURlc2NyaWJlZEJ5SWQiLCJJbnRlcm5hbENvbnRleHQiLCJQdWJsaWNDb250ZXh0IiwiZ2V0SW5pdGlhbFN0YXRlIiwibm9kZXMiLCJ0cmFuc2xhdGUiLCJyZWR1Y2VyIiwic3RhdGUiLCJhY3Rpb24iLCJEcmFnTW92ZSIsIkRyYWdFbmQiLCJEcmFnQ2FuY2VsIiwiUmVnaXN0ZXJEcm9wcGFibGUiLCJTZXREcm9wcGFibGVEaXNhYmxlZCIsIlVucmVnaXN0ZXJEcm9wcGFibGUiLCJSZXN0b3JlRm9jdXMiLCJwcmV2aW91c0FjdGl2YXRvckV2ZW50IiwicHJldmlvdXNBY3RpdmVJZCIsImFjdGl2ZUVsZW1lbnQiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJmb2N1c2FibGVOb2RlIiwiZm9jdXMiLCJhcHBseU1vZGlmaWVycyIsIm1vZGlmaWVycyIsInVzZU1lYXN1cmluZ0NvbmZpZ3VyYXRpb24iLCJ1c2VMYXlvdXRTaGlmdFNjcm9sbENvbXBlbnNhdGlvbiIsImluaXRpYWxpemVkIiwicmVjdERlbHRhIiwiQWN0aXZlRHJhZ2dhYmxlQ29udGV4dCIsIlN0YXR1cyIsIkRuZENvbnRleHQiLCJtZW1vIiwiX3NlbnNvckNvbnRleHQkY3VycmVuIiwiX2RyYWdPdmVybGF5JG5vZGVSZWYkIiwiX2RyYWdPdmVybGF5JHJlY3QiLCJfb3ZlciRyZWN0IiwiYWNjZXNzaWJpbGl0eSIsImNvbGxpc2lvbkRldGVjdGlvbiIsIm1lYXN1cmluZyIsInN0b3JlIiwidXNlUmVkdWNlciIsImRpc3BhdGNoTW9uaXRvckV2ZW50IiwicmVnaXN0ZXJNb25pdG9yTGlzdGVuZXIiLCJzdGF0dXMiLCJzZXRTdGF0dXMiLCJVbmluaXRpYWxpemVkIiwiaXNJbml0aWFsaXplZCIsIkluaXRpYWxpemVkIiwiYWN0aXZlSWQiLCJhY3RpdmVSZWN0cyIsImluaXRpYWwiLCJ0cmFuc2xhdGVkIiwiX25vZGUkZGF0YSIsImFjdGl2ZVJlZiIsImFjdGl2ZVNlbnNvciIsInNldEFjdGl2ZVNlbnNvciIsInNldEFjdGl2YXRvckV2ZW50IiwibGF0ZXN0UHJvcHMiLCJkcmFnZ2FibGVEZXNjcmliZWRCeUlkIiwiZW5hYmxlZERyb3BwYWJsZUNvbnRhaW5lcnMiLCJhY3RpdmF0aW9uQ29vcmRpbmF0ZXMiLCJhdXRvU2Nyb2xsT3B0aW9ucyIsImdldEF1dG9TY3JvbGxlck9wdGlvbnMiLCJpbml0aWFsQWN0aXZlTm9kZVJlY3QiLCJsYXlvdXRTaGlmdENvbXBlbnNhdGlvbiIsInBhcmVudEVsZW1lbnQiLCJzZW5zb3JDb250ZXh0IiwiZHJhZ2dpbmdOb2RlIiwiZHJhZ2dpbmdOb2RlUmVjdCIsInNjcm9sbEFkanVzdGVkVHJhbnNsYXRlIiwib3Zlck5vZGUiLCJ1c2VzRHJhZ092ZXJsYXkiLCJub2RlUmVjdERlbHRhIiwibW9kaWZpZWRUcmFuc2xhdGUiLCJvdmVybGF5Tm9kZVJlY3QiLCJzY3JvbGxBZGp1c3RtZW50IiwiYWN0aXZlTm9kZVNjcm9sbERlbHRhIiwib3ZlcklkIiwic2V0T3ZlciIsImFwcGxpZWRUcmFuc2xhdGUiLCJhY3RpdmVTZW5zb3JSZWYiLCJpbnN0YW50aWF0ZVNlbnNvciIsInNlbnNvckluc3RhbmNlIiwib25EcmFnQWJvcnQiLCJvbkRyYWdQZW5kaW5nIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJJbml0aWFsaXppbmciLCJjcmVhdGVIYW5kbGVyIiwiY2FuY2VsRHJvcCIsInNob3VsZENhbmNlbCIsIlByb21pc2UiLCJyZXNvbHZlIiwiYmluZEFjdGl2YXRvclRvU2Vuc29ySW5zdGFudGlhdG9yIiwiYWN0aXZlRHJhZ2dhYmxlTm9kZSIsImRuZEtpdCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJhY3RpdmF0aW9uQ29udGV4dCIsInNob3VsZEFjdGl2YXRlIiwiY2FwdHVyZWRCeSIsIm92ZXJDb250YWluZXIiLCJwdWJsaWNDb250ZXh0IiwiaW50ZXJuYWxDb250ZXh0IiwiUHJvdmlkZXIiLCJyZXN0b3JlRm9jdXMiLCJhY3RpdmVTZW5zb3JEaXNhYmxlc0F1dG9zY3JvbGwiLCJhdXRvU2Nyb2xsR2xvYmFsbHlEaXNhYmxlZCIsIk51bGxDb250ZXh0IiwiZGVmYXVsdFJvbGUiLCJJRF9QUkVGSVgiLCJ1c2VEcmFnZ2FibGUiLCJhdHRyaWJ1dGVzIiwicm9sZURlc2NyaXB0aW9uIiwidGFiSW5kZXgiLCJpc0RyYWdnaW5nIiwic2V0QWN0aXZhdG9yTm9kZVJlZiIsImRhdGFSZWYiLCJtZW1vaXplZEF0dHJpYnV0ZXMiLCJ1c2VEbmRDb250ZXh0IiwiSURfUFJFRklYJDEiLCJkZWZhdWx0UmVzaXplT2JzZXJ2ZXJDb25maWciLCJ0aW1lb3V0IiwidXNlRHJvcHBhYmxlIiwicmVzaXplT2JzZXJ2ZXJDb25maWciLCJwcmV2aW91cyIsInJlc2l6ZU9ic2VydmVyQ29ubmVjdGVkIiwiY2FsbGJhY2tJZCIsInJlc2l6ZU9ic2VydmVyRGlzYWJsZWQiLCJ1cGRhdGVNZWFzdXJlbWVudHNGb3IiLCJyZXNpemVPYnNlcnZlclRpbWVvdXQiLCJuZXdFbGVtZW50IiwicHJldmlvdXNFbGVtZW50IiwidW5vYnNlcnZlIiwiaXNPdmVyIiwiQW5pbWF0aW9uTWFuYWdlciIsImFuaW1hdGlvbiIsImNsb25lZENoaWxkcmVuIiwic2V0Q2xvbmVkQ2hpbGRyZW4iLCJzZXRFbGVtZW50IiwicHJldmlvdXNDaGlsZHJlbiIsInRoZW4iLCJjbG9uZUVsZW1lbnQiLCJkZWZhdWx0VHJhbnNmb3JtIiwiTnVsbGlmaWVkQ29udGV4dFByb3ZpZGVyIiwiYmFzZVN0eWxlcyIsInRvdWNoQWN0aW9uIiwiZGVmYXVsdFRyYW5zaXRpb24iLCJpc0tleWJvYXJkQWN0aXZhdG9yIiwiUG9zaXRpb25lZE92ZXJsYXkiLCJmb3J3YXJkUmVmIiwiYXMiLCJjbGFzc05hbWUiLCJ0cmFuc2l0aW9uIiwic2NhbGVBZGp1c3RlZFRyYW5zZm9ybSIsInN0eWxlcyIsImRlZmF1bHREcm9wQW5pbWF0aW9uU2lkZUVmZmVjdHMiLCJvcmlnaW5hbFN0eWxlcyIsImdldFByb3BlcnR5VmFsdWUiLCJzZXRQcm9wZXJ0eSIsImNsYXNzTGlzdCIsInJlbW92ZSIsImRlZmF1bHRLZXlmcmFtZVJlc29sdmVyIiwiZmluYWwiLCJkZWZhdWx0RHJvcEFuaW1hdGlvbkNvbmZpZ3VyYXRpb24iLCJrZXlmcmFtZXMiLCJzaWRlRWZmZWN0cyIsIm9wYWNpdHkiLCJ1c2VEcm9wQW5pbWF0aW9uIiwiYWN0aXZlRHJhZ2dhYmxlIiwibWVhc3VyYWJsZU5vZGUiLCJjcmVhdGVEZWZhdWx0RHJvcEFuaW1hdGlvbiIsInJlc3QiLCJzY2FsZSIsImZpbmFsVHJhbnNmb3JtIiwiYW5pbWF0aW9uS2V5ZnJhbWVzIiwiZmlyc3RLZXlmcmFtZSIsImxhc3RLZXlmcmFtZSIsImFuaW1hdGUiLCJmaWxsIiwib25maW5pc2giLCJ1c2VLZXkiLCJEcmFnT3ZlcmxheSIsImRyb3BBbmltYXRpb24iLCJkcm9wQW5pbWF0aW9uQ29uZmlnIiwid3JhcHBlckVsZW1lbnQiLCJ6SW5kZXgiLCJtb2RpZmllZFRyYW5zZm9ybSIsInNuYXBDZW50ZXJUb0N1cnNvciIsImFjdGl2YXRvckNvb3JkaW5hdGVzIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJnZW5lcmF0ZUJvYXJkIiwibm9PZlJvd3MiLCJub09mQ29sdW1ucyIsImJvYXJkT3JpZW50YXRpb24iLCJib2FyZCIsInJvdyIsImNvbHVtbiIsInNxdWFyZUlkIiwiY29sdW1uSW5kZXhUb0NoZXNzQ29sdW1uIiwicm93SW5kZXhUb0NoZXNzUm93IiwiaXNMaWdodFNxdWFyZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImNoZXNzQ29sdW1uVG9Db2x1bW5JbmRleCIsImNoYXJDb2RlQXQiLCJjaGVzc1Jvd1RvUm93SW5kZXgiLCJmZW5TdHJpbmdUb1Bvc2l0aW9uT2JqZWN0IiwiZmVuIiwicG9zaXRpb25PYmplY3QiLCJyb3dzIiwiY2hhciIsImlzTmFOIiwicGllY2VUeXBlIiwiZmVuVG9QaWVjZUNvZGUiLCJwaWVjZSIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJnZXRQb3NpdGlvblVwZGF0ZXMiLCJvbGRQb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwidXBkYXRlcyIsIm5ld1NxdWFyZSIsImNhbmRpZGF0ZVNxdWFyZXMiLCJvbGRTcXVhcmUiLCJjYW5kaWRhdGVTcXVhcmUiLCJjYW5kaWRhdGVQaWVjZVR5cGUiLCJjb2x1bW5EaWZmZXJlbmNlIiwicm93RGlmZmVyZW5jZSIsImlzT2xkU3F1YXJlTGlnaHQiLCJpc05ld1NxdWFyZUxpZ2h0IiwiZ2V0UmVsYXRpdmVDb29yZHMiLCJib2FyZFdpZHRoIiwiY2hlc3Nib2FyZENvbHVtbnMiLCJjaGVzc2JvYXJkUm93cyIsInNxdWFyZSIsInNxdWFyZVdpZHRoIiwiZGVmYXVsdFBpZWNlcyIsIndQIiwieG1sbnMiLCJ2ZXJzaW9uIiwidmlld0JveCIsInN2Z1N0eWxlIiwiZCIsImZpbGxPcGFjaXR5IiwiZmlsbFJ1bGUiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsInN0cm9rZU1pdGVybGltaXQiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VPcGFjaXR5Iiwid1IiLCJ3TiIsIndCIiwid1EiLCJjeCIsImN5IiwiciIsIndLIiwiYlAiLCJiUiIsImJOIiwiYkIiLCJiUSIsImJLIiwiZGVmYXVsdEJvYXJkU3R5bGUiLCJncmlkVGVtcGxhdGVDb2x1bW5zIiwiZGVmYXVsdFNxdWFyZVN0eWxlIiwiYXNwZWN0UmF0aW8iLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJkZWZhdWx0RGFya1NxdWFyZVN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiZGVmYXVsdExpZ2h0U3F1YXJlU3R5bGUiLCJkZWZhdWx0RHJvcFNxdWFyZVN0eWxlIiwiYm94U2hhZG93IiwiZGVmYXVsdERhcmtTcXVhcmVOb3RhdGlvblN0eWxlIiwiY29sb3IiLCJkZWZhdWx0TGlnaHRTcXVhcmVOb3RhdGlvblN0eWxlIiwiZGVmYXVsdEFscGhhTm90YXRpb25TdHlsZSIsImZvbnRTaXplIiwidXNlclNlbGVjdCIsImRlZmF1bHROdW1lcmljTm90YXRpb25TdHlsZSIsImRlZmF1bHREcmFnZ2luZ1BpZWNlU3R5bGUiLCJkZWZhdWx0RHJhZ2dpbmdQaWVjZUdob3N0U3R5bGUiLCJkZWZhdWx0QXJyb3dPcHRpb25zIiwic2Vjb25kYXJ5Q29sb3IiLCJ0ZXJ0aWFyeUNvbG9yIiwiYXJyb3dMZW5ndGhSZWR1Y2VyRGVub21pbmF0b3IiLCJzYW1lVGFyZ2V0QXJyb3dMZW5ndGhSZWR1Y2VyRGVub21pbmF0b3IiLCJhcnJvd1dpZHRoRGVub21pbmF0b3IiLCJhY3RpdmVBcnJvd1dpZHRoTXVsdGlwbGllciIsImFjdGl2ZU9wYWNpdHkiLCJDaGVzc2JvYXJkQ29udGV4dCIsInVzZUNoZXNzYm9hcmRDb250ZXh0IiwidXNlIiwiQ2hlc3Nib2FyZFByb3ZpZGVyIiwicGllY2VzIiwiYm9hcmRTdHlsZSIsInNxdWFyZVN0eWxlIiwic3F1YXJlU3R5bGVzIiwiZGFya1NxdWFyZVN0eWxlIiwibGlnaHRTcXVhcmVTdHlsZSIsImRyb3BTcXVhcmVTdHlsZSIsImRyYWdnaW5nUGllY2VTdHlsZSIsImRyYWdnaW5nUGllY2VHaG9zdFN0eWxlIiwiZGFya1NxdWFyZU5vdGF0aW9uU3R5bGUiLCJsaWdodFNxdWFyZU5vdGF0aW9uU3R5bGUiLCJhbHBoYU5vdGF0aW9uU3R5bGUiLCJudW1lcmljTm90YXRpb25TdHlsZSIsInNob3dOb3RhdGlvbiIsImFuaW1hdGlvbkR1cmF0aW9uSW5NcyIsInNob3dBbmltYXRpb25zIiwiYWxsb3dEcmFnZ2luZyIsImFsbG93RHJhZ09mZkJvYXJkIiwiYWxsb3dBdXRvU2Nyb2xsIiwiZHJhZ0FjdGl2YXRpb25EaXN0YW5jZSIsImFsbG93RHJhd2luZ0Fycm93cyIsImFycm93cyIsImFycm93T3B0aW9ucyIsImNsZWFyQXJyb3dzT25DbGljayIsImNhbkRyYWdQaWVjZSIsIm9uQXJyb3dzQ2hhbmdlIiwib25Nb3VzZU91dFNxdWFyZSIsIm9uTW91c2VPdmVyU3F1YXJlIiwib25QaWVjZUNsaWNrIiwib25QaWVjZURyYWciLCJvblBpZWNlRHJvcCIsIm9uU3F1YXJlQ2xpY2siLCJvblNxdWFyZVJpZ2h0Q2xpY2siLCJzcXVhcmVSZW5kZXJlciIsImRyYWdnaW5nUGllY2UiLCJzZXREcmFnZ2luZ1BpZWNlIiwiY3VycmVudFBvc2l0aW9uIiwic2V0Q3VycmVudFBvc2l0aW9uIiwicG9zaXRpb25EaWZmZXJlbmNlcyIsInNldFBvc2l0aW9uRGlmZmVyZW5jZXMiLCJtYW51YWxseURyb3BwZWRQaWVjZUFuZFNxdWFyZSIsInNldE1hbnVhbGx5RHJvcHBlZFBpZWNlQW5kU3F1YXJlIiwibmV3QXJyb3dTdGFydFNxdWFyZSIsInNldE5ld0Fycm93U3RhcnRTcXVhcmUiLCJuZXdBcnJvd092ZXJTcXVhcmUiLCJzZXROZXdBcnJvd092ZXJTcXVhcmUiLCJpbnRlcm5hbEFycm93cyIsInNldEludGVybmFsQXJyb3dzIiwid2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uIiwic2V0V2FpdGluZ0ZvckFuaW1hdGlvblBvc2l0aW9uIiwiYW5pbWF0aW9uVGltZW91dFJlZiIsImN1cnJlbnRXYWl0aW5nRm9yQW5pbWF0aW9uUG9zaXRpb24iLCJwb3NpdGlvblVwZGF0ZXMiLCJtdWx0aXBsZVBpZWNlc01vdmVkIiwiaW50ZXJtZWRpYXRlUG9zaXRpb24iLCJzb3VyY2VTcXVhcmUiLCJ0YXJnZXRTcXVhcmUiLCJvdGhlclBpZWNlc1VwZGF0ZXMiLCJuZXdUaW1lb3V0IiwiZHJhd0Fycm93IiwibmV3QXJyb3dFbmRTcXVhcmUiLCJhcnJvd0V4aXN0c0luZGV4IiwiZmluZEluZGV4IiwiYXJyb3ciLCJzdGFydFNxdWFyZSIsImVuZFNxdWFyZSIsImFycm93RXhpc3RzRXh0ZXJuYWxseSIsImFycm93Q29sb3IiLCJzaGlmdEtleSIsImN0cmxLZXkiLCJwcmV2QXJyb3dzIiwiXyIsImNsZWFyQXJyb3dzIiwic2V0TmV3QXJyb3dPdmVyU3F1YXJlV2l0aE1vZGlmaWVycyIsImhhbmRsZURyYWdDYW5jZWwiLCJoYW5kbGVEcmFnRW5kIiwiZHJvcFNxdWFyZSIsImlzRHJvcFZhbGlkIiwiaGFuZGxlRHJhZ1N0YXJ0IiwiaXNTcGFyZVBpZWNlIiwicG9pbnRlckNvbGxpc2lvbnMiLCJpc1dyYXBwZWQiLCJBcnJvd3MiLCJib2FyZEhlaWdodCIsImN1cnJlbnRseURyYXdpbmdBcnJvdyIsImFycm93c1RvRHJhdyIsInBvaW50ZXJFdmVudHMiLCJ0byIsIkFSUk9XX0xFTkdUSF9SRURVQ0VSIiwiaXNBcnJvd0FjdGl2ZSIsInJlc3RBcnJvdyIsImh5cG90IiwibWFya2VyV2lkdGgiLCJtYXJrZXJIZWlnaHQiLCJyZWZYIiwicmVmWSIsIm9yaWVudCIsInBvaW50cyIsIngxIiwieTEiLCJ4MiIsInkyIiwibWFya2VyRW5kIiwiRHJhZ2dhYmxlIiwiRHJvcHBhYmxlIiwiUGllY2UiLCJjbG9uZSIsImFuaW1hdGlvblN0eWxlIiwic2V0QW5pbWF0aW9uU3R5bGUiLCJjdXJzb3JTdHlsZSIsIlBpZWNlU3ZnIiwiY3Vyc29yIiwib25DbGljayIsIlNxdWFyZSIsIm9uVG91Y2hFbmQiLCJvbkNvbnRleHRNZW51Iiwib25Nb3VzZURvd24iLCJvbk1vdXNlVXAiLCJvbk1vdXNlT3ZlciIsImJ1dHRvbnMiLCJvbk1vdXNlTGVhdmUiLCJwcmV2ZW50RHJhZ09mZkJvYXJkIiwiYm9hcmRJZCIsImRyYWdnaW5nUGllY2VQb3NpdGlvbiIsImJvYXJkRWxlbWVudCIsImdldEVsZW1lbnRCeUlkIiwiYm9hcmRSZWN0IiwiYTFTcXVhcmUiLCJoYWxmU3F1YXJlV2lkdGgiLCJjb2wiLCJzdGFydFNxdWFyZVJlY3QiLCJzdGFydFgiLCJzdGFydFkiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwiY2xhbXBlZFgiLCJjbGFtcGVkWSIsIkJvYXJkIiwiYm9hcmRSZWYiLCJzZXRCb2FyZFdpZHRoIiwic2V0Qm9hcmRIZWlnaHQiLCJDaGVzc2JvYXJkIiwiU3BhcmVQaWVjZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxRQUFRQyxRQUFRO0FBQ3BCLElBQUlDLFdBQVdELFFBQVE7QUFFdkIsSUFBSUUsYUFBYTtJQUFDQyxTQUFTLENBQUM7QUFBQztBQUU3QixJQUFJQyw2QkFBNkIsQ0FBQztBQUVsQzs7Ozs7Ozs7Q0FRQyxHQUVELElBQUlDO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1Q0FBdUMsT0FBT0Q7SUFDbERDLHdDQUF3QztJQUN4QyxJQUFJRSxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQywrQkFDbENDLHNCQUFzQkYsT0FBT0MsR0FBRyxDQUFDO0lBQ25DLFNBQVNFLFFBQVFDLElBQUksRUFBRUMsTUFBTSxFQUFFQyxRQUFRO1FBQ3JDLElBQUlDLE1BQU07UUFDVixLQUFLLE1BQU1ELFlBQWFDLENBQUFBLE1BQU0sS0FBS0QsUUFBTztRQUMxQyxLQUFLLE1BQU1ELE9BQU9FLEdBQUcsSUFBS0EsQ0FBQUEsTUFBTSxLQUFLRixPQUFPRSxHQUFHLEFBQUQ7UUFDOUMsSUFBSSxTQUFTRixRQUFRO1lBQ25CQyxXQUFXLENBQUM7WUFDWixJQUFLLElBQUlFLFlBQVlILE9BQ25CLFVBQVVHLFlBQWFGLENBQUFBLFFBQVEsQ0FBQ0UsU0FBUyxHQUFHSCxNQUFNLENBQUNHLFNBQVMsQUFBRDtRQUMvRCxPQUFPRixXQUFXRDtRQUNsQkEsU0FBU0MsU0FBU0csR0FBRztRQUNyQixPQUFPO1lBQ0xDLFVBQVVYO1lBQ1ZLLE1BQU1BO1lBQ05HLEtBQUtBO1lBQ0xFLEtBQUssS0FBSyxNQUFNSixTQUFTQSxTQUFTO1lBQ2xDTSxPQUFPTDtRQUNUO0lBQ0Y7SUFDQVYsMkJBQTJCZ0IsUUFBUSxHQUFHVjtJQUN0Q04sMkJBQTJCaUIsR0FBRyxHQUFHVjtJQUNqQ1AsMkJBQTJCa0IsSUFBSSxHQUFHWDtJQUNsQyxPQUFPUDtBQUNSO0FBRUEsSUFBSW1CLDhCQUE4QixDQUFDO0FBRW5DOzs7Ozs7OztDQVFDLEdBRUQsSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELHdDQUF3QyxPQUFPRDtJQUNuREMseUNBQXlDO0lBQ3pDLGlCQUFpQkUsUUFBUUMsR0FBRyxDQUFDQyxRQUFRLElBQ25DLEFBQUM7UUFDQyxTQUFTQyx5QkFBeUJqQixJQUFJO1lBQ3BDLElBQUksUUFBUUEsTUFBTSxPQUFPO1lBQ3pCLElBQUksZUFBZSxPQUFPQSxNQUN4QixPQUFPQSxLQUFLTSxRQUFRLEtBQUtZLDJCQUNyQixPQUNBbEIsS0FBS21CLFdBQVcsSUFBSW5CLEtBQUtvQixJQUFJLElBQUk7WUFDdkMsSUFBSSxhQUFhLE9BQU9wQixNQUFNLE9BQU9BO1lBQ3JDLE9BQVFBO2dCQUNOLEtBQUtGO29CQUNILE9BQU87Z0JBQ1QsS0FBS3VCO29CQUNILE9BQU87Z0JBQ1QsS0FBS0M7b0JBQ0gsT0FBTztnQkFDVCxLQUFLQztvQkFDSCxPQUFPO2dCQUNULEtBQUtDO29CQUNILE9BQU87Z0JBQ1QsS0FBS0M7b0JBQ0gsT0FBTztZQUNYO1lBQ0EsSUFBSSxhQUFhLE9BQU96QixNQUN0QixPQUNHLGFBQWEsT0FBT0EsS0FBSzBCLEdBQUcsSUFDM0JDLFFBQVFDLEtBQUssQ0FDWCxzSEFFSjVCLEtBQUtNLFFBQVE7Z0JBRWIsS0FBS3VCO29CQUNILE9BQU8sQUFBQzdCLENBQUFBLEtBQUttQixXQUFXLElBQUksU0FBUSxJQUFLO2dCQUMzQyxLQUFLVztvQkFDSCxPQUFPLEFBQUM5QixDQUFBQSxLQUFLK0IsUUFBUSxDQUFDWixXQUFXLElBQUksU0FBUSxJQUFLO2dCQUNwRCxLQUFLYTtvQkFDSCxJQUFJQyxZQUFZakMsS0FBS2tDLE1BQU07b0JBQzNCbEMsT0FBT0EsS0FBS21CLFdBQVc7b0JBQ3ZCbkIsUUFDRyxDQUFBLEFBQUNBLE9BQU9pQyxVQUFVZCxXQUFXLElBQUljLFVBQVViLElBQUksSUFBSSxJQUNuRHBCLE9BQU8sT0FBT0EsT0FBTyxnQkFBZ0JBLE9BQU8sTUFBTSxZQUFZO29CQUNqRSxPQUFPQTtnQkFDVCxLQUFLbUM7b0JBQ0gsT0FDRSxBQUFDRixZQUFZakMsS0FBS21CLFdBQVcsSUFBSSxNQUNqQyxTQUFTYyxZQUNMQSxZQUNBaEIseUJBQXlCakIsS0FBS0EsSUFBSSxLQUFLO2dCQUUvQyxLQUFLb0M7b0JBQ0hILFlBQVlqQyxLQUFLcUMsUUFBUTtvQkFDekJyQyxPQUFPQSxLQUFLc0MsS0FBSztvQkFDakIsSUFBSTt3QkFDRixPQUFPckIseUJBQXlCakIsS0FBS2lDO29CQUN2QyxFQUFFLE9BQU9NLEdBQUcsQ0FBQztZQUNqQjtZQUNGLE9BQU87UUFDVDtRQUNBLFNBQVNDLG1CQUFtQkMsS0FBSztZQUMvQixPQUFPLEtBQUtBO1FBQ2Q7UUFDQSxTQUFTQyx1QkFBdUJELEtBQUs7WUFDbkMsSUFBSTtnQkFDRkQsbUJBQW1CQztnQkFDbkIsSUFBSUUsMkJBQTJCLENBQUM7WUFDbEMsRUFBRSxPQUFPQyxHQUFHO2dCQUNWRCwyQkFBMkI7WUFDN0I7WUFDQSxJQUFJQSwwQkFBMEI7Z0JBQzVCQSwyQkFBMkJoQjtnQkFDM0IsSUFBSWtCLHdCQUF3QkYseUJBQXlCZixLQUFLO2dCQUMxRCxJQUFJa0Isb0NBQ0YsQUFBQyxlQUFlLE9BQU9sRCxVQUNyQkEsT0FBT21ELFdBQVcsSUFDbEJOLEtBQUssQ0FBQzdDLE9BQU9tRCxXQUFXLENBQUMsSUFDM0JOLE1BQU0sV0FBVyxDQUFDckIsSUFBSSxJQUN0QjtnQkFDRnlCLHNCQUFzQkcsSUFBSSxDQUN4QkwsMEJBQ0EsNEdBQ0FHO2dCQUVGLE9BQU9OLG1CQUFtQkM7WUFDNUI7UUFDRjtRQUNBLFNBQVNRLGVBQWU7UUFDeEIsU0FBU0M7WUFDUCxJQUFJLE1BQU1DLGVBQWU7Z0JBQ3ZCQyxVQUFVekIsUUFBUTBCLEdBQUc7Z0JBQ3JCQyxXQUFXM0IsUUFBUTRCLElBQUk7Z0JBQ3ZCQyxXQUFXN0IsUUFBUThCLElBQUk7Z0JBQ3ZCQyxZQUFZL0IsUUFBUUMsS0FBSztnQkFDekIrQixZQUFZaEMsUUFBUWlDLEtBQUs7Z0JBQ3pCQyxxQkFBcUJsQyxRQUFRbUMsY0FBYztnQkFDM0NDLGVBQWVwQyxRQUFRcUMsUUFBUTtnQkFDL0IsSUFBSXpELFFBQVE7b0JBQ1YwRCxjQUFjO29CQUNkQyxZQUFZO29CQUNaekIsT0FBT1E7b0JBQ1BrQixVQUFVO2dCQUNaO2dCQUNBQyxPQUFPQyxnQkFBZ0IsQ0FBQzFDLFNBQVM7b0JBQy9CNEIsTUFBTWhEO29CQUNOOEMsS0FBSzlDO29CQUNMa0QsTUFBTWxEO29CQUNOcUIsT0FBT3JCO29CQUNQcUQsT0FBT3JEO29CQUNQdUQsZ0JBQWdCdkQ7b0JBQ2hCeUQsVUFBVXpEO2dCQUNaO1lBQ0Y7WUFDQTRDO1FBQ0Y7UUFDQSxTQUFTbUI7WUFDUG5CO1lBQ0EsSUFBSSxNQUFNQSxlQUFlO2dCQUN2QixJQUFJNUMsUUFBUTtvQkFBRTBELGNBQWM7b0JBQU1DLFlBQVk7b0JBQU1DLFVBQVU7Z0JBQUs7Z0JBQ25FQyxPQUFPQyxnQkFBZ0IsQ0FBQzFDLFNBQVM7b0JBQy9CMEIsS0FBS2tCLE9BQU8sQ0FBQyxHQUFHaEUsT0FBTzt3QkFBRWtDLE9BQU9XO29CQUFRO29CQUN4Q0csTUFBTWdCLE9BQU8sQ0FBQyxHQUFHaEUsT0FBTzt3QkFBRWtDLE9BQU9hO29CQUFTO29CQUMxQ0csTUFBTWMsT0FBTyxDQUFDLEdBQUdoRSxPQUFPO3dCQUFFa0MsT0FBT2U7b0JBQVM7b0JBQzFDNUIsT0FBTzJDLE9BQU8sQ0FBQyxHQUFHaEUsT0FBTzt3QkFBRWtDLE9BQU9pQjtvQkFBVTtvQkFDNUNFLE9BQU9XLE9BQU8sQ0FBQyxHQUFHaEUsT0FBTzt3QkFBRWtDLE9BQU9rQjtvQkFBVTtvQkFDNUNHLGdCQUFnQlMsT0FBTyxDQUFDLEdBQUdoRSxPQUFPO3dCQUFFa0MsT0FBT29CO29CQUFtQjtvQkFDOURHLFVBQVVPLE9BQU8sQ0FBQyxHQUFHaEUsT0FBTzt3QkFBRWtDLE9BQU9zQjtvQkFBYTtnQkFDcEQ7WUFDRjtZQUNBLElBQUlaLGlCQUNGeEIsUUFBUUMsS0FBSyxDQUNYO1FBRU47UUFDQSxTQUFTNEMsOEJBQThCcEQsSUFBSTtZQUN6QyxJQUFJLEtBQUssTUFBTXFELFFBQ2IsSUFBSTtnQkFDRixNQUFNQztZQUNSLEVBQUUsT0FBT25DLEdBQUc7Z0JBQ1YsSUFBSW9DLFFBQVFwQyxFQUFFcUMsS0FBSyxDQUFDQyxJQUFJLEdBQUdGLEtBQUssQ0FBQztnQkFDakNGLFNBQVMsQUFBQ0UsU0FBU0EsS0FBSyxDQUFDLEVBQUUsSUFBSztnQkFDaENHLFNBQ0UsQ0FBQyxJQUFJdkMsRUFBRXFDLEtBQUssQ0FBQ0csT0FBTyxDQUFDLGNBQ2pCLG1CQUNBLENBQUMsSUFBSXhDLEVBQUVxQyxLQUFLLENBQUNHLE9BQU8sQ0FBQyxPQUNuQixpQkFDQTtZQUNWO1lBQ0YsT0FBTyxPQUFPTixTQUFTckQsT0FBTzBEO1FBQ2hDO1FBQ0EsU0FBU0UsNkJBQTZCQyxFQUFFLEVBQUVDLFNBQVM7WUFDakQsSUFBSSxDQUFDRCxNQUFNRSxTQUFTLE9BQU87WUFDM0IsSUFBSUMsUUFBUUMsb0JBQW9CQyxHQUFHLENBQUNMO1lBQ3BDLElBQUksS0FBSyxNQUFNRyxPQUFPLE9BQU9BO1lBQzdCRCxVQUFVO1lBQ1ZDLFFBQVFWLE1BQU1hLGlCQUFpQjtZQUMvQmIsTUFBTWEsaUJBQWlCLEdBQUcsS0FBSztZQUMvQixJQUFJQyxxQkFBcUI7WUFDekJBLHFCQUFxQkMscUJBQXFCQyxDQUFDO1lBQzNDRCxxQkFBcUJDLENBQUMsR0FBRztZQUN6QnhDO1lBQ0EsSUFBSTtnQkFDRixJQUFJeUMsaUJBQWlCO29CQUNuQkMsNkJBQTZCO3dCQUMzQixJQUFJOzRCQUNGLElBQUlWLFdBQVc7Z0NBQ2IsSUFBSVcsT0FBTztvQ0FDVCxNQUFNbkI7Z0NBQ1I7Z0NBQ0FOLE9BQU8wQixjQUFjLENBQUNELEtBQUtFLFNBQVMsRUFBRSxTQUFTO29DQUM3Q0MsS0FBSzt3Q0FDSCxNQUFNdEI7b0NBQ1I7Z0NBQ0Y7Z0NBQ0EsSUFBSSxhQUFhLE9BQU91QixXQUFXQSxRQUFRZixTQUFTLEVBQUU7b0NBQ3BELElBQUk7d0NBQ0ZlLFFBQVFmLFNBQVMsQ0FBQ1csTUFBTSxFQUFFO29DQUM1QixFQUFFLE9BQU90RCxHQUFHO3dDQUNWLElBQUkyRCxVQUFVM0Q7b0NBQ2hCO29DQUNBMEQsUUFBUWYsU0FBUyxDQUFDRCxJQUFJLEVBQUUsRUFBRVk7Z0NBQzVCLE9BQU87b0NBQ0wsSUFBSTt3Q0FDRkEsS0FBSzdDLElBQUk7b0NBQ1gsRUFBRSxPQUFPbUQsS0FBSzt3Q0FDWkQsVUFBVUM7b0NBQ1o7b0NBQ0FsQixHQUFHakMsSUFBSSxDQUFDNkMsS0FBS0UsU0FBUztnQ0FDeEI7NEJBQ0YsT0FBTztnQ0FDTCxJQUFJO29DQUNGLE1BQU1yQjtnQ0FDUixFQUFFLE9BQU8wQixLQUFLO29DQUNaRixVQUFVRTtnQ0FDWjtnQ0FDQ1AsQ0FBQUEsT0FBT1osSUFBRyxLQUNULGVBQWUsT0FBT1ksS0FBS1EsS0FBSyxJQUNoQ1IsS0FBS1EsS0FBSyxDQUFDLFlBQWE7NEJBQzVCO3dCQUNGLEVBQUUsT0FBT0MsUUFBUTs0QkFDZixJQUFJQSxVQUFVSixXQUFXLGFBQWEsT0FBT0ksT0FBTzFCLEtBQUssRUFDdkQsT0FBTztnQ0FBQzBCLE9BQU8xQixLQUFLO2dDQUFFc0IsUUFBUXRCLEtBQUs7NkJBQUM7d0JBQ3hDO3dCQUNBLE9BQU87NEJBQUM7NEJBQU07eUJBQUs7b0JBQ3JCO2dCQUNGO2dCQUNBZSxlQUFlQywyQkFBMkIsQ0FBQ3pFLFdBQVcsR0FDcEQ7Z0JBQ0YsSUFBSW9GLHFCQUFxQm5DLE9BQU9vQyx3QkFBd0IsQ0FDdERiLGVBQWVDLDJCQUEyQixFQUMxQztnQkFFRlcsc0JBQ0VBLG1CQUFtQnRDLFlBQVksSUFDL0JHLE9BQU8wQixjQUFjLENBQ25CSCxlQUFlQywyQkFBMkIsRUFDMUMsUUFDQTtvQkFBRW5ELE9BQU87Z0JBQThCO2dCQUUzQyxJQUFJZ0Usd0JBQ0FkLGVBQWVDLDJCQUEyQixJQUM1Q2MsY0FBY0QscUJBQXFCLENBQUMsRUFBRSxFQUN0Q0UsZUFBZUYscUJBQXFCLENBQUMsRUFBRTtnQkFDekMsSUFBSUMsZUFBZUMsY0FBYztvQkFDL0IsSUFBSUMsY0FBY0YsWUFBWUcsS0FBSyxDQUFDLE9BQ2xDQyxlQUFlSCxhQUFhRSxLQUFLLENBQUM7b0JBQ3BDLElBQ0VKLHdCQUF3QkYscUJBQXFCLEdBQzdDQSxxQkFBcUJLLFlBQVlHLE1BQU0sSUFDdkMsQ0FBQ0gsV0FBVyxDQUFDTCxtQkFBbUIsQ0FBQ1MsUUFBUSxDQUN2QyxnQ0FJRlQ7b0JBQ0YsTUFFRUUsd0JBQXdCSyxhQUFhQyxNQUFNLElBQzNDLENBQUNELFlBQVksQ0FBQ0wsc0JBQXNCLENBQUNPLFFBQVEsQ0FDM0MsZ0NBSUZQO29CQUNGLElBQ0VGLHVCQUF1QkssWUFBWUcsTUFBTSxJQUN6Q04sMEJBQTBCSyxhQUFhQyxNQUFNLEVBRTdDLElBQ0VSLHFCQUFxQkssWUFBWUcsTUFBTSxHQUFHLEdBQ3hDTix3QkFBd0JLLGFBQWFDLE1BQU0sR0FBRyxHQUNoRCxLQUFLUixzQkFDTCxLQUFLRSx5QkFDTEcsV0FBVyxDQUFDTCxtQkFBbUIsS0FDN0JPLFlBQVksQ0FBQ0wsc0JBQXNCLEVBR3JDQTtvQkFDSixNQUVFLEtBQUtGLHNCQUFzQixLQUFLRSx1QkFDaENGLHNCQUFzQkUsd0JBRXRCLElBQ0VHLFdBQVcsQ0FBQ0wsbUJBQW1CLEtBQy9CTyxZQUFZLENBQUNMLHNCQUFzQixFQUNuQzt3QkFDQSxJQUFJLE1BQU1GLHNCQUFzQixNQUFNRSx1QkFBdUI7NEJBQzNELEdBQ0UsSUFDR0Ysc0JBQ0RFLHlCQUNBLElBQUlBLHlCQUNGRyxXQUFXLENBQUNMLG1CQUFtQixLQUM3Qk8sWUFBWSxDQUFDTCxzQkFBc0IsRUFDdkM7Z0NBQ0EsSUFBSVEsU0FDRixPQUNBTCxXQUFXLENBQUNMLG1CQUFtQixDQUFDVyxPQUFPLENBQ3JDLFlBQ0E7Z0NBRUpqQyxHQUFHOUQsV0FBVyxJQUNaOEYsT0FBT0QsUUFBUSxDQUFDLGtCQUNmQyxDQUFBQSxTQUFTQSxPQUFPQyxPQUFPLENBQUMsZUFBZWpDLEdBQUc5RCxXQUFXLENBQUE7Z0NBQ3hELGVBQWUsT0FBTzhELE1BQ3BCSSxvQkFBb0JXLEdBQUcsQ0FBQ2YsSUFBSWdDO2dDQUM5QixPQUFPQTs0QkFDVDttQ0FDSyxLQUFLVixzQkFBc0IsS0FBS0Usc0JBQXVCO3dCQUNoRTt3QkFDQTtvQkFDRjtnQkFDSjtZQUNGLFNBQVU7Z0JBQ1B0QixVQUFVLE9BQ1JNLHFCQUFxQkMsQ0FBQyxHQUFHRixvQkFDMUJsQixnQkFDQ0ksTUFBTWEsaUJBQWlCLEdBQUdIO1lBQy9CO1lBQ0F3QixjQUFjLEFBQUNBLENBQUFBLGNBQWMzQixLQUFLQSxHQUFHOUQsV0FBVyxJQUFJOEQsR0FBRzdELElBQUksR0FBRyxFQUFDLElBQzNEb0QsOEJBQThCb0MsZUFDOUI7WUFDSixlQUFlLE9BQU8zQixNQUFNSSxvQkFBb0JXLEdBQUcsQ0FBQ2YsSUFBSTJCO1lBQ3hELE9BQU9BO1FBQ1Q7UUFDQSxTQUFTTyxxQ0FBcUNuSCxJQUFJO1lBQ2hELElBQUksUUFBUUEsTUFBTSxPQUFPO1lBQ3pCLElBQUksZUFBZSxPQUFPQSxNQUFNO2dCQUM5QixJQUFJK0YsWUFBWS9GLEtBQUsrRixTQUFTO2dCQUM5QixPQUFPZiw2QkFDTGhGLE1BQ0EsQ0FBRSxDQUFBLENBQUMrRixhQUFhLENBQUNBLFVBQVVxQixnQkFBZ0IsQUFBRDtZQUU5QztZQUNBLElBQUksYUFBYSxPQUFPcEgsTUFBTSxPQUFPd0UsOEJBQThCeEU7WUFDbkUsT0FBUUE7Z0JBQ04sS0FBS3dCO29CQUNILE9BQU9nRCw4QkFBOEI7Z0JBQ3ZDLEtBQUsvQztvQkFDSCxPQUFPK0MsOEJBQThCO1lBQ3pDO1lBQ0EsSUFBSSxhQUFhLE9BQU94RSxNQUN0QixPQUFRQSxLQUFLTSxRQUFRO2dCQUNuQixLQUFLMEI7b0JBQ0gsT0FBTyxBQUFDaEMsT0FBT2dGLDZCQUE2QmhGLEtBQUtrQyxNQUFNLEVBQUUsUUFBU2xDO2dCQUNwRSxLQUFLbUM7b0JBQ0gsT0FBT2dGLHFDQUFxQ25ILEtBQUtBLElBQUk7Z0JBQ3ZELEtBQUtvQztvQkFDSDJELFlBQVkvRixLQUFLcUMsUUFBUTtvQkFDekJyQyxPQUFPQSxLQUFLc0MsS0FBSztvQkFDakIsSUFBSTt3QkFDRixPQUFPNkUscUNBQXFDbkgsS0FBSytGO29CQUNuRCxFQUFFLE9BQU94RCxHQUFHLENBQUM7WUFDakI7WUFDRixPQUFPO1FBQ1Q7UUFDQSxTQUFTOEU7WUFDUCxJQUFJQyxhQUFhN0IscUJBQXFCOEIsQ0FBQztZQUN2QyxPQUFPLFNBQVNELGFBQWEsT0FBT0EsV0FBV0QsUUFBUTtRQUN6RDtRQUNBLFNBQVNHLFlBQVl2SCxNQUFNO1lBQ3pCLElBQUl3SCxlQUFlekUsSUFBSSxDQUFDL0MsUUFBUSxRQUFRO2dCQUN0QyxJQUFJeUgsU0FBU3RELE9BQU9vQyx3QkFBd0IsQ0FBQ3ZHLFFBQVEsT0FBT3FGLEdBQUc7Z0JBQy9ELElBQUlvQyxVQUFVQSxPQUFPQyxjQUFjLEVBQUUsT0FBTztZQUM5QztZQUNBLE9BQU8sS0FBSyxNQUFNMUgsT0FBT0UsR0FBRztRQUM5QjtRQUNBLFNBQVN5SCwyQkFBMkJySCxLQUFLLEVBQUVZLFdBQVc7WUFDcEQsU0FBUzBHO2dCQUNQQyw4QkFDRyxDQUFBLEFBQUNBLDZCQUE2QixNQUMvQm5HLFFBQVFDLEtBQUssQ0FDWCwyT0FDQVQsWUFDRjtZQUNKO1lBQ0EwRyxzQkFBc0JGLGNBQWMsR0FBRztZQUN2Q3ZELE9BQU8wQixjQUFjLENBQUN2RixPQUFPLE9BQU87Z0JBQ2xDK0UsS0FBS3VDO2dCQUNMNUQsY0FBYztZQUNoQjtRQUNGO1FBQ0EsU0FBUzhEO1lBQ1AsSUFBSUMsZ0JBQWdCL0cseUJBQXlCLElBQUksQ0FBQ2pCLElBQUk7WUFDdERpSSxzQkFBc0IsQ0FBQ0QsY0FBYyxJQUNsQyxDQUFBLEFBQUNDLHNCQUFzQixDQUFDRCxjQUFjLEdBQUcsTUFDMUNyRyxRQUFRQyxLQUFLLENBQ1gsOElBQ0Y7WUFDRm9HLGdCQUFnQixJQUFJLENBQUN6SCxLQUFLLENBQUNGLEdBQUc7WUFDOUIsT0FBTyxLQUFLLE1BQU0ySCxnQkFBZ0JBLGdCQUFnQjtRQUNwRDtRQUNBLFNBQVNFLGFBQWFsSSxJQUFJLEVBQUVHLEdBQUcsRUFBRWdJLElBQUksRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUU5SCxLQUFLO1lBQ3pENEgsT0FBTzVILE1BQU1GLEdBQUc7WUFDaEJMLE9BQU87Z0JBQ0xNLFVBQVVYO2dCQUNWSyxNQUFNQTtnQkFDTkcsS0FBS0E7Z0JBQ0xJLE9BQU9BO2dCQUNQK0gsUUFBUUQ7WUFDVjtZQUNBLFNBQVUsQ0FBQSxLQUFLLE1BQU1GLE9BQU9BLE9BQU8sSUFBRyxJQUNsQy9ELE9BQU8wQixjQUFjLENBQUM5RixNQUFNLE9BQU87Z0JBQ2pDa0UsWUFBWTtnQkFDWm9CLEtBQUt5QztZQUNQLEtBQ0EzRCxPQUFPMEIsY0FBYyxDQUFDOUYsTUFBTSxPQUFPO2dCQUFFa0UsWUFBWTtnQkFBT3pCLE9BQU87WUFBSztZQUN4RXpDLEtBQUt1SSxNQUFNLEdBQUcsQ0FBQztZQUNmbkUsT0FBTzBCLGNBQWMsQ0FBQzlGLEtBQUt1SSxNQUFNLEVBQUUsYUFBYTtnQkFDOUN0RSxjQUFjO2dCQUNkQyxZQUFZO2dCQUNaQyxVQUFVO2dCQUNWMUIsT0FBTztZQUNUO1lBQ0EyQixPQUFPMEIsY0FBYyxDQUFDOUYsTUFBTSxjQUFjO2dCQUN4Q2lFLGNBQWM7Z0JBQ2RDLFlBQVk7Z0JBQ1pDLFVBQVU7Z0JBQ1YxQixPQUFPO1lBQ1Q7WUFDQTJCLE9BQU9vRSxNQUFNLElBQUtwRSxDQUFBQSxPQUFPb0UsTUFBTSxDQUFDeEksS0FBS08sS0FBSyxHQUFHNkQsT0FBT29FLE1BQU0sQ0FBQ3hJLEtBQUk7WUFDL0QsT0FBT0E7UUFDVDtRQUNBLFNBQVN5SSxXQUNQekksSUFBSSxFQUNKQyxNQUFNLEVBQ05DLFFBQVEsRUFDUndJLGdCQUFnQixFQUNoQk4sTUFBTSxFQUNORCxJQUFJO1lBRUosSUFDRSxhQUFhLE9BQU9uSSxRQUNwQixlQUFlLE9BQU9BLFFBQ3RCQSxTQUFTRix1QkFDVEUsU0FBU3NCLHVCQUNUdEIsU0FBU3VCLDBCQUNUdkIsU0FBU3dCLHVCQUNUeEIsU0FBU3lCLDRCQUNUekIsU0FBUzJJLHdCQUNSLGFBQWEsT0FBTzNJLFFBQ25CLFNBQVNBLFFBQ1JBLENBQUFBLEtBQUtNLFFBQVEsS0FBSzhCLG1CQUNqQnBDLEtBQUtNLFFBQVEsS0FBSzZCLG1CQUNsQm5DLEtBQUtNLFFBQVEsS0FBS3VCLHNCQUNsQjdCLEtBQUtNLFFBQVEsS0FBS3dCLHVCQUNsQjlCLEtBQUtNLFFBQVEsS0FBSzBCLDBCQUNsQmhDLEtBQUtNLFFBQVEsS0FBS3NJLDRCQUNsQixLQUFLLE1BQU01SSxLQUFLNkksV0FBVyxBQUFELEdBQzlCO2dCQUNBLElBQUlDLFdBQVc3SSxPQUFPNkksUUFBUTtnQkFDOUIsSUFBSSxLQUFLLE1BQU1BLFVBQ2IsSUFBSUosa0JBQ0YsSUFBSUssWUFBWUQsV0FBVztvQkFDekIsSUFDRUosbUJBQW1CLEdBQ25CQSxtQkFBbUJJLFNBQVMvQixNQUFNLEVBQ2xDMkIsbUJBRUFNLGtCQUFrQkYsUUFBUSxDQUFDSixpQkFBaUIsRUFBRTFJO29CQUNoRG9FLE9BQU9vRSxNQUFNLElBQUlwRSxPQUFPb0UsTUFBTSxDQUFDTTtnQkFDakMsT0FDRW5ILFFBQVFDLEtBQUssQ0FDWDtxQkFFRG9ILGtCQUFrQkYsVUFBVTlJO1lBQ3JDLE9BQU87Z0JBQ0w4SSxXQUFXO2dCQUNYLElBQ0UsS0FBSyxNQUFNOUksUUFDVixhQUFhLE9BQU9BLFFBQ25CLFNBQVNBLFFBQ1QsTUFBTW9FLE9BQU82RSxJQUFJLENBQUNqSixNQUFNK0csTUFBTSxFQUVoQytCLFlBQ0U7Z0JBQ0osU0FBUzlJLE9BQ0owSSxtQkFBbUIsU0FDcEJLLFlBQVkvSSxRQUNUMEksbUJBQW1CLFVBQ3BCLEtBQUssTUFBTTFJLFFBQVFBLEtBQUtNLFFBQVEsS0FBS1gscUJBQ2xDLENBQUEsQUFBQytJLG1CQUNBLE1BQ0N6SCxDQUFBQSx5QkFBeUJqQixLQUFLQSxJQUFJLEtBQUssU0FBUSxJQUNoRCxPQUNEOEksV0FDQyxvRUFBb0UsSUFDckVKLG1CQUFtQixPQUFPMUk7Z0JBQ25DMkIsUUFBUUMsS0FBSyxDQUNYLDJJQUNBOEcsa0JBQ0FJO1lBRUo7WUFDQSxJQUFJckIsZUFBZXpFLElBQUksQ0FBQy9DLFFBQVEsUUFBUTtnQkFDdEM2SSxXQUFXN0gseUJBQXlCakI7Z0JBQ3BDLElBQUlpSixPQUFPN0UsT0FBTzZFLElBQUksQ0FBQ2hKLFFBQVFpSixNQUFNLENBQUMsU0FBVUMsQ0FBQztvQkFDL0MsT0FBTyxVQUFVQTtnQkFDbkI7Z0JBQ0FULG1CQUNFLElBQUlPLEtBQUtsQyxNQUFNLEdBQ1gsb0JBQW9Ca0MsS0FBS0csSUFBSSxDQUFDLGFBQWEsV0FDM0M7Z0JBQ05DLHFCQUFxQixDQUFDUCxXQUFXSixpQkFBaUIsSUFDL0MsQ0FBQSxBQUFDTyxPQUNBLElBQUlBLEtBQUtsQyxNQUFNLEdBQUcsTUFBTWtDLEtBQUtHLElBQUksQ0FBQyxhQUFhLFdBQVcsTUFDNUR6SCxRQUFRQyxLQUFLLENBQ1gsbU9BQ0E4RyxrQkFDQUksVUFDQUcsTUFDQUgsV0FFRE8scUJBQXFCLENBQUNQLFdBQVdKLGlCQUFpQixHQUFHLElBQUk7WUFDOUQ7WUFDQUksV0FBVztZQUNYLEtBQUssTUFBTTVJLFlBQ1J3QyxDQUFBQSx1QkFBdUJ4QyxXQUFZNEksV0FBVyxLQUFLNUksUUFBUTtZQUM5RHNILFlBQVl2SCxXQUNUeUMsQ0FBQUEsdUJBQXVCekMsT0FBT0UsR0FBRyxHQUFJMkksV0FBVyxLQUFLN0ksT0FBT0UsR0FBRztZQUNsRSxJQUFJLFNBQVNGLFFBQVE7Z0JBQ25CQyxXQUFXLENBQUM7Z0JBQ1osSUFBSyxJQUFJRSxZQUFZSCxPQUNuQixVQUFVRyxZQUFhRixDQUFBQSxRQUFRLENBQUNFLFNBQVMsR0FBR0gsTUFBTSxDQUFDRyxTQUFTLEFBQUQ7WUFDL0QsT0FBT0YsV0FBV0Q7WUFDbEI2SSxZQUNFbEIsMkJBQ0UxSCxVQUNBLGVBQWUsT0FBT0YsT0FDbEJBLEtBQUttQixXQUFXLElBQUluQixLQUFLb0IsSUFBSSxJQUFJLFlBQ2pDcEI7WUFFUixPQUFPa0ksYUFBYWxJLE1BQU04SSxVQUFVWCxNQUFNQyxRQUFRZixZQUFZbkg7UUFDaEU7UUFDQSxTQUFTOEksa0JBQWtCTSxJQUFJLEVBQUVDLFVBQVU7WUFDekMsSUFDRSxhQUFhLE9BQU9ELFFBQ3BCQSxRQUNBQSxLQUFLaEosUUFBUSxLQUFLa0osd0JBRWxCO2dCQUFBLElBQUlULFlBQVlPLE9BQ2QsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlILEtBQUt2QyxNQUFNLEVBQUUwQyxJQUFLO29CQUNwQyxJQUFJQyxRQUFRSixJQUFJLENBQUNHLEVBQUU7b0JBQ25CRSxlQUFlRCxVQUFVRSxvQkFBb0JGLE9BQU9IO2dCQUN0RDtxQkFDRyxJQUFJSSxlQUFlTCxPQUN0QkEsS0FBS2YsTUFBTSxJQUFLZSxDQUFBQSxLQUFLZixNQUFNLENBQUNzQixTQUFTLEdBQUcsQ0FBQTtxQkFDckMsSUFDRixTQUFTUCxRQUFRLGFBQWEsT0FBT0EsT0FDakNHLElBQUksT0FDSixDQUFBLEFBQUNBLElBQ0EsQUFBQ0sseUJBQXlCUixJQUFJLENBQUNRLHNCQUFzQixJQUNyRFIsSUFBSSxDQUFDLGFBQWEsRUFDbkJHLElBQUksZUFBZSxPQUFPQSxJQUFJQSxJQUFJLElBQUksR0FDM0MsZUFBZSxPQUFPQSxLQUNwQkEsTUFBTUgsS0FBS1MsT0FBTyxJQUNqQixDQUFBLEFBQUNOLElBQUlBLEVBQUV6RyxJQUFJLENBQUNzRyxPQUFRRyxNQUFNSCxJQUFHLEdBRWhDLE1BQU8sQ0FBQyxBQUFDQSxDQUFBQSxPQUFPRyxFQUFFTyxJQUFJLEVBQUMsRUFBR0MsSUFBSSxFQUM1Qk4sZUFBZUwsS0FBSzdHLEtBQUssS0FDdkJtSCxvQkFBb0JOLEtBQUs3RyxLQUFLLEVBQUU4RztZQUFXO1FBQ3JEO1FBQ0EsU0FBU0ksZUFBZU8sTUFBTTtZQUM1QixPQUNFLGFBQWEsT0FBT0EsVUFDcEIsU0FBU0EsVUFDVEEsT0FBTzVKLFFBQVEsS0FBS1g7UUFFeEI7UUFDQSxTQUFTaUssb0JBQW9CTyxPQUFPLEVBQUVaLFVBQVU7WUFDOUMsSUFDRVksUUFBUTVCLE1BQU0sSUFDZCxDQUFDNEIsUUFBUTVCLE1BQU0sQ0FBQ3NCLFNBQVMsSUFDekIsUUFBUU0sUUFBUWhLLEdBQUcsSUFDbEIsQ0FBQSxBQUFDZ0ssUUFBUTVCLE1BQU0sQ0FBQ3NCLFNBQVMsR0FBRyxHQUM1Qk4sYUFBYWEsNkJBQTZCYixhQUMzQyxDQUFDYyxxQkFBcUIsQ0FBQ2QsV0FBVyxBQUFELEdBQ2pDO2dCQUNBYyxxQkFBcUIsQ0FBQ2QsV0FBVyxHQUFHO2dCQUNwQyxJQUFJZSxhQUFhO2dCQUNqQkgsV0FDRSxRQUFRQSxRQUFRN0IsTUFBTSxJQUN0QjZCLFFBQVE3QixNQUFNLEtBQUtqQixjQUNsQixDQUFBLEFBQUNpRCxhQUFhLE1BQ2YsYUFBYSxPQUFPSCxRQUFRN0IsTUFBTSxDQUFDNUcsR0FBRyxHQUNqQzRJLGFBQWFySix5QkFBeUJrSixRQUFRN0IsTUFBTSxDQUFDdEksSUFBSSxJQUMxRCxhQUFhLE9BQU9tSyxRQUFRN0IsTUFBTSxDQUFDbEgsSUFBSSxJQUN0Q2tKLENBQUFBLGFBQWFILFFBQVE3QixNQUFNLENBQUNsSCxJQUFJLEFBQUQsR0FDbkNrSixhQUFhLGlDQUFpQ0EsYUFBYSxHQUFHO2dCQUNqRSxJQUFJQyxzQkFBc0I5RSxxQkFBcUIrRSxlQUFlO2dCQUM5RC9FLHFCQUFxQitFLGVBQWUsR0FBRztvQkFDckMsSUFBSTVGLFFBQVF1QyxxQ0FBcUNnRCxRQUFRbkssSUFBSTtvQkFDN0R1Syx1QkFBd0IzRixDQUFBQSxTQUFTMkYseUJBQXlCLEVBQUM7b0JBQzNELE9BQU8zRjtnQkFDVDtnQkFDQWpELFFBQVFDLEtBQUssQ0FDWCwySEFDQTJILFlBQ0FlO2dCQUVGN0UscUJBQXFCK0UsZUFBZSxHQUFHRDtZQUN6QztRQUNGO1FBQ0EsU0FBU0gsNkJBQTZCYixVQUFVO1lBQzlDLElBQUloRyxPQUFPLElBQ1Q4RSxRQUFRaEI7WUFDVmdCLFNBQ0dBLENBQUFBLFFBQVFwSCx5QkFBeUJvSCxNQUFNckksSUFBSSxDQUFBLEtBQzNDdUQsQ0FBQUEsT0FBTyxxQ0FBcUM4RSxRQUFRLElBQUc7WUFDMUQ5RSxRQUNHLEFBQUNnRyxDQUFBQSxhQUFhdEkseUJBQXlCc0ksV0FBVSxLQUMvQ2hHLENBQUFBLE9BQ0MsZ0RBQWdEZ0csYUFBYSxJQUFHO1lBQ3RFLE9BQU9oRztRQUNUO1FBQ0EsSUFBSWtILFVBQVV0TCxPQUNaUSxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQywrQkFDaEN3QixvQkFBb0J6QixPQUFPQyxHQUFHLENBQUMsaUJBQy9CQyxzQkFBc0JGLE9BQU9DLEdBQUcsQ0FBQyxtQkFDakMwQix5QkFBeUIzQixPQUFPQyxHQUFHLENBQUMsc0JBQ3BDeUIsc0JBQXNCMUIsT0FBT0MsR0FBRyxDQUFDO1FBQ25DLElBQUlpQyxzQkFBc0JsQyxPQUFPQyxHQUFHLENBQUMsbUJBQ25DZ0MscUJBQXFCakMsT0FBT0MsR0FBRyxDQUFDLGtCQUNoQ21DLHlCQUF5QnBDLE9BQU9DLEdBQUcsQ0FBQyxzQkFDcEMyQixzQkFBc0I1QixPQUFPQyxHQUFHLENBQUMsbUJBQ2pDNEIsMkJBQTJCN0IsT0FBT0MsR0FBRyxDQUFDLHdCQUN0Q3NDLGtCQUFrQnZDLE9BQU9DLEdBQUcsQ0FBQyxlQUM3QnVDLGtCQUFrQnhDLE9BQU9DLEdBQUcsQ0FBQyxlQUM3QjhJLHVCQUF1Qi9JLE9BQU9DLEdBQUcsQ0FBQyxvQkFDbENpSyx3QkFBd0JsSyxPQUFPOEssUUFBUSxFQUN2Q3hKLDJCQUEyQnRCLE9BQU9DLEdBQUcsQ0FBQywyQkFDdEM0Rix1QkFDRWdGLFFBQVFFLCtEQUErRCxFQUN6RWxELGlCQUFpQnJELE9BQU8yQixTQUFTLENBQUMwQixjQUFjLEVBQ2hEbEQsU0FBU0gsT0FBT0csTUFBTSxFQUN0QnFFLDJCQUEyQmhKLE9BQU9DLEdBQUcsQ0FBQywyQkFDdENrSixjQUFjNkIsTUFBTUMsT0FBTyxFQUMzQjFILGdCQUFnQixHQUNoQkMsU0FDQUUsVUFDQUUsVUFDQUUsV0FDQUMsV0FDQUUsb0JBQ0FFO1FBQ0ZkLFlBQVk2SCxrQkFBa0IsR0FBRztRQUNqQyxJQUFJckcsUUFDRkssUUFDQUssVUFBVTtRQUNaLElBQUlFLHNCQUFzQixJQUN4QixDQUFBLGVBQWUsT0FBTzBGLFVBQVVBLFVBQVVDLEdBQUU7UUFFOUMsSUFBSXhCLHlCQUF5QjVKLE9BQU9DLEdBQUcsQ0FBQywyQkFDdENpSTtRQUNGLElBQUlHLHlCQUF5QixDQUFDO1FBQzlCLElBQUlvQix3QkFBd0IsQ0FBQyxHQUMzQmdCLHdCQUF3QixDQUFDO1FBQzNCMUosNEJBQTRCSCxRQUFRLEdBQUdWO1FBQ3ZDYSw0QkFBNEJGLEdBQUcsR0FBRyxTQUFVVCxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsUUFBUSxFQUFFa0ksTUFBTSxFQUFFRCxJQUFJO1lBQzlFLE9BQU9NLFdBQVd6SSxNQUFNQyxRQUFRQyxVQUFVLE9BQU9rSSxRQUFRRDtRQUMzRDtRQUNBeEgsNEJBQTRCRCxJQUFJLEdBQUcsU0FBVVYsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRWtJLE1BQU0sRUFBRUQsSUFBSTtZQUMvRSxPQUFPTSxXQUFXekksTUFBTUMsUUFBUUMsVUFBVSxNQUFNa0ksUUFBUUQ7UUFDMUQ7SUFDRjtJQUNGLE9BQU94SDtBQUNSO0FBRUEsSUFBSXNLO0FBRUosU0FBU0M7SUFDUixJQUFJRCx1QkFBdUIsT0FBTzNMLFdBQVdDLE9BQU87SUFDcEQwTCx3QkFBd0I7SUFFeEIsSUFBSW5LLFFBQVFDLEdBQUcsQ0FBQ0MsUUFBUSxLQUFLLGNBQWM7UUFDekMxQixXQUFXQyxPQUFPLEdBQUdHO0lBQ3ZCLE9BQU87UUFDTEosV0FBV0MsT0FBTyxHQUFHc0I7SUFDdkI7SUFDQSxPQUFPdkIsV0FBV0MsT0FBTztBQUMxQjtBQUVBLElBQUk0TCxvQkFBb0JEO0FBRXhCLHdGQUF3RjtBQUN4RixNQUFNRSxZQUFZLE9BQU9DLFdBQVcsZUFBZSxPQUFPQSxPQUFPQyxRQUFRLEtBQUssZUFBZSxPQUFPRCxPQUFPQyxRQUFRLENBQUNDLGFBQWEsS0FBSztBQUV0SSxTQUFTQyxTQUFTckIsT0FBTztJQUN2QixNQUFNc0IsZ0JBQWdCckgsT0FBTzJCLFNBQVMsQ0FBQzJGLFFBQVEsQ0FBQzFJLElBQUksQ0FBQ21IO0lBQ3JELE9BQU9zQixrQkFBa0IscUJBQXFCLHNFQUFzRTtJQUNwSEEsa0JBQWtCO0FBQ3BCO0FBRUEsU0FBU0UsT0FBT3JDLElBQUk7SUFDbEIsT0FBTyxjQUFjQTtBQUN2QjtBQUVBLFNBQVNzQyxVQUFVQyxNQUFNO0lBQ3ZCLElBQUlDLHVCQUF1QkM7SUFFM0IsSUFBSSxDQUFDRixRQUFRO1FBQ1gsT0FBT1I7SUFDVDtJQUVBLElBQUlHLFNBQVNLLFNBQVM7UUFDcEIsT0FBT0E7SUFDVDtJQUVBLElBQUksQ0FBQ0YsT0FBT0UsU0FBUztRQUNuQixPQUFPUjtJQUNUO0lBRUEsT0FBTyxBQUFDUyxDQUFBQSx3QkFBd0IsQUFBQ0MsQ0FBQUEseUJBQXlCRixPQUFPRyxhQUFhLEFBQUQsS0FBTSxPQUFPLEtBQUssSUFBSUQsdUJBQXVCRSxXQUFXLEFBQUQsS0FBTSxPQUFPSCx3QkFBd0JUO0FBQzNLO0FBRUEsU0FBU2EsV0FBVzVDLElBQUk7SUFDdEIsTUFBTSxFQUNKNkMsUUFBUSxFQUNULEdBQUdQLFVBQVV0QztJQUNkLE9BQU9BLGdCQUFnQjZDO0FBQ3pCO0FBRUEsU0FBU0MsY0FBYzlDLElBQUk7SUFDekIsSUFBSWtDLFNBQVNsQyxPQUFPO1FBQ2xCLE9BQU87SUFDVDtJQUVBLE9BQU9BLGdCQUFnQnNDLFVBQVV0QyxNQUFNK0MsV0FBVztBQUNwRDtBQUVBLFNBQVNDLGFBQWFoRCxJQUFJO0lBQ3hCLE9BQU9BLGdCQUFnQnNDLFVBQVV0QyxNQUFNaUQsVUFBVTtBQUNuRDtBQUVBLFNBQVNDLGlCQUFpQlgsTUFBTTtJQUM5QixJQUFJLENBQUNBLFFBQVE7UUFDWCxPQUFPUDtJQUNUO0lBRUEsSUFBSUUsU0FBU0ssU0FBUztRQUNwQixPQUFPQSxPQUFPUCxRQUFRO0lBQ3hCO0lBRUEsSUFBSSxDQUFDSyxPQUFPRSxTQUFTO1FBQ25CLE9BQU9QO0lBQ1Q7SUFFQSxJQUFJWSxXQUFXTCxTQUFTO1FBQ3RCLE9BQU9BO0lBQ1Q7SUFFQSxJQUFJTyxjQUFjUCxXQUFXUyxhQUFhVCxTQUFTO1FBQ2pELE9BQU9BLE9BQU9HLGFBQWE7SUFDN0I7SUFFQSxPQUFPVjtBQUNUO0FBRUE7OztDQUdDLEdBRUQsTUFBTW1CLDRCQUE0QnJCLFlBQVlqTSxNQUFNdU4sZUFBZSxHQUFHdk4sTUFBTXdOLFNBQVM7QUFFckYsU0FBU0MsU0FBU0MsT0FBTztJQUN2QixNQUFNQyxhQUFhM04sTUFBTTROLE1BQU0sQ0FBQ0Y7SUFDaENKLDBCQUEwQjtRQUN4QkssV0FBV0UsT0FBTyxHQUFHSDtJQUN2QjtJQUNBLE9BQU8xTixNQUFNOE4sV0FBVyxDQUFDO1FBQ3ZCLElBQUssSUFBSUMsT0FBT0MsVUFBVXBHLE1BQU0sRUFBRXFHLE9BQU8sSUFBSXhDLE1BQU1zQyxPQUFPRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7WUFDdkZELElBQUksQ0FBQ0MsS0FBSyxHQUFHRixTQUFTLENBQUNFLEtBQUs7UUFDOUI7UUFFQSxPQUFPUCxXQUFXRSxPQUFPLElBQUksT0FBTyxLQUFLLElBQUlGLFdBQVdFLE9BQU8sSUFBSUk7SUFDckUsR0FBRyxFQUFFO0FBQ1A7QUFFQSxTQUFTRTtJQUNQLE1BQU1DLGNBQWNwTyxNQUFNNE4sTUFBTSxDQUFDO0lBQ2pDLE1BQU0vRyxNQUFNN0csTUFBTThOLFdBQVcsQ0FBQyxDQUFDTyxVQUFVQztRQUN2Q0YsWUFBWVAsT0FBTyxHQUFHVSxZQUFZRixVQUFVQztJQUM5QyxHQUFHLEVBQUU7SUFDTCxNQUFNRSxRQUFReE8sTUFBTThOLFdBQVcsQ0FBQztRQUM5QixJQUFJTSxZQUFZUCxPQUFPLEtBQUssTUFBTTtZQUNoQ1ksY0FBY0wsWUFBWVAsT0FBTztZQUNqQ08sWUFBWVAsT0FBTyxHQUFHO1FBQ3hCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBTztRQUFDaEg7UUFBSzJIO0tBQU07QUFDckI7QUFFQSxTQUFTRSxlQUFlcEwsS0FBSyxFQUFFcUwsWUFBWTtJQUN6QyxJQUFJQSxpQkFBaUIsS0FBSyxHQUFHO1FBQzNCQSxlQUFlO1lBQUNyTDtTQUFNO0lBQ3hCO0lBRUEsTUFBTXNMLFdBQVc1TyxNQUFNNE4sTUFBTSxDQUFDdEs7SUFDOUJnSywwQkFBMEI7UUFDeEIsSUFBSXNCLFNBQVNmLE9BQU8sS0FBS3ZLLE9BQU87WUFDOUJzTCxTQUFTZixPQUFPLEdBQUd2SztRQUNyQjtJQUNGLEdBQUdxTDtJQUNILE9BQU9DO0FBQ1Q7QUFFQSxTQUFTQyxZQUFZQyxRQUFRLEVBQUVILFlBQVk7SUFDekMsTUFBTUMsV0FBVzVPLE1BQU00TixNQUFNO0lBQzdCLE9BQU81TixNQUFNK08sT0FBTyxDQUFDO1FBQ25CLE1BQU1DLFdBQVdGLFNBQVNGLFNBQVNmLE9BQU87UUFDMUNlLFNBQVNmLE9BQU8sR0FBR21CO1FBQ25CLE9BQU9BO0lBQ1QsR0FDQTtXQUFJTDtLQUFhO0FBQ25CO0FBRUEsU0FBU00sV0FBV0MsUUFBUTtJQUMxQixNQUFNQyxrQkFBa0IxQixTQUFTeUI7SUFDakMsTUFBTS9FLE9BQU9uSyxNQUFNNE4sTUFBTSxDQUFDO0lBQzFCLE1BQU13QixhQUFhcFAsTUFBTThOLFdBQVcsQ0FBQzlDLENBQUFBO1FBQ25DLElBQUlBLFlBQVliLEtBQUswRCxPQUFPLEVBQUU7WUFDNUJzQixtQkFBbUIsT0FBTyxLQUFLLElBQUlBLGdCQUFnQm5FLFNBQVNiLEtBQUswRCxPQUFPO1FBQzFFO1FBRUExRCxLQUFLMEQsT0FBTyxHQUFHN0M7SUFDakIsR0FDQSxFQUFFO0lBQ0YsT0FBTztRQUFDYjtRQUFNaUY7S0FBVztBQUMzQjtBQUVBLFNBQVNDLFlBQVkvTCxLQUFLO0lBQ3hCLE1BQU1wQyxNQUFNbEIsTUFBTTROLE1BQU07SUFDeEI1TixNQUFNd04sU0FBUyxDQUFDO1FBQ2R0TSxJQUFJMk0sT0FBTyxHQUFHdks7SUFDaEIsR0FBRztRQUFDQTtLQUFNO0lBQ1YsT0FBT3BDLElBQUkyTSxPQUFPO0FBQ3BCO0FBRUEsSUFBSXlCLE1BQU0sQ0FBQztBQUNYLFNBQVNDLFlBQVlqSyxNQUFNLEVBQUVoQyxLQUFLO0lBQ2hDLE9BQU90RCxNQUFNK08sT0FBTyxDQUFDO1FBQ25CLElBQUl6TCxPQUFPO1lBQ1QsT0FBT0E7UUFDVDtRQUVBLE1BQU1rTSxLQUFLRixHQUFHLENBQUNoSyxPQUFPLElBQUksT0FBTyxJQUFJZ0ssR0FBRyxDQUFDaEssT0FBTyxHQUFHO1FBQ25EZ0ssR0FBRyxDQUFDaEssT0FBTyxHQUFHa0s7UUFDZCxPQUFPbEssU0FBUyxNQUFNa0s7SUFDeEIsR0FBRztRQUFDbEs7UUFBUWhDO0tBQU07QUFDcEI7QUFFQSxTQUFTbU0sbUJBQW1CQyxRQUFRO0lBQ2xDLE9BQU8sU0FBVTNFLE1BQU07UUFDckIsSUFBSyxJQUFJZ0QsT0FBT0MsVUFBVXBHLE1BQU0sRUFBRStILGNBQWMsSUFBSWxFLE1BQU1zQyxPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJRyxPQUFPLEdBQUdBLE9BQU9ILE1BQU1HLE9BQVE7WUFDakh5QixXQUFXLENBQUN6QixPQUFPLEVBQUUsR0FBR0YsU0FBUyxDQUFDRSxLQUFLO1FBQ3pDO1FBRUEsT0FBT3lCLFlBQVlDLE1BQU0sQ0FBQyxDQUFDQyxhQUFhQztZQUN0QyxNQUFNbEYsVUFBVTNGLE9BQU8yRixPQUFPLENBQUNrRjtZQUUvQixLQUFLLE1BQU0sQ0FBQzlPLEtBQUsrTyxnQkFBZ0IsSUFBSW5GLFFBQVM7Z0JBQzVDLE1BQU10SCxRQUFRdU0sV0FBVyxDQUFDN08sSUFBSTtnQkFFOUIsSUFBSXNDLFNBQVMsTUFBTTtvQkFDakJ1TSxXQUFXLENBQUM3TyxJQUFJLEdBQUdzQyxRQUFRb00sV0FBV0s7Z0JBQ3hDO1lBQ0Y7WUFFQSxPQUFPRjtRQUNULEdBQUc7WUFBRSxHQUFHOUUsTUFBTTtRQUNkO0lBQ0Y7QUFDRjtBQUVBLE1BQU1pRixNQUFNLFdBQVcsR0FBRVAsbUJBQW1CO0FBQzVDLE1BQU1RLFdBQVcsV0FBVyxHQUFFUixtQkFBbUIsQ0FBQztBQUVsRCxTQUFTUywrQkFBK0JDLEtBQUs7SUFDM0MsT0FBTyxhQUFhQSxTQUFTLGFBQWFBO0FBQzVDO0FBRUEsU0FBU0MsZ0JBQWdCRCxLQUFLO0lBQzVCLElBQUksQ0FBQ0EsT0FBTztRQUNWLE9BQU87SUFDVDtJQUVBLE1BQU0sRUFDSkUsYUFBYSxFQUNkLEdBQUc1RCxVQUFVMEQsTUFBTXpELE1BQU07SUFDMUIsT0FBTzJELGlCQUFpQkYsaUJBQWlCRTtBQUMzQztBQUVBLFNBQVNDLGFBQWFILEtBQUs7SUFDekIsSUFBSSxDQUFDQSxPQUFPO1FBQ1YsT0FBTztJQUNUO0lBRUEsTUFBTSxFQUNKSSxVQUFVLEVBQ1gsR0FBRzlELFVBQVUwRCxNQUFNekQsTUFBTTtJQUMxQixPQUFPNkQsY0FBY0osaUJBQWlCSTtBQUN4QztBQUVBOztDQUVDLEdBRUQsU0FBU0Msb0JBQW9CTCxLQUFLO0lBQ2hDLElBQUlHLGFBQWFILFFBQVE7UUFDdkIsSUFBSUEsTUFBTU0sT0FBTyxJQUFJTixNQUFNTSxPQUFPLENBQUM3SSxNQUFNLEVBQUU7WUFDekMsTUFBTSxFQUNKOEksU0FBU3ROLENBQUMsRUFDVnVOLFNBQVNDLENBQUMsRUFDWCxHQUFHVCxNQUFNTSxPQUFPLENBQUMsRUFBRTtZQUNwQixPQUFPO2dCQUNMck47Z0JBQ0F3TjtZQUNGO1FBQ0YsT0FBTyxJQUFJVCxNQUFNVSxjQUFjLElBQUlWLE1BQU1VLGNBQWMsQ0FBQ2pKLE1BQU0sRUFBRTtZQUM5RCxNQUFNLEVBQ0o4SSxTQUFTdE4sQ0FBQyxFQUNWdU4sU0FBU0MsQ0FBQyxFQUNYLEdBQUdULE1BQU1VLGNBQWMsQ0FBQyxFQUFFO1lBQzNCLE9BQU87Z0JBQ0x6TjtnQkFDQXdOO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsSUFBSVYsK0JBQStCQyxRQUFRO1FBQ3pDLE9BQU87WUFDTC9NLEdBQUcrTSxNQUFNTyxPQUFPO1lBQ2hCRSxHQUFHVCxNQUFNUSxPQUFPO1FBQ2xCO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxNQUFNRyxNQUFNLFdBQVcsR0FBRTdMLE9BQU9vRSxNQUFNLENBQUM7SUFDckMwSCxXQUFXO1FBQ1R4RSxVQUFTeUUsU0FBUztZQUNoQixJQUFJLENBQUNBLFdBQVc7Z0JBQ2Q7WUFDRjtZQUVBLE1BQU0sRUFDSjVOLENBQUMsRUFDRHdOLENBQUMsRUFDRixHQUFHSTtZQUNKLE9BQU8saUJBQWtCNU4sQ0FBQUEsSUFBSTZOLEtBQUtDLEtBQUssQ0FBQzlOLEtBQUssQ0FBQSxJQUFLLFNBQVV3TixDQUFBQSxJQUFJSyxLQUFLQyxLQUFLLENBQUNOLEtBQUssQ0FBQSxJQUFLO1FBQ3ZGO0lBRUY7SUFDQU8sT0FBTztRQUNMNUUsVUFBU3lFLFNBQVM7WUFDaEIsSUFBSSxDQUFDQSxXQUFXO2dCQUNkO1lBQ0Y7WUFFQSxNQUFNLEVBQ0pJLE1BQU0sRUFDTkMsTUFBTSxFQUNQLEdBQUdMO1lBQ0osT0FBTyxZQUFZSSxTQUFTLGNBQWNDLFNBQVM7UUFDckQ7SUFFRjtJQUNBQyxXQUFXO1FBQ1QvRSxVQUFTeUUsU0FBUztZQUNoQixJQUFJLENBQUNBLFdBQVc7Z0JBQ2Q7WUFDRjtZQUVBLE9BQU87Z0JBQUNGLElBQUlDLFNBQVMsQ0FBQ3hFLFFBQVEsQ0FBQ3lFO2dCQUFZRixJQUFJSyxLQUFLLENBQUM1RSxRQUFRLENBQUN5RTthQUFXLENBQUMvRyxJQUFJLENBQUM7UUFDakY7SUFFRjtJQUNBc0gsWUFBWTtRQUNWaEYsVUFBU2lGLElBQUk7WUFDWCxJQUFJLEVBQ0ZDLFFBQVEsRUFDUm5ELFFBQVEsRUFDUm9ELE1BQU0sRUFDUCxHQUFHRjtZQUNKLE9BQU9DLFdBQVcsTUFBTW5ELFdBQVcsUUFBUW9EO1FBQzdDO0lBRUY7QUFDRjtBQUVBLE1BQU1DLFdBQVc7QUFDakIsU0FBU0MsdUJBQXVCNUcsT0FBTztJQUNyQyxJQUFJQSxRQUFRNkcsT0FBTyxDQUFDRixXQUFXO1FBQzdCLE9BQU8zRztJQUNUO0lBRUEsT0FBT0EsUUFBUThHLGFBQWEsQ0FBQ0g7QUFDL0I7QUFFQSxNQUFNSSxlQUFlO0lBQ25CQyxTQUFTO0FBQ1g7QUFDQSxTQUFTQyxXQUFXVCxJQUFJO0lBQ3RCLElBQUksRUFDRmhDLEVBQUUsRUFDRmxNLEtBQUssRUFDTixHQUFHa087SUFDSixPQUFPeFIsTUFBTW9NLGFBQWEsQ0FBQyxPQUFPO1FBQ2hDb0QsSUFBSUE7UUFDSjBDLE9BQU9IO0lBQ1QsR0FBR3pPO0FBQ0w7QUFFQSxTQUFTNk8sV0FBV1gsSUFBSTtJQUN0QixJQUFJLEVBQ0ZoQyxFQUFFLEVBQ0Y0QyxZQUFZLEVBQ1pDLGVBQWUsV0FBVyxFQUMzQixHQUFHYjtJQUNKLCtEQUErRDtJQUMvRCxNQUFNYyxpQkFBaUI7UUFDckJDLFVBQVU7UUFDVkMsS0FBSztRQUNMQyxNQUFNO1FBQ05DLE9BQU87UUFDUEMsUUFBUTtRQUNSQyxRQUFRLENBQUM7UUFDVEMsUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLFVBQVU7UUFDVkMsTUFBTTtRQUNOQyxVQUFVO1FBQ1ZDLFlBQVk7SUFDZDtJQUNBLE9BQU9sVCxNQUFNb00sYUFBYSxDQUFDLE9BQU87UUFDaENvRCxJQUFJQTtRQUNKMEMsT0FBT0k7UUFDUGEsTUFBTTtRQUNOLGFBQWFkO1FBQ2IsZUFBZTtJQUNqQixHQUFHRDtBQUNMO0FBRUEsU0FBU2dCO0lBQ1AsTUFBTSxDQUFDaEIsY0FBY2lCLGdCQUFnQixHQUFHclQsTUFBTXNULFFBQVEsQ0FBQztJQUN2RCxNQUFNQyxXQUFXdlQsTUFBTThOLFdBQVcsQ0FBQ3hLLENBQUFBO1FBQ2pDLElBQUlBLFNBQVMsTUFBTTtZQUNqQitQLGdCQUFnQi9QO1FBQ2xCO0lBQ0YsR0FBRyxFQUFFO0lBQ0wsT0FBTztRQUNMaVE7UUFDQW5CO0lBQ0Y7QUFDRjtBQUVBLE1BQU1vQixvQkFBb0IsV0FBVyxHQUFFeFQsTUFBTXlULGFBQWEsQ0FBQztBQUUzRCxTQUFTQyxjQUFjckYsUUFBUTtJQUM3QixNQUFNc0YsbUJBQW1CM1QsTUFBTTRULFVBQVUsQ0FBQ0o7SUFDMUN4VCxNQUFNd04sU0FBUyxDQUFDO1FBQ2QsSUFBSSxDQUFDbUcsa0JBQWtCO1lBQ3JCLE1BQU0sSUFBSXBPLE1BQU07UUFDbEI7UUFFQSxNQUFNc08sY0FBY0YsaUJBQWlCdEY7UUFDckMsT0FBT3dGO0lBQ1QsR0FBRztRQUFDeEY7UUFBVXNGO0tBQWlCO0FBQ2pDO0FBRUEsU0FBU0c7SUFDUCxNQUFNLENBQUNDLFVBQVUsR0FBRy9ULE1BQU1zVCxRQUFRLENBQUMsSUFBTSxJQUFJVTtJQUM3QyxNQUFNTCxtQkFBbUIzVCxNQUFNOE4sV0FBVyxDQUFDTyxDQUFBQTtRQUN6QzBGLFVBQVUvRCxHQUFHLENBQUMzQjtRQUNkLE9BQU8sSUFBTTBGLFVBQVVFLE1BQU0sQ0FBQzVGO0lBQ2hDLEdBQUc7UUFBQzBGO0tBQVU7SUFDZCxNQUFNRyxXQUFXbFUsTUFBTThOLFdBQVcsQ0FBQzBELENBQUFBO1FBQ2pDLElBQUksRUFDRjNRLElBQUksRUFDSnNQLEtBQUssRUFDTixHQUFHcUI7UUFDSnVDLFVBQVVJLE9BQU8sQ0FBQzlGLENBQUFBO1lBQ2hCLElBQUkrRjtZQUVKLE9BQU8sQUFBQ0EsQ0FBQUEsaUJBQWlCL0YsUUFBUSxDQUFDeE4sS0FBSyxBQUFELEtBQU0sT0FBTyxLQUFLLElBQUl1VCxlQUFldlEsSUFBSSxDQUFDd0ssVUFBVThCO1FBQzVGO0lBQ0YsR0FBRztRQUFDNEQ7S0FBVTtJQUNkLE9BQU87UUFBQ0c7UUFBVVA7S0FBaUI7QUFDckM7QUFFQSxNQUFNVSxrQ0FBa0M7SUFDdENDLFdBQVc7QUFDYjtBQUNBLE1BQU1DLHVCQUF1QjtJQUMzQkMsYUFBWWhELElBQUk7UUFDZCxJQUFJLEVBQ0ZpRCxNQUFNLEVBQ1AsR0FBR2pEO1FBQ0osT0FBTyw4QkFBOEJpRCxPQUFPakYsRUFBRSxHQUFHO0lBQ25EO0lBRUFrRixZQUFXQyxLQUFLO1FBQ2QsSUFBSSxFQUNGRixNQUFNLEVBQ05HLElBQUksRUFDTCxHQUFHRDtRQUVKLElBQUlDLE1BQU07WUFDUixPQUFPLG9CQUFvQkgsT0FBT2pGLEVBQUUsR0FBRyxvQ0FBb0NvRixLQUFLcEYsRUFBRSxHQUFHO1FBQ3ZGO1FBRUEsT0FBTyxvQkFBb0JpRixPQUFPakYsRUFBRSxHQUFHO0lBQ3pDO0lBRUFxRixXQUFVQyxLQUFLO1FBQ2IsSUFBSSxFQUNGTCxNQUFNLEVBQ05HLElBQUksRUFDTCxHQUFHRTtRQUVKLElBQUlGLE1BQU07WUFDUixPQUFPLG9CQUFvQkgsT0FBT2pGLEVBQUUsR0FBRyxzQ0FBc0NvRixLQUFLcEYsRUFBRTtRQUN0RjtRQUVBLE9BQU8sb0JBQW9CaUYsT0FBT2pGLEVBQUUsR0FBRztJQUN6QztJQUVBdUYsY0FBYUMsS0FBSztRQUNoQixJQUFJLEVBQ0ZQLE1BQU0sRUFDUCxHQUFHTztRQUNKLE9BQU8sNENBQTRDUCxPQUFPakYsRUFBRSxHQUFHO0lBQ2pFO0FBRUY7QUFFQSxTQUFTeUYsY0FBY3pELElBQUk7SUFDekIsSUFBSSxFQUNGMEQsZ0JBQWdCWCxvQkFBb0IsRUFDcENZLFNBQVMsRUFDVEMsdUJBQXVCLEVBQ3ZCQywyQkFBMkJoQiwrQkFBK0IsRUFDM0QsR0FBRzdDO0lBQ0osTUFBTSxFQUNKK0IsUUFBUSxFQUNSbkIsWUFBWSxFQUNiLEdBQUdnQjtJQUNKLE1BQU1rQyxlQUFlL0YsWUFBWTtJQUNqQyxNQUFNLENBQUNnRyxTQUFTQyxXQUFXLEdBQUd4VixNQUFNc1QsUUFBUSxDQUFDO0lBQzdDdFQsTUFBTXdOLFNBQVMsQ0FBQztRQUNkZ0ksV0FBVztJQUNiLEdBQUcsRUFBRTtJQUNMOUIsY0FBYzFULE1BQU0rTyxPQUFPLENBQUMsSUFBTyxDQUFBO1lBQ2pDeUYsYUFBWUcsS0FBSztnQkFDZixJQUFJLEVBQ0ZGLE1BQU0sRUFDUCxHQUFHRTtnQkFDSnBCLFNBQVMyQixjQUFjVixXQUFXLENBQUM7b0JBQ2pDQztnQkFDRjtZQUNGO1lBRUFnQixZQUFXWCxLQUFLO2dCQUNkLElBQUksRUFDRkwsTUFBTSxFQUNORyxJQUFJLEVBQ0wsR0FBR0U7Z0JBRUosSUFBSUksY0FBY08sVUFBVSxFQUFFO29CQUM1QmxDLFNBQVMyQixjQUFjTyxVQUFVLENBQUM7d0JBQ2hDaEI7d0JBQ0FHO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQUYsWUFBV00sS0FBSztnQkFDZCxJQUFJLEVBQ0ZQLE1BQU0sRUFDTkcsSUFBSSxFQUNMLEdBQUdJO2dCQUNKekIsU0FBUzJCLGNBQWNSLFVBQVUsQ0FBQztvQkFDaENEO29CQUNBRztnQkFDRjtZQUNGO1lBRUFDLFdBQVVhLEtBQUs7Z0JBQ2IsSUFBSSxFQUNGakIsTUFBTSxFQUNORyxJQUFJLEVBQ0wsR0FBR2M7Z0JBQ0puQyxTQUFTMkIsY0FBY0wsU0FBUyxDQUFDO29CQUMvQko7b0JBQ0FHO2dCQUNGO1lBQ0Y7WUFFQUcsY0FBYVksS0FBSztnQkFDaEIsSUFBSSxFQUNGbEIsTUFBTSxFQUNORyxJQUFJLEVBQ0wsR0FBR2U7Z0JBQ0pwQyxTQUFTMkIsY0FBY0gsWUFBWSxDQUFDO29CQUNsQ047b0JBQ0FHO2dCQUNGO1lBQ0Y7UUFFRixDQUFBLEdBQUk7UUFBQ3JCO1FBQVUyQjtLQUFjO0lBRTdCLElBQUksQ0FBQ0ssU0FBUztRQUNaLE9BQU87SUFDVDtJQUVBLE1BQU1LLFNBQVM1VixNQUFNb00sYUFBYSxDQUFDcE0sTUFBTXFCLFFBQVEsRUFBRSxNQUFNckIsTUFBTW9NLGFBQWEsQ0FBQzZGLFlBQVk7UUFDdkZ6QyxJQUFJNEY7UUFDSjlSLE9BQU8rUix5QkFBeUJmLFNBQVM7SUFDM0MsSUFBSXRVLE1BQU1vTSxhQUFhLENBQUMrRixZQUFZO1FBQ2xDM0MsSUFBSThGO1FBQ0psRCxjQUFjQTtJQUNoQjtJQUNBLE9BQU8rQyxZQUFZalYsU0FBUzJWLFlBQVksQ0FBQ0QsUUFBUVQsYUFBYVM7QUFDaEU7QUFFQSxJQUFJRTtBQUVILENBQUEsU0FBVUEsTUFBTTtJQUNmQSxNQUFNLENBQUMsWUFBWSxHQUFHO0lBQ3RCQSxNQUFNLENBQUMsV0FBVyxHQUFHO0lBQ3JCQSxNQUFNLENBQUMsVUFBVSxHQUFHO0lBQ3BCQSxNQUFNLENBQUMsYUFBYSxHQUFHO0lBQ3ZCQSxNQUFNLENBQUMsV0FBVyxHQUFHO0lBQ3JCQSxNQUFNLENBQUMsb0JBQW9CLEdBQUc7SUFDOUJBLE1BQU0sQ0FBQyx1QkFBdUIsR0FBRztJQUNqQ0EsTUFBTSxDQUFDLHNCQUFzQixHQUFHO0FBQ2xDLENBQUEsRUFBR0EsVUFBV0EsQ0FBQUEsU0FBUyxDQUFDLENBQUE7QUFFeEIsU0FBU0MsUUFBUTtBQUVqQixTQUFTQyxVQUFVQyxNQUFNLEVBQUVDLE9BQU87SUFDaEMsT0FBT2xXLE1BQU0rTyxPQUFPLENBQUMsSUFBTyxDQUFBO1lBQzFCa0g7WUFDQUMsU0FBU0EsV0FBVyxPQUFPQSxVQUFVLENBQUM7UUFDeEMsQ0FBQSxHQUNBO1FBQUNEO1FBQVFDO0tBQVE7QUFDbkI7QUFFQSxTQUFTQztJQUNQLElBQUssSUFBSXBJLE9BQU9DLFVBQVVwRyxNQUFNLEVBQUV3TyxVQUFVLElBQUkzSyxNQUFNc0MsT0FBT0csT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1FBQzFGa0ksT0FBTyxDQUFDbEksS0FBSyxHQUFHRixTQUFTLENBQUNFLEtBQUs7SUFDakM7SUFFQSxPQUFPbE8sTUFBTStPLE9BQU8sQ0FBQyxJQUFNO2VBQUlxSDtTQUFRLENBQUNyTSxNQUFNLENBQUNrTSxDQUFBQSxTQUFVQSxVQUFVLE9BQ25FO1dBQUlHO0tBQVE7QUFDZDtBQUVBLE1BQU1DLHFCQUFxQixXQUFXLEdBQUVwUixPQUFPb0UsTUFBTSxDQUFDO0lBQ3BEakcsR0FBRztJQUNId04sR0FBRztBQUNMO0FBRUE7O0NBRUMsR0FDRCxTQUFTMEYsZ0JBQWdCQyxFQUFFLEVBQUVDLEVBQUU7SUFDN0IsT0FBT3ZGLEtBQUt3RixJQUFJLENBQUN4RixLQUFLeUYsR0FBRyxDQUFDSCxHQUFHblQsQ0FBQyxHQUFHb1QsR0FBR3BULENBQUMsRUFBRSxLQUFLNk4sS0FBS3lGLEdBQUcsQ0FBQ0gsR0FBRzNGLENBQUMsR0FBRzRGLEdBQUc1RixDQUFDLEVBQUU7QUFDcEU7QUFFQSxTQUFTK0YsMkJBQTJCeEcsS0FBSyxFQUFFeUcsSUFBSTtJQUM3QyxNQUFNQyxtQkFBbUJyRyxvQkFBb0JMO0lBRTdDLElBQUksQ0FBQzBHLGtCQUFrQjtRQUNyQixPQUFPO0lBQ1Q7SUFFQSxNQUFNQyxrQkFBa0I7UUFDdEIxVCxHQUFHLEFBQUN5VCxDQUFBQSxpQkFBaUJ6VCxDQUFDLEdBQUd3VCxLQUFLbkUsSUFBSSxBQUFELElBQUttRSxLQUFLbEUsS0FBSyxHQUFHO1FBQ25EOUIsR0FBRyxBQUFDaUcsQ0FBQUEsaUJBQWlCakcsQ0FBQyxHQUFHZ0csS0FBS3BFLEdBQUcsQUFBRCxJQUFLb0UsS0FBS2pFLE1BQU0sR0FBRztJQUNyRDtJQUNBLE9BQU9tRSxnQkFBZ0IxVCxDQUFDLEdBQUcsT0FBTzBULGdCQUFnQmxHLENBQUMsR0FBRztBQUN4RDtBQUVBOztDQUVDLEdBQ0QsU0FBU21HLGtCQUFrQnZGLElBQUksRUFBRW1ELEtBQUs7SUFDcEMsSUFBSSxFQUNGcUMsTUFBTSxFQUNKMVQsT0FBTzJULENBQUMsRUFDVCxFQUNGLEdBQUd6RjtJQUNKLElBQUksRUFDRndGLE1BQU0sRUFDSjFULE9BQU80VCxDQUFDLEVBQ1QsRUFDRixHQUFHdkM7SUFDSixPQUFPc0MsSUFBSUM7QUFDYjtBQUNBOztDQUVDLEdBRUQsU0FBU0MsbUJBQW1CckMsS0FBSyxFQUFFRSxLQUFLO0lBQ3RDLElBQUksRUFDRmdDLE1BQU0sRUFDSjFULE9BQU8yVCxDQUFDLEVBQ1QsRUFDRixHQUFHbkM7SUFDSixJQUFJLEVBQ0ZrQyxNQUFNLEVBQ0oxVCxPQUFPNFQsQ0FBQyxFQUNULEVBQ0YsR0FBR2xDO0lBQ0osT0FBT2tDLElBQUlEO0FBQ2I7QUFDQTs7O0NBR0MsR0FFRCxTQUFTRyxtQkFBbUIxQixLQUFLO0lBQy9CLElBQUksRUFDRmpELElBQUksRUFDSkQsR0FBRyxFQUNIRyxNQUFNLEVBQ05ELEtBQUssRUFDTixHQUFHZ0Q7SUFDSixPQUFPO1FBQUM7WUFDTnRTLEdBQUdxUDtZQUNIN0IsR0FBRzRCO1FBQ0w7UUFBRztZQUNEcFAsR0FBR3FQLE9BQU9DO1lBQ1Y5QixHQUFHNEI7UUFDTDtRQUFHO1lBQ0RwUCxHQUFHcVA7WUFDSDdCLEdBQUc0QixNQUFNRztRQUNYO1FBQUc7WUFDRHZQLEdBQUdxUCxPQUFPQztZQUNWOUIsR0FBRzRCLE1BQU1HO1FBQ1g7S0FBRTtBQUNKO0FBQ0EsU0FBUzBFLGtCQUFrQkMsVUFBVSxFQUFFN0YsUUFBUTtJQUM3QyxJQUFJLENBQUM2RixjQUFjQSxXQUFXMVAsTUFBTSxLQUFLLEdBQUc7UUFDMUMsT0FBTztJQUNUO0lBRUEsTUFBTSxDQUFDMlAsZUFBZSxHQUFHRDtJQUN6QixPQUFPQyxjQUFjLENBQUM5RixTQUFTO0FBQ2pDO0FBRUE7O0NBRUMsR0FFRCxTQUFTK0YscUJBQXFCQyxLQUFLLEVBQUUvSyxNQUFNO0lBQ3pDLE1BQU04RixNQUFNdkIsS0FBS3lHLEdBQUcsQ0FBQ2hMLE9BQU84RixHQUFHLEVBQUVpRixNQUFNakYsR0FBRztJQUMxQyxNQUFNQyxPQUFPeEIsS0FBS3lHLEdBQUcsQ0FBQ2hMLE9BQU8rRixJQUFJLEVBQUVnRixNQUFNaEYsSUFBSTtJQUM3QyxNQUFNa0YsUUFBUTFHLEtBQUsyRyxHQUFHLENBQUNsTCxPQUFPK0YsSUFBSSxHQUFHL0YsT0FBT2dHLEtBQUssRUFBRStFLE1BQU1oRixJQUFJLEdBQUdnRixNQUFNL0UsS0FBSztJQUMzRSxNQUFNbUYsU0FBUzVHLEtBQUsyRyxHQUFHLENBQUNsTCxPQUFPOEYsR0FBRyxHQUFHOUYsT0FBT2lHLE1BQU0sRUFBRThFLE1BQU1qRixHQUFHLEdBQUdpRixNQUFNOUUsTUFBTTtJQUM1RSxNQUFNRCxRQUFRaUYsUUFBUWxGO0lBQ3RCLE1BQU1FLFNBQVNrRixTQUFTckY7SUFFeEIsSUFBSUMsT0FBT2tGLFNBQVNuRixNQUFNcUYsUUFBUTtRQUNoQyxNQUFNQyxhQUFhcEwsT0FBT2dHLEtBQUssR0FBR2hHLE9BQU9pRyxNQUFNO1FBQy9DLE1BQU1vRixZQUFZTixNQUFNL0UsS0FBSyxHQUFHK0UsTUFBTTlFLE1BQU07UUFDNUMsTUFBTXFGLG1CQUFtQnRGLFFBQVFDO1FBQ2pDLE1BQU1zRixvQkFBb0JELG1CQUFvQkYsQ0FBQUEsYUFBYUMsWUFBWUMsZ0JBQWU7UUFDdEYsT0FBT0UsT0FBT0Qsa0JBQWtCRSxPQUFPLENBQUM7SUFDMUMsRUFBRSxrRkFBa0Y7SUFHcEYsT0FBTztBQUNUO0FBQ0E7OztDQUdDLEdBRUQsTUFBTUMsbUJBQW1CNUcsQ0FBQUE7SUFDdkIsSUFBSSxFQUNGNkcsYUFBYSxFQUNiQyxjQUFjLEVBQ2RDLG1CQUFtQixFQUNwQixHQUFHL0c7SUFDSixNQUFNOEYsYUFBYSxFQUFFO0lBRXJCLEtBQUssTUFBTWtCLHNCQUFzQkQsb0JBQXFCO1FBQ3BELE1BQU0sRUFDSi9JLEVBQUUsRUFDSCxHQUFHZ0o7UUFDSixNQUFNNUIsT0FBTzBCLGVBQWVuUyxHQUFHLENBQUNxSjtRQUVoQyxJQUFJb0gsTUFBTTtZQUNSLE1BQU1xQixvQkFBb0JULHFCQUFxQlosTUFBTXlCO1lBRXJELElBQUlKLG9CQUFvQixHQUFHO2dCQUN6QlgsV0FBV21CLElBQUksQ0FBQztvQkFDZGpKO29CQUNBd0gsTUFBTTt3QkFDSndCO3dCQUNBbFYsT0FBTzJVO29CQUNUO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBT1gsV0FBV29CLElBQUksQ0FBQ3ZCO0FBQ3pCO0FBRUE7O0NBRUMsR0FFRCxTQUFTd0Isa0JBQWtCQyxLQUFLLEVBQUVoQyxJQUFJO0lBQ3BDLE1BQU0sRUFDSnBFLEdBQUcsRUFDSEMsSUFBSSxFQUNKb0YsTUFBTSxFQUNORixLQUFLLEVBQ04sR0FBR2Y7SUFDSixPQUFPcEUsT0FBT29HLE1BQU1oSSxDQUFDLElBQUlnSSxNQUFNaEksQ0FBQyxJQUFJaUgsVUFBVXBGLFFBQVFtRyxNQUFNeFYsQ0FBQyxJQUFJd1YsTUFBTXhWLENBQUMsSUFBSXVVO0FBQzlFO0FBQ0E7O0NBRUMsR0FHRCxNQUFNa0IsZ0JBQWdCckgsQ0FBQUE7SUFDcEIsSUFBSSxFQUNGK0csbUJBQW1CLEVBQ25CRCxjQUFjLEVBQ2RRLGtCQUFrQixFQUNuQixHQUFHdEg7SUFFSixJQUFJLENBQUNzSCxvQkFBb0I7UUFDdkIsT0FBTyxFQUFFO0lBQ1g7SUFFQSxNQUFNeEIsYUFBYSxFQUFFO0lBRXJCLEtBQUssTUFBTWtCLHNCQUFzQkQsb0JBQXFCO1FBQ3BELE1BQU0sRUFDSi9JLEVBQUUsRUFDSCxHQUFHZ0o7UUFDSixNQUFNNUIsT0FBTzBCLGVBQWVuUyxHQUFHLENBQUNxSjtRQUVoQyxJQUFJb0gsUUFBUStCLGtCQUFrQkcsb0JBQW9CbEMsT0FBTztZQUN2RDs7OztPQUlDLEdBQ0QsTUFBTW1DLFVBQVUzQixtQkFBbUJSO1lBQ25DLE1BQU1vQyxZQUFZRCxRQUFRbkosTUFBTSxDQUFDLENBQUNDLGFBQWFvSjtnQkFDN0MsT0FBT3BKLGNBQWN5RyxnQkFBZ0J3QyxvQkFBb0JHO1lBQzNELEdBQUc7WUFDSCxNQUFNQyxvQkFBb0JoQixPQUFPLEFBQUNjLENBQUFBLFlBQVksQ0FBQSxFQUFHYixPQUFPLENBQUM7WUFDekRiLFdBQVdtQixJQUFJLENBQUM7Z0JBQ2RqSjtnQkFDQXdILE1BQU07b0JBQ0p3QjtvQkFDQWxWLE9BQU80VjtnQkFDVDtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU81QixXQUFXb0IsSUFBSSxDQUFDM0I7QUFDekI7QUFFQSxTQUFTb0MsWUFBWW5JLFNBQVMsRUFBRW9JLEtBQUssRUFBRUMsS0FBSztJQUMxQyxPQUFPO1FBQUUsR0FBR3JJLFNBQVM7UUFDbkJJLFFBQVFnSSxTQUFTQyxRQUFRRCxNQUFNMUcsS0FBSyxHQUFHMkcsTUFBTTNHLEtBQUssR0FBRztRQUNyRHJCLFFBQVErSCxTQUFTQyxRQUFRRCxNQUFNekcsTUFBTSxHQUFHMEcsTUFBTTFHLE1BQU0sR0FBRztJQUN6RDtBQUNGO0FBRUEsU0FBUzJHLGFBQWFGLEtBQUssRUFBRUMsS0FBSztJQUNoQyxPQUFPRCxTQUFTQyxRQUFRO1FBQ3RCalcsR0FBR2dXLE1BQU0zRyxJQUFJLEdBQUc0RyxNQUFNNUcsSUFBSTtRQUMxQjdCLEdBQUd3SSxNQUFNNUcsR0FBRyxHQUFHNkcsTUFBTTdHLEdBQUc7SUFDMUIsSUFBSTZEO0FBQ047QUFFQSxTQUFTa0QsdUJBQXVCN0osUUFBUTtJQUN0QyxPQUFPLFNBQVM4SixpQkFBaUI1QyxJQUFJO1FBQ25DLElBQUssSUFBSTdJLE9BQU9DLFVBQVVwRyxNQUFNLEVBQUUrSCxjQUFjLElBQUlsRSxNQUFNc0MsT0FBTyxJQUFJQSxPQUFPLElBQUksSUFBSUcsT0FBTyxHQUFHQSxPQUFPSCxNQUFNRyxPQUFRO1lBQ2pIeUIsV0FBVyxDQUFDekIsT0FBTyxFQUFFLEdBQUdGLFNBQVMsQ0FBQ0UsS0FBSztRQUN6QztRQUVBLE9BQU95QixZQUFZQyxNQUFNLENBQUMsQ0FBQzZKLEtBQUszSixhQUFnQixDQUFBO2dCQUFFLEdBQUcySixHQUFHO2dCQUN0RGpILEtBQUtpSCxJQUFJakgsR0FBRyxHQUFHOUMsV0FBV0ksV0FBV2MsQ0FBQztnQkFDdENpSCxRQUFRNEIsSUFBSTVCLE1BQU0sR0FBR25JLFdBQVdJLFdBQVdjLENBQUM7Z0JBQzVDNkIsTUFBTWdILElBQUloSCxJQUFJLEdBQUcvQyxXQUFXSSxXQUFXMU0sQ0FBQztnQkFDeEN1VSxPQUFPOEIsSUFBSTlCLEtBQUssR0FBR2pJLFdBQVdJLFdBQVcxTSxDQUFDO1lBQzVDLENBQUEsR0FBSTtZQUFFLEdBQUd3VCxJQUFJO1FBQ2I7SUFDRjtBQUNGO0FBQ0EsTUFBTThDLGtCQUFrQixXQUFXLEdBQUVILHVCQUF1QjtBQUU1RCxTQUFTSSxlQUFlM0ksU0FBUztJQUMvQixJQUFJQSxVQUFVNEksVUFBVSxDQUFDLGNBQWM7UUFDckMsTUFBTUMsaUJBQWlCN0ksVUFBVThJLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBR3BTLEtBQUssQ0FBQztRQUNwRCxPQUFPO1lBQ0x0RSxHQUFHLENBQUN5VyxjQUFjLENBQUMsR0FBRztZQUN0QmpKLEdBQUcsQ0FBQ2lKLGNBQWMsQ0FBQyxHQUFHO1lBQ3RCekksUUFBUSxDQUFDeUksY0FBYyxDQUFDLEVBQUU7WUFDMUJ4SSxRQUFRLENBQUN3SSxjQUFjLENBQUMsRUFBRTtRQUM1QjtJQUNGLE9BQU8sSUFBSTdJLFVBQVU0SSxVQUFVLENBQUMsWUFBWTtRQUMxQyxNQUFNQyxpQkFBaUI3SSxVQUFVOEksS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHcFMsS0FBSyxDQUFDO1FBQ3BELE9BQU87WUFDTHRFLEdBQUcsQ0FBQ3lXLGNBQWMsQ0FBQyxFQUFFO1lBQ3JCakosR0FBRyxDQUFDaUosY0FBYyxDQUFDLEVBQUU7WUFDckJ6SSxRQUFRLENBQUN5SSxjQUFjLENBQUMsRUFBRTtZQUMxQnhJLFFBQVEsQ0FBQ3dJLGNBQWMsQ0FBQyxFQUFFO1FBQzVCO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTRSxpQkFBaUJuRCxJQUFJLEVBQUU1RixTQUFTLEVBQUU4RixlQUFlO0lBQ3hELE1BQU1rRCxrQkFBa0JMLGVBQWUzSTtJQUV2QyxJQUFJLENBQUNnSixpQkFBaUI7UUFDcEIsT0FBT3BEO0lBQ1Q7SUFFQSxNQUFNLEVBQ0p4RixNQUFNLEVBQ05DLE1BQU0sRUFDTmpPLEdBQUc2VyxVQUFVLEVBQ2JySixHQUFHc0osVUFBVSxFQUNkLEdBQUdGO0lBQ0osTUFBTTVXLElBQUl3VCxLQUFLbkUsSUFBSSxHQUFHd0gsYUFBYSxBQUFDLENBQUEsSUFBSTdJLE1BQUssSUFBSytJLFdBQVdyRDtJQUM3RCxNQUFNbEcsSUFBSWdHLEtBQUtwRSxHQUFHLEdBQUcwSCxhQUFhLEFBQUMsQ0FBQSxJQUFJN0ksTUFBSyxJQUFLOEksV0FBV3JELGdCQUFnQmdELEtBQUssQ0FBQ2hELGdCQUFnQmxSLE9BQU8sQ0FBQyxPQUFPO0lBQ2pILE1BQU13VSxJQUFJaEosU0FBU3dGLEtBQUtsRSxLQUFLLEdBQUd0QixTQUFTd0YsS0FBS2xFLEtBQUs7SUFDbkQsTUFBTTJILElBQUloSixTQUFTdUYsS0FBS2pFLE1BQU0sR0FBR3RCLFNBQVN1RixLQUFLakUsTUFBTTtJQUNyRCxPQUFPO1FBQ0xELE9BQU8wSDtRQUNQekgsUUFBUTBIO1FBQ1I3SCxLQUFLNUI7UUFDTCtHLE9BQU92VSxJQUFJZ1g7UUFDWHZDLFFBQVFqSCxJQUFJeUo7UUFDWjVILE1BQU1yUDtJQUNSO0FBQ0Y7QUFFQSxNQUFNa1gsaUJBQWlCO0lBQ3JCQyxpQkFBaUI7QUFDbkI7QUFDQTs7Q0FFQyxHQUVELFNBQVNDLGNBQWN4UCxPQUFPLEVBQUVrTCxPQUFPO0lBQ3JDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVb0U7SUFDWjtJQUVBLElBQUkxRCxPQUFPNUwsUUFBUXlQLHFCQUFxQjtJQUV4QyxJQUFJdkUsUUFBUXFFLGVBQWUsRUFBRTtRQUMzQixNQUFNLEVBQ0p2SixTQUFTLEVBQ1Q4RixlQUFlLEVBQ2hCLEdBQUdySyxVQUFVekIsU0FBUzBQLGdCQUFnQixDQUFDMVA7UUFFeEMsSUFBSWdHLFdBQVc7WUFDYjRGLE9BQU9tRCxpQkFBaUJuRCxNQUFNNUYsV0FBVzhGO1FBQzNDO0lBQ0Y7SUFFQSxNQUFNLEVBQ0p0RSxHQUFHLEVBQ0hDLElBQUksRUFDSkMsS0FBSyxFQUNMQyxNQUFNLEVBQ05rRixNQUFNLEVBQ05GLEtBQUssRUFDTixHQUFHZjtJQUNKLE9BQU87UUFDTHBFO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FrRjtRQUNBRjtJQUNGO0FBQ0Y7QUFDQTs7Ozs7OztDQU9DLEdBRUQsU0FBU2dELCtCQUErQjNQLE9BQU87SUFDN0MsT0FBT3dQLGNBQWN4UCxTQUFTO1FBQzVCdVAsaUJBQWlCO0lBQ25CO0FBQ0Y7QUFFQSxTQUFTSyxvQkFBb0I1UCxPQUFPO0lBQ2xDLE1BQU0wSCxRQUFRMUgsUUFBUTZQLFVBQVU7SUFDaEMsTUFBTWxJLFNBQVMzSCxRQUFROFAsV0FBVztJQUNsQyxPQUFPO1FBQ0x0SSxLQUFLO1FBQ0xDLE1BQU07UUFDTmtGLE9BQU9qRjtRQUNQbUYsUUFBUWxGO1FBQ1JEO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNvSSxRQUFRNVEsSUFBSSxFQUFFNlEsYUFBYTtJQUNsQyxJQUFJQSxrQkFBa0IsS0FBSyxHQUFHO1FBQzVCQSxnQkFBZ0J2TyxVQUFVdEMsTUFBTXVRLGdCQUFnQixDQUFDdlE7SUFDbkQ7SUFFQSxPQUFPNlEsY0FBY3pJLFFBQVEsS0FBSztBQUNwQztBQUVBLFNBQVMwSSxhQUFhalEsT0FBTyxFQUFFZ1EsYUFBYTtJQUMxQyxJQUFJQSxrQkFBa0IsS0FBSyxHQUFHO1FBQzVCQSxnQkFBZ0J2TyxVQUFVekIsU0FBUzBQLGdCQUFnQixDQUFDMVA7SUFDdEQ7SUFFQSxNQUFNa1EsZ0JBQWdCO0lBQ3RCLE1BQU1DLGFBQWE7UUFBQztRQUFZO1FBQWE7S0FBWTtJQUN6RCxPQUFPQSxXQUFXQyxJQUFJLENBQUMzSixDQUFBQTtRQUNyQixNQUFNbk8sUUFBUTBYLGFBQWEsQ0FBQ3ZKLFNBQVM7UUFDckMsT0FBTyxPQUFPbk8sVUFBVSxXQUFXNFgsY0FBY0csSUFBSSxDQUFDL1gsU0FBUztJQUNqRTtBQUNGO0FBRUEsU0FBU2dZLHVCQUF1QnRRLE9BQU8sRUFBRXVRLEtBQUs7SUFDNUMsTUFBTUMsZ0JBQWdCLEVBQUU7SUFFeEIsU0FBU0Msd0JBQXdCdFIsSUFBSTtRQUNuQyxJQUFJb1IsU0FBUyxRQUFRQyxjQUFjNVQsTUFBTSxJQUFJMlQsT0FBTztZQUNsRCxPQUFPQztRQUNUO1FBRUEsSUFBSSxDQUFDclIsTUFBTTtZQUNULE9BQU9xUjtRQUNUO1FBRUEsSUFBSXpPLFdBQVc1QyxTQUFTQSxLQUFLdVIsZ0JBQWdCLElBQUksUUFBUSxDQUFDRixjQUFjM1QsUUFBUSxDQUFDc0MsS0FBS3VSLGdCQUFnQixHQUFHO1lBQ3ZHRixjQUFjL0MsSUFBSSxDQUFDdE8sS0FBS3VSLGdCQUFnQjtZQUN4QyxPQUFPRjtRQUNUO1FBRUEsSUFBSSxDQUFDdk8sY0FBYzlDLFNBQVNnRCxhQUFhaEQsT0FBTztZQUM5QyxPQUFPcVI7UUFDVDtRQUVBLElBQUlBLGNBQWMzVCxRQUFRLENBQUNzQyxPQUFPO1lBQ2hDLE9BQU9xUjtRQUNUO1FBRUEsTUFBTVIsZ0JBQWdCdk8sVUFBVXpCLFNBQVMwUCxnQkFBZ0IsQ0FBQ3ZRO1FBRTFELElBQUlBLFNBQVNhLFNBQVM7WUFDcEIsSUFBSWlRLGFBQWE5USxNQUFNNlEsZ0JBQWdCO2dCQUNyQ1EsY0FBYy9DLElBQUksQ0FBQ3RPO1lBQ3JCO1FBQ0Y7UUFFQSxJQUFJNFEsUUFBUTVRLE1BQU02USxnQkFBZ0I7WUFDaEMsT0FBT1E7UUFDVDtRQUVBLE9BQU9DLHdCQUF3QnRSLEtBQUt3UixVQUFVO0lBQ2hEO0lBRUEsSUFBSSxDQUFDM1EsU0FBUztRQUNaLE9BQU93UTtJQUNUO0lBRUEsT0FBT0Msd0JBQXdCelE7QUFDakM7QUFDQSxTQUFTNFEsMkJBQTJCelIsSUFBSTtJQUN0QyxNQUFNLENBQUMwUix3QkFBd0IsR0FBR1AsdUJBQXVCblIsTUFBTTtJQUMvRCxPQUFPMFIsMkJBQTJCLE9BQU9BLDBCQUEwQjtBQUNyRTtBQUVBLFNBQVNDLHFCQUFxQjlRLE9BQU87SUFDbkMsSUFBSSxDQUFDaUIsYUFBYSxDQUFDakIsU0FBUztRQUMxQixPQUFPO0lBQ1Q7SUFFQSxJQUFJcUIsU0FBU3JCLFVBQVU7UUFDckIsT0FBT0E7SUFDVDtJQUVBLElBQUksQ0FBQ3dCLE9BQU94QixVQUFVO1FBQ3BCLE9BQU87SUFDVDtJQUVBLElBQUkrQixXQUFXL0IsWUFBWUEsWUFBWXFDLGlCQUFpQnJDLFNBQVMwUSxnQkFBZ0IsRUFBRTtRQUNqRixPQUFPeFA7SUFDVDtJQUVBLElBQUllLGNBQWNqQyxVQUFVO1FBQzFCLE9BQU9BO0lBQ1Q7SUFFQSxPQUFPO0FBQ1Q7QUFFQSxTQUFTK1EscUJBQXFCL1EsT0FBTztJQUNuQyxJQUFJcUIsU0FBU3JCLFVBQVU7UUFDckIsT0FBT0EsUUFBUWdSLE9BQU87SUFDeEI7SUFFQSxPQUFPaFIsUUFBUWlSLFVBQVU7QUFDM0I7QUFDQSxTQUFTQyxxQkFBcUJsUixPQUFPO0lBQ25DLElBQUlxQixTQUFTckIsVUFBVTtRQUNyQixPQUFPQSxRQUFRbVIsT0FBTztJQUN4QjtJQUVBLE9BQU9uUixRQUFRb1IsU0FBUztBQUMxQjtBQUNBLFNBQVNDLHFCQUFxQnJSLE9BQU87SUFDbkMsT0FBTztRQUNMNUgsR0FBRzJZLHFCQUFxQi9RO1FBQ3hCNEYsR0FBR3NMLHFCQUFxQmxSO0lBQzFCO0FBQ0Y7QUFFQSxJQUFJc1I7QUFFSCxDQUFBLFNBQVVBLFNBQVM7SUFDbEJBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDdENBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxDQUFDLEVBQUUsR0FBRztBQUMxQyxDQUFBLEVBQUdBLGFBQWNBLENBQUFBLFlBQVksQ0FBQyxDQUFBO0FBRTlCLFNBQVNDLDJCQUEyQnZSLE9BQU87SUFDekMsSUFBSSxDQUFDaUIsYUFBYSxDQUFDakIsU0FBUztRQUMxQixPQUFPO0lBQ1Q7SUFFQSxPQUFPQSxZQUFZbUIsU0FBU3VQLGdCQUFnQjtBQUM5QztBQUVBLFNBQVNjLGtCQUFrQkMsa0JBQWtCO0lBQzNDLE1BQU1DLFlBQVk7UUFDaEJ0WixHQUFHO1FBQ0h3TixHQUFHO0lBQ0w7SUFDQSxNQUFNK0wsYUFBYUosMkJBQTJCRSxzQkFBc0I7UUFDbEU5SixRQUFRekcsT0FBTzRPLFdBQVc7UUFDMUJwSSxPQUFPeEcsT0FBTzJPLFVBQVU7SUFDMUIsSUFBSTtRQUNGbEksUUFBUThKLG1CQUFtQkcsWUFBWTtRQUN2Q2xLLE9BQU8rSixtQkFBbUJJLFdBQVc7SUFDdkM7SUFDQSxNQUFNQyxZQUFZO1FBQ2hCMVosR0FBR3FaLG1CQUFtQk0sV0FBVyxHQUFHSixXQUFXakssS0FBSztRQUNwRDlCLEdBQUc2TCxtQkFBbUJPLFlBQVksR0FBR0wsV0FBV2hLLE1BQU07SUFDeEQ7SUFDQSxNQUFNc0ssUUFBUVIsbUJBQW1CTCxTQUFTLElBQUlNLFVBQVU5TCxDQUFDO0lBQ3pELE1BQU1zTSxTQUFTVCxtQkFBbUJSLFVBQVUsSUFBSVMsVUFBVXRaLENBQUM7SUFDM0QsTUFBTStaLFdBQVdWLG1CQUFtQkwsU0FBUyxJQUFJVSxVQUFVbE0sQ0FBQztJQUM1RCxNQUFNd00sVUFBVVgsbUJBQW1CUixVQUFVLElBQUlhLFVBQVUxWixDQUFDO0lBQzVELE9BQU87UUFDTDZaO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FOO1FBQ0FKO0lBQ0Y7QUFDRjtBQUVBLE1BQU1XLG1CQUFtQjtJQUN2QmphLEdBQUc7SUFDSHdOLEdBQUc7QUFDTDtBQUNBLFNBQVMwTSwyQkFBMkJDLGVBQWUsRUFBRUMsbUJBQW1CLEVBQUVoTSxJQUFJLEVBQUVpTSxZQUFZLEVBQUVDLG1CQUFtQjtJQUMvRyxJQUFJLEVBQ0ZsTCxHQUFHLEVBQ0hDLElBQUksRUFDSmtGLEtBQUssRUFDTEUsTUFBTSxFQUNQLEdBQUdyRztJQUVKLElBQUlpTSxpQkFBaUIsS0FBSyxHQUFHO1FBQzNCQSxlQUFlO0lBQ2pCO0lBRUEsSUFBSUMsd0JBQXdCLEtBQUssR0FBRztRQUNsQ0Esc0JBQXNCTDtJQUN4QjtJQUVBLE1BQU0sRUFDSkosS0FBSyxFQUNMRSxRQUFRLEVBQ1JELE1BQU0sRUFDTkUsT0FBTyxFQUNSLEdBQUdaLGtCQUFrQmU7SUFDdEIsTUFBTUksWUFBWTtRQUNoQnZhLEdBQUc7UUFDSHdOLEdBQUc7SUFDTDtJQUNBLE1BQU1nTixRQUFRO1FBQ1p4YSxHQUFHO1FBQ0h3TixHQUFHO0lBQ0w7SUFDQSxNQUFNaU4sWUFBWTtRQUNoQmxMLFFBQVE2SyxvQkFBb0I3SyxNQUFNLEdBQUcrSyxvQkFBb0I5TSxDQUFDO1FBQzFEOEIsT0FBTzhLLG9CQUFvQjlLLEtBQUssR0FBR2dMLG9CQUFvQnRhLENBQUM7SUFDMUQ7SUFFQSxJQUFJLENBQUM2WixTQUFTekssT0FBT2dMLG9CQUFvQmhMLEdBQUcsR0FBR3FMLFVBQVVsTCxNQUFNLEVBQUU7UUFDL0QsWUFBWTtRQUNaZ0wsVUFBVS9NLENBQUMsR0FBRzBMLFVBQVV3QixRQUFRO1FBQ2hDRixNQUFNaE4sQ0FBQyxHQUFHNk0sZUFBZXhNLEtBQUs4TSxHQUFHLENBQUMsQUFBQ1AsQ0FBQUEsb0JBQW9CaEwsR0FBRyxHQUFHcUwsVUFBVWxMLE1BQU0sR0FBR0gsR0FBRSxJQUFLcUwsVUFBVWxMLE1BQU07SUFDekcsT0FBTyxJQUFJLENBQUN3SyxZQUFZdEYsVUFBVTJGLG9CQUFvQjNGLE1BQU0sR0FBR2dHLFVBQVVsTCxNQUFNLEVBQUU7UUFDL0UsY0FBYztRQUNkZ0wsVUFBVS9NLENBQUMsR0FBRzBMLFVBQVUwQixPQUFPO1FBQy9CSixNQUFNaE4sQ0FBQyxHQUFHNk0sZUFBZXhNLEtBQUs4TSxHQUFHLENBQUMsQUFBQ1AsQ0FBQUEsb0JBQW9CM0YsTUFBTSxHQUFHZ0csVUFBVWxMLE1BQU0sR0FBR2tGLE1BQUssSUFBS2dHLFVBQVVsTCxNQUFNO0lBQy9HO0lBRUEsSUFBSSxDQUFDeUssV0FBV3pGLFNBQVM2RixvQkFBb0I3RixLQUFLLEdBQUdrRyxVQUFVbkwsS0FBSyxFQUFFO1FBQ3BFLGVBQWU7UUFDZmlMLFVBQVV2YSxDQUFDLEdBQUdrWixVQUFVMEIsT0FBTztRQUMvQkosTUFBTXhhLENBQUMsR0FBR3FhLGVBQWV4TSxLQUFLOE0sR0FBRyxDQUFDLEFBQUNQLENBQUFBLG9CQUFvQjdGLEtBQUssR0FBR2tHLFVBQVVuTCxLQUFLLEdBQUdpRixLQUFJLElBQUtrRyxVQUFVbkwsS0FBSztJQUMzRyxPQUFPLElBQUksQ0FBQ3dLLFVBQVV6SyxRQUFRK0ssb0JBQW9CL0ssSUFBSSxHQUFHb0wsVUFBVW5MLEtBQUssRUFBRTtRQUN4RSxjQUFjO1FBQ2RpTCxVQUFVdmEsQ0FBQyxHQUFHa1osVUFBVXdCLFFBQVE7UUFDaENGLE1BQU14YSxDQUFDLEdBQUdxYSxlQUFleE0sS0FBSzhNLEdBQUcsQ0FBQyxBQUFDUCxDQUFBQSxvQkFBb0IvSyxJQUFJLEdBQUdvTCxVQUFVbkwsS0FBSyxHQUFHRCxJQUFHLElBQUtvTCxVQUFVbkwsS0FBSztJQUN6RztJQUVBLE9BQU87UUFDTGlMO1FBQ0FDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNLLHFCQUFxQmpULE9BQU87SUFDbkMsSUFBSUEsWUFBWW1CLFNBQVN1UCxnQkFBZ0IsRUFBRTtRQUN6QyxNQUFNLEVBQ0piLFVBQVUsRUFDVkMsV0FBVyxFQUNaLEdBQUc1TztRQUNKLE9BQU87WUFDTHNHLEtBQUs7WUFDTEMsTUFBTTtZQUNOa0YsT0FBT2tEO1lBQ1BoRCxRQUFRaUQ7WUFDUnBJLE9BQU9tSTtZQUNQbEksUUFBUW1JO1FBQ1Y7SUFDRjtJQUVBLE1BQU0sRUFDSnRJLEdBQUcsRUFDSEMsSUFBSSxFQUNKa0YsS0FBSyxFQUNMRSxNQUFNLEVBQ1AsR0FBRzdNLFFBQVF5UCxxQkFBcUI7SUFDakMsT0FBTztRQUNMakk7UUFDQUM7UUFDQWtGO1FBQ0FFO1FBQ0FuRixPQUFPMUgsUUFBUTZSLFdBQVc7UUFDMUJsSyxRQUFRM0gsUUFBUTRSLFlBQVk7SUFDOUI7QUFDRjtBQUVBLFNBQVNzQixpQkFBaUJDLG1CQUFtQjtJQUMzQyxPQUFPQSxvQkFBb0J2TyxNQUFNLENBQUMsQ0FBQzZKLEtBQUt0UDtRQUN0QyxPQUFPNkYsSUFBSXlKLEtBQUs0QyxxQkFBcUJsUztJQUN2QyxHQUFHa007QUFDTDtBQUNBLFNBQVMrSCxpQkFBaUJELG1CQUFtQjtJQUMzQyxPQUFPQSxvQkFBb0J2TyxNQUFNLENBQUMsQ0FBQzZKLEtBQUt0UDtRQUN0QyxPQUFPc1AsTUFBTXNDLHFCQUFxQjVSO0lBQ3BDLEdBQUc7QUFDTDtBQUNBLFNBQVNrVSxpQkFBaUJGLG1CQUFtQjtJQUMzQyxPQUFPQSxvQkFBb0J2TyxNQUFNLENBQUMsQ0FBQzZKLEtBQUt0UDtRQUN0QyxPQUFPc1AsTUFBTXlDLHFCQUFxQi9SO0lBQ3BDLEdBQUc7QUFDTDtBQUVBLFNBQVNtVSx1QkFBdUJ0VCxPQUFPLEVBQUV1VCxPQUFPO0lBQzlDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVL0Q7SUFDWjtJQUVBLElBQUksQ0FBQ3hQLFNBQVM7UUFDWjtJQUNGO0lBRUEsTUFBTSxFQUNKd0gsR0FBRyxFQUNIQyxJQUFJLEVBQ0pvRixNQUFNLEVBQ05GLEtBQUssRUFDTixHQUFHNEcsUUFBUXZUO0lBQ1osTUFBTTZRLDBCQUEwQkQsMkJBQTJCNVE7SUFFM0QsSUFBSSxDQUFDNlEseUJBQXlCO1FBQzVCO0lBQ0Y7SUFFQSxJQUFJaEUsVUFBVSxLQUFLRixTQUFTLEtBQUtuRixPQUFPdEcsT0FBTzRPLFdBQVcsSUFBSXJJLFFBQVF2RyxPQUFPMk8sVUFBVSxFQUFFO1FBQ3ZGN1AsUUFBUXdULGNBQWMsQ0FBQztZQUNyQkMsT0FBTztZQUNQQyxRQUFRO1FBQ1Y7SUFDRjtBQUNGO0FBRUEsTUFBTXZELGFBQWE7SUFBQztRQUFDO1FBQUs7WUFBQztZQUFRO1NBQVE7UUFBRWlEO0tBQWlCO0lBQUU7UUFBQztRQUFLO1lBQUM7WUFBTztTQUFTO1FBQUVDO0tBQWlCO0NBQUM7QUFDM0csTUFBTU07SUFDSixZQUFZL0gsSUFBSSxFQUFFNUwsT0FBTyxDQUFFO1FBQ3pCLElBQUksQ0FBQzRMLElBQUksR0FBRyxLQUFLO1FBQ2pCLElBQUksQ0FBQ2xFLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDSCxHQUFHLEdBQUcsS0FBSztRQUNoQixJQUFJLENBQUNxRixNQUFNLEdBQUcsS0FBSztRQUNuQixJQUFJLENBQUNGLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ2xGLElBQUksR0FBRyxLQUFLO1FBQ2pCLE1BQU0wTCxzQkFBc0I3Qyx1QkFBdUJ0UTtRQUNuRCxNQUFNNFQsZ0JBQWdCVixpQkFBaUJDO1FBQ3ZDLElBQUksQ0FBQ3ZILElBQUksR0FBRztZQUFFLEdBQUdBLElBQUk7UUFDckI7UUFDQSxJQUFJLENBQUNsRSxLQUFLLEdBQUdrRSxLQUFLbEUsS0FBSztRQUN2QixJQUFJLENBQUNDLE1BQU0sR0FBR2lFLEtBQUtqRSxNQUFNO1FBRXpCLEtBQUssTUFBTSxDQUFDa00sTUFBTS9VLE1BQU1nVixnQkFBZ0IsSUFBSTNELFdBQVk7WUFDdEQsS0FBSyxNQUFNbmEsT0FBTzhJLEtBQU07Z0JBQ3RCN0UsT0FBTzBCLGNBQWMsQ0FBQyxJQUFJLEVBQUUzRixLQUFLO29CQUMvQm1GLEtBQUs7d0JBQ0gsTUFBTTRZLGlCQUFpQkQsZ0JBQWdCWDt3QkFDdkMsTUFBTWEsc0JBQXNCSixhQUFhLENBQUNDLEtBQUssR0FBR0U7d0JBQ2xELE9BQU8sSUFBSSxDQUFDbkksSUFBSSxDQUFDNVYsSUFBSSxHQUFHZ2U7b0JBQzFCO29CQUNBamEsWUFBWTtnQkFDZDtZQUNGO1FBQ0Y7UUFFQUUsT0FBTzBCLGNBQWMsQ0FBQyxJQUFJLEVBQUUsUUFBUTtZQUNsQzVCLFlBQVk7UUFDZDtJQUNGO0FBRUY7QUFFQSxNQUFNa2E7SUFnQkpqUCxJQUFJa1AsU0FBUyxFQUFFeFIsT0FBTyxFQUFFd0ksT0FBTyxFQUFFO1FBQy9CLElBQUlpSjtRQUVIQSxDQUFBQSxnQkFBZ0IsSUFBSSxDQUFDelMsTUFBTSxBQUFELEtBQU0sT0FBTyxLQUFLLElBQUl5UyxjQUFjQyxnQkFBZ0IsQ0FBQ0YsV0FBV3hSLFNBQVN3STtRQUNwRyxJQUFJLENBQUNuQyxTQUFTLENBQUMwRSxJQUFJLENBQUM7WUFBQ3lHO1lBQVd4UjtZQUFTd0k7U0FBUTtJQUNuRDtJQXBCQSxZQUFZeEosTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDcUgsU0FBUyxHQUFHLEVBQUU7UUFFbkIsSUFBSSxDQUFDc0wsU0FBUyxHQUFHO1lBQ2YsSUFBSSxDQUFDdEwsU0FBUyxDQUFDSSxPQUFPLENBQUM5RixDQUFBQTtnQkFDckIsSUFBSWlSO2dCQUVKLE9BQU8sQUFBQ0EsQ0FBQUEsZUFBZSxJQUFJLENBQUM1UyxNQUFNLEFBQUQsS0FBTSxPQUFPLEtBQUssSUFBSTRTLGFBQWFDLG1CQUFtQixJQUFJbFI7WUFDN0Y7UUFDRjtRQUVBLElBQUksQ0FBQzNCLE1BQU0sR0FBR0E7SUFDaEI7QUFTRjtBQUVBLFNBQVM4Uyx1QkFBdUI5UyxNQUFNO0lBQ3BDLDJGQUEyRjtJQUMzRiw2RUFBNkU7SUFDN0UsOEVBQThFO0lBQzlFLDZFQUE2RTtJQUM3RSwrREFBK0Q7SUFDL0QsTUFBTSxFQUNKK1MsV0FBVyxFQUNaLEdBQUdoVCxVQUFVQztJQUNkLE9BQU9BLGtCQUFrQitTLGNBQWMvUyxTQUFTVyxpQkFBaUJYO0FBQ25FO0FBRUEsU0FBU2dULG9CQUFvQkMsS0FBSyxFQUFFQyxXQUFXO0lBQzdDLE1BQU1DLEtBQUs1TyxLQUFLOE0sR0FBRyxDQUFDNEIsTUFBTXZjLENBQUM7SUFDM0IsTUFBTTBjLEtBQUs3TyxLQUFLOE0sR0FBRyxDQUFDNEIsTUFBTS9PLENBQUM7SUFFM0IsSUFBSSxPQUFPZ1AsZ0JBQWdCLFVBQVU7UUFDbkMsT0FBTzNPLEtBQUt3RixJQUFJLENBQUNvSixNQUFNLElBQUlDLE1BQU0sS0FBS0Y7SUFDeEM7SUFFQSxJQUFJLE9BQU9BLGVBQWUsT0FBT0EsYUFBYTtRQUM1QyxPQUFPQyxLQUFLRCxZQUFZeGMsQ0FBQyxJQUFJMGMsS0FBS0YsWUFBWWhQLENBQUM7SUFDakQ7SUFFQSxJQUFJLE9BQU9nUCxhQUFhO1FBQ3RCLE9BQU9DLEtBQUtELFlBQVl4YyxDQUFDO0lBQzNCO0lBRUEsSUFBSSxPQUFPd2MsYUFBYTtRQUN0QixPQUFPRSxLQUFLRixZQUFZaFAsQ0FBQztJQUMzQjtJQUVBLE9BQU87QUFDVDtBQUVBLElBQUltUDtBQUVILENBQUEsU0FBVUEsU0FBUztJQUNsQkEsU0FBUyxDQUFDLFFBQVEsR0FBRztJQUNyQkEsU0FBUyxDQUFDLFlBQVksR0FBRztJQUN6QkEsU0FBUyxDQUFDLFVBQVUsR0FBRztJQUN2QkEsU0FBUyxDQUFDLGNBQWMsR0FBRztJQUMzQkEsU0FBUyxDQUFDLFNBQVMsR0FBRztJQUN0QkEsU0FBUyxDQUFDLGtCQUFrQixHQUFHO0lBQy9CQSxTQUFTLENBQUMsbUJBQW1CLEdBQUc7QUFDbEMsQ0FBQSxFQUFHQSxhQUFjQSxDQUFBQSxZQUFZLENBQUMsQ0FBQTtBQUU5QixTQUFTQyxlQUFlN1AsS0FBSztJQUMzQkEsTUFBTTZQLGNBQWM7QUFDdEI7QUFDQSxTQUFTQyxnQkFBZ0I5UCxLQUFLO0lBQzVCQSxNQUFNOFAsZUFBZTtBQUN2QjtBQUVBLElBQUlDO0FBRUgsQ0FBQSxTQUFVQSxZQUFZO0lBQ3JCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsS0FBSyxHQUFHO0lBQ3JCQSxZQUFZLENBQUMsTUFBTSxHQUFHO0lBQ3RCQSxZQUFZLENBQUMsUUFBUSxHQUFHO0lBQ3hCQSxZQUFZLENBQUMsTUFBTSxHQUFHO0FBQ3hCLENBQUEsRUFBR0EsZ0JBQWlCQSxDQUFBQSxlQUFlLENBQUMsQ0FBQTtBQUVwQyxNQUFNQyx1QkFBdUI7SUFDM0JDLE9BQU87UUFBQ0YsYUFBYUcsS0FBSztRQUFFSCxhQUFhSSxLQUFLO0tBQUM7SUFDL0NDLFFBQVE7UUFBQ0wsYUFBYU0sR0FBRztLQUFDO0lBQzFCQyxLQUFLO1FBQUNQLGFBQWFHLEtBQUs7UUFBRUgsYUFBYUksS0FBSztRQUFFSixhQUFhUSxHQUFHO0tBQUM7QUFDakU7QUFDQSxNQUFNQyxrQ0FBa0MsQ0FBQ3hRLE9BQU9xQjtJQUM5QyxJQUFJLEVBQ0ZvUCxrQkFBa0IsRUFDbkIsR0FBR3BQO0lBRUosT0FBUXJCLE1BQU0wUSxJQUFJO1FBQ2hCLEtBQUtYLGFBQWFZLEtBQUs7WUFDckIsT0FBTztnQkFBRSxHQUFHRixrQkFBa0I7Z0JBQzVCeGQsR0FBR3dkLG1CQUFtQnhkLENBQUMsR0FBRztZQUM1QjtRQUVGLEtBQUs4YyxhQUFhYSxJQUFJO1lBQ3BCLE9BQU87Z0JBQUUsR0FBR0gsa0JBQWtCO2dCQUM1QnhkLEdBQUd3ZCxtQkFBbUJ4ZCxDQUFDLEdBQUc7WUFDNUI7UUFFRixLQUFLOGMsYUFBYWMsSUFBSTtZQUNwQixPQUFPO2dCQUFFLEdBQUdKLGtCQUFrQjtnQkFDNUJoUSxHQUFHZ1EsbUJBQW1CaFEsQ0FBQyxHQUFHO1lBQzVCO1FBRUYsS0FBS3NQLGFBQWFlLEVBQUU7WUFDbEIsT0FBTztnQkFBRSxHQUFHTCxrQkFBa0I7Z0JBQzVCaFEsR0FBR2dRLG1CQUFtQmhRLENBQUMsR0FBRztZQUM1QjtJQUNKO0lBRUEsT0FBT3NRO0FBQ1Q7QUFFQSxNQUFNQztJQXFCSkMsU0FBUztRQUNQLElBQUksQ0FBQ0MsV0FBVztRQUNoQixJQUFJLENBQUNDLGVBQWUsQ0FBQ3RSLEdBQUcsQ0FBQytQLFVBQVV3QixNQUFNLEVBQUUsSUFBSSxDQUFDQyxZQUFZO1FBQzVELElBQUksQ0FBQ0YsZUFBZSxDQUFDdFIsR0FBRyxDQUFDK1AsVUFBVTBCLGdCQUFnQixFQUFFLElBQUksQ0FBQ0QsWUFBWTtRQUN0RUUsV0FBVyxJQUFNLElBQUksQ0FBQzNOLFNBQVMsQ0FBQy9ELEdBQUcsQ0FBQytQLFVBQVU0QixPQUFPLEVBQUUsSUFBSSxDQUFDQyxhQUFhO0lBQzNFO0lBRUFQLGNBQWM7UUFDWixNQUFNLEVBQ0pRLFVBQVUsRUFDVkMsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDMWdCLEtBQUs7UUFDZCxNQUFNK0ksT0FBTzBYLFdBQVcxWCxJQUFJLENBQUMwRCxPQUFPO1FBRXBDLElBQUkxRCxNQUFNO1lBQ1JtVSx1QkFBdUJuVTtRQUN6QjtRQUVBMlgsUUFBUXpMO0lBQ1Y7SUFFQXVMLGNBQWN6UixLQUFLLEVBQUU7UUFDbkIsSUFBSUMsZ0JBQWdCRCxRQUFRO1lBQzFCLE1BQU0sRUFDSnNFLE1BQU0sRUFDTnNOLE9BQU8sRUFDUDdMLE9BQU8sRUFDUixHQUFHLElBQUksQ0FBQzlVLEtBQUs7WUFDZCxNQUFNLEVBQ0o0Z0IsZ0JBQWdCN0Isb0JBQW9CLEVBQ3BDOEIsbUJBQW1CdEIsK0JBQStCLEVBQ2xEdUIsaUJBQWlCLFFBQVEsRUFDMUIsR0FBR2hNO1lBQ0osTUFBTSxFQUNKMkssSUFBSSxFQUNMLEdBQUcxUTtZQUVKLElBQUk2UixjQUFjdkIsR0FBRyxDQUFDNVksUUFBUSxDQUFDZ1osT0FBTztnQkFDcEMsSUFBSSxDQUFDc0IsU0FBUyxDQUFDaFM7Z0JBQ2Y7WUFDRjtZQUVBLElBQUk2UixjQUFjekIsTUFBTSxDQUFDMVksUUFBUSxDQUFDZ1osT0FBTztnQkFDdkMsSUFBSSxDQUFDVyxZQUFZLENBQUNyUjtnQkFDbEI7WUFDRjtZQUVBLE1BQU0sRUFDSmtJLGFBQWEsRUFDZCxHQUFHMEosUUFBUWxVLE9BQU87WUFDbkIsTUFBTStTLHFCQUFxQnZJLGdCQUFnQjtnQkFDekNqVixHQUFHaVYsY0FBYzVGLElBQUk7Z0JBQ3JCN0IsR0FBR3lILGNBQWM3RixHQUFHO1lBQ3RCLElBQUk2RDtZQUVKLElBQUksQ0FBQyxJQUFJLENBQUMrTCxvQkFBb0IsRUFBRTtnQkFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR3hCO1lBQzlCO1lBRUEsTUFBTXlCLGlCQUFpQkosaUJBQWlCOVIsT0FBTztnQkFDN0NzRTtnQkFDQXNOLFNBQVNBLFFBQVFsVSxPQUFPO2dCQUN4QitTO1lBQ0Y7WUFFQSxJQUFJeUIsZ0JBQWdCO2dCQUNsQixNQUFNQyxtQkFBbUJyUyxTQUFTb1MsZ0JBQWdCekI7Z0JBQ2xELE1BQU0yQixjQUFjO29CQUNsQm5mLEdBQUc7b0JBQ0h3TixHQUFHO2dCQUNMO2dCQUNBLE1BQU0sRUFDSnVOLG1CQUFtQixFQUNwQixHQUFHNEQsUUFBUWxVLE9BQU87Z0JBRW5CLEtBQUssTUFBTTBQLG1CQUFtQlksb0JBQXFCO29CQUNqRCxNQUFNUixZQUFZeE4sTUFBTTBRLElBQUk7b0JBQzVCLE1BQU0sRUFDSjVELEtBQUssRUFDTEcsT0FBTyxFQUNQRixNQUFNLEVBQ05DLFFBQVEsRUFDUkwsU0FBUyxFQUNUSixTQUFTLEVBQ1YsR0FBR0Ysa0JBQWtCZTtvQkFDdEIsTUFBTWlGLG9CQUFvQnZFLHFCQUFxQlY7b0JBQy9DLE1BQU1rRixxQkFBcUI7d0JBQ3pCcmYsR0FBRzZOLEtBQUsyRyxHQUFHLENBQUMrRixjQUFjdUMsYUFBYVksS0FBSyxHQUFHMEIsa0JBQWtCN0ssS0FBSyxHQUFHNkssa0JBQWtCOVAsS0FBSyxHQUFHLElBQUk4UCxrQkFBa0I3SyxLQUFLLEVBQUUxRyxLQUFLeUcsR0FBRyxDQUFDaUcsY0FBY3VDLGFBQWFZLEtBQUssR0FBRzBCLGtCQUFrQi9QLElBQUksR0FBRytQLGtCQUFrQi9QLElBQUksR0FBRytQLGtCQUFrQjlQLEtBQUssR0FBRyxHQUFHMlAsZUFBZWpmLENBQUM7d0JBQzNRd04sR0FBR0ssS0FBSzJHLEdBQUcsQ0FBQytGLGNBQWN1QyxhQUFhYyxJQUFJLEdBQUd3QixrQkFBa0IzSyxNQUFNLEdBQUcySyxrQkFBa0I3UCxNQUFNLEdBQUcsSUFBSTZQLGtCQUFrQjNLLE1BQU0sRUFBRTVHLEtBQUt5RyxHQUFHLENBQUNpRyxjQUFjdUMsYUFBYWMsSUFBSSxHQUFHd0Isa0JBQWtCaFEsR0FBRyxHQUFHZ1Esa0JBQWtCaFEsR0FBRyxHQUFHZ1Esa0JBQWtCN1AsTUFBTSxHQUFHLEdBQUcwUCxlQUFlelIsQ0FBQztvQkFDN1E7b0JBQ0EsTUFBTThSLGFBQWEvRSxjQUFjdUMsYUFBYVksS0FBSyxJQUFJLENBQUMxRCxXQUFXTyxjQUFjdUMsYUFBYWEsSUFBSSxJQUFJLENBQUM3RDtvQkFDdkcsTUFBTXlGLGFBQWFoRixjQUFjdUMsYUFBYWMsSUFBSSxJQUFJLENBQUM3RCxZQUFZUSxjQUFjdUMsYUFBYWUsRUFBRSxJQUFJLENBQUNoRTtvQkFFckcsSUFBSXlGLGNBQWNELG1CQUFtQnJmLENBQUMsS0FBS2lmLGVBQWVqZixDQUFDLEVBQUU7d0JBQzNELE1BQU13Zix1QkFBdUJyRixnQkFBZ0J0QixVQUFVLEdBQUdxRyxpQkFBaUJsZixDQUFDO3dCQUM1RSxNQUFNeWYsNEJBQTRCbEYsY0FBY3VDLGFBQWFZLEtBQUssSUFBSThCLHdCQUF3QjlGLFVBQVUxWixDQUFDLElBQUl1YSxjQUFjdUMsYUFBYWEsSUFBSSxJQUFJNkIsd0JBQXdCbEcsVUFBVXRaLENBQUM7d0JBRW5MLElBQUl5Ziw2QkFBNkIsQ0FBQ1AsaUJBQWlCMVIsQ0FBQyxFQUFFOzRCQUNwRCxnRkFBZ0Y7NEJBQ2hGLHFEQUFxRDs0QkFDckQyTSxnQkFBZ0J1RixRQUFRLENBQUM7Z0NBQ3ZCclEsTUFBTW1RO2dDQUNORyxVQUFVYjs0QkFDWjs0QkFDQTt3QkFDRjt3QkFFQSxJQUFJVywyQkFBMkI7NEJBQzdCTixZQUFZbmYsQ0FBQyxHQUFHbWEsZ0JBQWdCdEIsVUFBVSxHQUFHMkc7d0JBQy9DLE9BQU87NEJBQ0xMLFlBQVluZixDQUFDLEdBQUd1YSxjQUFjdUMsYUFBYVksS0FBSyxHQUFHdkQsZ0JBQWdCdEIsVUFBVSxHQUFHYSxVQUFVMVosQ0FBQyxHQUFHbWEsZ0JBQWdCdEIsVUFBVSxHQUFHUyxVQUFVdFosQ0FBQzt3QkFDeEk7d0JBRUEsSUFBSW1mLFlBQVluZixDQUFDLEVBQUU7NEJBQ2pCbWEsZ0JBQWdCeUYsUUFBUSxDQUFDO2dDQUN2QnZRLE1BQU0sQ0FBQzhQLFlBQVluZixDQUFDO2dDQUNwQjJmLFVBQVViOzRCQUNaO3dCQUNGO3dCQUVBO29CQUNGLE9BQU8sSUFBSVMsY0FBY0YsbUJBQW1CN1IsQ0FBQyxLQUFLeVIsZUFBZXpSLENBQUMsRUFBRTt3QkFDbEUsTUFBTWdTLHVCQUF1QnJGLGdCQUFnQm5CLFNBQVMsR0FBR2tHLGlCQUFpQjFSLENBQUM7d0JBQzNFLE1BQU1pUyw0QkFBNEJsRixjQUFjdUMsYUFBYWMsSUFBSSxJQUFJNEIsd0JBQXdCOUYsVUFBVWxNLENBQUMsSUFBSStNLGNBQWN1QyxhQUFhZSxFQUFFLElBQUkyQix3QkFBd0JsRyxVQUFVOUwsQ0FBQzt3QkFFaEwsSUFBSWlTLDZCQUE2QixDQUFDUCxpQkFBaUJsZixDQUFDLEVBQUU7NEJBQ3BELGdGQUFnRjs0QkFDaEYscURBQXFEOzRCQUNyRG1hLGdCQUFnQnVGLFFBQVEsQ0FBQztnQ0FDdkJ0USxLQUFLb1E7Z0NBQ0xHLFVBQVViOzRCQUNaOzRCQUNBO3dCQUNGO3dCQUVBLElBQUlXLDJCQUEyQjs0QkFDN0JOLFlBQVkzUixDQUFDLEdBQUcyTSxnQkFBZ0JuQixTQUFTLEdBQUd3Rzt3QkFDOUMsT0FBTzs0QkFDTEwsWUFBWTNSLENBQUMsR0FBRytNLGNBQWN1QyxhQUFhYyxJQUFJLEdBQUd6RCxnQkFBZ0JuQixTQUFTLEdBQUdVLFVBQVVsTSxDQUFDLEdBQUcyTSxnQkFBZ0JuQixTQUFTLEdBQUdNLFVBQVU5TCxDQUFDO3dCQUNySTt3QkFFQSxJQUFJMlIsWUFBWTNSLENBQUMsRUFBRTs0QkFDakIyTSxnQkFBZ0J5RixRQUFRLENBQUM7Z0NBQ3ZCeFEsS0FBSyxDQUFDK1AsWUFBWTNSLENBQUM7Z0NBQ25CbVMsVUFBVWI7NEJBQ1o7d0JBQ0Y7d0JBRUE7b0JBQ0Y7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDZSxVQUFVLENBQUM5UyxPQUFPSCxJQUFJQyxTQUFTb1MsZ0JBQWdCLElBQUksQ0FBQ0Qsb0JBQW9CLEdBQUdHO1lBQ2xGO1FBQ0Y7SUFDRjtJQUVBVSxXQUFXOVMsS0FBSyxFQUFFK1MsV0FBVyxFQUFFO1FBQzdCLE1BQU0sRUFDSkMsTUFBTSxFQUNQLEdBQUcsSUFBSSxDQUFDL2hCLEtBQUs7UUFDZCtPLE1BQU02UCxjQUFjO1FBQ3BCbUQsT0FBT0Q7SUFDVDtJQUVBZixVQUFVaFMsS0FBSyxFQUFFO1FBQ2YsTUFBTSxFQUNKaVQsS0FBSyxFQUNOLEdBQUcsSUFBSSxDQUFDaGlCLEtBQUs7UUFDZCtPLE1BQU02UCxjQUFjO1FBQ3BCLElBQUksQ0FBQ3FELE1BQU07UUFDWEQ7SUFDRjtJQUVBNUIsYUFBYXJSLEtBQUssRUFBRTtRQUNsQixNQUFNLEVBQ0ptVCxRQUFRLEVBQ1QsR0FBRyxJQUFJLENBQUNsaUIsS0FBSztRQUNkK08sTUFBTTZQLGNBQWM7UUFDcEIsSUFBSSxDQUFDcUQsTUFBTTtRQUNYQztJQUNGO0lBRUFELFNBQVM7UUFDUCxJQUFJLENBQUN0UCxTQUFTLENBQUNzTCxTQUFTO1FBQ3hCLElBQUksQ0FBQ2lDLGVBQWUsQ0FBQ2pDLFNBQVM7SUFDaEM7SUE5TUEsWUFBWWplLEtBQUssQ0FBRTtRQUNqQixJQUFJLENBQUNBLEtBQUssR0FBRyxLQUFLO1FBQ2xCLElBQUksQ0FBQ21pQixpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNuQixvQkFBb0IsR0FBRyxLQUFLO1FBQ2pDLElBQUksQ0FBQ3JPLFNBQVMsR0FBRyxLQUFLO1FBQ3RCLElBQUksQ0FBQ3VOLGVBQWUsR0FBRyxLQUFLO1FBQzVCLElBQUksQ0FBQ2xnQixLQUFLLEdBQUdBO1FBQ2IsTUFBTSxFQUNKK08sT0FBTyxFQUNMekQsTUFBTSxFQUNQLEVBQ0YsR0FBR3RMO1FBQ0osSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDMlMsU0FBUyxHQUFHLElBQUlrTCxVQUFVNVIsaUJBQWlCWDtRQUNoRCxJQUFJLENBQUM0VSxlQUFlLEdBQUcsSUFBSXJDLFVBQVV4UyxVQUFVQztRQUMvQyxJQUFJLENBQUNrVixhQUFhLEdBQUcsSUFBSSxDQUFDQSxhQUFhLENBQUM0QixJQUFJLENBQUMsSUFBSTtRQUNqRCxJQUFJLENBQUNoQyxZQUFZLEdBQUcsSUFBSSxDQUFDQSxZQUFZLENBQUNnQyxJQUFJLENBQUMsSUFBSTtRQUMvQyxJQUFJLENBQUNwQyxNQUFNO0lBQ2I7QUE4TEY7QUFDQUQsZUFBZXNDLFVBQVUsR0FBRztJQUFDO1FBQzNCdkUsV0FBVztRQUNYeFIsU0FBUyxDQUFDeUMsT0FBT3FCLE1BQU1tRDtZQUNyQixJQUFJLEVBQ0ZxTixnQkFBZ0I3QixvQkFBb0IsRUFDcEN1RCxZQUFZLEVBQ2IsR0FBR2xTO1lBQ0osSUFBSSxFQUNGaUQsTUFBTSxFQUNQLEdBQUdFO1lBQ0osTUFBTSxFQUNKa00sSUFBSSxFQUNMLEdBQUcxUSxNQUFNd1QsV0FBVztZQUVyQixJQUFJM0IsY0FBYzVCLEtBQUssQ0FBQ3ZZLFFBQVEsQ0FBQ2daLE9BQU87Z0JBQ3RDLE1BQU0rQyxZQUFZblAsT0FBT29QLGFBQWEsQ0FBQ2hXLE9BQU87Z0JBRTlDLElBQUkrVixhQUFhelQsTUFBTXpELE1BQU0sS0FBS2tYLFdBQVc7b0JBQzNDLE9BQU87Z0JBQ1Q7Z0JBRUF6VCxNQUFNNlAsY0FBYztnQkFDcEIwRCxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7b0JBQzNDdlQsT0FBT0EsTUFBTXdULFdBQVc7Z0JBQzFCO2dCQUNBLE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixTQUFTRyxxQkFBcUJDLFVBQVU7SUFDdEMsT0FBT0MsUUFBUUQsY0FBYyxjQUFjQTtBQUM3QztBQUVBLFNBQVNFLGtCQUFrQkYsVUFBVTtJQUNuQyxPQUFPQyxRQUFRRCxjQUFjLFdBQVdBO0FBQzFDO0FBRUEsTUFBTUc7SUEwQ0o5QyxTQUFTO1FBQ1AsTUFBTSxFQUNKK0MsTUFBTSxFQUNOL2lCLE9BQU8sRUFDTDhVLFNBQVMsRUFDUGtPLG9CQUFvQixFQUNwQkMsMEJBQTBCLEVBQzNCLEVBQ0YsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJLENBQUN0USxTQUFTLENBQUMvRCxHQUFHLENBQUNtVSxPQUFPRyxJQUFJLENBQUNyaUIsSUFBSSxFQUFFLElBQUksQ0FBQ2doQixVQUFVLEVBQUU7WUFDcERzQixTQUFTO1FBQ1g7UUFDQSxJQUFJLENBQUN4USxTQUFTLENBQUMvRCxHQUFHLENBQUNtVSxPQUFPMUQsR0FBRyxDQUFDeGUsSUFBSSxFQUFFLElBQUksQ0FBQ2tnQixTQUFTO1FBRWxELElBQUlnQyxPQUFPNUQsTUFBTSxFQUFFO1lBQ2pCLElBQUksQ0FBQ3hNLFNBQVMsQ0FBQy9ELEdBQUcsQ0FBQ21VLE9BQU81RCxNQUFNLENBQUN0ZSxJQUFJLEVBQUUsSUFBSSxDQUFDdWYsWUFBWTtRQUMxRDtRQUVBLElBQUksQ0FBQ0YsZUFBZSxDQUFDdFIsR0FBRyxDQUFDK1AsVUFBVXdCLE1BQU0sRUFBRSxJQUFJLENBQUNDLFlBQVk7UUFDNUQsSUFBSSxDQUFDRixlQUFlLENBQUN0UixHQUFHLENBQUMrUCxVQUFVeUUsU0FBUyxFQUFFeEU7UUFDOUMsSUFBSSxDQUFDc0IsZUFBZSxDQUFDdFIsR0FBRyxDQUFDK1AsVUFBVTBCLGdCQUFnQixFQUFFLElBQUksQ0FBQ0QsWUFBWTtRQUN0RSxJQUFJLENBQUNGLGVBQWUsQ0FBQ3RSLEdBQUcsQ0FBQytQLFVBQVUwRSxXQUFXLEVBQUV6RTtRQUNoRCxJQUFJLENBQUMwRSxpQkFBaUIsQ0FBQzFVLEdBQUcsQ0FBQytQLFVBQVU0QixPQUFPLEVBQUUsSUFBSSxDQUFDZ0QsYUFBYTtRQUVoRSxJQUFJUCxzQkFBc0I7WUFDeEIsSUFBSUMsOEJBQThCLFFBQVFBLDJCQUEyQjtnQkFDbkVsVSxPQUFPLElBQUksQ0FBQy9PLEtBQUssQ0FBQytPLEtBQUs7Z0JBQ3ZCMFIsWUFBWSxJQUFJLENBQUN6Z0IsS0FBSyxDQUFDeWdCLFVBQVU7Z0JBQ2pDM0wsU0FBUyxJQUFJLENBQUM5VSxLQUFLLENBQUM4VSxPQUFPO1lBQzdCLElBQUk7Z0JBQ0YsT0FBTyxJQUFJLENBQUNtTCxXQUFXO1lBQ3pCO1lBRUEsSUFBSTRDLGtCQUFrQkcsdUJBQXVCO2dCQUMzQyxJQUFJLENBQUNRLFNBQVMsR0FBR2xELFdBQVcsSUFBSSxDQUFDTCxXQUFXLEVBQUUrQyxxQkFBcUJTLEtBQUs7Z0JBQ3hFLElBQUksQ0FBQ0MsYUFBYSxDQUFDVjtnQkFDbkI7WUFDRjtZQUVBLElBQUlOLHFCQUFxQk0sdUJBQXVCO2dCQUM5QyxJQUFJLENBQUNVLGFBQWEsQ0FBQ1Y7Z0JBQ25CO1lBQ0Y7UUFDRjtRQUVBLElBQUksQ0FBQy9DLFdBQVc7SUFDbEI7SUFFQWdDLFNBQVM7UUFDUCxJQUFJLENBQUN0UCxTQUFTLENBQUNzTCxTQUFTO1FBQ3hCLElBQUksQ0FBQ2lDLGVBQWUsQ0FBQ2pDLFNBQVMsSUFBSSxvRUFBb0U7UUFDdEcseUZBQXlGO1FBRXpGcUMsV0FBVyxJQUFJLENBQUNnRCxpQkFBaUIsQ0FBQ3JGLFNBQVMsRUFBRTtRQUU3QyxJQUFJLElBQUksQ0FBQ3VGLFNBQVMsS0FBSyxNQUFNO1lBQzNCRyxhQUFhLElBQUksQ0FBQ0gsU0FBUztZQUMzQixJQUFJLENBQUNBLFNBQVMsR0FBRztRQUNuQjtJQUNGO0lBRUFFLGNBQWNmLFVBQVUsRUFBRWlCLE1BQU0sRUFBRTtRQUNoQyxNQUFNLEVBQ0p2USxNQUFNLEVBQ053USxTQUFTLEVBQ1YsR0FBRyxJQUFJLENBQUM3akIsS0FBSztRQUNkNmpCLFVBQVV4USxRQUFRc1AsWUFBWSxJQUFJLENBQUNtQixrQkFBa0IsRUFBRUY7SUFDekQ7SUFFQTNELGNBQWM7UUFDWixNQUFNLEVBQ0o2RCxrQkFBa0IsRUFDbkIsR0FBRyxJQUFJO1FBQ1IsTUFBTSxFQUNKcEQsT0FBTyxFQUNSLEdBQUcsSUFBSSxDQUFDMWdCLEtBQUs7UUFFZCxJQUFJOGpCLG9CQUFvQjtZQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRyxNQUFNLHVFQUF1RTtZQUU5RixJQUFJLENBQUNULGlCQUFpQixDQUFDMVUsR0FBRyxDQUFDK1AsVUFBVXFGLEtBQUssRUFBRW5GLGlCQUFpQjtnQkFDM0RvRixTQUFTO1lBQ1gsSUFBSSw4Q0FBOEM7WUFFbEQsSUFBSSxDQUFDQyxtQkFBbUIsSUFBSSxnREFBZ0Q7WUFFNUUsSUFBSSxDQUFDWixpQkFBaUIsQ0FBQzFVLEdBQUcsQ0FBQytQLFVBQVV3RixlQUFlLEVBQUUsSUFBSSxDQUFDRCxtQkFBbUI7WUFDOUV4RCxRQUFRb0Q7UUFDVjtJQUNGO0lBRUFqQyxXQUFXOVMsS0FBSyxFQUFFO1FBQ2hCLElBQUlxVjtRQUVKLE1BQU0sRUFDSkwsU0FBUyxFQUNURCxrQkFBa0IsRUFDbEI5akIsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLE1BQU0sRUFDSitoQixNQUFNLEVBQ05qTixTQUFTLEVBQ1BrTyxvQkFBb0IsRUFDckIsRUFDRixHQUFHaGpCO1FBRUosSUFBSSxDQUFDOGpCLG9CQUFvQjtZQUN2QjtRQUNGO1FBRUEsTUFBTWhDLGNBQWMsQUFBQ3NDLENBQUFBLHdCQUF3QmhWLG9CQUFvQkwsTUFBSyxLQUFNLE9BQU9xVix3QkFBd0JuUDtRQUMzRyxNQUFNc0osUUFBUTFQLFNBQVNpVixvQkFBb0JoQyxjQUFjLHdCQUF3QjtRQUVqRixJQUFJLENBQUNpQyxhQUFhZixzQkFBc0I7WUFDdEMsSUFBSU4scUJBQXFCTSx1QkFBdUI7Z0JBQzlDLElBQUlBLHFCQUFxQnFCLFNBQVMsSUFBSSxRQUFRL0Ysb0JBQW9CQyxPQUFPeUUscUJBQXFCcUIsU0FBUyxHQUFHO29CQUN4RyxPQUFPLElBQUksQ0FBQ2pFLFlBQVk7Z0JBQzFCO2dCQUVBLElBQUk5QixvQkFBb0JDLE9BQU95RSxxQkFBcUJzQixRQUFRLEdBQUc7b0JBQzdELE9BQU8sSUFBSSxDQUFDckUsV0FBVztnQkFDekI7WUFDRjtZQUVBLElBQUk0QyxrQkFBa0JHLHVCQUF1QjtnQkFDM0MsSUFBSTFFLG9CQUFvQkMsT0FBT3lFLHFCQUFxQnFCLFNBQVMsR0FBRztvQkFDOUQsT0FBTyxJQUFJLENBQUNqRSxZQUFZO2dCQUMxQjtZQUNGO1lBRUEsSUFBSSxDQUFDc0QsYUFBYSxDQUFDVixzQkFBc0J6RTtZQUN6QztRQUNGO1FBRUEsSUFBSXhQLE1BQU13VixVQUFVLEVBQUU7WUFDcEJ4VixNQUFNNlAsY0FBYztRQUN0QjtRQUVBbUQsT0FBT0Q7SUFDVDtJQUVBZixZQUFZO1FBQ1YsTUFBTSxFQUNKeUQsT0FBTyxFQUNQeEMsS0FBSyxFQUNOLEdBQUcsSUFBSSxDQUFDaGlCLEtBQUs7UUFDZCxJQUFJLENBQUNpaUIsTUFBTTtRQUVYLElBQUksQ0FBQyxJQUFJLENBQUM4QixTQUFTLEVBQUU7WUFDbkJTLFFBQVEsSUFBSSxDQUFDeGtCLEtBQUssQ0FBQ3FULE1BQU07UUFDM0I7UUFFQTJPO0lBQ0Y7SUFFQTVCLGVBQWU7UUFDYixNQUFNLEVBQ0pvRSxPQUFPLEVBQ1B0QyxRQUFRLEVBQ1QsR0FBRyxJQUFJLENBQUNsaUIsS0FBSztRQUNkLElBQUksQ0FBQ2lpQixNQUFNO1FBRVgsSUFBSSxDQUFDLElBQUksQ0FBQzhCLFNBQVMsRUFBRTtZQUNuQlMsUUFBUSxJQUFJLENBQUN4a0IsS0FBSyxDQUFDcVQsTUFBTTtRQUMzQjtRQUVBNk87SUFDRjtJQUVBcUIsY0FBY3hVLEtBQUssRUFBRTtRQUNuQixJQUFJQSxNQUFNMFEsSUFBSSxLQUFLWCxhQUFhTSxHQUFHLEVBQUU7WUFDbkMsSUFBSSxDQUFDZ0IsWUFBWTtRQUNuQjtJQUNGO0lBRUE4RCxzQkFBc0I7UUFDcEIsSUFBSU87UUFFSEEsQ0FBQUEsd0JBQXdCLElBQUksQ0FBQzFaLFFBQVEsQ0FBQzJaLFlBQVksRUFBQyxLQUFNLE9BQU8sS0FBSyxJQUFJRCxzQkFBc0JFLGVBQWU7SUFDakg7SUE3TkEsWUFBWTNrQixLQUFLLEVBQUUraUIsTUFBTSxFQUFFNkIsY0FBYyxDQUFFO1FBQ3pDLElBQUlDO1FBRUosSUFBSUQsbUJBQW1CLEtBQUssR0FBRztZQUM3QkEsaUJBQWlCeEcsdUJBQXVCcGUsTUFBTStPLEtBQUssQ0FBQ3pELE1BQU07UUFDNUQ7UUFFQSxJQUFJLENBQUN0TCxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUMraUIsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDWixpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNwWCxRQUFRLEdBQUcsS0FBSztRQUNyQixJQUFJLENBQUNnWixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxLQUFLO1FBQy9CLElBQUksQ0FBQ04sU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQzdRLFNBQVMsR0FBRyxLQUFLO1FBQ3RCLElBQUksQ0FBQzJRLGlCQUFpQixHQUFHLEtBQUs7UUFDOUIsSUFBSSxDQUFDcEQsZUFBZSxHQUFHLEtBQUs7UUFDNUIsSUFBSSxDQUFDbGdCLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUMraUIsTUFBTSxHQUFHQTtRQUNkLE1BQU0sRUFDSmhVLEtBQUssRUFDTixHQUFHL087UUFDSixNQUFNLEVBQ0pzTCxNQUFNLEVBQ1AsR0FBR3lEO1FBQ0osSUFBSSxDQUFDL08sS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQytpQixNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDaFksUUFBUSxHQUFHa0IsaUJBQWlCWDtRQUNqQyxJQUFJLENBQUNnWSxpQkFBaUIsR0FBRyxJQUFJekYsVUFBVSxJQUFJLENBQUM5UyxRQUFRO1FBQ3BELElBQUksQ0FBQzRILFNBQVMsR0FBRyxJQUFJa0wsVUFBVStHO1FBQy9CLElBQUksQ0FBQzFFLGVBQWUsR0FBRyxJQUFJckMsVUFBVXhTLFVBQVVDO1FBQy9DLElBQUksQ0FBQ3dZLGtCQUFrQixHQUFHLEFBQUNlLENBQUFBLHVCQUF1QnpWLG9CQUFvQkwsTUFBSyxLQUFNLE9BQU84Vix1QkFBdUI1UDtRQUMvRyxJQUFJLENBQUNnTCxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNtQyxJQUFJLENBQUMsSUFBSTtRQUM3QyxJQUFJLENBQUNQLFVBQVUsR0FBRyxJQUFJLENBQUNBLFVBQVUsQ0FBQ08sSUFBSSxDQUFDLElBQUk7UUFDM0MsSUFBSSxDQUFDckIsU0FBUyxHQUFHLElBQUksQ0FBQ0EsU0FBUyxDQUFDcUIsSUFBSSxDQUFDLElBQUk7UUFDekMsSUFBSSxDQUFDaEMsWUFBWSxHQUFHLElBQUksQ0FBQ0EsWUFBWSxDQUFDZ0MsSUFBSSxDQUFDLElBQUk7UUFDL0MsSUFBSSxDQUFDbUIsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDbkIsSUFBSSxDQUFDLElBQUk7UUFDakQsSUFBSSxDQUFDOEIsbUJBQW1CLEdBQUcsSUFBSSxDQUFDQSxtQkFBbUIsQ0FBQzlCLElBQUksQ0FBQyxJQUFJO1FBQzdELElBQUksQ0FBQ3BDLE1BQU07SUFDYjtBQXdMRjtBQUVBLE1BQU0rQyxTQUFTO0lBQ2I1RCxRQUFRO1FBQ050ZSxNQUFNO0lBQ1I7SUFDQXFpQixNQUFNO1FBQ0pyaUIsTUFBTTtJQUNSO0lBQ0F3ZSxLQUFLO1FBQ0h4ZSxNQUFNO0lBQ1I7QUFDRjtBQUNBLE1BQU1pa0Isc0JBQXNCaEM7SUFDMUIsWUFBWTlpQixLQUFLLENBQUU7UUFDakIsTUFBTSxFQUNKK08sS0FBSyxFQUNOLEdBQUcvTyxPQUFPLHVFQUF1RTtRQUNsRiw4REFBOEQ7UUFFOUQsTUFBTTRrQixpQkFBaUIzWSxpQkFBaUI4QyxNQUFNekQsTUFBTTtRQUNwRCxLQUFLLENBQUN0TCxPQUFPK2lCLFFBQVE2QjtJQUN2QjtBQUVGO0FBQ0FFLGNBQWN6QyxVQUFVLEdBQUc7SUFBQztRQUMxQnZFLFdBQVc7UUFDWHhSLFNBQVMsQ0FBQzhELE1BQU1tRDtZQUNkLElBQUksRUFDRmdQLGFBQWF4VCxLQUFLLEVBQ25CLEdBQUdxQjtZQUNKLElBQUksRUFDRmtTLFlBQVksRUFDYixHQUFHL087WUFFSixJQUFJLENBQUN4RSxNQUFNZ1csU0FBUyxJQUFJaFcsTUFBTWlXLE1BQU0sS0FBSyxHQUFHO2dCQUMxQyxPQUFPO1lBQ1Q7WUFFQTFDLGdCQUFnQixPQUFPLEtBQUssSUFBSUEsYUFBYTtnQkFDM0N2VDtZQUNGO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7Q0FBRTtBQUVGLE1BQU1rVyxXQUFXO0lBQ2YvQixNQUFNO1FBQ0pyaUIsTUFBTTtJQUNSO0lBQ0F3ZSxLQUFLO1FBQ0h4ZSxNQUFNO0lBQ1I7QUFDRjtBQUNBLElBQUlxa0I7QUFFSCxDQUFBLFNBQVVBLFdBQVc7SUFDcEJBLFdBQVcsQ0FBQ0EsV0FBVyxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7QUFDL0MsQ0FBQSxFQUFHQSxlQUFnQkEsQ0FBQUEsY0FBYyxDQUFDLENBQUE7QUFFbEMsTUFBTUMsb0JBQW9CckM7SUFDeEIsWUFBWTlpQixLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQSxPQUFPaWxCLFVBQVVoWixpQkFBaUJqTSxNQUFNK08sS0FBSyxDQUFDekQsTUFBTTtJQUM1RDtBQUVGO0FBQ0E2WixZQUFZOUMsVUFBVSxHQUFHO0lBQUM7UUFDeEJ2RSxXQUFXO1FBQ1h4UixTQUFTLENBQUM4RCxNQUFNbUQ7WUFDZCxJQUFJLEVBQ0ZnUCxhQUFheFQsS0FBSyxFQUNuQixHQUFHcUI7WUFDSixJQUFJLEVBQ0ZrUyxZQUFZLEVBQ2IsR0FBRy9PO1lBRUosSUFBSXhFLE1BQU1pVyxNQUFNLEtBQUtFLFlBQVlFLFVBQVUsRUFBRTtnQkFDM0MsT0FBTztZQUNUO1lBRUE5QyxnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7Z0JBQzNDdlQ7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixNQUFNc1csV0FBVztJQUNmbEcsUUFBUTtRQUNOdGUsTUFBTTtJQUNSO0lBQ0FxaUIsTUFBTTtRQUNKcmlCLE1BQU07SUFDUjtJQUNBd2UsS0FBSztRQUNIeGUsTUFBTTtJQUNSO0FBQ0Y7QUFDQSxNQUFNeWtCLG9CQUFvQnhDO0lBS3hCLE9BQU95QyxRQUFRO1FBQ2IscUVBQXFFO1FBQ3JFLHVFQUF1RTtRQUN2RSw2REFBNkQ7UUFDN0R6YSxPQUFPa1QsZ0JBQWdCLENBQUNxSCxTQUFTbkMsSUFBSSxDQUFDcmlCLElBQUksRUFBRThULE1BQU07WUFDaERzUCxTQUFTO1lBQ1RkLFNBQVM7UUFDWDtRQUNBLE9BQU8sU0FBU3FDO1lBQ2QxYSxPQUFPcVQsbUJBQW1CLENBQUNrSCxTQUFTbkMsSUFBSSxDQUFDcmlCLElBQUksRUFBRThUO1FBQ2pELEdBQUcsMEVBQTBFO1FBQzdFLDRFQUE0RTtRQUU1RSxTQUFTQSxRQUFRO0lBQ25CO0lBbEJBLFlBQVkzVSxLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQSxPQUFPcWxCO0lBQ2Y7QUFrQkY7QUFDQUMsWUFBWWpELFVBQVUsR0FBRztJQUFDO1FBQ3hCdkUsV0FBVztRQUNYeFIsU0FBUyxDQUFDOEQsTUFBTW1EO1lBQ2QsSUFBSSxFQUNGZ1AsYUFBYXhULEtBQUssRUFDbkIsR0FBR3FCO1lBQ0osSUFBSSxFQUNGa1MsWUFBWSxFQUNiLEdBQUcvTztZQUNKLE1BQU0sRUFDSmxFLE9BQU8sRUFDUixHQUFHTjtZQUVKLElBQUlNLFFBQVE3SSxNQUFNLEdBQUcsR0FBRztnQkFDdEIsT0FBTztZQUNUO1lBRUE4YixnQkFBZ0IsT0FBTyxLQUFLLElBQUlBLGFBQWE7Z0JBQzNDdlQ7WUFDRjtZQUNBLE9BQU87UUFDVDtJQUNGO0NBQUU7QUFFRixJQUFJMFc7QUFFSCxDQUFBLFNBQVVBLG1CQUFtQjtJQUM1QkEsbUJBQW1CLENBQUNBLG1CQUFtQixDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDMURBLG1CQUFtQixDQUFDQSxtQkFBbUIsQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUc7QUFDbEUsQ0FBQSxFQUFHQSx1QkFBd0JBLENBQUFBLHNCQUFzQixDQUFDLENBQUE7QUFFbEQsSUFBSUM7QUFFSCxDQUFBLFNBQVVBLGNBQWM7SUFDdkJBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbERBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztBQUM1RCxDQUFBLEVBQUdBLGtCQUFtQkEsQ0FBQUEsaUJBQWlCLENBQUMsQ0FBQTtBQUV4QyxTQUFTQyxnQkFBZ0J2VixJQUFJO0lBQzNCLElBQUksRUFDRmlNLFlBQVksRUFDWm1HLFlBQVlpRCxvQkFBb0JHLE9BQU8sRUFDdkNDLFNBQVMsRUFDVEMsWUFBWSxFQUNaQyxPQUFPLEVBQ1BDLFdBQVcsQ0FBQyxFQUNaQyxRQUFRUCxlQUFlUSxTQUFTLEVBQ2hDeE8sa0JBQWtCLEVBQ2xCcUYsbUJBQW1CLEVBQ25Cb0osdUJBQXVCLEVBQ3ZCNUgsS0FBSyxFQUNMOUIsU0FBUyxFQUNWLEdBQUdyTTtJQUNKLE1BQU1nVyxlQUFlQyxnQkFBZ0I7UUFDbkM5SDtRQUNBK0gsVUFBVSxDQUFDUDtJQUNiO0lBQ0EsTUFBTSxDQUFDUSx1QkFBdUJDLHdCQUF3QixHQUFHelo7SUFDekQsTUFBTTBaLGNBQWM3bkIsTUFBTTROLE1BQU0sQ0FBQztRQUMvQnhLLEdBQUc7UUFDSHdOLEdBQUc7SUFDTDtJQUNBLE1BQU1rWCxrQkFBa0I5bkIsTUFBTTROLE1BQU0sQ0FBQztRQUNuQ3hLLEdBQUc7UUFDSHdOLEdBQUc7SUFDTDtJQUNBLE1BQU1nRyxPQUFPNVcsTUFBTStPLE9BQU8sQ0FBQztRQUN6QixPQUFRNlU7WUFDTixLQUFLaUQsb0JBQW9CRyxPQUFPO2dCQUM5QixPQUFPbE8scUJBQXFCO29CQUMxQnRHLEtBQUtzRyxtQkFBbUJsSSxDQUFDO29CQUN6QmlILFFBQVFpQixtQkFBbUJsSSxDQUFDO29CQUM1QjZCLE1BQU1xRyxtQkFBbUIxVixDQUFDO29CQUMxQnVVLE9BQU9tQixtQkFBbUIxVixDQUFDO2dCQUM3QixJQUFJO1lBRU4sS0FBS3lqQixvQkFBb0JrQixhQUFhO2dCQUNwQyxPQUFPYjtRQUNYO0lBQ0YsR0FBRztRQUFDdEQ7UUFBV3NEO1FBQWNwTztLQUFtQjtJQUNoRCxNQUFNa1AscUJBQXFCaG9CLE1BQU00TixNQUFNLENBQUM7SUFDeEMsTUFBTXFhLGFBQWFqb0IsTUFBTThOLFdBQVcsQ0FBQztRQUNuQyxNQUFNeVAsa0JBQWtCeUssbUJBQW1CbmEsT0FBTztRQUVsRCxJQUFJLENBQUMwUCxpQkFBaUI7WUFDcEI7UUFDRjtRQUVBLE1BQU10QixhQUFhNEwsWUFBWWhhLE9BQU8sQ0FBQ3pLLENBQUMsR0FBRzBrQixnQkFBZ0JqYSxPQUFPLENBQUN6SyxDQUFDO1FBQ3BFLE1BQU1nWixZQUFZeUwsWUFBWWhhLE9BQU8sQ0FBQytDLENBQUMsR0FBR2tYLGdCQUFnQmphLE9BQU8sQ0FBQytDLENBQUM7UUFDbkUyTSxnQkFBZ0J5RixRQUFRLENBQUMvRyxZQUFZRztJQUN2QyxHQUFHLEVBQUU7SUFDTCxNQUFNOEwsNEJBQTRCbG9CLE1BQU0rTyxPQUFPLENBQUMsSUFBTXNZLFVBQVVQLGVBQWVRLFNBQVMsR0FBRztlQUFJbko7U0FBb0IsQ0FBQ2dLLE9BQU8sS0FBS2hLLHFCQUFxQjtRQUFDa0o7UUFBT2xKO0tBQW9CO0lBQ2pMbmUsTUFBTXdOLFNBQVMsQ0FBQztRQUNkLElBQUksQ0FBQzJaLFdBQVcsQ0FBQ2hKLG9CQUFvQnZXLE1BQU0sSUFBSSxDQUFDZ1AsTUFBTTtZQUNwRGdSO1lBQ0E7UUFDRjtRQUVBLEtBQUssTUFBTXJLLG1CQUFtQjJLLDBCQUEyQjtZQUN2RCxJQUFJLEFBQUNqQixDQUFBQSxhQUFhLE9BQU8sS0FBSyxJQUFJQSxVQUFVMUosZ0JBQWUsTUFBTyxPQUFPO2dCQUN2RTtZQUNGO1lBRUEsTUFBTTZLLFFBQVFqSyxvQkFBb0J2WSxPQUFPLENBQUMyWDtZQUMxQyxNQUFNQyxzQkFBc0IrSix1QkFBdUIsQ0FBQ2EsTUFBTTtZQUUxRCxJQUFJLENBQUM1SyxxQkFBcUI7Z0JBQ3hCO1lBQ0Y7WUFFQSxNQUFNLEVBQ0pHLFNBQVMsRUFDVEMsS0FBSyxFQUNOLEdBQUdOLDJCQUEyQkMsaUJBQWlCQyxxQkFBcUI1RyxNQUFNNkcsY0FBY0k7WUFFekYsS0FBSyxNQUFNZ0IsUUFBUTtnQkFBQztnQkFBSzthQUFJLENBQUU7Z0JBQzdCLElBQUksQ0FBQzJJLFlBQVksQ0FBQzNJLEtBQUssQ0FBQ2xCLFNBQVMsQ0FBQ2tCLEtBQUssQ0FBQyxFQUFFO29CQUN4Q2pCLEtBQUssQ0FBQ2lCLEtBQUssR0FBRztvQkFDZGxCLFNBQVMsQ0FBQ2tCLEtBQUssR0FBRztnQkFDcEI7WUFDRjtZQUVBLElBQUlqQixNQUFNeGEsQ0FBQyxHQUFHLEtBQUt3YSxNQUFNaE4sQ0FBQyxHQUFHLEdBQUc7Z0JBQzlCZ1g7Z0JBQ0FJLG1CQUFtQm5hLE9BQU8sR0FBRzBQO2dCQUM3Qm9LLHNCQUFzQk0sWUFBWWI7Z0JBQ2xDUyxZQUFZaGEsT0FBTyxHQUFHK1A7Z0JBQ3RCa0ssZ0JBQWdCamEsT0FBTyxHQUFHOFA7Z0JBQzFCO1lBQ0Y7UUFDRjtRQUVBa0ssWUFBWWhhLE9BQU8sR0FBRztZQUNwQnpLLEdBQUc7WUFDSHdOLEdBQUc7UUFDTDtRQUNBa1gsZ0JBQWdCamEsT0FBTyxHQUFHO1lBQ3hCekssR0FBRztZQUNId04sR0FBRztRQUNMO1FBQ0FnWDtJQUNGLEdBQ0E7UUFBQ25LO1FBQWN3SztRQUFZaEI7UUFBV1c7UUFBeUJUO1FBQVNDO1FBQ3hFaUIsS0FBS0MsU0FBUyxDQUFDMVI7UUFDZnlSLEtBQUtDLFNBQVMsQ0FBQ2Q7UUFBZUc7UUFBdUJ4SjtRQUFxQitKO1FBQTJCWDtRQUNyR2MsS0FBS0MsU0FBUyxDQUFDeks7S0FBVztBQUM1QjtBQUNBLE1BQU0wSyxzQkFBc0I7SUFDMUJubEIsR0FBRztRQUNELENBQUNrWixVQUFVd0IsUUFBUSxDQUFDLEVBQUU7UUFDdEIsQ0FBQ3hCLFVBQVUwQixPQUFPLENBQUMsRUFBRTtJQUN2QjtJQUNBcE4sR0FBRztRQUNELENBQUMwTCxVQUFVd0IsUUFBUSxDQUFDLEVBQUU7UUFDdEIsQ0FBQ3hCLFVBQVUwQixPQUFPLENBQUMsRUFBRTtJQUN2QjtBQUNGO0FBRUEsU0FBU3lKLGdCQUFnQjlTLEtBQUs7SUFDNUIsSUFBSSxFQUNGZ0wsS0FBSyxFQUNMK0gsUUFBUSxFQUNULEdBQUcvUztJQUNKLE1BQU02VCxnQkFBZ0JuWixZQUFZc1E7SUFDbEMsT0FBTzlRLFlBQVk0WixDQUFBQTtRQUNqQixJQUFJZixZQUFZLENBQUNjLGlCQUFpQixDQUFDQyxnQkFBZ0I7WUFDakQsK0RBQStEO1lBQy9ELE9BQU9GO1FBQ1Q7UUFFQSxNQUFNNUssWUFBWTtZQUNoQnZhLEdBQUc2TixLQUFLeVgsSUFBSSxDQUFDL0ksTUFBTXZjLENBQUMsR0FBR29sQixjQUFjcGxCLENBQUM7WUFDdEN3TixHQUFHSyxLQUFLeVgsSUFBSSxDQUFDL0ksTUFBTS9PLENBQUMsR0FBRzRYLGNBQWM1WCxDQUFDO1FBQ3hDLEdBQUcsMEVBQTBFO1FBRTdFLE9BQU87WUFDTHhOLEdBQUc7Z0JBQ0QsQ0FBQ2taLFVBQVV3QixRQUFRLENBQUMsRUFBRTJLLGVBQWVybEIsQ0FBQyxDQUFDa1osVUFBVXdCLFFBQVEsQ0FBQyxJQUFJSCxVQUFVdmEsQ0FBQyxLQUFLLENBQUM7Z0JBQy9FLENBQUNrWixVQUFVMEIsT0FBTyxDQUFDLEVBQUV5SyxlQUFlcmxCLENBQUMsQ0FBQ2taLFVBQVUwQixPQUFPLENBQUMsSUFBSUwsVUFBVXZhLENBQUMsS0FBSztZQUM5RTtZQUNBd04sR0FBRztnQkFDRCxDQUFDMEwsVUFBVXdCLFFBQVEsQ0FBQyxFQUFFMkssZUFBZTdYLENBQUMsQ0FBQzBMLFVBQVV3QixRQUFRLENBQUMsSUFBSUgsVUFBVS9NLENBQUMsS0FBSyxDQUFDO2dCQUMvRSxDQUFDMEwsVUFBVTBCLE9BQU8sQ0FBQyxFQUFFeUssZUFBZTdYLENBQUMsQ0FBQzBMLFVBQVUwQixPQUFPLENBQUMsSUFBSUwsVUFBVS9NLENBQUMsS0FBSztZQUM5RTtRQUNGO0lBQ0YsR0FBRztRQUFDOFc7UUFBVS9IO1FBQU82STtLQUFjO0FBQ3JDO0FBRUEsU0FBU0csY0FBY0MsY0FBYyxFQUFFcFosRUFBRTtJQUN2QyxNQUFNcVosZ0JBQWdCclosTUFBTSxPQUFPb1osZUFBZXppQixHQUFHLENBQUNxSixNQUFNMFI7SUFDNUQsTUFBTS9XLE9BQU8wZSxnQkFBZ0JBLGNBQWMxZSxJQUFJLENBQUMwRCxPQUFPLEdBQUc7SUFDMUQsT0FBT2dCLFlBQVlpYSxDQUFBQTtRQUNqQixJQUFJdFg7UUFFSixJQUFJaEMsTUFBTSxNQUFNO1lBQ2QsT0FBTztRQUNULEVBQUUsK0RBQStEO1FBQ2pFLCtEQUErRDtRQUMvRCxzREFBc0Q7UUFHdEQsT0FBTyxBQUFDZ0MsQ0FBQUEsT0FBT3JILFFBQVEsT0FBT0EsT0FBTzJlLFVBQVMsS0FBTSxPQUFPdFgsT0FBTztJQUNwRSxHQUFHO1FBQUNySDtRQUFNcUY7S0FBRztBQUNmO0FBRUEsU0FBU3VaLHFCQUFxQjNTLE9BQU8sRUFBRTRTLG1CQUFtQjtJQUN4RCxPQUFPaHBCLE1BQU0rTyxPQUFPLENBQUMsSUFBTXFILFFBQVF4RyxNQUFNLENBQUMsQ0FBQ0MsYUFBYW9HO1lBQ3RELE1BQU0sRUFDSkEsUUFBUWdULE1BQU0sRUFDZixHQUFHaFQ7WUFDSixNQUFNaVQsbUJBQW1CRCxPQUFPeEYsVUFBVSxDQUFDMEYsR0FBRyxDQUFDdkYsQ0FBQUEsWUFBYyxDQUFBO29CQUMzRDFFLFdBQVcwRSxVQUFVMUUsU0FBUztvQkFDOUJ4UixTQUFTc2Isb0JBQW9CcEYsVUFBVWxXLE9BQU8sRUFBRXVJO2dCQUNsRCxDQUFBO1lBQ0EsT0FBTzttQkFBSXBHO21CQUFnQnFaO2FBQWlCO1FBQzlDLEdBQUcsRUFBRSxHQUFHO1FBQUM5UztRQUFTNFM7S0FBb0I7QUFDeEM7QUFFQSxJQUFJSTtBQUVILENBQUEsU0FBVUEsaUJBQWlCO0lBQzFCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsU0FBUyxHQUFHLEVBQUUsR0FBRztJQUNyREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGlCQUFpQixHQUFHLEVBQUUsR0FBRztJQUM3REEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGdCQUFnQixHQUFHLEVBQUUsR0FBRztBQUM5RCxDQUFBLEVBQUdBLHFCQUFzQkEsQ0FBQUEsb0JBQW9CLENBQUMsQ0FBQTtBQUU5QyxJQUFJQztBQUVILENBQUEsU0FBVUEsa0JBQWtCO0lBQzNCQSxrQkFBa0IsQ0FBQyxZQUFZLEdBQUc7QUFDcEMsQ0FBQSxFQUFHQSxzQkFBdUJBLENBQUFBLHFCQUFxQixDQUFDLENBQUE7QUFFaEQsTUFBTUMsZUFBZSxXQUFXLEdBQUUsSUFBSXpkO0FBQ3RDLFNBQVMwZCxzQkFBc0JDLFVBQVUsRUFBRWhZLElBQUk7SUFDN0MsSUFBSSxFQUNGaVksUUFBUSxFQUNSOWEsWUFBWSxFQUNaN04sTUFBTSxFQUNQLEdBQUcwUTtJQUNKLE1BQU0sQ0FBQ2tZLE9BQU9DLFNBQVMsR0FBRzNwQixNQUFNc1QsUUFBUSxDQUFDO0lBQ3pDLE1BQU0sRUFDSnNXLFNBQVMsRUFDVHJMLE9BQU8sRUFDUHNMLFFBQVEsRUFDVCxHQUFHL29CO0lBQ0osTUFBTWdwQixnQkFBZ0I5cEIsTUFBTTROLE1BQU0sQ0FBQzRiO0lBQ25DLE1BQU05QixXQUFXcUM7SUFDakIsTUFBTUMsY0FBY3RiLGVBQWVnWjtJQUNuQyxNQUFNdUMsNkJBQTZCanFCLE1BQU04TixXQUFXLENBQUMsU0FBVXdCLEdBQUc7UUFDaEUsSUFBSUEsUUFBUSxLQUFLLEdBQUc7WUFDbEJBLE1BQU0sRUFBRTtRQUNWO1FBRUEsSUFBSTBhLFlBQVluYyxPQUFPLEVBQUU7WUFDdkI7UUFDRjtRQUVBOGIsU0FBU3JtQixDQUFBQTtZQUNQLElBQUlBLFVBQVUsTUFBTTtnQkFDbEIsT0FBT2dNO1lBQ1Q7WUFFQSxPQUFPaE0sTUFBTTRtQixNQUFNLENBQUM1YSxJQUFJdkYsTUFBTSxDQUFDeUYsQ0FBQUEsS0FBTSxDQUFDbE0sTUFBTXVFLFFBQVEsQ0FBQzJIO1FBQ3ZEO0lBQ0YsR0FBRztRQUFDd2E7S0FBWTtJQUNoQixNQUFNcEYsWUFBWTVrQixNQUFNNE4sTUFBTSxDQUFDO0lBQy9CLE1BQU0wSyxpQkFBaUJ6SixZQUFZc2IsQ0FBQUE7UUFDakMsSUFBSXpDLFlBQVksQ0FBQytCLFVBQVU7WUFDekIsT0FBT0g7UUFDVDtRQUVBLElBQUksQ0FBQ2EsaUJBQWlCQSxrQkFBa0JiLGdCQUFnQlEsY0FBY2pjLE9BQU8sS0FBSzJiLGNBQWNFLFNBQVMsTUFBTTtZQUM3RyxNQUFNUCxNQUFNLElBQUl0ZDtZQUVoQixLQUFLLElBQUlzSixhQUFhcVUsV0FBWTtnQkFDaEMsSUFBSSxDQUFDclUsV0FBVztvQkFDZDtnQkFDRjtnQkFFQSxJQUFJdVUsU0FBU0EsTUFBTTloQixNQUFNLEdBQUcsS0FBSyxDQUFDOGhCLE1BQU03aEIsUUFBUSxDQUFDc04sVUFBVTNGLEVBQUUsS0FBSzJGLFVBQVV5QixJQUFJLENBQUMvSSxPQUFPLEVBQUU7b0JBQ3hGLGlEQUFpRDtvQkFDakRzYixJQUFJdGlCLEdBQUcsQ0FBQ3NPLFVBQVUzRixFQUFFLEVBQUUyRixVQUFVeUIsSUFBSSxDQUFDL0ksT0FBTztvQkFDNUM7Z0JBQ0Y7Z0JBRUEsTUFBTTFELE9BQU9nTCxVQUFVaEwsSUFBSSxDQUFDMEQsT0FBTztnQkFDbkMsTUFBTStJLE9BQU96TSxPQUFPLElBQUl3VSxLQUFLSixRQUFRcFUsT0FBT0EsUUFBUTtnQkFDcERnTCxVQUFVeUIsSUFBSSxDQUFDL0ksT0FBTyxHQUFHK0k7Z0JBRXpCLElBQUlBLE1BQU07b0JBQ1J1UyxJQUFJdGlCLEdBQUcsQ0FBQ3NPLFVBQVUzRixFQUFFLEVBQUVvSDtnQkFDeEI7WUFDRjtZQUVBLE9BQU91UztRQUNUO1FBRUEsT0FBT2dCO0lBQ1QsR0FBRztRQUFDWDtRQUFZRTtRQUFPRDtRQUFVL0I7UUFBVW5KO0tBQVE7SUFDbkR2ZSxNQUFNd04sU0FBUyxDQUFDO1FBQ2RzYyxjQUFjamMsT0FBTyxHQUFHMmI7SUFDMUIsR0FBRztRQUFDQTtLQUFXO0lBQ2Z4cEIsTUFBTXdOLFNBQVMsQ0FBQztRQUNkLElBQUlrYSxVQUFVO1lBQ1o7UUFDRjtRQUVBdUM7SUFDRixHQUNBO1FBQUNSO1FBQVUvQjtLQUFTO0lBQ3BCMW5CLE1BQU13TixTQUFTLENBQUM7UUFDZCxJQUFJa2MsU0FBU0EsTUFBTTloQixNQUFNLEdBQUcsR0FBRztZQUM3QitoQixTQUFTO1FBQ1g7SUFDRixHQUNBO1FBQUN0QixLQUFLQyxTQUFTLENBQUNvQjtLQUFPO0lBQ3ZCMXBCLE1BQU13TixTQUFTLENBQUM7UUFDZCxJQUFJa2EsWUFBWSxPQUFPa0MsY0FBYyxZQUFZaEYsVUFBVS9XLE9BQU8sS0FBSyxNQUFNO1lBQzNFO1FBQ0Y7UUFFQStXLFVBQVUvVyxPQUFPLEdBQUc2VCxXQUFXO1lBQzdCdUk7WUFDQXJGLFVBQVUvVyxPQUFPLEdBQUc7UUFDdEIsR0FBRytiO0lBQ0wsR0FDQTtRQUFDQTtRQUFXbEM7UUFBVXVDO1dBQStCdGI7S0FBYTtJQUNsRSxPQUFPO1FBQ0wySjtRQUNBMlI7UUFDQUcsb0JBQW9CVixTQUFTO0lBQy9CO0lBRUEsU0FBU0s7UUFDUCxPQUFRRjtZQUNOLEtBQUtULGtCQUFrQmlCLE1BQU07Z0JBQzNCLE9BQU87WUFFVCxLQUFLakIsa0JBQWtCa0IsY0FBYztnQkFDbkMsT0FBT2I7WUFFVDtnQkFDRSxPQUFPLENBQUNBO1FBQ1o7SUFDRjtBQUNGO0FBRUEsU0FBU2MsZ0JBQWdCam5CLEtBQUssRUFBRWtuQixTQUFTO0lBQ3ZDLE9BQU8zYixZQUFZc2IsQ0FBQUE7UUFDakIsSUFBSSxDQUFDN21CLE9BQU87WUFDVixPQUFPO1FBQ1Q7UUFFQSxJQUFJNm1CLGVBQWU7WUFDakIsT0FBT0E7UUFDVDtRQUVBLE9BQU8sT0FBT0ssY0FBYyxhQUFhQSxVQUFVbG5CLFNBQVNBO0lBQzlELEdBQUc7UUFBQ2tuQjtRQUFXbG5CO0tBQU07QUFDdkI7QUFFQSxTQUFTbW5CLGVBQWV0Z0IsSUFBSSxFQUFFb1UsT0FBTztJQUNuQyxPQUFPZ00sZ0JBQWdCcGdCLE1BQU1vVTtBQUMvQjtBQUVBOzs7Q0FHQyxHQUVELFNBQVNtTSxvQkFBb0JsWixJQUFJO0lBQy9CLElBQUksRUFDRjFDLFFBQVEsRUFDUjRZLFFBQVEsRUFDVCxHQUFHbFc7SUFDSixNQUFNbVosa0JBQWtCbGQsU0FBU3FCO0lBQ2pDLE1BQU04YixtQkFBbUI1cUIsTUFBTStPLE9BQU8sQ0FBQztRQUNyQyxJQUFJMlksWUFBWSxPQUFPeGIsV0FBVyxlQUFlLE9BQU9BLE9BQU8yZSxnQkFBZ0IsS0FBSyxhQUFhO1lBQy9GLE9BQU8zSjtRQUNUO1FBRUEsTUFBTSxFQUNKMkosZ0JBQWdCLEVBQ2pCLEdBQUczZTtRQUNKLE9BQU8sSUFBSTJlLGlCQUFpQkY7SUFDOUIsR0FBRztRQUFDQTtRQUFpQmpEO0tBQVM7SUFDOUIxbkIsTUFBTXdOLFNBQVMsQ0FBQztRQUNkLE9BQU8sSUFBTW9kLG9CQUFvQixPQUFPLEtBQUssSUFBSUEsaUJBQWlCRSxVQUFVO0lBQzlFLEdBQUc7UUFBQ0Y7S0FBaUI7SUFDckIsT0FBT0E7QUFDVDtBQUVBOzs7Q0FHQyxHQUVELFNBQVNHLGtCQUFrQnZaLElBQUk7SUFDN0IsSUFBSSxFQUNGMUMsUUFBUSxFQUNSNFksUUFBUSxFQUNULEdBQUdsVztJQUNKLE1BQU13WixlQUFldmQsU0FBU3FCO0lBQzlCLE1BQU1tYyxpQkFBaUJqckIsTUFBTStPLE9BQU8sQ0FBQztRQUNuQyxJQUFJMlksWUFBWSxPQUFPeGIsV0FBVyxlQUFlLE9BQU9BLE9BQU9nZixjQUFjLEtBQUssYUFBYTtZQUM3RixPQUFPaEs7UUFDVDtRQUVBLE1BQU0sRUFDSmdLLGdCQUFBQSxlQUFjLEVBQ2YsR0FBR2hmO1FBQ0osT0FBTyxJQUFJZ2YsZ0JBQWVGO0lBQzVCLEdBQ0E7UUFBQ3REO0tBQVM7SUFDVjFuQixNQUFNd04sU0FBUyxDQUFDO1FBQ2QsT0FBTyxJQUFNeWQsa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlSCxVQUFVO0lBQzFFLEdBQUc7UUFBQ0c7S0FBZTtJQUNuQixPQUFPQTtBQUNUO0FBRUEsU0FBU0UsZUFBZW5nQixPQUFPO0lBQzdCLE9BQU8sSUFBSTJULEtBQUtuRSxjQUFjeFAsVUFBVUE7QUFDMUM7QUFFQSxTQUFTb2dCLFFBQVFwZ0IsT0FBTyxFQUFFdVQsT0FBTyxFQUFFOE0sWUFBWTtJQUM3QyxJQUFJOU0sWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVU0TTtJQUNaO0lBRUEsTUFBTSxDQUFDdlUsTUFBTTBVLFFBQVEsR0FBR3RyQixNQUFNc1QsUUFBUSxDQUFDO0lBRXZDLFNBQVNpWTtRQUNQRCxRQUFRRSxDQUFBQTtZQUNOLElBQUksQ0FBQ3hnQixTQUFTO2dCQUNaLE9BQU87WUFDVDtZQUVBLElBQUlBLFFBQVF5Z0IsV0FBVyxLQUFLLE9BQU87Z0JBQ2pDLElBQUlqYTtnQkFFSix1REFBdUQ7Z0JBQ3ZELGtDQUFrQztnQkFDbEMsT0FBTyxBQUFDQSxDQUFBQSxPQUFPZ2EsZUFBZSxPQUFPQSxjQUFjSCxZQUFXLEtBQU0sT0FBTzdaLE9BQU87WUFDcEY7WUFFQSxNQUFNa2EsVUFBVW5OLFFBQVF2VDtZQUV4QixJQUFJcWQsS0FBS0MsU0FBUyxDQUFDa0QsaUJBQWlCbkQsS0FBS0MsU0FBUyxDQUFDb0QsVUFBVTtnQkFDM0QsT0FBT0Y7WUFDVDtZQUVBLE9BQU9FO1FBQ1Q7SUFDRjtJQUVBLE1BQU1kLG1CQUFtQkYsb0JBQW9CO1FBQzNDNWIsVUFBUzZjLE9BQU87WUFDZCxJQUFJLENBQUMzZ0IsU0FBUztnQkFDWjtZQUNGO1lBRUEsS0FBSyxNQUFNNGdCLFVBQVVELFFBQVM7Z0JBQzVCLE1BQU0sRUFDSjlxQixJQUFJLEVBQ0o2TCxNQUFNLEVBQ1AsR0FBR2tmO2dCQUVKLElBQUkvcUIsU0FBUyxlQUFlNkwsa0JBQWtCUSxlQUFlUixPQUFPbWYsUUFBUSxDQUFDN2dCLFVBQVU7b0JBQ3JGdWdCO29CQUNBO2dCQUNGO1lBQ0Y7UUFDRjtJQUVGO0lBQ0EsTUFBTU4saUJBQWlCRixrQkFBa0I7UUFDdkNqYyxVQUFVeWM7SUFDWjtJQUNBamUsMEJBQTBCO1FBQ3hCaWU7UUFFQSxJQUFJdmdCLFNBQVM7WUFDWGlnQixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVhLE9BQU8sQ0FBQzlnQjtZQUN6RDRmLG9CQUFvQixPQUFPLEtBQUssSUFBSUEsaUJBQWlCa0IsT0FBTyxDQUFDM2YsU0FBUzRmLElBQUksRUFBRTtnQkFDMUVDLFdBQVc7Z0JBQ1hDLFNBQVM7WUFDWDtRQUNGLE9BQU87WUFDTGhCLGtCQUFrQixPQUFPLEtBQUssSUFBSUEsZUFBZUgsVUFBVTtZQUMzREYsb0JBQW9CLE9BQU8sS0FBSyxJQUFJQSxpQkFBaUJFLFVBQVU7UUFDakU7SUFDRixHQUFHO1FBQUM5ZjtLQUFRO0lBQ1osT0FBTzRMO0FBQ1Q7QUFFQSxTQUFTc1YsYUFBYXRWLElBQUk7SUFDeEIsTUFBTXVWLGNBQWM1QixnQkFBZ0IzVDtJQUNwQyxPQUFPMEMsYUFBYTFDLE1BQU11VjtBQUM1QjtBQUVBLE1BQU1DLGlCQUFpQixFQUFFO0FBQ3pCLFNBQVNDLHVCQUF1QmxpQixJQUFJO0lBQ2xDLE1BQU1taUIsZUFBZXRzQixNQUFNNE4sTUFBTSxDQUFDekQ7SUFDbEMsTUFBTW9pQixZQUFZMWQsWUFBWXNiLENBQUFBO1FBQzVCLElBQUksQ0FBQ2hnQixNQUFNO1lBQ1QsT0FBT2lpQjtRQUNUO1FBRUEsSUFBSWpDLGlCQUFpQkEsa0JBQWtCaUMsa0JBQWtCamlCLFFBQVFtaUIsYUFBYXplLE9BQU8sSUFBSTFELEtBQUt3UixVQUFVLEtBQUsyUSxhQUFhemUsT0FBTyxDQUFDOE4sVUFBVSxFQUFFO1lBQzVJLE9BQU93TztRQUNUO1FBRUEsT0FBTzdPLHVCQUF1Qm5SO0lBQ2hDLEdBQUc7UUFBQ0E7S0FBSztJQUNUbkssTUFBTXdOLFNBQVMsQ0FBQztRQUNkOGUsYUFBYXplLE9BQU8sR0FBRzFEO0lBQ3pCLEdBQUc7UUFBQ0E7S0FBSztJQUNULE9BQU9vaUI7QUFDVDtBQUVBLFNBQVNDLGlCQUFpQkMsUUFBUTtJQUNoQyxNQUFNLENBQUNDLG1CQUFtQkMscUJBQXFCLEdBQUczc0IsTUFBTXNULFFBQVEsQ0FBQztJQUNqRSxNQUFNc1osZUFBZTVzQixNQUFNNE4sTUFBTSxDQUFDNmUsV0FBVyw0Q0FBNEM7SUFFekYsTUFBTUksZUFBZTdzQixNQUFNOE4sV0FBVyxDQUFDcUMsQ0FBQUE7UUFDckMsTUFBTXVMLG1CQUFtQkkscUJBQXFCM0wsTUFBTXpELE1BQU07UUFFMUQsSUFBSSxDQUFDZ1Asa0JBQWtCO1lBQ3JCO1FBQ0Y7UUFFQWlSLHFCQUFxQkQsQ0FBQUE7WUFDbkIsSUFBSSxDQUFDQSxtQkFBbUI7Z0JBQ3RCLE9BQU87WUFDVDtZQUVBQSxrQkFBa0I3bEIsR0FBRyxDQUFDNlUsa0JBQWtCVyxxQkFBcUJYO1lBQzdELE9BQU8sSUFBSTdQLElBQUk2Z0I7UUFDakI7SUFDRixHQUFHLEVBQUU7SUFDTDFzQixNQUFNd04sU0FBUyxDQUFDO1FBQ2QsTUFBTXNmLG1CQUFtQkYsYUFBYS9lLE9BQU87UUFFN0MsSUFBSTRlLGFBQWFLLGtCQUFrQjtZQUNqQ0MsUUFBUUQ7WUFDUixNQUFNbGlCLFVBQVU2aEIsU0FBU3RELEdBQUcsQ0FBQ25lLENBQUFBO2dCQUMzQixNQUFNZ2lCLG9CQUFvQmxSLHFCQUFxQjlRO2dCQUUvQyxJQUFJZ2lCLG1CQUFtQjtvQkFDckJBLGtCQUFrQjVOLGdCQUFnQixDQUFDLFVBQVV5TixjQUFjO3dCQUN6RHRJLFNBQVM7b0JBQ1g7b0JBQ0EsT0FBTzt3QkFBQ3lJO3dCQUFtQjNRLHFCQUFxQjJRO3FCQUFtQjtnQkFDckU7Z0JBRUEsT0FBTztZQUNULEdBQUdqakIsTUFBTSxDQUFDME4sQ0FBQUEsUUFBU0EsU0FBUztZQUM1QmtWLHFCQUFxQi9oQixRQUFRaEQsTUFBTSxHQUFHLElBQUlpRSxJQUFJakIsV0FBVztZQUN6RGdpQixhQUFhL2UsT0FBTyxHQUFHNGU7UUFDekI7UUFFQSxPQUFPO1lBQ0xNLFFBQVFOO1lBQ1JNLFFBQVFEO1FBQ1Y7UUFFQSxTQUFTQyxRQUFRTixRQUFRO1lBQ3ZCQSxTQUFTdFksT0FBTyxDQUFDbkosQ0FBQUE7Z0JBQ2YsTUFBTWdpQixvQkFBb0JsUixxQkFBcUI5UTtnQkFDL0NnaUIscUJBQXFCLE9BQU8sS0FBSyxJQUFJQSxrQkFBa0J6TixtQkFBbUIsQ0FBQyxVQUFVc047WUFDdkY7UUFDRjtJQUNGLEdBQUc7UUFBQ0E7UUFBY0o7S0FBUztJQUMzQixPQUFPenNCLE1BQU0rTyxPQUFPLENBQUM7UUFDbkIsSUFBSTBkLFNBQVM3a0IsTUFBTSxFQUFFO1lBQ25CLE9BQU84a0Isb0JBQW9CamhCLE1BQU13aEIsSUFBSSxDQUFDUCxrQkFBa0JRLE1BQU0sSUFBSXRkLE1BQU0sQ0FBQyxDQUFDNkosS0FBS3lKLGNBQWdCbFQsSUFBSXlKLEtBQUt5SixjQUFjN00sc0JBQXNCNkgsaUJBQWlCdU87UUFDL0o7UUFFQSxPQUFPcFc7SUFDVCxHQUFHO1FBQUNvVztRQUFVQztLQUFrQjtBQUNsQztBQUVBLFNBQVNTLHNCQUFzQnZPLGFBQWEsRUFBRWpRLFlBQVk7SUFDeEQsSUFBSUEsaUJBQWlCLEtBQUssR0FBRztRQUMzQkEsZUFBZSxFQUFFO0lBQ25CO0lBRUEsTUFBTXllLHVCQUF1QnB0QixNQUFNNE4sTUFBTSxDQUFDO0lBQzFDNU4sTUFBTXdOLFNBQVMsQ0FBQztRQUNkNGYscUJBQXFCdmYsT0FBTyxHQUFHO0lBQ2pDLEdBQ0FjO0lBQ0EzTyxNQUFNd04sU0FBUyxDQUFDO1FBQ2QsTUFBTTZmLG1CQUFtQnpPLGtCQUFrQnZJO1FBRTNDLElBQUlnWCxvQkFBb0IsQ0FBQ0QscUJBQXFCdmYsT0FBTyxFQUFFO1lBQ3JEdWYscUJBQXFCdmYsT0FBTyxHQUFHK1E7UUFDakM7UUFFQSxJQUFJLENBQUN5TyxvQkFBb0JELHFCQUFxQnZmLE9BQU8sRUFBRTtZQUNyRHVmLHFCQUFxQnZmLE9BQU8sR0FBRztRQUNqQztJQUNGLEdBQUc7UUFBQytRO0tBQWM7SUFDbEIsT0FBT3dPLHFCQUFxQnZmLE9BQU8sR0FBR29DLFNBQVMyTyxlQUFld08scUJBQXFCdmYsT0FBTyxJQUFJd0k7QUFDaEc7QUFFQSxTQUFTaVgsZUFBZWxYLE9BQU87SUFDN0JwVyxNQUFNd04sU0FBUyxDQUFDO1FBQ2QsSUFBSSxDQUFDdkIsV0FBVztZQUNkO1FBQ0Y7UUFFQSxNQUFNc2hCLGNBQWNuWCxRQUFRK1MsR0FBRyxDQUFDM1gsQ0FBQUE7WUFDOUIsSUFBSSxFQUNGeUUsTUFBTSxFQUNQLEdBQUd6RTtZQUNKLE9BQU95RSxPQUFPMFEsS0FBSyxJQUFJLE9BQU8sS0FBSyxJQUFJMVEsT0FBTzBRLEtBQUs7UUFDckQ7UUFDQSxPQUFPO1lBQ0wsS0FBSyxNQUFNQyxZQUFZMkcsWUFBYTtnQkFDbEMzRyxZQUFZLE9BQU8sS0FBSyxJQUFJQTtZQUM5QjtRQUNGO0lBQ0YsR0FDQSx1REFBdUQ7SUFDdkR4USxRQUFRK1MsR0FBRyxDQUFDeFUsQ0FBQUE7UUFDVixJQUFJLEVBQ0ZzQixNQUFNLEVBQ1AsR0FBR3RCO1FBQ0osT0FBT3NCO0lBQ1Q7QUFDRjtBQUVBLFNBQVN1WCxzQkFBc0J6WixTQUFTLEVBQUV2RSxFQUFFO0lBQzFDLE9BQU94UCxNQUFNK08sT0FBTyxDQUFDO1FBQ25CLE9BQU9nRixVQUFVbkUsTUFBTSxDQUFDLENBQUM2SixLQUFLakk7WUFDNUIsSUFBSSxFQUNGME4sU0FBUyxFQUNUeFIsT0FBTyxFQUNSLEdBQUc4RDtZQUVKaUksR0FBRyxDQUFDeUYsVUFBVSxHQUFHL08sQ0FBQUE7Z0JBQ2Z6QyxRQUFReUMsT0FBT1g7WUFDakI7WUFFQSxPQUFPaUs7UUFDVCxHQUFHLENBQUM7SUFDTixHQUFHO1FBQUMxRjtRQUFXdkU7S0FBRztBQUNwQjtBQUVBLFNBQVNpZSxjQUFjemlCLE9BQU87SUFDNUIsT0FBT2hMLE1BQU0rTyxPQUFPLENBQUMsSUFBTS9ELFVBQVU0UCxvQkFBb0I1UCxXQUFXLE1BQU07UUFBQ0E7S0FBUTtBQUNyRjtBQUVBLE1BQU0waUIsaUJBQWlCLEVBQUU7QUFDekIsU0FBU0MsU0FBU2xCLFFBQVEsRUFBRWxPLE9BQU87SUFDakMsSUFBSUEsWUFBWSxLQUFLLEdBQUc7UUFDdEJBLFVBQVUvRDtJQUNaO0lBRUEsTUFBTSxDQUFDb1QsYUFBYSxHQUFHbkI7SUFDdkIsTUFBTW9CLGFBQWFKLGNBQWNHLGVBQWVuaEIsVUFBVW1oQixnQkFBZ0I7SUFDMUUsTUFBTSxDQUFDRSxPQUFPQyxTQUFTLEdBQUcvdEIsTUFBTXNULFFBQVEsQ0FBQ29hO0lBRXpDLFNBQVNNO1FBQ1BELFNBQVM7WUFDUCxJQUFJLENBQUN0QixTQUFTN2tCLE1BQU0sRUFBRTtnQkFDcEIsT0FBTzhsQjtZQUNUO1lBRUEsT0FBT2pCLFNBQVN0RCxHQUFHLENBQUNuZSxDQUFBQSxVQUFXdVIsMkJBQTJCdlIsV0FBVzZpQixhQUFhLElBQUlsUCxLQUFLSixRQUFRdlQsVUFBVUE7UUFDL0c7SUFDRjtJQUVBLE1BQU1pZ0IsaUJBQWlCRixrQkFBa0I7UUFDdkNqYyxVQUFVa2Y7SUFDWjtJQUNBMWdCLDBCQUEwQjtRQUN4QjJkLGtCQUFrQixPQUFPLEtBQUssSUFBSUEsZUFBZUgsVUFBVTtRQUMzRGtEO1FBQ0F2QixTQUFTdFksT0FBTyxDQUFDbkosQ0FBQUEsVUFBV2lnQixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVhLE9BQU8sQ0FBQzlnQjtJQUN2RixHQUFHO1FBQUN5aEI7S0FBUztJQUNiLE9BQU9xQjtBQUNUO0FBRUEsU0FBU0csa0JBQWtCOWpCLElBQUk7SUFDN0IsSUFBSSxDQUFDQSxNQUFNO1FBQ1QsT0FBTztJQUNUO0lBRUEsSUFBSUEsS0FBS1IsUUFBUSxDQUFDL0IsTUFBTSxHQUFHLEdBQUc7UUFDNUIsT0FBT3VDO0lBQ1Q7SUFFQSxNQUFNK2pCLGFBQWEvakIsS0FBS1IsUUFBUSxDQUFDLEVBQUU7SUFDbkMsT0FBT3NELGNBQWNpaEIsY0FBY0EsYUFBYS9qQjtBQUNsRDtBQUVBLFNBQVNna0Isd0JBQXdCM2MsSUFBSTtJQUNuQyxJQUFJLEVBQ0YrTSxPQUFPLEVBQ1IsR0FBRy9NO0lBQ0osTUFBTSxDQUFDb0YsTUFBTTBVLFFBQVEsR0FBR3RyQixNQUFNc1QsUUFBUSxDQUFDO0lBQ3ZDLE1BQU0wWCxlQUFlaHJCLE1BQU04TixXQUFXLENBQUNsRCxDQUFBQTtRQUNyQyxLQUFLLE1BQU0sRUFDVDhCLE1BQU0sRUFDUCxJQUFJOUIsUUFBUztZQUNaLElBQUlxQyxjQUFjUCxTQUFTO2dCQUN6QjRlLFFBQVExVSxDQUFBQTtvQkFDTixNQUFNOFUsVUFBVW5OLFFBQVE3UjtvQkFDeEIsT0FBT2tLLE9BQU87d0JBQUUsR0FBR0EsSUFBSTt3QkFDckJsRSxPQUFPZ1osUUFBUWhaLEtBQUs7d0JBQ3BCQyxRQUFRK1ksUUFBUS9ZLE1BQU07b0JBQ3hCLElBQUkrWTtnQkFDTjtnQkFDQTtZQUNGO1FBQ0Y7SUFDRixHQUFHO1FBQUNuTjtLQUFRO0lBQ1osTUFBTTBNLGlCQUFpQkYsa0JBQWtCO1FBQ3ZDamMsVUFBVWtjO0lBQ1o7SUFDQSxNQUFNb0QsbUJBQW1CcHVCLE1BQU04TixXQUFXLENBQUM5QyxDQUFBQTtRQUN6QyxNQUFNYixPQUFPOGpCLGtCQUFrQmpqQjtRQUMvQmlnQixrQkFBa0IsT0FBTyxLQUFLLElBQUlBLGVBQWVILFVBQVU7UUFFM0QsSUFBSTNnQixNQUFNO1lBQ1I4Z0Isa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlYSxPQUFPLENBQUMzaEI7UUFDM0Q7UUFFQW1oQixRQUFRbmhCLE9BQU9vVSxRQUFRcFUsUUFBUTtJQUNqQyxHQUFHO1FBQUNvVTtRQUFTME07S0FBZTtJQUM1QixNQUFNLENBQUNvRCxTQUFTQyxPQUFPLEdBQUdyZixXQUFXbWY7SUFDckMsT0FBT3B1QixNQUFNK08sT0FBTyxDQUFDLElBQU8sQ0FBQTtZQUMxQnNmO1lBQ0F6WDtZQUNBMFg7UUFDRixDQUFBLEdBQUk7UUFBQzFYO1FBQU15WDtRQUFTQztLQUFPO0FBQzdCO0FBRUEsTUFBTUMsaUJBQWlCO0lBQUM7UUFDdEJ0WSxRQUFRaVE7UUFDUmhRLFNBQVMsQ0FBQztJQUNaO0lBQUc7UUFDREQsUUFBUWtMO1FBQ1JqTCxTQUFTLENBQUM7SUFDWjtDQUFFO0FBQ0YsTUFBTXNZLGNBQWM7SUFDbEIzZ0IsU0FBUyxDQUFDO0FBQ1o7QUFDQSxNQUFNNGdCLGdDQUFnQztJQUNwQ25hLFdBQVc7UUFDVGlLLFNBQVM1RDtJQUNYO0lBQ0ErVCxXQUFXO1FBQ1RuUSxTQUFTNUQ7UUFDVGtQLFVBQVVULGtCQUFrQnVGLGFBQWE7UUFDekMvRSxXQUFXUCxtQkFBbUJ1RixTQUFTO0lBQ3pDO0lBQ0FDLGFBQWE7UUFDWHRRLFNBQVMvRDtJQUNYO0FBQ0Y7QUFFQSxNQUFNc1UsK0JBQStCampCO0lBQ25DMUYsSUFBSXFKLEVBQUUsRUFBRTtRQUNOLElBQUl1ZjtRQUVKLE9BQU92ZixNQUFNLE9BQU8sQUFBQ3VmLENBQUFBLGFBQWEsS0FBSyxDQUFDNW9CLElBQUlxSixHQUFFLEtBQU0sT0FBT3VmLGFBQWE3TixZQUFZQTtJQUN0RjtJQUVBOE4sVUFBVTtRQUNSLE9BQU92akIsTUFBTXdoQixJQUFJLENBQUMsSUFBSSxDQUFDQyxNQUFNO0lBQy9CO0lBRUErQixhQUFhO1FBQ1gsT0FBTyxJQUFJLENBQUNELE9BQU8sR0FBR2psQixNQUFNLENBQUN5SCxDQUFBQTtZQUMzQixJQUFJLEVBQ0ZrVyxRQUFRLEVBQ1QsR0FBR2xXO1lBQ0osT0FBTyxDQUFDa1c7UUFDVjtJQUNGO0lBRUF3SCxXQUFXMWYsRUFBRSxFQUFFO1FBQ2IsSUFBSTJmLHVCQUF1QkM7UUFFM0IsT0FBTyxBQUFDRCxDQUFBQSx3QkFBd0IsQUFBQ0MsQ0FBQUEsWUFBWSxJQUFJLENBQUNqcEIsR0FBRyxDQUFDcUosR0FBRSxLQUFNLE9BQU8sS0FBSyxJQUFJNGYsVUFBVWpsQixJQUFJLENBQUMwRCxPQUFPLEFBQUQsS0FBTSxPQUFPc2hCLHdCQUF3QmpPO0lBQzFJO0FBRUY7QUFFQSxNQUFNbU8sdUJBQXVCO0lBQzNCQyxnQkFBZ0I7SUFDaEI3YSxRQUFRO0lBQ1JvTixZQUFZO0lBQ1owTixnQkFBZ0I7SUFDaEJqWSxZQUFZO0lBQ1prWSxtQkFBbUI7SUFDbkI1RyxnQkFBZ0IsV0FBVyxHQUFFLElBQUkvYztJQUNqQ3lNLGdCQUFnQixXQUFXLEdBQUUsSUFBSXpNO0lBQ2pDME0scUJBQXFCLFdBQVcsR0FBRSxJQUFJdVc7SUFDdENsYSxNQUFNO0lBQ05pYSxhQUFhO1FBQ1hSLFNBQVM7WUFDUHhnQixTQUFTO1FBQ1g7UUFDQStJLE1BQU07UUFDTjBYLFFBQVF2WTtJQUNWO0lBQ0FvSSxxQkFBcUIsRUFBRTtJQUN2Qm9KLHlCQUF5QixFQUFFO0lBQzNCa0ksd0JBQXdCaEI7SUFDeEJ4RSw0QkFBNEJsVTtJQUM1QjhYLFlBQVk7SUFDWnpELG9CQUFvQjtBQUN0QjtBQUNBLE1BQU1zRix5QkFBeUI7SUFDN0JKLGdCQUFnQjtJQUNoQjdMLFlBQVksRUFBRTtJQUNkaFAsUUFBUTtJQUNSOGEsZ0JBQWdCO0lBQ2hCSSxtQkFBbUI7UUFDakJyYixXQUFXO0lBQ2I7SUFDQUosVUFBVTZCO0lBQ1Y2UyxnQkFBZ0IsV0FBVyxHQUFFLElBQUkvYztJQUNqQytJLE1BQU07SUFDTnFWLDRCQUE0QmxVO0FBQzlCO0FBQ0EsTUFBTTZaLGtCQUFrQixXQUFXLEdBQUU1dkIsTUFBTXlULGFBQWEsQ0FBQ2ljO0FBQ3pELE1BQU1HLGdCQUFnQixXQUFXLEdBQUU3dkIsTUFBTXlULGFBQWEsQ0FBQzRiO0FBRXZELFNBQVNTO0lBQ1AsT0FBTztRQUNMeGIsV0FBVztZQUNURyxRQUFRO1lBQ1J5USxvQkFBb0I7Z0JBQ2xCOWhCLEdBQUc7Z0JBQ0h3TixHQUFHO1lBQ0w7WUFDQW1mLE9BQU8sSUFBSWxrQjtZQUNYbWtCLFdBQVc7Z0JBQ1Q1c0IsR0FBRztnQkFDSHdOLEdBQUc7WUFDTDtRQUNGO1FBQ0E4ZCxXQUFXO1lBQ1RsRixZQUFZLElBQUlzRjtRQUNsQjtJQUNGO0FBQ0Y7QUFDQSxTQUFTbUIsUUFBUUMsS0FBSyxFQUFFQyxNQUFNO0lBQzVCLE9BQVFBLE9BQU90dkIsSUFBSTtRQUNqQixLQUFLaVYsT0FBTzBPLFNBQVM7WUFDbkIsT0FBTztnQkFBRSxHQUFHMEwsS0FBSztnQkFDZjViLFdBQVc7b0JBQUUsR0FBRzRiLE1BQU01YixTQUFTO29CQUM3QjRRLG9CQUFvQmlMLE9BQU9qTCxrQkFBa0I7b0JBQzdDelEsUUFBUTBiLE9BQU8xYixNQUFNO2dCQUN2QjtZQUNGO1FBRUYsS0FBS3FCLE9BQU9zYSxRQUFRO1lBQ2xCLElBQUlGLE1BQU01YixTQUFTLENBQUNHLE1BQU0sSUFBSSxNQUFNO2dCQUNsQyxPQUFPeWI7WUFDVDtZQUVBLE9BQU87Z0JBQUUsR0FBR0EsS0FBSztnQkFDZjViLFdBQVc7b0JBQUUsR0FBRzRiLE1BQU01YixTQUFTO29CQUM3QjBiLFdBQVc7d0JBQ1Q1c0IsR0FBRytzQixPQUFPak4sV0FBVyxDQUFDOWYsQ0FBQyxHQUFHOHNCLE1BQU01YixTQUFTLENBQUM0USxrQkFBa0IsQ0FBQzloQixDQUFDO3dCQUM5RHdOLEdBQUd1ZixPQUFPak4sV0FBVyxDQUFDdFMsQ0FBQyxHQUFHc2YsTUFBTTViLFNBQVMsQ0FBQzRRLGtCQUFrQixDQUFDdFUsQ0FBQztvQkFDaEU7Z0JBQ0Y7WUFDRjtRQUVGLEtBQUtrRixPQUFPdWEsT0FBTztRQUNuQixLQUFLdmEsT0FBT3dhLFVBQVU7WUFDcEIsT0FBTztnQkFBRSxHQUFHSixLQUFLO2dCQUNmNWIsV0FBVztvQkFBRSxHQUFHNGIsTUFBTTViLFNBQVM7b0JBQzdCRyxRQUFRO29CQUNSeVEsb0JBQW9CO3dCQUNsQjloQixHQUFHO3dCQUNId04sR0FBRztvQkFDTDtvQkFDQW9mLFdBQVc7d0JBQ1Q1c0IsR0FBRzt3QkFDSHdOLEdBQUc7b0JBQ0w7Z0JBQ0Y7WUFDRjtRQUVGLEtBQUtrRixPQUFPeWEsaUJBQWlCO1lBQzNCO2dCQUNFLE1BQU0sRUFDSnZsQixPQUFPLEVBQ1IsR0FBR21sQjtnQkFDSixNQUFNLEVBQ0ozZ0IsRUFBRSxFQUNILEdBQUd4RTtnQkFDSixNQUFNd2UsYUFBYSxJQUFJc0YsdUJBQXVCb0IsTUFBTXhCLFNBQVMsQ0FBQ2xGLFVBQVU7Z0JBQ3hFQSxXQUFXM2lCLEdBQUcsQ0FBQzJJLElBQUl4RTtnQkFDbkIsT0FBTztvQkFBRSxHQUFHa2xCLEtBQUs7b0JBQ2Z4QixXQUFXO3dCQUFFLEdBQUd3QixNQUFNeEIsU0FBUzt3QkFDN0JsRjtvQkFDRjtnQkFDRjtZQUNGO1FBRUYsS0FBSzFULE9BQU8wYSxvQkFBb0I7WUFDOUI7Z0JBQ0UsTUFBTSxFQUNKaGhCLEVBQUUsRUFDRnhPLEdBQUcsRUFDSDBtQixRQUFRLEVBQ1QsR0FBR3lJO2dCQUNKLE1BQU1ubEIsVUFBVWtsQixNQUFNeEIsU0FBUyxDQUFDbEYsVUFBVSxDQUFDcmpCLEdBQUcsQ0FBQ3FKO2dCQUUvQyxJQUFJLENBQUN4RSxXQUFXaEssUUFBUWdLLFFBQVFoSyxHQUFHLEVBQUU7b0JBQ25DLE9BQU9rdkI7Z0JBQ1Q7Z0JBRUEsTUFBTTFHLGFBQWEsSUFBSXNGLHVCQUF1Qm9CLE1BQU14QixTQUFTLENBQUNsRixVQUFVO2dCQUN4RUEsV0FBVzNpQixHQUFHLENBQUMySSxJQUFJO29CQUFFLEdBQUd4RSxPQUFPO29CQUM3QjBjO2dCQUNGO2dCQUNBLE9BQU87b0JBQUUsR0FBR3dJLEtBQUs7b0JBQ2Z4QixXQUFXO3dCQUFFLEdBQUd3QixNQUFNeEIsU0FBUzt3QkFDN0JsRjtvQkFDRjtnQkFDRjtZQUNGO1FBRUYsS0FBSzFULE9BQU8yYSxtQkFBbUI7WUFDN0I7Z0JBQ0UsTUFBTSxFQUNKamhCLEVBQUUsRUFDRnhPLEdBQUcsRUFDSixHQUFHbXZCO2dCQUNKLE1BQU1ubEIsVUFBVWtsQixNQUFNeEIsU0FBUyxDQUFDbEYsVUFBVSxDQUFDcmpCLEdBQUcsQ0FBQ3FKO2dCQUUvQyxJQUFJLENBQUN4RSxXQUFXaEssUUFBUWdLLFFBQVFoSyxHQUFHLEVBQUU7b0JBQ25DLE9BQU9rdkI7Z0JBQ1Q7Z0JBRUEsTUFBTTFHLGFBQWEsSUFBSXNGLHVCQUF1Qm9CLE1BQU14QixTQUFTLENBQUNsRixVQUFVO2dCQUN4RUEsV0FBV3ZWLE1BQU0sQ0FBQ3pFO2dCQUNsQixPQUFPO29CQUFFLEdBQUcwZ0IsS0FBSztvQkFDZnhCLFdBQVc7d0JBQUUsR0FBR3dCLE1BQU14QixTQUFTO3dCQUM3QmxGO29CQUNGO2dCQUNGO1lBQ0Y7UUFFRjtZQUNFO2dCQUNFLE9BQU8wRztZQUNUO0lBQ0o7QUFDRjtBQUVBLFNBQVNRLGFBQWFsZixJQUFJO0lBQ3hCLElBQUksRUFDRmtXLFFBQVEsRUFDVCxHQUFHbFc7SUFDSixNQUFNLEVBQ0ppRCxNQUFNLEVBQ042YSxjQUFjLEVBQ2QxRyxjQUFjLEVBQ2YsR0FBRzVvQixNQUFNNFQsVUFBVSxDQUFDZ2M7SUFDckIsTUFBTWUseUJBQXlCdGhCLFlBQVlpZ0I7SUFDM0MsTUFBTXNCLG1CQUFtQnZoQixZQUFZb0YsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT2pGLEVBQUUsR0FBRywrQ0FBK0M7SUFFMUh4UCxNQUFNd04sU0FBUyxDQUFDO1FBQ2QsSUFBSWthLFVBQVU7WUFDWjtRQUNGO1FBRUEsSUFBSSxDQUFDNEgsa0JBQWtCcUIsMEJBQTBCQyxvQkFBb0IsTUFBTTtZQUN6RSxJQUFJLENBQUN4Z0IsZ0JBQWdCdWdCLHlCQUF5QjtnQkFDNUM7WUFDRjtZQUVBLElBQUl4a0IsU0FBUzBrQixhQUFhLEtBQUtGLHVCQUF1QmprQixNQUFNLEVBQUU7Z0JBQzVELDJCQUEyQjtnQkFDM0I7WUFDRjtZQUVBLE1BQU1tYyxnQkFBZ0JELGVBQWV6aUIsR0FBRyxDQUFDeXFCO1lBRXpDLElBQUksQ0FBQy9ILGVBQWU7Z0JBQ2xCO1lBQ0Y7WUFFQSxNQUFNLEVBQ0poRixhQUFhLEVBQ2IxWixJQUFJLEVBQ0wsR0FBRzBlO1lBRUosSUFBSSxDQUFDaEYsY0FBY2hXLE9BQU8sSUFBSSxDQUFDMUQsS0FBSzBELE9BQU8sRUFBRTtnQkFDM0M7WUFDRjtZQUVBaWpCLHNCQUFzQjtnQkFDcEIsS0FBSyxNQUFNOWxCLFdBQVc7b0JBQUM2WSxjQUFjaFcsT0FBTztvQkFBRTFELEtBQUswRCxPQUFPO2lCQUFDLENBQUU7b0JBQzNELElBQUksQ0FBQzdDLFNBQVM7d0JBQ1o7b0JBQ0Y7b0JBRUEsTUFBTStsQixnQkFBZ0JuZix1QkFBdUI1RztvQkFFN0MsSUFBSStsQixlQUFlO3dCQUNqQkEsY0FBY0MsS0FBSzt3QkFDbkI7b0JBQ0Y7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDMUI7UUFBZ0I1SDtRQUFVa0I7UUFBZ0JnSTtRQUFrQkQ7S0FBdUI7SUFDdkYsT0FBTztBQUNUO0FBRUEsU0FBU00sZUFBZUMsU0FBUyxFQUFFMWYsSUFBSTtJQUNyQyxJQUFJLEVBQ0ZSLFNBQVMsRUFDVCxHQUFHL0MsTUFDSixHQUFHdUQ7SUFDSixPQUFPMGYsYUFBYSxRQUFRQSxVQUFVdHBCLE1BQU0sR0FBR3NwQixVQUFVdGhCLE1BQU0sQ0FBQyxDQUFDQyxhQUFhSDtRQUM1RSxPQUFPQSxTQUFTO1lBQ2RzQixXQUFXbkI7WUFDWCxHQUFHNUIsSUFBSTtRQUNUO0lBQ0YsR0FBRytDLGFBQWFBO0FBQ2xCO0FBRUEsU0FBU21nQiwwQkFBMEJyd0IsTUFBTTtJQUN2QyxPQUFPZCxNQUFNK08sT0FBTyxDQUFDLElBQU8sQ0FBQTtZQUMxQnVGLFdBQVc7Z0JBQUUsR0FBR21hLDhCQUE4Qm5hLFNBQVM7Z0JBQ3JELEdBQUl4VCxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPd1QsU0FBUztZQUNoRDtZQUNBb2EsV0FBVztnQkFBRSxHQUFHRCw4QkFBOEJDLFNBQVM7Z0JBQ3JELEdBQUk1dEIsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBTzR0QixTQUFTO1lBQ2hEO1lBQ0FHLGFBQWE7Z0JBQUUsR0FBR0osOEJBQThCSSxXQUFXO2dCQUN6RCxHQUFJL3RCLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU8rdEIsV0FBVztZQUNsRDtRQUNGLENBQUEsR0FDQTtRQUFDL3RCLFVBQVUsT0FBTyxLQUFLLElBQUlBLE9BQU93VCxTQUFTO1FBQUV4VCxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPNHRCLFNBQVM7UUFBRTV0QixVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPK3RCLFdBQVc7S0FBQztBQUN4STtBQUVBLFNBQVN1QyxpQ0FBaUM1ZixJQUFJO0lBQzVDLElBQUksRUFDRnFRLFVBQVUsRUFDVnRELE9BQU8sRUFDUDROLFdBQVcsRUFDWHJyQixTQUFTLElBQUksRUFDZCxHQUFHMFE7SUFDSixNQUFNNmYsY0FBY3J4QixNQUFNNE4sTUFBTSxDQUFDO0lBQ2pDLE1BQU0sRUFDSnhLLENBQUMsRUFDRHdOLENBQUMsRUFDRixHQUFHLE9BQU85UCxXQUFXLFlBQVk7UUFDaENzQyxHQUFHdEM7UUFDSDhQLEdBQUc5UDtJQUNMLElBQUlBO0lBQ0p3TSwwQkFBMEI7UUFDeEIsTUFBTW9hLFdBQVcsQ0FBQ3RrQixLQUFLLENBQUN3TjtRQUV4QixJQUFJOFcsWUFBWSxDQUFDN0YsWUFBWTtZQUMzQndQLFlBQVl4akIsT0FBTyxHQUFHO1lBQ3RCO1FBQ0Y7UUFFQSxJQUFJd2pCLFlBQVl4akIsT0FBTyxJQUFJLENBQUNzZSxhQUFhO1lBQ3ZDLHlFQUF5RTtZQUN6RSwrQ0FBK0M7WUFDL0M7UUFDRixFQUFFLDREQUE0RDtRQUc5RCxNQUFNaGlCLE9BQU8wWCxjQUFjLE9BQU8sS0FBSyxJQUFJQSxXQUFXMVgsSUFBSSxDQUFDMEQsT0FBTztRQUVsRSxJQUFJLENBQUMxRCxRQUFRQSxLQUFLc2hCLFdBQVcsS0FBSyxPQUFPO1lBQ3ZDLGtFQUFrRTtZQUNsRSxrQ0FBa0M7WUFDbEM7UUFDRjtRQUVBLE1BQU03VSxPQUFPMkgsUUFBUXBVO1FBQ3JCLE1BQU1tbkIsWUFBWWhZLGFBQWExQyxNQUFNdVY7UUFFckMsSUFBSSxDQUFDL29CLEdBQUc7WUFDTmt1QixVQUFVbHVCLENBQUMsR0FBRztRQUNoQjtRQUVBLElBQUksQ0FBQ3dOLEdBQUc7WUFDTjBnQixVQUFVMWdCLENBQUMsR0FBRztRQUNoQixFQUFFLHFEQUFxRDtRQUd2RHlnQixZQUFZeGpCLE9BQU8sR0FBRztRQUV0QixJQUFJb0QsS0FBSzhNLEdBQUcsQ0FBQ3VULFVBQVVsdUIsQ0FBQyxJQUFJLEtBQUs2TixLQUFLOE0sR0FBRyxDQUFDdVQsVUFBVTFnQixDQUFDLElBQUksR0FBRztZQUMxRCxNQUFNaUwsMEJBQTBCRCwyQkFBMkJ6UjtZQUUzRCxJQUFJMFIseUJBQXlCO2dCQUMzQkEsd0JBQXdCbUgsUUFBUSxDQUFDO29CQUMvQnhRLEtBQUs4ZSxVQUFVMWdCLENBQUM7b0JBQ2hCNkIsTUFBTTZlLFVBQVVsdUIsQ0FBQztnQkFDbkI7WUFDRjtRQUNGO0lBQ0YsR0FBRztRQUFDeWU7UUFBWXplO1FBQUd3TjtRQUFHdWI7UUFBYTVOO0tBQVE7QUFDN0M7QUFFQSxNQUFNZ1QseUJBQXlCLFdBQVcsR0FBRXZ4QixNQUFNeVQsYUFBYSxDQUFDO0lBQUUsR0FBRzRDLGtCQUFrQjtJQUNyRmpGLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBQ0EsSUFBSW1nQjtBQUVILENBQUEsU0FBVUEsTUFBTTtJQUNmQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxFQUFFLEdBQUc7SUFDckNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGNBQWMsR0FBRyxFQUFFLEdBQUc7QUFDdEMsQ0FBQSxFQUFHQSxVQUFXQSxDQUFBQSxTQUFTLENBQUMsQ0FBQTtBQUV4QixNQUFNQyxhQUFhLFdBQVcsR0FBRXp4QixNQUFNMHhCLElBQUksQ0FBQyxTQUFTRCxXQUFXamdCLElBQUk7SUFDakUsSUFBSW1nQix1QkFBdUJDLHVCQUF1QkMsbUJBQW1CQztJQUVyRSxJQUFJLEVBQ0Z0aUIsRUFBRSxFQUNGdWlCLGFBQWEsRUFDYjlKLGFBQWEsSUFBSSxFQUNqQnRlLFFBQVEsRUFDUnlNLFVBQVVtWSxjQUFjLEVBQ3hCeUQscUJBQXFCNVosZ0JBQWdCLEVBQ3JDNlosU0FBUyxFQUNUZixTQUFTLEVBQ1QsR0FBRzl2QixPQUNKLEdBQUdvUTtJQUNKLE1BQU0wZ0IsUUFBUWx5QixNQUFNbXlCLFVBQVUsQ0FBQ2xDLFNBQVMvTyxXQUFXNE87SUFDbkQsTUFBTSxDQUFDSSxPQUFPaGMsU0FBUyxHQUFHZ2U7SUFDMUIsTUFBTSxDQUFDRSxzQkFBc0JDLHdCQUF3QixHQUFHdmU7SUFDeEQsTUFBTSxDQUFDd2UsUUFBUUMsVUFBVSxHQUFHdnlCLE1BQU1zVCxRQUFRLENBQUNrZSxPQUFPZ0IsYUFBYTtJQUMvRCxNQUFNQyxnQkFBZ0JILFdBQVdkLE9BQU9rQixXQUFXO0lBQ25ELE1BQU0sRUFDSnBlLFdBQVcsRUFDVEcsUUFBUWtlLFFBQVEsRUFDaEI1QyxPQUFPbkgsY0FBYyxFQUNyQm9ILFNBQVMsRUFDVixFQUNEdEIsV0FBVyxFQUNUbEYsWUFBWWpSLG1CQUFtQixFQUNoQyxFQUNGLEdBQUcyWDtJQUNKLE1BQU0vbEIsT0FBT3dvQixZQUFZLE9BQU8vSixlQUFlemlCLEdBQUcsQ0FBQ3dzQixZQUFZO0lBQy9ELE1BQU1DLGNBQWM1eUIsTUFBTTROLE1BQU0sQ0FBQztRQUMvQmlsQixTQUFTO1FBQ1RDLFlBQVk7SUFDZDtJQUNBLE1BQU1yZSxTQUFTelUsTUFBTStPLE9BQU8sQ0FBQztRQUMzQixJQUFJZ2tCO1FBRUosT0FBT0osWUFBWSxPQUFPO1lBQ3hCbmpCLElBQUltakI7WUFDSiw4REFBOEQ7WUFDOUQzYixNQUFNLEFBQUMrYixDQUFBQSxhQUFhNW9CLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUs2TSxJQUFJLEFBQUQsS0FBTSxPQUFPK2IsYUFBYXZFO1lBQzlFNVgsTUFBTWdjO1FBQ1IsSUFBSTtJQUNOLEdBQUc7UUFBQ0Q7UUFBVXhvQjtLQUFLO0lBQ25CLE1BQU02b0IsWUFBWWh6QixNQUFNNE4sTUFBTSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ3FsQixjQUFjQyxnQkFBZ0IsR0FBR2x6QixNQUFNc1QsUUFBUSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ2djLGdCQUFnQjZELGtCQUFrQixHQUFHbnpCLE1BQU1zVCxRQUFRLENBQUM7SUFDM0QsTUFBTThmLGNBQWMxa0IsZUFBZXROLE9BQU82RCxPQUFPaW9CLE1BQU0sQ0FBQzlyQjtJQUN4RCxNQUFNaXlCLHlCQUF5QjlqQixZQUFZLGtCQUFrQkM7SUFDN0QsTUFBTThqQiw2QkFBNkJ0ekIsTUFBTStPLE9BQU8sQ0FBQyxJQUFNd0osb0JBQW9CMFcsVUFBVSxJQUFJO1FBQUMxVztLQUFvQjtJQUM5RyxNQUFNa1gseUJBQXlCMEIsMEJBQTBCYztJQUN6RCxNQUFNLEVBQ0ozWixjQUFjLEVBQ2QyUiwwQkFBMEIsRUFDMUJHLGtCQUFrQixFQUNuQixHQUFHYixzQkFBc0IrSiw0QkFBNEI7UUFDcEQ3SixVQUFVZ0o7UUFDVjlqQixjQUFjO1lBQUNxaEIsVUFBVTVzQixDQUFDO1lBQUU0c0IsVUFBVXBmLENBQUM7U0FBQztRQUN4QzlQLFFBQVEydUIsdUJBQXVCZixTQUFTO0lBQzFDO0lBQ0EsTUFBTTdNLGFBQWE4RyxjQUFjQyxnQkFBZ0IrSjtJQUNqRCxNQUFNWSx3QkFBd0J2ekIsTUFBTStPLE9BQU8sQ0FBQyxJQUFNdWdCLGlCQUFpQjllLG9CQUFvQjhlLGtCQUFrQixNQUFNO1FBQUNBO0tBQWU7SUFDL0gsTUFBTWtFLG9CQUFvQkM7SUFDMUIsTUFBTUMsd0JBQXdCakosZUFBZTVJLFlBQVk0Tix1QkFBdUJuYixTQUFTLENBQUNpSyxPQUFPO0lBQ2pHNlMsaUNBQWlDO1FBQy9CdlAsWUFBWThRLFlBQVksT0FBTy9KLGVBQWV6aUIsR0FBRyxDQUFDd3NCLFlBQVk7UUFDOUQ3eEIsUUFBUTB5QixrQkFBa0JHLHVCQUF1QjtRQUNqRHhILGFBQWF1SDtRQUNiblYsU0FBU2tSLHVCQUF1Qm5iLFNBQVMsQ0FBQ2lLLE9BQU87SUFDbkQ7SUFDQSxNQUFNZ1IsaUJBQWlCbkUsUUFBUXZKLFlBQVk0Tix1QkFBdUJuYixTQUFTLENBQUNpSyxPQUFPLEVBQUVtVjtJQUNyRixNQUFNbEUsb0JBQW9CcEUsUUFBUXZKLGFBQWFBLFdBQVcrUixhQUFhLEdBQUc7SUFDMUUsTUFBTUMsZ0JBQWdCN3pCLE1BQU00TixNQUFNLENBQUM7UUFDakMwaEIsZ0JBQWdCO1FBQ2hCN2EsUUFBUTtRQUNSb047UUFDQXhKLGVBQWU7UUFDZmYsWUFBWTtRQUNaZ0I7UUFDQXNRO1FBQ0FrTCxjQUFjO1FBQ2RDLGtCQUFrQjtRQUNsQnhiO1FBQ0EzRCxNQUFNO1FBQ051SixxQkFBcUIsRUFBRTtRQUN2QjZWLHlCQUF5QjtJQUMzQjtJQUNBLE1BQU1DLFdBQVcxYixvQkFBb0IyVyxVQUFVLENBQUMsQUFBQ3lDLENBQUFBLHdCQUF3QmtDLGNBQWNobUIsT0FBTyxDQUFDK0csSUFBSSxBQUFELEtBQU0sT0FBTyxLQUFLLElBQUkrYyxzQkFBc0JuaUIsRUFBRTtJQUNoSixNQUFNcWYsY0FBY1Ysd0JBQXdCO1FBQzFDNVAsU0FBU2tSLHVCQUF1QlosV0FBVyxDQUFDdFEsT0FBTztJQUNyRCxJQUFJLG9EQUFvRDtJQUV4RCxNQUFNdVYsZUFBZSxBQUFDbEMsQ0FBQUEsd0JBQXdCL0MsWUFBWVIsT0FBTyxDQUFDeGdCLE9BQU8sQUFBRCxLQUFNLE9BQU8rakIsd0JBQXdCL1A7SUFDN0csTUFBTWtTLG1CQUFtQnRCLGdCQUFnQixBQUFDWixDQUFBQSxvQkFBb0JoRCxZQUFZalksSUFBSSxBQUFELEtBQU0sT0FBT2liLG9CQUFvQnRDLGlCQUFpQjtJQUMvSCxNQUFNMkUsa0JBQWtCbFEsUUFBUTZLLFlBQVlSLE9BQU8sQ0FBQ3hnQixPQUFPLElBQUlnaEIsWUFBWWpZLElBQUksR0FBRyx3RUFBd0U7SUFDMUosaURBQWlEO0lBRWpELE1BQU11ZCxnQkFBZ0JqSSxhQUFhZ0ksa0JBQWtCLE9BQU8zRSxpQkFBaUIsMkNBQTJDO0lBRXhILE1BQU0xQixhQUFhSixjQUFjcUcsZUFBZXJuQixVQUFVcW5CLGdCQUFnQixPQUFPLGdEQUFnRDtJQUVqSSxNQUFNM1Ysc0JBQXNCa08sdUJBQXVCb0csZ0JBQWdCd0IsWUFBWSxPQUFPQSxXQUFXcFMsYUFBYTtJQUM5RyxNQUFNMEYsMEJBQTBCb0csU0FBU3hQLHNCQUFzQixrQkFBa0I7SUFFakYsTUFBTWlXLG9CQUFvQm5ELGVBQWVDLFdBQVc7UUFDbERsZ0IsV0FBVztZQUNUNU4sR0FBRzRzQixVQUFVNXNCLENBQUMsR0FBRyt3QixjQUFjL3dCLENBQUM7WUFDaEN3TixHQUFHb2YsVUFBVXBmLENBQUMsR0FBR3VqQixjQUFjdmpCLENBQUM7WUFDaENRLFFBQVE7WUFDUkMsUUFBUTtRQUNWO1FBQ0FpZTtRQUNBN2E7UUFDQThhO1FBQ0FDO1FBQ0F1RTtRQUNBbmYsTUFBTWlmLGNBQWNobUIsT0FBTyxDQUFDK0csSUFBSTtRQUNoQ3lmLGlCQUFpQnhGLFlBQVlqWSxJQUFJO1FBQ2pDdUg7UUFDQW9KO1FBQ0FzRztJQUNGO0lBQ0EsTUFBTS9VLHFCQUFxQnlhLHdCQUF3QnZqQixJQUFJdWpCLHVCQUF1QnZELGFBQWE7SUFDM0YsTUFBTXBSLGdCQUFnQjROLGlCQUFpQnJPLHNCQUFzQiwyREFBMkQ7SUFFeEgsTUFBTW1XLG1CQUFtQm5ILHNCQUFzQnZPLGdCQUFnQixvRkFBb0Y7SUFFbkosTUFBTTJWLHdCQUF3QnBILHNCQUFzQnZPLGVBQWU7UUFBQzJRO0tBQWU7SUFDbkYsTUFBTXlFLDBCQUEwQmhrQixJQUFJb2tCLG1CQUFtQkU7SUFDdkQsTUFBTWpjLGdCQUFnQjBiLG1CQUFtQnJhLGdCQUFnQnFhLGtCQUFrQksscUJBQXFCO0lBQ2hHLE1BQU05YyxhQUFhN0MsVUFBVTRELGdCQUFnQjJaLG1CQUFtQjtRQUM5RHZkO1FBQ0E0RDtRQUNBQztRQUNBQyxxQkFBcUIrYTtRQUNyQnhhO0lBQ0YsS0FBSztJQUNMLE1BQU0wYixTQUFTbmQsa0JBQWtCQyxZQUFZO0lBQzdDLE1BQU0sQ0FBQzFDLE1BQU02ZixRQUFRLEdBQUd6MEIsTUFBTXNULFFBQVEsQ0FBQyxPQUFPLGlFQUFpRTtJQUMvRyxzQkFBc0I7SUFFdEIsTUFBTW9oQixtQkFBbUJSLGtCQUFrQkUsb0JBQW9CcGtCLElBQUlva0IsbUJBQW1CRztJQUN0RixNQUFNdmpCLFlBQVltSSxZQUFZdWIsa0JBQWtCLEFBQUM1QyxDQUFBQSxhQUFhbGQsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS2dDLElBQUksQUFBRCxLQUFNLE9BQU9rYixhQUFhLE1BQU12QztJQUM5SCxNQUFNb0Ysa0JBQWtCMzBCLE1BQU00TixNQUFNLENBQUM7SUFDckMsTUFBTWduQixvQkFBb0I1MEIsTUFBTThOLFdBQVcsQ0FBQyxDQUFDcUMsT0FBT3dFO1FBQ2xELElBQUksRUFDRnNCLFFBQVFnVCxNQUFNLEVBQ2QvUyxPQUFPLEVBQ1IsR0FBR3ZCO1FBRUosSUFBSXFlLFVBQVVubEIsT0FBTyxJQUFJLE1BQU07WUFDN0I7UUFDRjtRQUVBLE1BQU1nVSxhQUFhK0csZUFBZXppQixHQUFHLENBQUM2c0IsVUFBVW5sQixPQUFPO1FBRXZELElBQUksQ0FBQ2dVLFlBQVk7WUFDZjtRQUNGO1FBRUEsTUFBTXlOLGlCQUFpQm5mLE1BQU13VCxXQUFXO1FBQ3hDLE1BQU1rUixpQkFBaUIsSUFBSTVMLE9BQU87WUFDaEN4VSxRQUFRdWUsVUFBVW5sQixPQUFPO1lBQ3pCZ1U7WUFDQTFSLE9BQU9tZjtZQUNQcFo7WUFDQSxnRkFBZ0Y7WUFDaEYsNkRBQTZEO1lBQzdENkwsU0FBUzhSO1lBRVRqTyxTQUFRcFcsRUFBRTtnQkFDUixNQUFNcVosZ0JBQWdCRCxlQUFlemlCLEdBQUcsQ0FBQ3FKO2dCQUV6QyxJQUFJLENBQUNxWixlQUFlO29CQUNsQjtnQkFDRjtnQkFFQSxNQUFNLEVBQ0ppTSxXQUFXLEVBQ1osR0FBRzFCLFlBQVl2bEIsT0FBTztnQkFDdkIsTUFBTXNDLFFBQVE7b0JBQ1pYO2dCQUNGO2dCQUNBc2xCLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVkza0I7Z0JBQzNDaWlCLHFCQUFxQjtvQkFDbkJ2eEIsTUFBTTtvQkFDTnNQO2dCQUNGO1lBQ0Y7WUFFQThVLFdBQVV6VixFQUFFLEVBQUV1VSxVQUFVLEVBQUVtQixrQkFBa0IsRUFBRUYsTUFBTTtnQkFDbEQsTUFBTTZELGdCQUFnQkQsZUFBZXppQixHQUFHLENBQUNxSjtnQkFFekMsSUFBSSxDQUFDcVosZUFBZTtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsTUFBTSxFQUNKa00sYUFBYSxFQUNkLEdBQUczQixZQUFZdmxCLE9BQU87Z0JBQ3ZCLE1BQU1zQyxRQUFRO29CQUNaWDtvQkFDQXVVO29CQUNBbUI7b0JBQ0FGO2dCQUNGO2dCQUNBK1AsaUJBQWlCLE9BQU8sS0FBSyxJQUFJQSxjQUFjNWtCO2dCQUMvQ2lpQixxQkFBcUI7b0JBQ25CdnhCLE1BQU07b0JBQ05zUDtnQkFDRjtZQUNGO1lBRUEyUixTQUFRb0Qsa0JBQWtCO2dCQUN4QixNQUFNMVYsS0FBS3dqQixVQUFVbmxCLE9BQU87Z0JBRTVCLElBQUkyQixNQUFNLE1BQU07b0JBQ2Q7Z0JBQ0Y7Z0JBRUEsTUFBTXFaLGdCQUFnQkQsZUFBZXppQixHQUFHLENBQUNxSjtnQkFFekMsSUFBSSxDQUFDcVosZUFBZTtvQkFDbEI7Z0JBQ0Y7Z0JBRUEsTUFBTSxFQUNKclUsV0FBVyxFQUNaLEdBQUc0ZSxZQUFZdmxCLE9BQU87Z0JBQ3ZCLE1BQU1zQyxRQUFRO29CQUNabWY7b0JBQ0E3YSxRQUFRO3dCQUNOakY7d0JBQ0F3SCxNQUFNNlIsY0FBYzdSLElBQUk7d0JBQ3hCSixNQUFNZ2M7b0JBQ1I7Z0JBQ0Y7Z0JBQ0ExeUIsU0FBUzgwQix1QkFBdUIsQ0FBQztvQkFDL0J4Z0IsZUFBZSxPQUFPLEtBQUssSUFBSUEsWUFBWXJFO29CQUMzQ29pQixVQUFVZixPQUFPeUQsWUFBWTtvQkFDN0IvZ0IsU0FBUzt3QkFDUHJULE1BQU1pVixPQUFPME8sU0FBUzt3QkFDdEJVO3dCQUNBelEsUUFBUWpGO29CQUNWO29CQUNBNGlCLHFCQUFxQjt3QkFDbkJ2eEIsTUFBTTt3QkFDTnNQO29CQUNGO29CQUNBK2lCLGdCQUFnQnlCLGdCQUFnQjltQixPQUFPO29CQUN2Q3NsQixrQkFBa0I3RDtnQkFDcEI7WUFDRjtZQUVBbk0sUUFBT0QsV0FBVztnQkFDaEJoUCxTQUFTO29CQUNQclQsTUFBTWlWLE9BQU9zYSxRQUFRO29CQUNyQmxOO2dCQUNGO1lBQ0Y7WUFFQUUsT0FBTzhSLGNBQWNwZixPQUFPdWEsT0FBTztZQUNuQy9NLFVBQVU0UixjQUFjcGYsT0FBT3dhLFVBQVU7UUFDM0M7UUFDQXFFLGdCQUFnQjltQixPQUFPLEdBQUdnbkI7UUFFMUIsU0FBU0ssY0FBY3IwQixJQUFJO1lBQ3pCLE9BQU8sZUFBZTZNO2dCQUNwQixNQUFNLEVBQ0orRyxNQUFNLEVBQ042QyxVQUFVLEVBQ1YxQyxJQUFJLEVBQ0pvZix1QkFBdUIsRUFDeEIsR0FBR0gsY0FBY2htQixPQUFPO2dCQUN6QixJQUFJc0MsUUFBUTtnQkFFWixJQUFJc0UsVUFBVXVmLHlCQUF5QjtvQkFDckMsTUFBTSxFQUNKbUIsVUFBVSxFQUNYLEdBQUcvQixZQUFZdmxCLE9BQU87b0JBQ3ZCc0MsUUFBUTt3QkFDTm1mO3dCQUNBN2EsUUFBUUE7d0JBQ1I2Qzt3QkFDQXFJLE9BQU9xVTt3QkFDUHBmO29CQUNGO29CQUVBLElBQUkvVCxTQUFTaVYsT0FBT3VhLE9BQU8sSUFBSSxPQUFPOEUsZUFBZSxZQUFZO3dCQUMvRCxNQUFNQyxlQUFlLE1BQU1DLFFBQVFDLE9BQU8sQ0FBQ0gsV0FBV2hsQjt3QkFFdEQsSUFBSWlsQixjQUFjOzRCQUNoQnYwQixPQUFPaVYsT0FBT3dhLFVBQVU7d0JBQzFCO29CQUNGO2dCQUNGO2dCQUVBMEMsVUFBVW5sQixPQUFPLEdBQUc7Z0JBQ3BCM04sU0FBUzgwQix1QkFBdUIsQ0FBQztvQkFDL0I5Z0IsU0FBUzt3QkFDUHJUO29CQUNGO29CQUNBMHhCLFVBQVVmLE9BQU9nQixhQUFhO29CQUM5QmlDLFFBQVE7b0JBQ1J2QixnQkFBZ0I7b0JBQ2hCQyxrQkFBa0I7b0JBQ2xCd0IsZ0JBQWdCOW1CLE9BQU8sR0FBRztvQkFDMUIsTUFBTXFSLFlBQVlyZSxTQUFTaVYsT0FBT3VhLE9BQU8sR0FBRyxjQUFjO29CQUUxRCxJQUFJbGdCLE9BQU87d0JBQ1QsTUFBTXpDLFVBQVUwbEIsWUFBWXZsQixPQUFPLENBQUNxUixVQUFVO3dCQUM5Q3hSLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF5Qzt3QkFDbkNpaUIscUJBQXFCOzRCQUNuQnZ4QixNQUFNcWU7NEJBQ04vTzt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRixHQUNBO1FBQUN5WTtLQUFlO0lBQ2hCLE1BQU0yTSxvQ0FBb0N2MUIsTUFBTThOLFdBQVcsQ0FBQyxDQUFDSixTQUFTdUk7UUFDcEUsT0FBTyxDQUFDOUYsT0FBT3NFO1lBQ2IsTUFBTWtQLGNBQWN4VCxNQUFNd1QsV0FBVztZQUNyQyxNQUFNNlIsc0JBQXNCNU0sZUFBZXppQixHQUFHLENBQUNzTztZQUUvQyxJQUNBdWUsVUFBVW5sQixPQUFPLEtBQUssUUFBUSxzQkFBc0I7WUFDcEQsQ0FBQzJuQix1QkFBdUIsa0NBQWtDO1lBQzFEN1IsWUFBWThSLE1BQU0sSUFBSTlSLFlBQVkrUixnQkFBZ0IsRUFBRTtnQkFDbEQ7WUFDRjtZQUVBLE1BQU1DLG9CQUFvQjtnQkFDeEJsaEIsUUFBUStnQjtZQUNWO1lBQ0EsTUFBTUksaUJBQWlCbG9CLFFBQVF5QyxPQUFPOEYsT0FBT0MsT0FBTyxFQUFFeWY7WUFFdEQsSUFBSUMsbUJBQW1CLE1BQU07Z0JBQzNCalMsWUFBWThSLE1BQU0sR0FBRztvQkFDbkJJLFlBQVk1ZixPQUFPQSxNQUFNO2dCQUMzQjtnQkFDQStjLFVBQVVubEIsT0FBTyxHQUFHNEc7Z0JBQ3BCbWdCLGtCQUFrQnprQixPQUFPOEY7WUFDM0I7UUFDRjtJQUNGLEdBQUc7UUFBQzJTO1FBQWdCZ007S0FBa0I7SUFDdEMsTUFBTW5SLGFBQWFzRixxQkFBcUIzUyxTQUFTbWY7SUFDakRqSSxlQUFlbFg7SUFDZjlJLDBCQUEwQjtRQUN4QixJQUFJaWlCLGtCQUFrQitDLFdBQVdkLE9BQU95RCxZQUFZLEVBQUU7WUFDcEQxQyxVQUFVZixPQUFPa0IsV0FBVztRQUM5QjtJQUNGLEdBQUc7UUFBQ25EO1FBQWdCK0M7S0FBTztJQUMzQnR5QixNQUFNd04sU0FBUyxDQUFDO1FBQ2QsTUFBTSxFQUNKaUksVUFBVSxFQUNYLEdBQUcyZCxZQUFZdmxCLE9BQU87UUFDdkIsTUFBTSxFQUNKNEcsTUFBTSxFQUNONmEsY0FBYyxFQUNkaFksVUFBVSxFQUNWMUMsSUFBSSxFQUNMLEdBQUdpZixjQUFjaG1CLE9BQU87UUFFekIsSUFBSSxDQUFDNEcsVUFBVSxDQUFDNmEsZ0JBQWdCO1lBQzlCO1FBQ0Y7UUFFQSxNQUFNbmYsUUFBUTtZQUNac0U7WUFDQTZhO1lBQ0FoWTtZQUNBcUksT0FBTztnQkFDTHZjLEdBQUc0d0Isd0JBQXdCNXdCLENBQUM7Z0JBQzVCd04sR0FBR29qQix3QkFBd0JwakIsQ0FBQztZQUM5QjtZQUNBZ0U7UUFDRjtRQUNBMVUsU0FBUzgwQix1QkFBdUIsQ0FBQztZQUMvQnZmLGNBQWMsT0FBTyxLQUFLLElBQUlBLFdBQVd0RjtZQUN6Q2lpQixxQkFBcUI7Z0JBQ25CdnhCLE1BQU07Z0JBQ05zUDtZQUNGO1FBQ0Y7SUFDRixHQUNBO1FBQUM2akIsd0JBQXdCNXdCLENBQUM7UUFBRTR3Qix3QkFBd0JwakIsQ0FBQztLQUFDO0lBQ3RENVEsTUFBTXdOLFNBQVMsQ0FBQztRQUNkLE1BQU0sRUFDSmlILE1BQU0sRUFDTjZhLGNBQWMsRUFDZGhZLFVBQVUsRUFDVmlCLG1CQUFtQixFQUNuQnliLHVCQUF1QixFQUN4QixHQUFHSCxjQUFjaG1CLE9BQU87UUFFekIsSUFBSSxDQUFDNEcsVUFBVXVlLFVBQVVubEIsT0FBTyxJQUFJLFFBQVEsQ0FBQ3loQixrQkFBa0IsQ0FBQzBFLHlCQUF5QjtZQUN2RjtRQUNGO1FBRUEsTUFBTSxFQUNKdGYsVUFBVSxFQUNYLEdBQUcwZSxZQUFZdmxCLE9BQU87UUFDdkIsTUFBTWlvQixnQkFBZ0J2ZCxvQkFBb0JwUyxHQUFHLENBQUNxdUI7UUFDOUMsTUFBTTVmLE9BQU9raEIsaUJBQWlCQSxjQUFjbGYsSUFBSSxDQUFDL0ksT0FBTyxHQUFHO1lBQ3pEMkIsSUFBSXNtQixjQUFjdG1CLEVBQUU7WUFDcEJvSCxNQUFNa2YsY0FBY2xmLElBQUksQ0FBQy9JLE9BQU87WUFDaENtSixNQUFNOGUsY0FBYzllLElBQUk7WUFDeEIwUSxVQUFVb08sY0FBY3BPLFFBQVE7UUFDbEMsSUFBSTtRQUNKLE1BQU12WCxRQUFRO1lBQ1pzRTtZQUNBNmE7WUFDQWhZO1lBQ0FxSSxPQUFPO2dCQUNMdmMsR0FBRzR3Qix3QkFBd0I1d0IsQ0FBQztnQkFDNUJ3TixHQUFHb2pCLHdCQUF3QnBqQixDQUFDO1lBQzlCO1lBQ0FnRTtRQUNGO1FBQ0ExVSxTQUFTODBCLHVCQUF1QixDQUFDO1lBQy9CUCxRQUFRN2Y7WUFDUkYsY0FBYyxPQUFPLEtBQUssSUFBSUEsV0FBV3ZFO1lBQ3pDaWlCLHFCQUFxQjtnQkFDbkJ2eEIsTUFBTTtnQkFDTnNQO1lBQ0Y7UUFDRjtJQUNGLEdBQ0E7UUFBQ3FrQjtLQUFPO0lBQ1JsbkIsMEJBQTBCO1FBQ3hCdW1CLGNBQWNobUIsT0FBTyxHQUFHO1lBQ3RCeWhCO1lBQ0E3YTtZQUNBb047WUFDQXhKO1lBQ0FmO1lBQ0FnQjtZQUNBc1E7WUFDQWtMO1lBQ0FDO1lBQ0F4YjtZQUNBM0Q7WUFDQXVKO1lBQ0E2VjtRQUNGO1FBQ0FwQixZQUFZL2tCLE9BQU8sR0FBRztZQUNwQmdsQixTQUFTa0I7WUFDVGpCLFlBQVl6YTtRQUNkO0lBQ0YsR0FBRztRQUFDNUQ7UUFBUW9OO1FBQVl2SztRQUFZZTtRQUFldVE7UUFBZ0JrTDtRQUFjQztRQUFrQnpiO1FBQWdCQztRQUFxQjNEO1FBQU11SjtRQUFxQjZWO0tBQXdCO0lBQzNMak4sZ0JBQWdCO1FBQUUsR0FBR3lNLGlCQUFpQjtRQUNwQzdULE9BQU9xUTtRQUNQOUksY0FBYzdPO1FBQ2RTO1FBQ0FxRjtRQUNBb0o7SUFDRjtJQUNBLE1BQU13TyxnQkFBZ0IvMUIsTUFBTStPLE9BQU8sQ0FBQztRQUNsQyxNQUFNZ1QsVUFBVTtZQUNkdE47WUFDQW9OO1lBQ0EwTjtZQUNBRDtZQUNBaFk7WUFDQWtZO1lBQ0FYO1lBQ0FqRztZQUNBclE7WUFDQUQ7WUFDQTFEO1lBQ0FxVjtZQUNBOUw7WUFDQW9KO1lBQ0FrSTtZQUNBckY7WUFDQXlEO1FBQ0Y7UUFDQSxPQUFPOUw7SUFDVCxHQUFHO1FBQUN0TjtRQUFRb047UUFBWTBOO1FBQWdCRDtRQUFnQmhZO1FBQVlrWTtRQUFtQlg7UUFBYWpHO1FBQWdCclE7UUFBcUJEO1FBQWdCMUQ7UUFBTXFWO1FBQTRCOUw7UUFBcUJvSjtRQUF5QmtJO1FBQXdCckY7UUFBb0J5RDtLQUFXO0lBQ2hTLE1BQU1tSSxrQkFBa0JoMkIsTUFBTStPLE9BQU8sQ0FBQztRQUNwQyxNQUFNZ1QsVUFBVTtZQUNkdU47WUFDQTdMO1lBQ0FoUDtZQUNBOGE7WUFDQUksbUJBQW1CO2dCQUNqQnJiLFdBQVcrZTtZQUNiO1lBQ0FuZjtZQUNBMFU7WUFDQWhVO1lBQ0FxVjtRQUNGO1FBQ0EsT0FBT2xJO0lBQ1QsR0FBRztRQUFDdU47UUFBZ0I3TDtRQUFZaFA7UUFBUThhO1FBQWdCcmI7UUFBVW1mO1FBQXdCeks7UUFBZ0JoVTtRQUFNcVY7S0FBMkI7SUFDM0ksT0FBT2pxQixNQUFNb00sYUFBYSxDQUFDb0gsa0JBQWtCeWlCLFFBQVEsRUFBRTtRQUNyRDN5QixPQUFPK3VCO0lBQ1QsR0FBR3J5QixNQUFNb00sYUFBYSxDQUFDd2pCLGdCQUFnQnFHLFFBQVEsRUFBRTtRQUMvQzN5QixPQUFPMHlCO0lBQ1QsR0FBR2gyQixNQUFNb00sYUFBYSxDQUFDeWpCLGNBQWNvRyxRQUFRLEVBQUU7UUFDN0MzeUIsT0FBT3l5QjtJQUNULEdBQUcvMUIsTUFBTW9NLGFBQWEsQ0FBQ21sQix1QkFBdUIwRSxRQUFRLEVBQUU7UUFDdEQzeUIsT0FBTzBOO0lBQ1QsR0FBR3JILFlBQVkzSixNQUFNb00sYUFBYSxDQUFDc2tCLGNBQWM7UUFDL0NoSixVQUFVLEFBQUNxSyxDQUFBQSxpQkFBaUIsT0FBTyxLQUFLLElBQUlBLGNBQWNtRSxZQUFZLEFBQUQsTUFBTztJQUM5RSxLQUFLbDJCLE1BQU1vTSxhQUFhLENBQUM2SSxlQUFlO1FBQUUsR0FBRzhjLGFBQWE7UUFDeEQzYyx5QkFBeUJpZTtJQUMzQjtJQUVBLFNBQVNJO1FBQ1AsTUFBTTBDLGlDQUFpQyxBQUFDbEQsQ0FBQUEsZ0JBQWdCLE9BQU8sS0FBSyxJQUFJQSxhQUFhMVAsaUJBQWlCLEFBQUQsTUFBTztRQUM1RyxNQUFNNlMsNkJBQTZCLE9BQU9uTyxlQUFlLFdBQVdBLFdBQVdkLE9BQU8sS0FBSyxRQUFRYyxlQUFlO1FBQ2xILE1BQU1kLFVBQVVzTCxpQkFBaUIsQ0FBQzBELGtDQUFrQyxDQUFDQztRQUVyRSxJQUFJLE9BQU9uTyxlQUFlLFVBQVU7WUFDbEMsT0FBTztnQkFBRSxHQUFHQSxVQUFVO2dCQUNwQmQ7WUFDRjtRQUNGO1FBRUEsT0FBTztZQUNMQTtRQUNGO0lBQ0Y7QUFDRjtBQUVBLE1BQU1rUCxjQUFjLFdBQVcsR0FBRXIyQixNQUFNeVQsYUFBYSxDQUFDO0FBQ3JELE1BQU02aUIsY0FBYztBQUNwQixNQUFNQyxZQUFZO0FBQ2xCLFNBQVNDLGFBQWFobEIsSUFBSTtJQUN4QixJQUFJLEVBQ0ZoQyxFQUFFLEVBQ0Z3SCxJQUFJLEVBQ0owUSxXQUFXLEtBQUssRUFDaEIrTyxVQUFVLEVBQ1gsR0FBR2psQjtJQUNKLE1BQU14USxNQUFNdU8sWUFBWWduQjtJQUN4QixNQUFNLEVBQ0o5UyxVQUFVLEVBQ1Y2TCxjQUFjLEVBQ2Q3YSxNQUFNLEVBQ044YSxjQUFjLEVBQ2RJLGlCQUFpQixFQUNqQi9HLGNBQWMsRUFDZGhVLElBQUksRUFDTCxHQUFHNVUsTUFBTTRULFVBQVUsQ0FBQ2djO0lBQ3JCLE1BQU0sRUFDSnpjLE9BQU9takIsV0FBVyxFQUNsQkksa0JBQWtCLFdBQVcsRUFDN0JDLFdBQVcsQ0FBQyxFQUNiLEdBQUdGLGNBQWMsT0FBT0EsYUFBYSxDQUFDO0lBQ3ZDLE1BQU1HLGFBQWEsQUFBQ25pQixDQUFBQSxVQUFVLE9BQU8sS0FBSyxJQUFJQSxPQUFPakYsRUFBRSxBQUFELE1BQU9BO0lBQzdELE1BQU13QixZQUFZaFIsTUFBTTRULFVBQVUsQ0FBQ2dqQixhQUFhckYseUJBQXlCOEU7SUFDekUsTUFBTSxDQUFDbHNCLE1BQU1pRixXQUFXLEdBQUdIO0lBQzNCLE1BQU0sQ0FBQzRVLGVBQWVnVCxvQkFBb0IsR0FBRzVuQjtJQUM3QyxNQUFNOEUsWUFBWXlaLHNCQUFzQi9KLFlBQVlqVTtJQUNwRCxNQUFNc25CLFVBQVVwb0IsZUFBZXNJO0lBQy9CMUosMEJBQTBCO1FBQ3hCc2IsZUFBZS9oQixHQUFHLENBQUMySSxJQUFJO1lBQ3JCQTtZQUNBeE87WUFDQW1KO1lBQ0EwWjtZQUNBN00sTUFBTThmO1FBQ1I7UUFDQSxPQUFPO1lBQ0wsTUFBTTNzQixPQUFPeWUsZUFBZXppQixHQUFHLENBQUNxSjtZQUVoQyxJQUFJckYsUUFBUUEsS0FBS25KLEdBQUcsS0FBS0EsS0FBSztnQkFDNUI0bkIsZUFBZTNVLE1BQU0sQ0FBQ3pFO1lBQ3hCO1FBQ0Y7SUFDRixHQUNBO1FBQUNvWjtRQUFnQnBaO0tBQUc7SUFDcEIsTUFBTXVuQixxQkFBcUIvMkIsTUFBTStPLE9BQU8sQ0FBQyxJQUFPLENBQUE7WUFDOUNvRTtZQUNBd2pCO1lBQ0EsaUJBQWlCalA7WUFDakIsZ0JBQWdCa1AsY0FBY3pqQixTQUFTbWpCLGNBQWMsT0FBT3BWO1lBQzVELHdCQUF3QndWO1lBQ3hCLG9CQUFvQi9HLGtCQUFrQnJiLFNBQVM7UUFDakQsQ0FBQSxHQUFJO1FBQUNvVDtRQUFVdlU7UUFBTXdqQjtRQUFVQztRQUFZRjtRQUFpQi9HLGtCQUFrQnJiLFNBQVM7S0FBQztJQUN4RixPQUFPO1FBQ0xHO1FBQ0E2YTtRQUNBQztRQUNBa0gsWUFBWU07UUFDWkg7UUFDQTdpQixXQUFXMlQsV0FBV3hHLFlBQVluTjtRQUNsQzVKO1FBQ0F5SztRQUNBeEY7UUFDQXluQjtRQUNBN2xCO0lBQ0Y7QUFDRjtBQUVBLFNBQVNnbUI7SUFDUCxPQUFPaDNCLE1BQU00VCxVQUFVLENBQUNpYztBQUMxQjtBQUVBLE1BQU1vSCxjQUFjO0FBQ3BCLE1BQU1DLDhCQUE4QjtJQUNsQ0MsU0FBUztBQUNYO0FBQ0EsU0FBU0MsYUFBYTVsQixJQUFJO0lBQ3hCLElBQUksRUFDRndGLElBQUksRUFDSjBRLFdBQVcsS0FBSyxFQUNoQmxZLEVBQUUsRUFDRjZuQixvQkFBb0IsRUFDckIsR0FBRzdsQjtJQUNKLE1BQU14USxNQUFNdU8sWUFBWTBuQjtJQUN4QixNQUFNLEVBQ0p4aUIsTUFBTSxFQUNOUCxRQUFRLEVBQ1JVLElBQUksRUFDSnFWLDBCQUEwQixFQUMzQixHQUFHanFCLE1BQU00VCxVQUFVLENBQUNnYztJQUNyQixNQUFNMEgsV0FBV3QzQixNQUFNNE4sTUFBTSxDQUFDO1FBQzVCOFo7SUFDRjtJQUNBLE1BQU02UCwwQkFBMEJ2M0IsTUFBTTROLE1BQU0sQ0FBQztJQUM3QyxNQUFNZ0osT0FBTzVXLE1BQU00TixNQUFNLENBQUM7SUFDMUIsTUFBTTRwQixhQUFheDNCLE1BQU00TixNQUFNLENBQUM7SUFDaEMsTUFBTSxFQUNKOFosVUFBVStQLHNCQUFzQixFQUNoQ0MscUJBQXFCLEVBQ3JCUCxTQUFTUSxxQkFBcUIsRUFDL0IsR0FBRztRQUFFLEdBQUdULDJCQUEyQjtRQUNsQyxHQUFHRyxvQkFBb0I7SUFDekI7SUFDQSxNQUFNL25CLE1BQU1aLGVBQWVncEIseUJBQXlCLE9BQU9BLHdCQUF3QmxvQjtJQUNuRixNQUFNd2IsZUFBZWhyQixNQUFNOE4sV0FBVyxDQUFDO1FBQ3JDLElBQUksQ0FBQ3lwQix3QkFBd0IxcEIsT0FBTyxFQUFFO1lBQ3BDLHFGQUFxRjtZQUNyRixrREFBa0Q7WUFDbEQwcEIsd0JBQXdCMXBCLE9BQU8sR0FBRztZQUNsQztRQUNGO1FBRUEsSUFBSTJwQixXQUFXM3BCLE9BQU8sSUFBSSxNQUFNO1lBQzlCa1gsYUFBYXlTLFdBQVczcEIsT0FBTztRQUNqQztRQUVBMnBCLFdBQVczcEIsT0FBTyxHQUFHNlQsV0FBVztZQUM5QnVJLDJCQUEyQnhlLE1BQU1DLE9BQU8sQ0FBQzRELElBQUl6QixPQUFPLElBQUl5QixJQUFJekIsT0FBTyxHQUFHO2dCQUFDeUIsSUFBSXpCLE9BQU87YUFBQztZQUNuRjJwQixXQUFXM3BCLE9BQU8sR0FBRztRQUN2QixHQUFHOHBCO0lBQ0wsR0FDQTtRQUFDQTtLQUFzQjtJQUN2QixNQUFNMU0saUJBQWlCRixrQkFBa0I7UUFDdkNqYyxVQUFVa2M7UUFDVnRELFVBQVUrUCwwQkFBMEIsQ0FBQ2hqQjtJQUN2QztJQUNBLE1BQU0yWixtQkFBbUJwdUIsTUFBTThOLFdBQVcsQ0FBQyxDQUFDOHBCLFlBQVlDO1FBQ3RELElBQUksQ0FBQzVNLGdCQUFnQjtZQUNuQjtRQUNGO1FBRUEsSUFBSTRNLGlCQUFpQjtZQUNuQjVNLGVBQWU2TSxTQUFTLENBQUNEO1lBQ3pCTix3QkFBd0IxcEIsT0FBTyxHQUFHO1FBQ3BDO1FBRUEsSUFBSStwQixZQUFZO1lBQ2QzTSxlQUFlYSxPQUFPLENBQUM4TDtRQUN6QjtJQUNGLEdBQUc7UUFBQzNNO0tBQWU7SUFDbkIsTUFBTSxDQUFDb0QsU0FBU2pmLFdBQVcsR0FBR0gsV0FBV21mO0lBQ3pDLE1BQU0wSSxVQUFVcG9CLGVBQWVzSTtJQUMvQmhYLE1BQU13TixTQUFTLENBQUM7UUFDZCxJQUFJLENBQUN5ZCxrQkFBa0IsQ0FBQ29ELFFBQVF4Z0IsT0FBTyxFQUFFO1lBQ3ZDO1FBQ0Y7UUFFQW9kLGVBQWVILFVBQVU7UUFDekJ5TSx3QkFBd0IxcEIsT0FBTyxHQUFHO1FBQ2xDb2QsZUFBZWEsT0FBTyxDQUFDdUMsUUFBUXhnQixPQUFPO0lBQ3hDLEdBQUc7UUFBQ3dnQjtRQUFTcEQ7S0FBZTtJQUM1QmpyQixNQUFNd04sU0FBUyxDQUFDO1FBQ2QwRyxTQUFTO1lBQ1ByVCxNQUFNaVYsT0FBT3lhLGlCQUFpQjtZQUM5QnZsQixTQUFTO2dCQUNQd0U7Z0JBQ0F4TztnQkFDQTBtQjtnQkFDQXZkLE1BQU1ra0I7Z0JBQ056WDtnQkFDQUksTUFBTThmO1lBQ1I7UUFDRjtRQUNBLE9BQU8sSUFBTTVpQixTQUFTO2dCQUNwQnJULE1BQU1pVixPQUFPMmEsbUJBQW1CO2dCQUNoQ3p2QjtnQkFDQXdPO1lBQ0Y7SUFDRixHQUNBO1FBQUNBO0tBQUc7SUFDSnhQLE1BQU13TixTQUFTLENBQUM7UUFDZCxJQUFJa2EsYUFBYTRQLFNBQVN6cEIsT0FBTyxDQUFDNlosUUFBUSxFQUFFO1lBQzFDeFQsU0FBUztnQkFDUHJULE1BQU1pVixPQUFPMGEsb0JBQW9CO2dCQUNqQ2hoQjtnQkFDQXhPO2dCQUNBMG1CO1lBQ0Y7WUFDQTRQLFNBQVN6cEIsT0FBTyxDQUFDNlosUUFBUSxHQUFHQTtRQUM5QjtJQUNGLEdBQUc7UUFBQ2xZO1FBQUl4TztRQUFLMG1CO1FBQVV4VDtLQUFTO0lBQ2hDLE9BQU87UUFDTE87UUFDQW1DO1FBQ0FtaEIsUUFBUSxBQUFDbmpCLENBQUFBLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtwRixFQUFFLEFBQUQsTUFBT0E7UUFDOUNyRixNQUFNa2tCO1FBQ056WjtRQUNBeEY7SUFDRjtBQUNGO0FBRUEsU0FBUzRvQixpQkFBaUJ4bUIsSUFBSTtJQUM1QixJQUFJLEVBQ0Z5bUIsU0FBUyxFQUNUdHVCLFFBQVEsRUFDVCxHQUFHNkg7SUFDSixNQUFNLENBQUMwbUIsZ0JBQWdCQyxrQkFBa0IsR0FBR240QixNQUFNc1QsUUFBUSxDQUFDO0lBQzNELE1BQU0sQ0FBQ3RJLFNBQVNvdEIsV0FBVyxHQUFHcDRCLE1BQU1zVCxRQUFRLENBQUM7SUFDN0MsTUFBTStrQixtQkFBbUJocEIsWUFBWTFGO0lBRXJDLElBQUksQ0FBQ0EsWUFBWSxDQUFDdXVCLGtCQUFrQkcsa0JBQWtCO1FBQ3BERixrQkFBa0JFO0lBQ3BCO0lBRUEvcUIsMEJBQTBCO1FBQ3hCLElBQUksQ0FBQ3RDLFNBQVM7WUFDWjtRQUNGO1FBRUEsTUFBTWhLLE1BQU1rM0Isa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlbDNCLEdBQUc7UUFDaEUsTUFBTXdPLEtBQUswb0Isa0JBQWtCLE9BQU8sS0FBSyxJQUFJQSxlQUFlOTJCLEtBQUssQ0FBQ29PLEVBQUU7UUFFcEUsSUFBSXhPLE9BQU8sUUFBUXdPLE1BQU0sTUFBTTtZQUM3QjJvQixrQkFBa0I7WUFDbEI7UUFDRjtRQUVBOUMsUUFBUUMsT0FBTyxDQUFDMkMsVUFBVXpvQixJQUFJeEUsVUFBVXN0QixJQUFJLENBQUM7WUFDM0NILGtCQUFrQjtRQUNwQjtJQUNGLEdBQUc7UUFBQ0Y7UUFBV0M7UUFBZ0JsdEI7S0FBUTtJQUN2QyxPQUFPaEwsTUFBTW9NLGFBQWEsQ0FBQ3BNLE1BQU1xQixRQUFRLEVBQUUsTUFBTXNJLFVBQVV1dUIsaUJBQWlCbDRCLE1BQU11NEIsWUFBWSxDQUFDTCxnQkFBZ0I7UUFDN0doM0IsS0FBS2szQjtJQUNQLEtBQUs7QUFDUDtBQUVBLE1BQU1JLG1CQUFtQjtJQUN2QnAxQixHQUFHO0lBQ0h3TixHQUFHO0lBQ0hRLFFBQVE7SUFDUkMsUUFBUTtBQUNWO0FBQ0EsU0FBU29uQix5QkFBeUJqbkIsSUFBSTtJQUNwQyxJQUFJLEVBQ0Y3SCxRQUFRLEVBQ1QsR0FBRzZIO0lBQ0osT0FBT3hSLE1BQU1vTSxhQUFhLENBQUN3akIsZ0JBQWdCcUcsUUFBUSxFQUFFO1FBQ25EM3lCLE9BQU9vc0I7SUFDVCxHQUFHMXZCLE1BQU1vTSxhQUFhLENBQUNtbEIsdUJBQXVCMEUsUUFBUSxFQUFFO1FBQ3REM3lCLE9BQU9rMUI7SUFDVCxHQUFHN3VCO0FBQ0w7QUFFQSxNQUFNK3VCLGFBQWE7SUFDakJubUIsVUFBVTtJQUNWb21CLGFBQWE7QUFDZjtBQUVBLE1BQU1DLG9CQUFvQnRKLENBQUFBO0lBQ3hCLE1BQU11SixzQkFBc0J6b0IsZ0JBQWdCa2Y7SUFDNUMsT0FBT3VKLHNCQUFzQix5QkFBeUIzWDtBQUN4RDtBQUVBLE1BQU00WCxvQkFBb0IsV0FBVyxHQUFFOTRCLE1BQU0rNEIsVUFBVSxDQUFDLENBQUN2bkIsTUFBTXRRO0lBQzdELElBQUksRUFDRjgzQixFQUFFLEVBQ0YxSixjQUFjLEVBQ2RuVyxXQUFXLEVBQ1h4UCxRQUFRLEVBQ1JzdkIsU0FBUyxFQUNUcmlCLElBQUksRUFDSjFFLEtBQUssRUFDTGxCLFNBQVMsRUFDVGtvQixhQUFhTixpQkFBaUIsRUFDL0IsR0FBR3BuQjtJQUVKLElBQUksQ0FBQ29GLE1BQU07UUFDVCxPQUFPO0lBQ1Q7SUFFQSxNQUFNdWlCLHlCQUF5QmhnQixjQUFjbkksWUFBWTtRQUFFLEdBQUdBLFNBQVM7UUFDckVJLFFBQVE7UUFDUkMsUUFBUTtJQUNWO0lBQ0EsTUFBTStuQixTQUFTO1FBQUUsR0FBR1YsVUFBVTtRQUM1QmhtQixPQUFPa0UsS0FBS2xFLEtBQUs7UUFDakJDLFFBQVFpRSxLQUFLakUsTUFBTTtRQUNuQkgsS0FBS29FLEtBQUtwRSxHQUFHO1FBQ2JDLE1BQU1tRSxLQUFLbkUsSUFBSTtRQUNmekIsV0FBV0YsSUFBSVEsU0FBUyxDQUFDL0UsUUFBUSxDQUFDNHNCO1FBQ2xDcmlCLGlCQUFpQnFDLGVBQWVtVyxpQkFBaUIzWSwyQkFBMkIyWSxnQkFBZ0IxWSxRQUFRc0s7UUFDcEdnWSxZQUFZLE9BQU9BLGVBQWUsYUFBYUEsV0FBVzVKLGtCQUFrQjRKO1FBQzVFLEdBQUdobkIsS0FBSztJQUNWO0lBQ0EsT0FBT2xTLE1BQU1vTSxhQUFhLENBQUM0c0IsSUFBSTtRQUM3QkM7UUFDQS9tQixPQUFPa25CO1FBQ1BsNEI7SUFDRixHQUFHeUk7QUFDTDtBQUVBLE1BQU0wdkIsa0NBQWtDbmpCLENBQUFBLFVBQVcxRSxDQUFBQTtRQUNqRCxJQUFJLEVBQ0ZpRCxNQUFNLEVBQ05vYSxXQUFXLEVBQ1osR0FBR3JkO1FBQ0osTUFBTThuQixpQkFBaUIsQ0FBQztRQUN4QixNQUFNLEVBQ0pGLE1BQU0sRUFDTkgsU0FBUyxFQUNWLEdBQUcvaUI7UUFFSixJQUFJa2pCLFVBQVUsUUFBUUEsT0FBTzNrQixNQUFNLEVBQUU7WUFDbkMsS0FBSyxNQUFNLENBQUN6VCxLQUFLc0MsTUFBTSxJQUFJMkIsT0FBTzJGLE9BQU8sQ0FBQ3d1QixPQUFPM2tCLE1BQU0sRUFBRztnQkFDeEQsSUFBSW5SLFVBQVU0ZCxXQUFXO29CQUN2QjtnQkFDRjtnQkFFQW9ZLGNBQWMsQ0FBQ3Q0QixJQUFJLEdBQUd5VCxPQUFPdEssSUFBSSxDQUFDK0gsS0FBSyxDQUFDcW5CLGdCQUFnQixDQUFDdjRCO2dCQUN6RHlULE9BQU90SyxJQUFJLENBQUMrSCxLQUFLLENBQUNzbkIsV0FBVyxDQUFDeDRCLEtBQUtzQztZQUNyQztRQUNGO1FBRUEsSUFBSTgxQixVQUFVLFFBQVFBLE9BQU92SyxXQUFXLEVBQUU7WUFDeEMsS0FBSyxNQUFNLENBQUM3dEIsS0FBS3NDLE1BQU0sSUFBSTJCLE9BQU8yRixPQUFPLENBQUN3dUIsT0FBT3ZLLFdBQVcsRUFBRztnQkFDN0QsSUFBSXZyQixVQUFVNGQsV0FBVztvQkFDdkI7Z0JBQ0Y7Z0JBRUEyTixZQUFZMWtCLElBQUksQ0FBQytILEtBQUssQ0FBQ3NuQixXQUFXLENBQUN4NEIsS0FBS3NDO1lBQzFDO1FBQ0Y7UUFFQSxJQUFJMjFCLGFBQWEsUUFBUUEsVUFBVXhrQixNQUFNLEVBQUU7WUFDekNBLE9BQU90SyxJQUFJLENBQUNzdkIsU0FBUyxDQUFDenBCLEdBQUcsQ0FBQ2lwQixVQUFVeGtCLE1BQU07UUFDNUM7UUFFQSxJQUFJd2tCLGFBQWEsUUFBUUEsVUFBVXBLLFdBQVcsRUFBRTtZQUM5Q0EsWUFBWTFrQixJQUFJLENBQUNzdkIsU0FBUyxDQUFDenBCLEdBQUcsQ0FBQ2lwQixVQUFVcEssV0FBVztRQUN0RDtRQUVBLE9BQU8sU0FBUzlCO1lBQ2QsS0FBSyxNQUFNLENBQUMvckIsS0FBS3NDLE1BQU0sSUFBSTJCLE9BQU8yRixPQUFPLENBQUMwdUIsZ0JBQWlCO2dCQUN6RDdrQixPQUFPdEssSUFBSSxDQUFDK0gsS0FBSyxDQUFDc25CLFdBQVcsQ0FBQ3g0QixLQUFLc0M7WUFDckM7WUFFQSxJQUFJMjFCLGFBQWEsUUFBUUEsVUFBVXhrQixNQUFNLEVBQUU7Z0JBQ3pDQSxPQUFPdEssSUFBSSxDQUFDc3ZCLFNBQVMsQ0FBQ0MsTUFBTSxDQUFDVCxVQUFVeGtCLE1BQU07WUFDL0M7UUFDRjtJQUNGO0FBRUEsTUFBTWtsQiwwQkFBMEJobEIsQ0FBQUE7SUFDOUIsSUFBSSxFQUNGM0QsV0FBVyxFQUNUNmhCLE9BQU8sRUFDUCtHLEtBQUssRUFDTixFQUNGLEdBQUdqbEI7SUFDSixPQUFPO1FBQUM7WUFDTjNELFdBQVdGLElBQUlRLFNBQVMsQ0FBQy9FLFFBQVEsQ0FBQ3NtQjtRQUNwQztRQUFHO1lBQ0Q3aEIsV0FBV0YsSUFBSVEsU0FBUyxDQUFDL0UsUUFBUSxDQUFDcXRCO1FBQ3BDO0tBQUU7QUFDSjtBQUVBLE1BQU1DLG9DQUFvQztJQUN4Q3ZyQixVQUFVO0lBQ1ZvRCxRQUFRO0lBQ1Jvb0IsV0FBV0g7SUFDWEksYUFBYSxXQUFXLEdBQUVWLGdDQUFnQztRQUN4REQsUUFBUTtZQUNOM2tCLFFBQVE7Z0JBQ051bEIsU0FBUztZQUNYO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsU0FBU0MsaUJBQWlCbmxCLEtBQUs7SUFDN0IsSUFBSSxFQUNGaFUsTUFBTSxFQUNOOG5CLGNBQWMsRUFDZHJRLG1CQUFtQixFQUNuQmtYLHNCQUFzQixFQUN2QixHQUFHM2E7SUFDSixPQUFPckgsU0FBUyxDQUFDK0IsSUFBSXJGO1FBQ25CLElBQUlySixXQUFXLE1BQU07WUFDbkI7UUFDRjtRQUVBLE1BQU1vNUIsa0JBQWtCdFIsZUFBZXppQixHQUFHLENBQUNxSjtRQUUzQyxJQUFJLENBQUMwcUIsaUJBQWlCO1lBQ3BCO1FBQ0Y7UUFFQSxNQUFNclksYUFBYXFZLGdCQUFnQi92QixJQUFJLENBQUMwRCxPQUFPO1FBRS9DLElBQUksQ0FBQ2dVLFlBQVk7WUFDZjtRQUNGO1FBRUEsTUFBTXNZLGlCQUFpQmxNLGtCQUFrQjlqQjtRQUV6QyxJQUFJLENBQUNnd0IsZ0JBQWdCO1lBQ25CO1FBQ0Y7UUFFQSxNQUFNLEVBQ0pucEIsU0FBUyxFQUNWLEdBQUd2RSxVQUFVdEMsTUFBTXVRLGdCQUFnQixDQUFDdlE7UUFDckMsTUFBTTZQLGtCQUFrQkwsZUFBZTNJO1FBRXZDLElBQUksQ0FBQ2dKLGlCQUFpQjtZQUNwQjtRQUNGO1FBRUEsTUFBTWllLFlBQVksT0FBT24zQixXQUFXLGFBQWFBLFNBQVNzNUIsMkJBQTJCdDVCO1FBQ3JGd2QsdUJBQXVCdUQsWUFBWTROLHVCQUF1Qm5iLFNBQVMsQ0FBQ2lLLE9BQU87UUFDM0UsT0FBTzBaLFVBQVU7WUFDZnhqQixRQUFRO2dCQUNOakY7Z0JBQ0F3SCxNQUFNa2pCLGdCQUFnQmxqQixJQUFJO2dCQUMxQjdNLE1BQU0wWDtnQkFDTmpMLE1BQU02WSx1QkFBdUJuYixTQUFTLENBQUNpSyxPQUFPLENBQUNzRDtZQUNqRDtZQUNBK0c7WUFDQWlHLGFBQWE7Z0JBQ1gxa0I7Z0JBQ0F5TSxNQUFNNlksdUJBQXVCWixXQUFXLENBQUN0USxPQUFPLENBQUM0YjtZQUNuRDtZQUNBNWhCO1lBQ0FrWDtZQUNBemUsV0FBV2dKO1FBQ2I7SUFDRjtBQUNGO0FBRUEsU0FBU29nQiwyQkFBMkJsa0IsT0FBTztJQUN6QyxNQUFNLEVBQ0o1SCxRQUFRLEVBQ1JvRCxNQUFNLEVBQ05xb0IsV0FBVyxFQUNYRCxTQUFTLEVBQ1YsR0FBRztRQUFFLEdBQUdELGlDQUFpQztRQUN4QyxHQUFHM2pCLE9BQU87SUFDWjtJQUNBLE9BQU9sQixDQUFBQTtRQUNMLElBQUksRUFDRlAsTUFBTSxFQUNOb2EsV0FBVyxFQUNYN2QsU0FBUyxFQUNULEdBQUdxcEIsTUFDSixHQUFHcmxCO1FBRUosSUFBSSxDQUFDMUcsVUFBVTtZQUNiLGdEQUFnRDtZQUNoRDtRQUNGO1FBRUEsTUFBTXFSLFFBQVE7WUFDWnZjLEdBQUd5ckIsWUFBWWpZLElBQUksQ0FBQ25FLElBQUksR0FBR2dDLE9BQU9tQyxJQUFJLENBQUNuRSxJQUFJO1lBQzNDN0IsR0FBR2llLFlBQVlqWSxJQUFJLENBQUNwRSxHQUFHLEdBQUdpQyxPQUFPbUMsSUFBSSxDQUFDcEUsR0FBRztRQUMzQztRQUNBLE1BQU04bkIsUUFBUTtZQUNabHBCLFFBQVFKLFVBQVVJLE1BQU0sS0FBSyxJQUFJcUQsT0FBT21DLElBQUksQ0FBQ2xFLEtBQUssR0FBRzFCLFVBQVVJLE1BQU0sR0FBR3lkLFlBQVlqWSxJQUFJLENBQUNsRSxLQUFLLEdBQUc7WUFDakdyQixRQUFRTCxVQUFVSyxNQUFNLEtBQUssSUFBSW9ELE9BQU9tQyxJQUFJLENBQUNqRSxNQUFNLEdBQUczQixVQUFVSyxNQUFNLEdBQUd3ZCxZQUFZalksSUFBSSxDQUFDakUsTUFBTSxHQUFHO1FBQ3JHO1FBQ0EsTUFBTTRuQixpQkFBaUI7WUFDckJuM0IsR0FBRzROLFVBQVU1TixDQUFDLEdBQUd1YyxNQUFNdmMsQ0FBQztZQUN4QndOLEdBQUdJLFVBQVVKLENBQUMsR0FBRytPLE1BQU0vTyxDQUFDO1lBQ3hCLEdBQUcwcEIsS0FBSztRQUNWO1FBQ0EsTUFBTUUscUJBQXFCVixVQUFVO1lBQUUsR0FBR08sSUFBSTtZQUM1QzVsQjtZQUNBb2E7WUFDQTdkLFdBQVc7Z0JBQ1Q2aEIsU0FBUzdoQjtnQkFDVDRvQixPQUFPVztZQUNUO1FBQ0Y7UUFDQSxNQUFNLENBQUNFLGNBQWMsR0FBR0Q7UUFDeEIsTUFBTUUsZUFBZUYsa0JBQWtCLENBQUNBLG1CQUFtQjV5QixNQUFNLEdBQUcsRUFBRTtRQUV0RSxJQUFJeWdCLEtBQUtDLFNBQVMsQ0FBQ21TLG1CQUFtQnBTLEtBQUtDLFNBQVMsQ0FBQ29TLGVBQWU7WUFDbEUscUZBQXFGO1lBQ3JGO1FBQ0Y7UUFFQSxNQUFNM04sVUFBVWdOLGVBQWUsT0FBTyxLQUFLLElBQUlBLFlBQVk7WUFDekR0bEI7WUFDQW9hO1lBQ0EsR0FBR3dMLElBQUk7UUFDVDtRQUNBLE1BQU1wQyxZQUFZcEosWUFBWTFrQixJQUFJLENBQUN3d0IsT0FBTyxDQUFDSCxvQkFBb0I7WUFDN0Rsc0I7WUFDQW9EO1lBQ0FrcEIsTUFBTTtRQUNSO1FBQ0EsT0FBTyxJQUFJdkYsUUFBUUMsQ0FBQUE7WUFDakIyQyxVQUFVNEMsUUFBUSxHQUFHO2dCQUNuQjlOLFdBQVcsT0FBTyxLQUFLLElBQUlBO2dCQUMzQnVJO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFJdDBCLE1BQU07QUFDVixTQUFTODVCLE9BQU90ckIsRUFBRTtJQUNoQixPQUFPeFAsTUFBTStPLE9BQU8sQ0FBQztRQUNuQixJQUFJUyxNQUFNLE1BQU07WUFDZDtRQUNGO1FBRUF4TztRQUNBLE9BQU9BO0lBQ1QsR0FBRztRQUFDd087S0FBRztBQUNUO0FBRUEsTUFBTXVyQixjQUFjLFdBQVcsR0FBRS82QixNQUFNMHhCLElBQUksQ0FBQ2xnQixDQUFBQTtJQUMxQyxJQUFJLEVBQ0YySCxjQUFjLEtBQUssRUFDbkJ4UCxRQUFRLEVBQ1JxeEIsZUFBZUMsbUJBQW1CLEVBQ2xDL29CLEtBQUssRUFDTGduQixVQUFVLEVBQ1ZoSSxTQUFTLEVBQ1RnSyxpQkFBaUIsS0FBSyxFQUN0QmpDLFNBQVMsRUFDVGtDLFNBQVMsR0FBRyxFQUNiLEdBQUczcEI7SUFDSixNQUFNLEVBQ0o4ZCxjQUFjLEVBQ2Q3YSxNQUFNLEVBQ044YSxjQUFjLEVBQ2RDLGlCQUFpQixFQUNqQjVHLGNBQWMsRUFDZHJRLG1CQUFtQixFQUNuQnNXLFdBQVcsRUFDWGphLElBQUksRUFDSjZhLHNCQUFzQixFQUN0QnRSLG1CQUFtQixFQUNuQm9KLHVCQUF1QixFQUN2QnNHLFVBQVUsRUFDWCxHQUFHbUo7SUFDSixNQUFNaG1CLFlBQVloUixNQUFNNFQsVUFBVSxDQUFDMmQ7SUFDbkMsTUFBTXZ3QixNQUFNODVCLE9BQU9ybUIsVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT2pGLEVBQUU7SUFDdEQsTUFBTTRyQixvQkFBb0JuSyxlQUFlQyxXQUFXO1FBQ2xENUI7UUFDQTdhO1FBQ0E4YTtRQUNBQztRQUNBdUUsa0JBQWtCbEYsWUFBWWpZLElBQUk7UUFDbENoQztRQUNBeWYsaUJBQWlCeEYsWUFBWWpZLElBQUk7UUFDakN1SDtRQUNBb0o7UUFDQXZXO1FBQ0E2YztJQUNGO0lBQ0EsTUFBTTFCLGNBQWM1QixnQkFBZ0JnRjtJQUNwQyxNQUFNeUwsZ0JBQWdCZixpQkFBaUI7UUFDckNuNUIsUUFBUW02QjtRQUNSclM7UUFDQXJRO1FBQ0FrWDtJQUNGLElBQUksNEZBQTRGO0lBQ2hHLDRFQUE0RTtJQUU1RSxNQUFNdnVCLE1BQU1pckIsY0FBYzBDLFlBQVlQLE1BQU0sR0FBR3BOO0lBQy9DLE9BQU9saEIsTUFBTW9NLGFBQWEsQ0FBQ3FzQiwwQkFBMEIsTUFBTXo0QixNQUFNb00sYUFBYSxDQUFDNHJCLGtCQUFrQjtRQUMvRkMsV0FBVytDO0lBQ2IsR0FBR3ZtQixVQUFVelQsTUFBTWhCLE1BQU1vTSxhQUFhLENBQUMwc0IsbUJBQW1CO1FBQ3hEOTNCLEtBQUtBO1FBQ0x3TyxJQUFJaUYsT0FBT2pGLEVBQUU7UUFDYnRPLEtBQUtBO1FBQ0w4M0IsSUFBSWtDO1FBQ0o1TCxnQkFBZ0JBO1FBQ2hCblcsYUFBYUE7UUFDYjhmLFdBQVdBO1FBQ1hDLFlBQVlBO1FBQ1p0aUIsTUFBTXVWO1FBQ05qYSxPQUFPO1lBQ0xpcEI7WUFDQSxHQUFHanBCLEtBQUs7UUFDVjtRQUNBbEIsV0FBV29xQjtJQUNiLEdBQUd6eEIsWUFBWTtBQUNqQjtBQUVBLE1BQU0weEIscUJBQXFCN3BCLENBQUFBO0lBQ3pCLElBQUksRUFDRjhkLGNBQWMsRUFDZHlFLGdCQUFnQixFQUNoQi9pQixTQUFTLEVBQ1YsR0FBR1E7SUFFSixJQUFJdWlCLG9CQUFvQnpFLGdCQUFnQjtRQUN0QyxNQUFNZ00sdUJBQXVCOXFCLG9CQUFvQjhlO1FBRWpELElBQUksQ0FBQ2dNLHNCQUFzQjtZQUN6QixPQUFPdHFCO1FBQ1Q7UUFFQSxNQUFNdXFCLFVBQVVELHFCQUFxQmw0QixDQUFDLEdBQUcyd0IsaUJBQWlCdGhCLElBQUk7UUFDOUQsTUFBTStvQixVQUFVRixxQkFBcUIxcUIsQ0FBQyxHQUFHbWpCLGlCQUFpQnZoQixHQUFHO1FBQzdELE9BQU87WUFBRSxHQUFHeEIsU0FBUztZQUNuQjVOLEdBQUc0TixVQUFVNU4sQ0FBQyxHQUFHbTRCLFVBQVV4SCxpQkFBaUJyaEIsS0FBSyxHQUFHO1lBQ3BEOUIsR0FBR0ksVUFBVUosQ0FBQyxHQUFHNHFCLFVBQVV6SCxpQkFBaUJwaEIsTUFBTSxHQUFHO1FBQ3ZEO0lBQ0Y7SUFFQSxPQUFPM0I7QUFDVDtBQUVBLFNBQVN5cUIsY0FBY0MsUUFBUSxFQUFFQyxXQUFXLEVBQUVDLGdCQUFnQjtJQUMxRCxNQUFNQyxRQUFRcHdCLE1BQU13aEIsSUFBSSxDQUFDeGhCLE1BQU1pd0IsV0FBVyxJQUFNLElBQUlqd0IsTUFBTWt3QjtJQUMxRCxJQUFLLElBQUlHLE1BQU0sR0FBR0EsTUFBTUosVUFBVUksTUFBTztRQUNyQyxJQUFLLElBQUlDLFNBQVMsR0FBR0EsU0FBU0osYUFBYUksU0FBVTtZQUNqREYsS0FBSyxDQUFDQyxJQUFJLENBQUNDLE9BQU8sR0FBRztnQkFDakJDLFVBQVUsR0FBR0MseUJBQXlCRixRQUFRSixhQUFhQyxvQkFBb0JNLG1CQUFtQkosS0FBS0osVUFBVUUsbUJBQW1CO2dCQUNwSU8sZUFBZSxBQUFDTCxDQUFBQSxNQUFNQyxNQUFLLElBQUssTUFBTTtZQUMxQztRQUNKO0lBQ0o7SUFDQSxPQUFPRjtBQUNYO0FBQ0EsU0FBU0ssbUJBQW1CSixHQUFHLEVBQUVKLFFBQVEsRUFBRUUsZ0JBQWdCO0lBQ3ZELE9BQU9BLHFCQUFxQixVQUN0QixBQUFDRixDQUFBQSxXQUFXSSxHQUFFLEVBQUd2dkIsUUFBUSxLQUN6QixBQUFDdXZCLENBQUFBLE1BQU0sQ0FBQSxFQUFHdnZCLFFBQVE7QUFDNUI7QUFDQSxTQUFTMHZCLHlCQUF5QkYsTUFBTSxFQUFFSixXQUFXLEVBQUVDLGdCQUFnQjtJQUNuRSxPQUFPQSxxQkFBcUIsVUFDdEJRLE9BQU9DLFlBQVksQ0FBQyxLQUFLTixVQUN6QkssT0FBT0MsWUFBWSxDQUFDLEtBQUtWLGNBQWNJLFNBQVM7QUFDMUQ7QUFDQSxTQUFTTyx5QkFBeUJQLE1BQU0sRUFBRUosV0FBVyxFQUFFQyxnQkFBZ0I7SUFDbkUsT0FBT0EscUJBQXFCLFVBQ3RCRyxPQUFPUSxVQUFVLENBQUMsS0FBSyxLQUN2QlosY0FBZUksQ0FBQUEsT0FBT1EsVUFBVSxDQUFDLEtBQUssRUFBQyxJQUFLO0FBQ3REO0FBQ0EsU0FBU0MsbUJBQW1CVixHQUFHLEVBQUVKLFFBQVEsRUFBRUUsZ0JBQWdCO0lBQ3ZELE9BQU9BLHFCQUFxQixVQUN0QkYsV0FBV3hqQixPQUFPNGpCLE9BQ2xCNWpCLE9BQU80akIsT0FBTztBQUN4QjtBQUNBLFNBQVNXLDBCQUEwQkMsR0FBRyxFQUFFaEIsUUFBUSxFQUFFQyxXQUFXO0lBQ3pELE1BQU1nQixpQkFBaUIsQ0FBQztJQUN4QixNQUFNQyxPQUFPRixJQUFJaDFCLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDQSxLQUFLLENBQUM7SUFDckMsZ0lBQWdJO0lBQ2hJLElBQUssSUFBSW8wQixNQUFNLEdBQUdBLE1BQU1jLEtBQUtoMUIsTUFBTSxFQUFFazBCLE1BQU87UUFDeEMsSUFBSUMsU0FBUztRQUNiLEtBQUssTUFBTWMsUUFBUUQsSUFBSSxDQUFDZCxJQUFJLENBQUU7WUFDMUIscUNBQXFDO1lBQ3JDLElBQUlnQixNQUFNNWtCLE9BQU8ya0IsUUFBUTtnQkFDckIsbUVBQW1FO2dCQUNuRSxNQUFNdHFCLFdBQVcsR0FBRzBwQix5QkFBeUJGLFFBQVFKLGFBQWEsV0FBV08sbUJBQW1CSixLQUFLSixVQUFVLFVBQVU7Z0JBQ3pILDREQUE0RDtnQkFDNURpQixjQUFjLENBQUNwcUIsU0FBUyxHQUFHO29CQUN2QndxQixXQUFXQyxlQUFlSDtnQkFDOUI7Z0JBQ0Esa0NBQWtDO2dCQUNsQ2Q7WUFDSixPQUNLO2dCQUNELG1FQUFtRTtnQkFDbkVBLFVBQVU3akIsT0FBTzJrQjtZQUNyQjtRQUNKO0lBQ0o7SUFDQSxPQUFPRjtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTSyxlQUFlQyxLQUFLO0lBQ3pCLDRCQUE0QjtJQUM1QixJQUFJQSxNQUFNQyxXQUFXLE9BQU9ELE9BQU87UUFDL0IsT0FBTyxNQUFNQSxNQUFNRSxXQUFXO0lBQ2xDO0lBQ0EsNEJBQTRCO0lBQzVCLE9BQU8sTUFBTUYsTUFBTUUsV0FBVztBQUNsQztBQUNBLG1EQUFtRDtBQUNuRDs7O0NBR0MsR0FDRCxTQUFTQyxtQkFBbUJDLFdBQVcsRUFBRUMsV0FBVyxFQUFFM0IsV0FBVyxFQUFFQyxnQkFBZ0I7SUFDL0UsTUFBTTJCLFVBQVUsQ0FBQztJQUNqQixJQUFLLE1BQU1DLGFBQWFGLFlBQWE7WUFHN0JEO1FBRkosTUFBTUksbUJBQW1CLEVBQUU7UUFDM0IsMERBQTBEO1FBQzFELElBQUlKLEVBQUFBLHlCQUFBQSxXQUFXLENBQUNHLFVBQVUsY0FBdEJILDZDQUFBQSx1QkFBd0JOLFNBQVMsTUFBS08sV0FBVyxDQUFDRSxVQUFVLENBQUNULFNBQVMsRUFBRTtZQUN4RTtRQUNKO1FBQ0EsSUFBSyxNQUFNVyxhQUFhTCxZQUFhO2dCQUlRQztZQUh6Qyx3SkFBd0o7WUFDeEosSUFBSUQsV0FBVyxDQUFDSyxVQUFVLENBQUNYLFNBQVMsS0FBS08sV0FBVyxDQUFDRSxVQUFVLENBQUNULFNBQVMsSUFDckVXLGNBQWNGLGFBQ2RILFdBQVcsQ0FBQ0ssVUFBVSxDQUFDWCxTQUFTLE9BQUtPLHlCQUFBQSxXQUFXLENBQUNJLFVBQVUsY0FBdEJKLDZDQUFBQSx1QkFBd0JQLFNBQVMsR0FBRTtnQkFDeEVVLGlCQUFpQmhsQixJQUFJLENBQUNpbEI7WUFDMUI7UUFDSjtRQUNBLElBQUlELGlCQUFpQjcxQixNQUFNLEtBQUssR0FBRztZQUMvQix3REFBd0Q7WUFDeEQyMUIsT0FBTyxDQUFDRSxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsR0FBR0Q7UUFDbkMsT0FDSztZQUNELCtIQUErSDtZQUMvSCxLQUFLLE1BQU1HLG1CQUFtQkYsaUJBQWtCO29CQUdlRSx3QkFDOUJILGtCQUNTRyx5QkFDM0JILG1CQUN3Q0cseUJBQ3hDQSx5QkFHd0NILG1CQUN4Q0E7Z0JBWFgsd0VBQXdFO2dCQUN4RSxNQUFNSSxxQkFBcUJQLFdBQVcsQ0FBQ00sZ0JBQWdCLENBQUNaLFNBQVMsQ0FBQyxFQUFFO29CQUNUWSx5QkFDOUJIO2dCQUQ3QixNQUFNSyxtQkFBbUI1c0IsS0FBSzhNLEdBQUcsQ0FBQ3VlLHlCQUF5QnFCLENBQUFBLDJCQUFBQSx5QkFBQUEsZ0JBQWdCbjRCLEtBQUssQ0FBQyx3QkFBdEJtNEIsNkNBQUFBLHNCQUFrQyxDQUFDLEVBQUUsY0FBckNBLHFDQUFBQSwwQkFBeUMsSUFBSWhDLGFBQWFDLG9CQUNqSFUseUJBQXlCa0IsQ0FBQUEscUJBQUFBLG1CQUFBQSxVQUFVaDRCLEtBQUssQ0FBQyx3QkFBaEJnNEIsdUNBQUFBLGdCQUE0QixDQUFDLEVBQUUsY0FBL0JBLCtCQUFBQSxvQkFBbUMsSUFBSTdCLGFBQWFDO29CQUMzQytCLDBCQUMzQkg7Z0JBRFgsTUFBTU0sZ0JBQWdCN3NCLEtBQUs4TSxHQUFHLENBQUM3RixPQUFPeWxCLENBQUFBLDRCQUFBQSwwQkFBQUEsZ0JBQWdCbjRCLEtBQUssQ0FBQyxxQkFBdEJtNEIsOENBQUFBLHVCQUErQixDQUFDLEVBQUUsY0FBbENBLHNDQUFBQSwyQkFBc0MsTUFDeEV6bEIsT0FBT3NsQixDQUFBQSxzQkFBQUEsb0JBQUFBLFVBQVVoNEIsS0FBSyxDQUFDLHFCQUFoQmc0Qix3Q0FBQUEsaUJBQXlCLENBQUMsRUFBRSxjQUE1QkEsZ0NBQUFBLHFCQUFnQztvQkFDUUcsMEJBQ3hDQTtnQkFEWCxNQUFNSSxtQkFBbUIsQUFBQ3pCLENBQUFBLHlCQUF5QnFCLENBQUFBLDRCQUFBQSwwQkFBQUEsZ0JBQWdCbjRCLEtBQUssQ0FBQyx3QkFBdEJtNEIsOENBQUFBLHVCQUFrQyxDQUFDLEVBQUUsY0FBckNBLHNDQUFBQSwyQkFBeUMsSUFBSWhDLGFBQWFDLG9CQUN6RzFqQixPQUFPeWxCLENBQUFBLDRCQUFBQSwwQkFBQUEsZ0JBQWdCbjRCLEtBQUssQ0FBQyxxQkFBdEJtNEIsOENBQUFBLHVCQUErQixDQUFDLEVBQUUsY0FBbENBLHNDQUFBQSwyQkFBc0MsR0FBRSxJQUMvQyxNQUNBO29CQUMrQ0gsb0JBQ3hDQTtnQkFEWCxNQUFNUSxtQkFBbUIsQUFBQzFCLENBQUFBLHlCQUF5QmtCLENBQUFBLHNCQUFBQSxvQkFBQUEsVUFBVWg0QixLQUFLLENBQUMsd0JBQWhCZzRCLHdDQUFBQSxpQkFBNEIsQ0FBQyxFQUFFLGNBQS9CQSxnQ0FBQUEscUJBQW1DLElBQUk3QixhQUFhQyxvQkFDbkcxakIsT0FBT3NsQixDQUFBQSxzQkFBQUEsb0JBQUFBLFVBQVVoNEIsS0FBSyxDQUFDLHFCQUFoQmc0Qix3Q0FBQUEsaUJBQXlCLENBQUMsRUFBRSxjQUE1QkEsZ0NBQUFBLHFCQUFnQyxHQUFFLElBQ3pDLE1BQ0E7Z0JBQ0osZ0NBQWdDO2dCQUNoQyxJQUFJSSx1QkFBdUIsS0FBSzt3QkFDeEJELHlCQUNBSDtvQkFESixJQUFJRyxFQUFBQSwwQkFBQUEsZ0JBQWdCbjRCLEtBQUssQ0FBQyx3QkFBdEJtNEIsOENBQUFBLHVCQUFrQyxDQUFDLEVBQUUsUUFDckNILG9CQUFBQSxVQUFVaDRCLEtBQUssQ0FBQyx3QkFBaEJnNEIsd0NBQUFBLGlCQUE0QixDQUFDLEVBQUUsR0FBRTt3QkFDakNELE9BQU8sQ0FBQ0ksZ0JBQWdCLEdBQUdIO3dCQUMzQjtvQkFDSjtnQkFDSjtnQkFDQSwyQ0FBMkM7Z0JBQzNDLElBQUlJLHVCQUF1QixLQUFLO29CQUM1QixJQUFJLEFBQUNDLHFCQUFxQixLQUFLQyxrQkFBa0IsS0FDNUNELHFCQUFxQixLQUFLQyxrQkFBa0IsR0FBSTt3QkFDakRQLE9BQU8sQ0FBQ0ksZ0JBQWdCLEdBQUdIO3dCQUMzQjtvQkFDSjtnQkFDSjtnQkFDQSxpRkFBaUY7Z0JBQ2pGLElBQUlJLHVCQUF1QixLQUFLO29CQUM1QixJQUFJQyxxQkFBcUJDLGlCQUNyQkMscUJBQXFCQyxrQkFBa0I7d0JBQ3ZDVCxPQUFPLENBQUNJLGdCQUFnQixHQUFHSDt3QkFDM0I7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsOERBQThEO2dCQUM5RCxJQUFJSSx1QkFBdUIsS0FBSztvQkFDNUIsSUFBSUMscUJBQXFCLEtBQUtDLGtCQUFrQixHQUFHO3dCQUMvQ1AsT0FBTyxDQUFDSSxnQkFBZ0IsR0FBR0g7d0JBQzNCO29CQUNKO2dCQUNKO2dCQUNBLDJFQUEyRTtnQkFDM0UsSUFBSUksdUJBQXVCLEtBQUs7b0JBQzVCLElBQUlDLHFCQUFxQixLQUNyQkMsa0JBQWtCLEtBQ2xCRCxxQkFBcUJDLGVBQWU7d0JBQ3BDUCxPQUFPLENBQUNJLGdCQUFnQixHQUFHSDt3QkFDM0I7b0JBQ0o7Z0JBQ0o7Z0JBQ0EsK0RBQStEO2dCQUMvRCxJQUFJSSx1QkFBdUIsS0FBSztvQkFDNUIsSUFBSUMsb0JBQW9CLEtBQUtDLGlCQUFpQixHQUFHO3dCQUM3Q1AsT0FBTyxDQUFDSSxnQkFBZ0IsR0FBR0g7d0JBQzNCO29CQUNKO2dCQUNKO1lBQ0o7WUFDQSx5RkFBeUY7WUFDekYsSUFBSSxDQUFDdjRCLE9BQU9pb0IsTUFBTSxDQUFDcVEsU0FBUzExQixRQUFRLENBQUMyMUIsY0FDakNDLGlCQUFpQjcxQixNQUFNLEdBQUcsR0FBRztnQkFDN0IsS0FBSyxNQUFNKzFCLG1CQUFtQkYsaUJBQWtCO29CQUM1QyxJQUFJLENBQUN4NEIsT0FBTzZFLElBQUksQ0FBQ3l6QixTQUFTMTFCLFFBQVEsQ0FBQzgxQixrQkFBa0I7d0JBQ2pESixPQUFPLENBQUNJLGdCQUFnQixHQUFHSDt3QkFDM0I7b0JBQ0o7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQSxPQUFPRDtBQUNYO0FBQ0E7O0NBRUMsR0FDRCxTQUFTVSxrQkFBa0JyQyxnQkFBZ0IsRUFBRXNDLFVBQVUsRUFBRUMsaUJBQWlCLEVBQUVDLGNBQWMsRUFBRUMsTUFBTTtRQUUzREEsZUFHTkE7SUFKN0IsTUFBTUMsY0FBY0osYUFBYUM7UUFDRUU7SUFBbkMsTUFBTWo3QixJQUFJazVCLHlCQUF5QitCLENBQUFBLGtCQUFBQSxnQkFBQUEsT0FBTzc0QixLQUFLLENBQUMsd0JBQWI2NEIsb0NBQUFBLGFBQXlCLENBQUMsRUFBRSxjQUE1QkEsNEJBQUFBLGlCQUFnQyxJQUFJRixtQkFBbUJ2QyxvQkFDdEYwQyxjQUNBQSxjQUFjO1FBQ1dEO0lBQTdCLE1BQU16dEIsSUFBSTRyQixtQkFBbUI2QixDQUFBQSxtQkFBQUEsaUJBQUFBLE9BQU83NEIsS0FBSyxDQUFDLHFCQUFiNjRCLHFDQUFBQSxjQUFzQixDQUFDLEVBQUUsY0FBekJBLDZCQUFBQSxrQkFBNkIsSUFBSUQsZ0JBQWdCeEMsb0JBQzFFMEMsY0FDQUEsY0FBYztJQUNsQixPQUFPO1FBQUVsN0I7UUFBR3dOO0lBQUU7QUFDbEI7QUFFQSxNQUFNMnRCLGdCQUFnQjtJQUNsQkMsSUFBSSxDQUFDcDlCO1lBRWFBO2VBRkY0SyxrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztZQUFFbTlCLE9BQU87WUFBOEJDLFNBQVM7WUFBT0MsU0FBUztZQUFhanNCLE9BQU87WUFBUUMsUUFBUTtZQUFRVCxLQUFLLEVBQUU5USxrQkFBQUEsNEJBQUFBLE1BQU93OUIsUUFBUTtZQUFFajFCLFVBQVVxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTtnQkFBRXU5QixHQUFHO2dCQUFtVDNzQixPQUFPO29CQUM1Z0I4bkIsU0FBUztvQkFDVFksTUFBTXg1QixDQUFBQSxjQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU93NUIsSUFBSSxjQUFYeDVCLHlCQUFBQSxjQUFlO29CQUNyQjA5QixhQUFhO29CQUNiQyxVQUFVO29CQUNWQyxRQUFRO29CQUNSQyxhQUFhO29CQUNiQyxlQUFlO29CQUNmQyxnQkFBZ0I7b0JBQ2hCQyxrQkFBa0I7b0JBQ2xCQyxpQkFBaUI7b0JBQ2pCQyxlQUFlO2dCQUNuQjtZQUFFO1FBQUc7O0lBQ2JDLElBQUksQ0FBQ24rQjtZQUVhQTtlQUZGNEssa0JBQWtCMUssR0FBRyxDQUFDLE9BQU87WUFBRW05QixPQUFPO1lBQThCQyxTQUFTO1lBQU9DLFNBQVM7WUFBYWpzQixPQUFPO1lBQVFDLFFBQVE7WUFBUVQsS0FBSyxFQUFFOVEsa0JBQUFBLDRCQUFBQSxNQUFPdzlCLFFBQVE7WUFBRWoxQixVQUFVcUMsa0JBQWtCekssSUFBSSxDQUFDLEtBQUs7Z0JBQUUyUSxPQUFPO29CQUNwTjhuQixTQUFTO29CQUNUWSxNQUFNeDVCLENBQUFBLGNBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT3c1QixJQUFJLGNBQVh4NUIseUJBQUFBLGNBQWU7b0JBQ3JCMDlCLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUEyQzNzQixPQUFPOzRCQUFFZ3RCLGVBQWU7d0JBQU87b0JBQUU7b0JBQUlsekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBOEMzc0IsT0FBTzs0QkFBRWd0QixlQUFlO3dCQUFPO29CQUFFO29CQUFJbHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQTZGM3NCLE9BQU87NEJBQUVndEIsZUFBZTt3QkFBTztvQkFBRTtvQkFBSWx6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO29CQUFrQztvQkFBSTd5QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF1QzNzQixPQUFPOzRCQUFFZ3RCLGVBQWU7NEJBQVFDLGdCQUFnQjt3QkFBUTtvQkFBRTtvQkFBSW56QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO29CQUEwQztvQkFBSTd5QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFtQjNzQixPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFROzRCQUFXRyxnQkFBZ0I7d0JBQVE7b0JBQUU7aUJBQUc7WUFBQztRQUFHOztJQUN2MEJLLElBQUksQ0FBQ3ArQjtZQVlvSUEsYUFBeVpBO2VBWmxoQjRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE44bkIsU0FBUztvQkFDVFksTUFBTTtvQkFDTmtFLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFpRTNzQixPQUFPOzRCQUFFMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFBVzQ5QixRQUFRO3dCQUFVO29CQUFFO29CQUFJaHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXFUM3NCLE9BQU87NEJBQUUwb0IsTUFBTXg1QixDQUFBQSxlQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU93NUIsSUFBSSxjQUFYeDVCLDBCQUFBQSxlQUFlOzRCQUFXNDlCLFFBQVE7d0JBQVU7b0JBQUU7b0JBQUloekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBa0Uzc0IsT0FBTzs0QkFBRTBvQixNQUFNOzRCQUFXb0UsUUFBUTt3QkFBVTtvQkFBRTtvQkFBSWh6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFpRTd0QixXQUFXO3dCQUE2Q2tCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBV29FLFFBQVE7d0JBQVU7b0JBQUU7aUJBQUc7WUFBQztRQUFHOztJQUM1N0JTLElBQUksQ0FBQ3IrQjtZQWFxQkE7ZUFiVjRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE44bkIsU0FBUztvQkFDVFksTUFBTTtvQkFDTm1FLFVBQVU7b0JBQ1ZELGFBQWE7b0JBQ2JFLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0J6SyxJQUFJLENBQUMsS0FBSzt3QkFBRTJRLE9BQU87NEJBQ3ZDMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFDckI0OUIsUUFBUTs0QkFDUkUsZUFBZTt3QkFDbkI7d0JBQUd2MUIsVUFBVTs0QkFBQ3FDLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQWtROzRCQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQW9NOzRCQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQXVEO3lCQUFHO29CQUFDO29CQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQStFM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7NEJBQVdHLGdCQUFnQjt3QkFBUTtvQkFBRTtpQkFBRztZQUFDO1FBQUc7O0lBQ2oxQk8sSUFBSSxDQUFDdCtCO1lBQ2FBO2VBREY0SyxrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztZQUFFbTlCLE9BQU87WUFBOEJDLFNBQVM7WUFBT0MsU0FBUztZQUFhanNCLE9BQU87WUFBUUMsUUFBUTtZQUFRVCxLQUFLLEVBQUU5USxrQkFBQUEsNEJBQUFBLE1BQU93OUIsUUFBUTtZQUFFajFCLFVBQVVxQyxrQkFBa0J6SyxJQUFJLENBQUMsS0FBSztnQkFBRTJRLE9BQU87b0JBQ3BOMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTtvQkFDckI0OUIsUUFBUTtvQkFDUkMsYUFBYTtvQkFDYkUsZ0JBQWdCO2dCQUNwQjtnQkFBR3gxQixVQUFVO29CQUFDcUMsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRztvQkFBNkk7b0JBQUk3eUIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRztvQkFBZ1I7b0JBQUk3eUIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBbUMzc0IsT0FBTzs0QkFBRTBvQixNQUFNO3dCQUFPO29CQUFFO29CQUFJNXVCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXVDM3NCLE9BQU87NEJBQUUwb0IsTUFBTTt3QkFBTztvQkFBRTtvQkFBSTV1QixrQkFBa0IxSyxHQUFHLENBQUMsVUFBVTt3QkFBRXErQixJQUFJO3dCQUFLQyxJQUFJO3dCQUFNQyxHQUFHO29CQUFJO29CQUFJN3pCLGtCQUFrQjFLLEdBQUcsQ0FBQyxVQUFVO3dCQUFFcStCLElBQUk7d0JBQU1DLElBQUk7d0JBQUtDLEdBQUc7b0JBQUk7b0JBQUk3ekIsa0JBQWtCMUssR0FBRyxDQUFDLFVBQVU7d0JBQUVxK0IsSUFBSTt3QkFBUUMsSUFBSTt3QkFBS0MsR0FBRztvQkFBSTtvQkFBSTd6QixrQkFBa0IxSyxHQUFHLENBQUMsVUFBVTt3QkFBRXErQixJQUFJO3dCQUFNQyxJQUFJO3dCQUFLQyxHQUFHO29CQUFJO29CQUFJN3pCLGtCQUFrQjFLLEdBQUcsQ0FBQyxVQUFVO3dCQUFFcStCLElBQUk7d0JBQU1DLElBQUk7d0JBQU1DLEdBQUc7b0JBQUk7aUJBQUc7WUFBQztRQUFHOztJQUMvZ0NDLElBQUksQ0FBQzErQjtZQVlxQkEsYUFJMk9BO2VBaEJyUDRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE4wb0IsTUFBTTtvQkFDTmtFLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF5QjNzQixPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFROzRCQUFXRyxnQkFBZ0I7d0JBQVE7b0JBQUU7b0JBQUluekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBaUIzc0IsT0FBTzs0QkFBRTBvQixNQUFNOzRCQUFRb0UsUUFBUTs0QkFBV0csZ0JBQWdCO3dCQUFRO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQTZIM3NCLE9BQU87NEJBQ3phMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFDckI0OUIsUUFBUTs0QkFDUkUsZUFBZTs0QkFDZkMsZ0JBQWdCO3dCQUNwQjtvQkFBRTtvQkFBSW56QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUE2TDNzQixPQUFPOzRCQUFFMG9CLE1BQU14NUIsQ0FBQUEsZUFBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1QiwwQkFBQUEsZUFBZTs0QkFBVzQ5QixRQUFRO3dCQUFVO29CQUFFO29CQUFJaHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQW1DM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7d0JBQVU7b0JBQUU7b0JBQUloekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBMkMzc0IsT0FBTzs0QkFBRTBvQixNQUFNOzRCQUFRb0UsUUFBUTt3QkFBVTtvQkFBRTtvQkFBSWh6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFtQzNzQixPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFRO3dCQUFVO29CQUFFO2lCQUFHO1lBQUM7UUFBRzs7SUFDanFCZSxJQUFJLENBQUMzK0I7WUFFYUE7ZUFGRjRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dCQUFFdTlCLEdBQUc7Z0JBQW1UM3NCLE9BQU87b0JBQzVnQjhuQixTQUFTO29CQUNUWSxNQUFNeDVCLENBQUFBLGNBQUFBLGtCQUFBQSw0QkFBQUEsTUFBT3c1QixJQUFJLGNBQVh4NUIseUJBQUFBLGNBQWU7b0JBQ3JCMDlCLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO1lBQUU7UUFBRzs7SUFDYlUsSUFBSSxDQUFDNStCO1lBRWFBO2VBRkY0SyxrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztZQUFFbTlCLE9BQU87WUFBOEJDLFNBQVM7WUFBT0MsU0FBUztZQUFhanNCLE9BQU87WUFBUUMsUUFBUTtZQUFRVCxLQUFLLEVBQUU5USxrQkFBQUEsNEJBQUFBLE1BQU93OUIsUUFBUTtZQUFFajFCLFVBQVVxQyxrQkFBa0J6SyxJQUFJLENBQUMsS0FBSztnQkFBRTJRLE9BQU87b0JBQ3BOOG5CLFNBQVM7b0JBQ1RZLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTtvQkFDckIwOUIsYUFBYTtvQkFDYkMsVUFBVTtvQkFDVkMsUUFBUTtvQkFDUkMsYUFBYTtvQkFDYkMsZUFBZTtvQkFDZkMsZ0JBQWdCO29CQUNoQkMsa0JBQWtCO29CQUNsQkMsaUJBQWlCO29CQUNqQkMsZUFBZTtnQkFDbkI7Z0JBQUczMUIsVUFBVTtvQkFBQ3FDLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQTJDM3NCLE9BQU87NEJBQUVndEIsZUFBZTt3QkFBTztvQkFBRTtvQkFBSWx6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF3RDNzQixPQUFPOzRCQUFFZ3RCLGVBQWU7d0JBQU87b0JBQUU7b0JBQUlsekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBOEMzc0IsT0FBTzs0QkFBRWd0QixlQUFlO3dCQUFPO29CQUFFO29CQUFJbHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXdEM3NCLE9BQU87NEJBQUVndEIsZUFBZTs0QkFBUUMsZ0JBQWdCO3dCQUFRO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQW9EM3NCLE9BQU87NEJBQUVndEIsZUFBZTt3QkFBTztvQkFBRTtvQkFBSWx6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF3RzNzQixPQUFPOzRCQUFFZ3RCLGVBQWU7d0JBQU87b0JBQUU7b0JBQUlsekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBaUMzc0IsT0FBTzs0QkFDMzNCMG9CLE1BQU07NEJBQ05vRSxRQUFROzRCQUNSQyxhQUFhOzRCQUNiRSxnQkFBZ0I7d0JBQ3BCO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXVCM3NCLE9BQU87NEJBQ25FMG9CLE1BQU07NEJBQ05vRSxRQUFROzRCQUNSQyxhQUFhOzRCQUNiRSxnQkFBZ0I7d0JBQ3BCO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXVCM3NCLE9BQU87NEJBQ25FMG9CLE1BQU07NEJBQ05vRSxRQUFROzRCQUNSQyxhQUFhOzRCQUNiRSxnQkFBZ0I7d0JBQ3BCO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXVCM3NCLE9BQU87NEJBQ25FMG9CLE1BQU07NEJBQ05vRSxRQUFROzRCQUNSQyxhQUFhOzRCQUNiRSxnQkFBZ0I7d0JBQ3BCO29CQUFFO29CQUFJbnpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQW1CM3NCLE9BQU87NEJBQy9EMG9CLE1BQU07NEJBQ05vRSxRQUFROzRCQUNSQyxhQUFhOzRCQUNiRSxnQkFBZ0I7d0JBQ3BCO29CQUFFO2lCQUFHO1lBQUM7UUFBRzs7SUFDekJjLElBQUksQ0FBQzcrQjtZQVlvSUEsYUFBeVpBO2VBWmxoQjRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE44bkIsU0FBUztvQkFDVFksTUFBTTtvQkFDTmtFLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFpRTNzQixPQUFPOzRCQUFFMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFBVzQ5QixRQUFRO3dCQUFVO29CQUFFO29CQUFJaHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQXFUM3NCLE9BQU87NEJBQUUwb0IsTUFBTXg1QixDQUFBQSxlQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU93NUIsSUFBSSxjQUFYeDVCLDBCQUFBQSxlQUFlOzRCQUFXNDlCLFFBQVE7d0JBQVU7b0JBQUU7b0JBQUloekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBa0Uzc0IsT0FBTzs0QkFBRTBvQixNQUFNOzRCQUFXb0UsUUFBUTt3QkFBVTtvQkFBRTtvQkFBSWh6QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUFpRTd0QixXQUFXO3dCQUE2Q2tCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBV29FLFFBQVE7d0JBQVU7b0JBQUU7b0JBQUloekIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBdU8zc0IsT0FBTzs0QkFBRTBvQixNQUFNOzRCQUFXb0UsUUFBUTt3QkFBTztvQkFBRTtpQkFBRztZQUFDO1FBQUc7O0lBQ3J2Q2tCLElBQUksQ0FBQzkrQjtZQWFxQkE7ZUFiVjRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE44bkIsU0FBUztvQkFDVFksTUFBTTtvQkFDTm1FLFVBQVU7b0JBQ1ZELGFBQWE7b0JBQ2JFLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0J6SyxJQUFJLENBQUMsS0FBSzt3QkFBRTJRLE9BQU87NEJBQ3ZDMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFDckI0OUIsUUFBUTs0QkFDUkUsZUFBZTt3QkFDbkI7d0JBQUd2MUIsVUFBVTs0QkFBQ3FDLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQWtROzRCQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQW9NOzRCQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO2dDQUFFdTlCLEdBQUc7NEJBQXVEO3lCQUFHO29CQUFDO29CQUFJN3lCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQStFM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7NEJBQVdHLGdCQUFnQjt3QkFBUTtvQkFBRTtpQkFBRztZQUFDO1FBQUc7O0lBQ2oxQmdCLElBQUksQ0FBQy8rQjtZQUNhQSxhQUsyTkE7ZUFON040SyxrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztZQUFFbTlCLE9BQU87WUFBOEJDLFNBQVM7WUFBT0MsU0FBUztZQUFhanNCLE9BQU87WUFBUUMsUUFBUTtZQUFRVCxLQUFLLEVBQUU5USxrQkFBQUEsNEJBQUFBLE1BQU93OUIsUUFBUTtZQUFFajFCLFVBQVVxQyxrQkFBa0J6SyxJQUFJLENBQUMsS0FBSztnQkFBRTJRLE9BQU87b0JBQ3BOMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTtvQkFDckI0OUIsUUFBUTtvQkFDUkMsYUFBYTtvQkFDYkMsZUFBZTtvQkFDZkMsZ0JBQWdCO2dCQUNwQjtnQkFBR3gxQixVQUFVO29CQUFDcUMsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRzt3QkFBOEkzc0IsT0FBTzs0QkFBRWd0QixlQUFlOzRCQUFRdEUsTUFBTXg1QixDQUFBQSxlQUFBQSxrQkFBQUEsNEJBQUFBLE1BQU93NUIsSUFBSSxjQUFYeDVCLDBCQUFBQSxlQUFlO3dCQUFVO29CQUFFO29CQUFJNEssa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRztvQkFBMk47b0JBQUk3eUIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRztvQkFBa0M7b0JBQUk3eUIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUV1OUIsR0FBRztvQkFBOEI7b0JBQUk3eUIsa0JBQWtCMUssR0FBRyxDQUFDLFVBQVU7d0JBQUVxK0IsSUFBSTt3QkFBS0MsSUFBSTt3QkFBTUMsR0FBRztvQkFBSTtvQkFBSTd6QixrQkFBa0IxSyxHQUFHLENBQUMsVUFBVTt3QkFBRXErQixJQUFJO3dCQUFNQyxJQUFJO3dCQUFLQyxHQUFHO29CQUFJO29CQUFJN3pCLGtCQUFrQjFLLEdBQUcsQ0FBQyxVQUFVO3dCQUFFcStCLElBQUk7d0JBQVFDLElBQUk7d0JBQUtDLEdBQUc7b0JBQUk7b0JBQUk3ekIsa0JBQWtCMUssR0FBRyxDQUFDLFVBQVU7d0JBQUVxK0IsSUFBSTt3QkFBTUMsSUFBSTt3QkFBS0MsR0FBRztvQkFBSTtvQkFBSTd6QixrQkFBa0IxSyxHQUFHLENBQUMsVUFBVTt3QkFBRXErQixJQUFJO3dCQUFNQyxJQUFJO3dCQUFNQyxHQUFHO29CQUFJO29CQUFJN3pCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQW1DM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7NEJBQVdFLGVBQWU7d0JBQU87b0JBQUU7b0JBQUlsekIsa0JBQWtCekssSUFBSSxDQUFDLEtBQUs7d0JBQUUyUSxPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFRO3dCQUFVO3dCQUFHcjFCLFVBQVU7NEJBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTtnQ0FBRXU5QixHQUFHOzRCQUE4Qjs0QkFBSTd5QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTtnQ0FBRXU5QixHQUFHOzRCQUEwQjs0QkFBSTd5QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTtnQ0FBRXU5QixHQUFHOzRCQUFzQzs0QkFBSTd5QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTtnQ0FBRXU5QixHQUFHOzRCQUFzQzt5QkFBRztvQkFBQztpQkFBRztZQUFDO1FBQUc7O0lBQ3YrQ3VCLElBQUksQ0FBQ2gvQjtZQVlxQkEsYUFJMk9BO2VBaEJyUDRLLGtCQUFrQjFLLEdBQUcsQ0FBQyxPQUFPO1lBQUVtOUIsT0FBTztZQUE4QkMsU0FBUztZQUFPQyxTQUFTO1lBQWFqc0IsT0FBTztZQUFRQyxRQUFRO1lBQVFULEtBQUssRUFBRTlRLGtCQUFBQSw0QkFBQUEsTUFBT3c5QixRQUFRO1lBQUVqMUIsVUFBVXFDLGtCQUFrQnpLLElBQUksQ0FBQyxLQUFLO2dCQUFFMlEsT0FBTztvQkFDcE4wb0IsTUFBTTtvQkFDTmtFLGFBQWE7b0JBQ2JDLFVBQVU7b0JBQ1ZDLFFBQVE7b0JBQ1JDLGFBQWE7b0JBQ2JDLGVBQWU7b0JBQ2ZDLGdCQUFnQjtvQkFDaEJDLGtCQUFrQjtvQkFDbEJDLGlCQUFpQjtvQkFDakJDLGVBQWU7Z0JBQ25CO2dCQUFHMzFCLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF5QjNzQixPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFROzRCQUFXRyxnQkFBZ0I7d0JBQVE7d0JBQUczdkIsSUFBSTtvQkFBVztvQkFBSXhELGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQTZIM3NCLE9BQU87NEJBQzdUMG9CLE1BQU14NUIsQ0FBQUEsY0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1Qix5QkFBQUEsY0FBZTs0QkFDckIwOUIsYUFBYTs0QkFDYkksZUFBZTs0QkFDZkMsZ0JBQWdCO3dCQUNwQjtvQkFBRTtvQkFBSW56QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUE2TDNzQixPQUFPOzRCQUFFMG9CLE1BQU14NUIsQ0FBQUEsZUFBQUEsa0JBQUFBLDRCQUFBQSxNQUFPdzVCLElBQUksY0FBWHg1QiwwQkFBQUEsZUFBZTs0QkFBVzQ5QixRQUFRO3dCQUFVO29CQUFFO29CQUFJaHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQWlCM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7NEJBQVdHLGdCQUFnQjt3QkFBUTtvQkFBRTtvQkFBSW56QixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRXU5QixHQUFHO3dCQUF1SjNzQixPQUFPOzRCQUFFMG9CLE1BQU07NEJBQVFvRSxRQUFRO3dCQUFVO29CQUFFO29CQUFJaHpCLGtCQUFrQjFLLEdBQUcsQ0FBQyxRQUFRO3dCQUFFdTlCLEdBQUc7d0JBQTJHM3NCLE9BQU87NEJBQUUwb0IsTUFBTTs0QkFBUW9FLFFBQVE7d0JBQVU7b0JBQUU7aUJBQUc7WUFBQztRQUFHOztBQUNoMkI7QUFFQSxTQUFTcUIsa0JBQWtCbEMsaUJBQWlCO0lBQ3hDLE9BQU87UUFDSG5zQixTQUFTO1FBQ1RzdUIscUJBQXFCLENBQUMsT0FBTyxFQUFFbkMsa0JBQWtCLE1BQU0sQ0FBQztRQUN4RHByQixVQUFVO1FBQ1ZMLE9BQU87UUFDUEMsUUFBUTtRQUNSSixVQUFVO0lBQ2Q7QUFDSjtBQUNBLE1BQU1ndUIscUJBQXFCO0lBQ3ZCQyxhQUFhO0lBQ2J4dUIsU0FBUztJQUNUeXVCLGdCQUFnQjtJQUNoQkMsWUFBWTtJQUNabnVCLFVBQVU7QUFDZDtBQUNBLE1BQU1vdUIseUJBQXlCO0lBQzNCQyxpQkFBaUI7QUFDckI7QUFDQSxNQUFNQywwQkFBMEI7SUFDNUJELGlCQUFpQjtBQUNyQjtBQUNBLE1BQU1FLHlCQUF5QjtJQUMzQkMsV0FBVztBQUNmO0FBQ0EsTUFBTUMsaUNBQWlDO0lBQ25DQyxPQUFPO0FBQ1g7QUFDQSxNQUFNQyxrQ0FBa0M7SUFDcENELE9BQU87QUFDWDtBQUNBLE1BQU1FLDRCQUE0QjtJQUM5QkMsVUFBVTtJQUNWN3VCLFVBQVU7SUFDVnNGLFFBQVE7SUFDUkYsT0FBTztJQUNQMHBCLFlBQVk7QUFDaEI7QUFDQSxNQUFNQyw4QkFBOEI7SUFDaENGLFVBQVU7SUFDVjd1QixVQUFVO0lBQ1ZDLEtBQUs7SUFDTEMsTUFBTTtJQUNONHVCLFlBQVk7QUFDaEI7QUFDQSxNQUFNRSw0QkFBNEI7SUFDOUJ2d0IsV0FBVztBQUNmO0FBQ0EsTUFBTXd3QixpQ0FBaUM7SUFDbkN4SCxTQUFTO0FBQ2I7QUFDQSxNQUFNeUgsc0JBQXNCO0lBQ3hCUixPQUFPO0lBQ1BTLGdCQUFnQjtJQUNoQkMsZUFBZTtJQUNmQywrQkFBK0I7SUFDL0JDLHlDQUF5QztJQUN6Q0MsdUJBQXVCO0lBQ3ZCQyw0QkFBNEI7SUFDNUIvSCxTQUFTO0lBQ1RnSSxlQUFlO0FBQ25CO0FBRUEsTUFBTUMsb0JBQW9CamlDLE1BQU15VCxhQUFhLENBQUM7QUFDOUMsTUFBTXl1Qix1QkFBdUIsSUFBTWxpQyxNQUFNbWlDLEdBQUcsQ0FBQ0Y7QUFDN0MsU0FBU0csbUJBQW1CLEVBQUV6NEIsUUFBUSxFQUFFdU0sT0FBTyxFQUFHO0lBQzlDLE1BQU0sRUFDTixLQUFLO0lBQ0wxRyxLQUFLLFlBQVksRUFDakIsc0JBQXNCO0lBQ3RCNnlCLFNBQVM5RCxhQUFhLEVBQUVoc0IsV0FBVyw2Q0FBNkMsRUFDaEYsbUNBQW1DO0lBQ25DcXBCLG1CQUFtQixPQUFPLEVBQUV3QyxpQkFBaUIsQ0FBQyxFQUFFRCxvQkFBb0IsQ0FBQyxFQUNyRSwyQkFBMkI7SUFDM0JtRSxhQUFhakMsa0JBQWtCbEMsa0JBQWtCLEVBQUVvRSxjQUFjaEMsa0JBQWtCLEVBQUVpQyxlQUFlLENBQUMsQ0FBQyxFQUFFQyxrQkFBa0I5QixzQkFBc0IsRUFBRStCLG1CQUFtQjdCLHVCQUF1QixFQUFFOEIsa0JBQWtCN0Isc0JBQXNCLEVBQUU4QixxQkFBcUJyQix5QkFBeUIsRUFBRXNCLDBCQUEwQnJCLDhCQUE4QixFQUNoVixXQUFXO0lBQ1hzQiwwQkFBMEI5Qiw4QkFBOEIsRUFBRStCLDJCQUEyQjdCLCtCQUErQixFQUFFOEIscUJBQXFCN0IseUJBQXlCLEVBQUU4Qix1QkFBdUIzQiwyQkFBMkIsRUFBRTRCLGVBQWUsSUFBSSxFQUM3TyxZQUFZO0lBQ1pDLHdCQUF3QixHQUFHLEVBQUVDLGlCQUFpQixJQUFJLEVBQ2xELGdCQUFnQjtJQUNoQkMsZ0JBQWdCLElBQUksRUFBRUMsb0JBQW9CLElBQUksRUFBRUMsa0JBQWtCLEtBQUssRUFBRUMseUJBQXlCLENBQUMsRUFDbkcsU0FBUztJQUNUQyxxQkFBcUIsSUFBSSxFQUFFQyxTQUFTLEVBQUUsRUFBRUMsZUFBZWxDLG1CQUFtQixFQUFFbUMscUJBQXFCLElBQUksRUFDckcsV0FBVztJQUNYQyxZQUFZLEVBQUVDLGNBQWMsRUFBRUMsZ0JBQWdCLEVBQUVDLGlCQUFpQixFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUVDLGtCQUFrQixFQUFFQyxjQUFjLEVBQUcsR0FBR3B1QixXQUFXLENBQUM7SUFDOUssb0NBQW9DO0lBQ3BDLE1BQU0sQ0FBQ3F1QixlQUFlQyxpQkFBaUIsR0FBR3hrQyxNQUFNc1QsUUFBUSxDQUFDO0lBQ3pELG1EQUFtRDtJQUNuRCxNQUFNLENBQUNteEIsaUJBQWlCQyxtQkFBbUIsR0FBRzFrQyxNQUFNc1QsUUFBUSxDQUFDLE9BQU9mLGFBQWEsV0FDM0VrcUIsMEJBQTBCbHFCLFVBQVU2ckIsZ0JBQWdCRCxxQkFDcEQ1ckI7SUFDTixnRUFBZ0U7SUFDaEUsTUFBTSxDQUFDb3lCLHFCQUFxQkMsdUJBQXVCLEdBQUc1a0MsTUFBTXNULFFBQVEsQ0FBQyxDQUFDO0lBQ3RFLHVDQUF1QztJQUN2QyxNQUFNLENBQUN1eEIsK0JBQStCQyxpQ0FBaUMsR0FBRzlrQyxNQUFNc1QsUUFBUSxDQUFDO0lBQ3pGLFNBQVM7SUFDVCxNQUFNLENBQUN5eEIscUJBQXFCQyx1QkFBdUIsR0FBR2hsQyxNQUFNc1QsUUFBUSxDQUFDO0lBQ3JFLE1BQU0sQ0FBQzJ4QixvQkFBb0JDLHNCQUFzQixHQUFHbGxDLE1BQU1zVCxRQUFRLENBQUM7SUFDbkUsTUFBTSxDQUFDNnhCLGdCQUFnQkMsa0JBQWtCLEdBQUdwbEMsTUFBTXNULFFBQVEsQ0FBQyxFQUFFO0lBQzdELG9JQUFvSTtJQUNwSSxNQUFNLENBQUMreEIsNkJBQTZCQywrQkFBK0IsR0FBR3RsQyxNQUFNc1QsUUFBUSxDQUFDO0lBQ3JGLGlFQUFpRTtJQUNqRSxNQUFNaXlCLHNCQUFzQnZsQyxNQUFNNE4sTUFBTSxDQUFDO0lBQ3pDLGdFQUFnRTtJQUNoRTVOLE1BQU13TixTQUFTLENBQUM7UUFDWixNQUFNOHZCLGNBQWMsT0FBTy9xQixhQUFhLFdBQ2xDa3FCLDBCQUEwQmxxQixVQUFVNnJCLGdCQUFnQkQscUJBQ3BENXJCO1FBQ04seUNBQXlDO1FBQ3pDLElBQUksQ0FBQzZ3QixnQkFBZ0I7WUFDakJzQixtQkFBbUJwSDtZQUNuQjtRQUNKO1FBQ0EsMElBQTBJO1FBQzFJLE1BQU1rSSxxQ0FBcUNIO1FBQzNDLCtIQUErSDtRQUMvSCxJQUFJRyxvQ0FBb0M7WUFDcENkLG1CQUFtQmM7WUFDbkJGLCtCQUErQjtRQUNuQztRQUNBLGdFQUFnRTtRQUNoRSxNQUFNRyxrQkFBa0JySSxtQkFBbUJvSSwrQ0FBQUEsZ0RBQUFBLHFDQUFzQ2YsaUJBQ2pGbkgsYUFBYWEsbUJBQW1CdkM7UUFDaEMsTUFBTThKLHNCQUFzQnpnQyxPQUFPNkUsSUFBSSxDQUFDMjdCLGlCQUFpQjc5QixNQUFNLEdBQUc7UUFDbEUsd0VBQXdFO1FBQ3hFLElBQUlpOUIsaUNBQWlDYSxxQkFBcUI7WUFDdEQsMERBQTBEO1lBQzFELE1BQU1DLHVCQUF1QjtnQkFBRSxHQUFHbEIsZUFBZTtZQUFDO1lBQ2xELE9BQU9rQixvQkFBb0IsQ0FBQ2QsOEJBQThCZSxZQUFZLENBQUM7WUFDdkVELG9CQUFvQixDQUFDZCw4QkFBOEJnQixZQUFZLENBQUMsR0FBRztnQkFDL0Q5SSxXQUFXOEgsOEJBQThCNUgsS0FBSztZQUNsRDtZQUNBeUgsbUJBQW1CaUI7WUFDbkIsb0VBQW9FO1lBQ3BFLE1BQU1HLHFCQUFxQjtnQkFBRSxHQUFHTCxlQUFlO1lBQUM7WUFDaEQsT0FBT0ssa0JBQWtCLENBQUNqQiw4QkFBOEJlLFlBQVksQ0FBQztZQUNyRWhCLHVCQUF1QmtCO1lBQ3ZCLHNDQUFzQztZQUN0QyxNQUFNQyxhQUFhcmtCLFdBQVc7Z0JBQzFCZ2pCLG1CQUFtQnBIO2dCQUNuQnNILHVCQUF1QixDQUFDO2dCQUN4QkUsaUNBQWlDO1lBQ3JDLEdBQUczQjtZQUNIb0Msb0JBQW9CMTNCLE9BQU8sR0FBR2s0QjtZQUM5QjtRQUNKO1FBQ0EsNkNBQTZDO1FBQzdDLElBQUlsQiwrQkFBK0I7WUFDL0IsZ0VBQWdFO1lBQ2hFSCxtQkFBbUJwSDtZQUNuQndILGlDQUFpQztZQUNqQztRQUNKO1FBQ0EsZ0RBQWdEO1FBQ2hERix1QkFBdUJhO1FBQ3ZCSCwrQkFBK0JoSTtRQUMvQiwwQkFBMEI7UUFDMUIsTUFBTXlJLGFBQWFya0IsV0FBVztZQUMxQmdqQixtQkFBbUJwSDtZQUNuQnNILHVCQUF1QixDQUFDO1lBQ3hCVSwrQkFBK0I7UUFDbkMsR0FBR25DO1FBQ0gsb0NBQW9DO1FBQ3BDb0Msb0JBQW9CMTNCLE9BQU8sR0FBR2s0QjtRQUM5QiwyQkFBMkI7UUFDM0IsT0FBTztZQUNILElBQUlSLG9CQUFvQjEzQixPQUFPLEVBQUU7Z0JBQzdCa1gsYUFBYXdnQixvQkFBb0IxM0IsT0FBTztZQUM1QztRQUNKO0lBQ0osR0FBRztRQUFDMEU7S0FBUztJQUNiLGlFQUFpRTtJQUNqRXZTLE1BQU13TixTQUFTLENBQUM7UUFDWmszQixtQkFBbUIsT0FBT255QixhQUFhLFdBQ2pDa3FCLDBCQUEwQmxxQixVQUFVNnJCLGdCQUFnQkQscUJBQ3BENXJCO0lBQ1YsR0FBRztRQUFDNnJCO1FBQWdCRDtRQUFtQnZDO0tBQWlCO0lBQ3hELHlEQUF5RDtJQUN6RDU3QixNQUFNd04sU0FBUyxDQUFDO1FBQ1pzMkIsMkJBQUFBLHFDQUFBQSxlQUFpQjtZQUFFSixRQUFReUI7UUFBZTtJQUM5QyxHQUFHO1FBQUNBO0tBQWU7SUFDbkIsd0VBQXdFO0lBQ3hFLE1BQU10SixRQUFRNzdCLE1BQU0rTyxPQUFPLENBQUMsSUFBTTBzQixjQUFjMkMsZ0JBQWdCRCxtQkFBbUJ2QyxtQkFBbUI7UUFBQ3dDO1FBQWdCRDtRQUFtQnZDO0tBQWlCO0lBQzNKLE1BQU1vSyxZQUFZaG1DLE1BQU04TixXQUFXLENBQUMsQ0FBQ200QixtQkFBbUIvVTtRQUNwRCxJQUFJLENBQUN1UyxvQkFBb0I7WUFDckI7UUFDSjtRQUNBLE1BQU15QyxtQkFBbUJmLGVBQWVnQixTQUFTLENBQUMsQ0FBQ0MsUUFBVUEsTUFBTUMsV0FBVyxLQUFLdEIsdUJBQy9FcUIsTUFBTUUsU0FBUyxLQUFLTDtRQUN4QixNQUFNTSx3QkFBd0I3QyxPQUFPdG9CLElBQUksQ0FBQyxDQUFDZ3JCLFFBQVVBLE1BQU1DLFdBQVcsS0FBS3RCLHVCQUN2RXFCLE1BQU1FLFNBQVMsS0FBS0w7UUFDeEIsOEVBQThFO1FBQzlFLElBQUlNLHVCQUF1QjtZQUN2QnZCLHVCQUF1QjtZQUN2QkUsc0JBQXNCO1lBQ3RCO1FBQ0o7UUFDQSx1R0FBdUc7UUFDdkcsSUFBSUgsdUJBQXVCQSx3QkFBd0JrQixtQkFBbUI7WUFDbEUsTUFBTU8sYUFBYXRWLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3VWLFFBQVEsSUFDaEM5QyxhQUFhakMsY0FBYyxHQUMzQnhRLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3dWLE9BQU8sSUFDZC9DLGFBQWFoQyxhQUFhLEdBQzFCZ0MsYUFBYTFDLEtBQUs7WUFDNUJtRSxrQkFBa0IsQ0FBQ3VCLGFBQWVULHFCQUFxQixDQUFDLElBQ2xEO3VCQUNLUztvQkFDSDt3QkFDSU4sYUFBYXRCO3dCQUNidUIsV0FBV0w7d0JBQ1hoRixPQUFPdUY7b0JBQ1g7aUJBQ0gsR0FDQ0csV0FBVzU4QixNQUFNLENBQUMsQ0FBQzY4QixHQUFHeGUsUUFBVUEsVUFBVThkO1lBQ2hEbEIsdUJBQXVCO1lBQ3ZCRSxzQkFBc0I7UUFDMUI7SUFDSixHQUFHO1FBQ0N6QjtRQUNBQztRQUNBQyxhQUFhMUMsS0FBSztRQUNsQjBDLGFBQWFqQyxjQUFjO1FBQzNCaUMsYUFBYWhDLGFBQWE7UUFDMUJ3RDtRQUNBSjtRQUNBRTtLQUNIO0lBQ0QsTUFBTTRCLGNBQWM3bUMsTUFBTThOLFdBQVcsQ0FBQztRQUNsQyxJQUFJODFCLG9CQUFvQjtZQUNwQndCLGtCQUFrQixFQUFFO1lBQ3BCSix1QkFBdUI7WUFDdkJFLHNCQUFzQjtRQUMxQjtJQUNKLEdBQUc7UUFBQ3RCO0tBQW1CO0lBQ3ZCLE1BQU1rRCxxQ0FBcUM5bUMsTUFBTThOLFdBQVcsQ0FBQyxDQUFDdXdCLFFBQVFuTjtRQUNsRSxNQUFNK1AsUUFBUS9QLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3VWLFFBQVEsSUFDM0I5QyxhQUFhakMsY0FBYyxHQUMzQnhRLENBQUFBLHNCQUFBQSxnQ0FBQUEsVUFBV3dWLE9BQU8sSUFDZC9DLGFBQWFoQyxhQUFhLEdBQzFCZ0MsYUFBYTFDLEtBQUs7UUFDNUJpRSxzQkFBc0I7WUFBRTdHO1lBQVE0QztRQUFNO0lBQzFDLEdBQUc7UUFBQzBDO0tBQWE7SUFDakIsTUFBTW9ELG1CQUFtQi9tQyxNQUFNOE4sV0FBVyxDQUFDO1FBQ3ZDMDJCLGlCQUFpQjtJQUNyQixHQUFHLEVBQUU7SUFDTCxNQUFNd0MsZ0JBQWdCaG5DLE1BQU04TixXQUFXLENBQUMsU0FBU2s1QixjQUFjNzJCLEtBQUs7WUFJN0NBO1FBSG5CLElBQUksQ0FBQ28wQixlQUFlO1lBQ2hCO1FBQ0o7UUFDQSxNQUFNMEMsY0FBYTkyQixjQUFBQSxNQUFNeUUsSUFBSSxjQUFWekUsa0NBQUFBLFlBQVlYLEVBQUUsQ0FBQ2pELFFBQVE7UUFDMUMscURBQXFEO1FBQ3JELElBQUksQ0FBQzA2QixZQUFZO1lBQ2I5Qyx3QkFBQUEsa0NBQUFBLFlBQWM7Z0JBQ1ZsSCxPQUFPc0g7Z0JBQ1BxQixjQUFjckIsY0FBY2h5QixRQUFRO2dCQUNwQ3N6QixjQUFjO1lBQ2xCO1lBQ0EsOERBQThEO1lBQzlEZixpQ0FBaUM7Z0JBQzdCN0gsT0FBT3NILGNBQWN4SCxTQUFTO2dCQUM5QjZJLGNBQWNyQixjQUFjaHlCLFFBQVE7Z0JBQ3BDc3pCLGNBQWM7WUFDbEI7WUFDQXJCLGlCQUFpQjtZQUNqQjtRQUNKO1FBQ0EsSUFBSXIwQixNQUFNeUUsSUFBSSxFQUFFO1lBQ1osTUFBTXN5QixjQUFjL0Msd0JBQUFBLGtDQUFBQSxZQUFjO2dCQUM5QmxILE9BQU9zSDtnQkFDUHFCLGNBQWNyQixjQUFjaHlCLFFBQVE7Z0JBQ3BDc3pCLGNBQWNvQjtZQUNsQjtZQUNBLGtFQUFrRTtZQUNsRSxJQUFJQyxhQUFhO2dCQUNicEMsaUNBQWlDO29CQUM3QjdILE9BQU9zSCxjQUFjeEgsU0FBUztvQkFDOUI2SSxjQUFjckIsY0FBY2h5QixRQUFRO29CQUNwQ3N6QixjQUFjb0I7Z0JBQ2xCO1lBQ0o7WUFDQXpDLGlCQUFpQjtRQUNyQjtJQUNKLEdBQUc7UUFBQ0Q7S0FBYztJQUNsQixNQUFNNEMsa0JBQWtCbm5DLE1BQU04TixXQUFXLENBQ3pDLGlEQUFpRDtJQUNqRCxTQUFTcTVCLGdCQUFnQixFQUFFMXlCLE1BQU0sRUFBRTtZQUVWQTtRQURyQiwrS0FBK0s7UUFDL0ssTUFBTTJ5QixnQkFBZTN5Qix1QkFBQUEsT0FBT3VDLElBQUksQ0FBQ25KLE9BQU8sY0FBbkI0RywyQ0FBQUEscUJBQXFCMnlCLFlBQVk7UUFDdERsRCx3QkFBQUEsa0NBQUFBLFlBQWM7WUFDVmtEO1lBQ0FuSyxPQUFPbUssZUFDRDtnQkFDRXJLLFdBQVd0b0IsT0FBT2pGLEVBQUU7WUFDeEIsSUFDRWkxQixlQUFlLENBQUNod0IsT0FBT2pGLEVBQUUsQ0FBQztZQUNoQzZ1QixRQUFRK0ksZUFBZSxPQUFPM3lCLE9BQU9qRixFQUFFO1FBQzNDO1FBQ0FnMUIsaUJBQWlCO1lBQ2I0QztZQUNBNzBCLFVBQVVrQyxPQUFPakYsRUFBRTtZQUNuQnV0QixXQUFXcUssZUFDTDN5QixPQUFPakYsRUFBRSxHQUNUaTFCLGVBQWUsQ0FBQ2h3QixPQUFPakYsRUFBRSxDQUFDLENBQUN1dEIsU0FBUztRQUM5QztRQUNBO0lBQ0osR0FBRztRQUFDMEg7S0FBZ0I7SUFDcEIsTUFBTXJ1QixVQUFVRCxXQUFXSCxVQUFVa1EsZUFBZTtRQUNoRDlCLHNCQUFzQm9mLHlCQUF5QixJQUN6QztZQUNFOWQsVUFBVThkO1FBQ2QsSUFDRXRpQjtJQUNWLElBQUlsTCxVQUFVbUwsaUJBQWlCbkwsVUFBVTBRLGNBQWMxUSxVQUFVdVE7SUFDakUsMkhBQTJIO0lBQzNILFNBQVN5TCxtQkFBbUIvakIsSUFBSTtRQUM1Qiw4Q0FBOEM7UUFDOUMsTUFBTW81QixvQkFBb0J4dUIsY0FBYzVLO1FBQ3hDLHdEQUF3RDtRQUN4RCxJQUFJbzVCLGtCQUFrQnovQixNQUFNLEdBQUcsR0FBRztZQUM5QixPQUFPeS9CO1FBQ1g7UUFDQSxnREFBZ0Q7UUFDaEQsT0FBT2p2QixpQkFBaUJuSztJQUM1QjtJQUNBLE9BQVFqQyxrQkFBa0IxSyxHQUFHLENBQUMyZ0Msa0JBQWtCaE0sUUFBUSxFQUFFO1FBQUUzeUIsT0FBTztZQUMzRCxxQkFBcUI7WUFDckJrTTtZQUNBNnlCO1lBQ0F6RztZQUNBd0M7WUFDQUQ7WUFDQW1FO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FHO1lBQ0FDO1lBQ0FDO1lBQ0FFO1lBQ0FFO1lBQ0FDO1lBQ0FDO1lBQ0FHO1lBQ0FDO1lBQ0FDO1lBQ0EsaUJBQWlCO1lBQ2pCekk7WUFDQXlMLFdBQVc7WUFDWC9DO1lBQ0FFO1lBQ0FFO1lBQ0FJO1lBQ0FFO1lBQ0FEO1lBQ0FFLHVCQUF1QjRCO1lBQ3ZCM0I7WUFDQWE7WUFDQWE7UUFDSjtRQUFHbDlCLFVBQVVxQyxrQkFBa0IxSyxHQUFHLENBQUNtd0IsWUFBWTtZQUFFeEosWUFBWXNiO1lBQWlCdlIsb0JBQW9CQTtZQUFvQnhkLGFBQWEyeUI7WUFBaUJ0eUIsV0FBV215QjtZQUFlanlCLGNBQWNneUI7WUFBa0Izd0IsU0FBU0E7WUFBU3pNLFVBQVVBO1FBQVM7SUFBRztBQUM5UDtBQUVBLFNBQVM0OUIsT0FBTyxFQUFFckosVUFBVSxFQUFFc0osV0FBVyxFQUFFO0lBQ3ZDLE1BQU0sRUFBRWg0QixFQUFFLEVBQUVrMEIsTUFBTSxFQUFFQyxZQUFZLEVBQUUvSCxnQkFBZ0IsRUFBRXVDLGlCQUFpQixFQUFFQyxjQUFjLEVBQUUrRyxjQUFjLEVBQUVKLG1CQUFtQixFQUFFRSxrQkFBa0IsRUFBRyxHQUFHL0M7SUFDcEosSUFBSSxDQUFDaEUsWUFBWTtRQUNiLE9BQU87SUFDWDtJQUNBLE1BQU11Six3QkFBd0IxQyx1QkFDMUJFLHNCQUNBRix3QkFBd0JFLG1CQUFtQjVHLE1BQU0sR0FDL0M7UUFDRWdJLGFBQWF0QjtRQUNidUIsV0FBV3JCLG1CQUFtQjVHLE1BQU07UUFDcEM0QyxPQUFPZ0UsbUJBQW1CaEUsS0FBSztJQUNuQyxJQUNFO0lBQ04sTUFBTXlHLGVBQWVELHdCQUNmO1dBQUkvRDtXQUFXeUI7UUFBZ0JzQztLQUFzQixHQUNyRDtXQUFJL0Q7V0FBV3lCO0tBQWU7SUFDcEMsT0FBUW41QixrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztRQUFFb1IsT0FBT3dyQjtRQUFZdnJCLFFBQVE2MEI7UUFBYXQxQixPQUFPO1lBQzlFSyxVQUFVO1lBQ1ZDLEtBQUs7WUFDTEMsTUFBTTtZQUNOazFCLGVBQWU7WUFDZnhNLFFBQVE7UUFDWjtRQUFHeHhCLFVBQVUrOUIsYUFBYXZlLEdBQUcsQ0FBQyxDQUFDaWQsT0FBTzk3QjtZQUNsQyxNQUFNMmlCLE9BQU9nUixrQkFBa0JyQyxrQkFBa0JzQyxZQUFZQyxtQkFBbUJDLGdCQUFnQmdJLE1BQU1DLFdBQVc7WUFDakgsTUFBTXVCLEtBQUszSixrQkFBa0JyQyxrQkFBa0JzQyxZQUFZQyxtQkFBbUJDLGdCQUFnQmdJLE1BQU1FLFNBQVM7WUFDN0csc0lBQXNJO1lBQ3RJLE1BQU1oSSxjQUFjSixhQUFhQztZQUNqQyxJQUFJMEosdUJBQXVCdkosY0FBY3FGLGFBQWEvQiw2QkFBNkI7WUFDbkYsTUFBTWtHLGdCQUFnQkwseUJBQXlCbjlCLE1BQU1vOUIsYUFBYTkvQixNQUFNLEdBQUc7WUFDM0UsMEZBQTBGO1lBQzFGLElBQUk4L0IsYUFBYXRzQixJQUFJLENBQUMsQ0FBQzJzQixZQUFjQSxVQUFVMUIsV0FBVyxLQUFLRCxNQUFNQyxXQUFXLElBQzVFMEIsVUFBVXpCLFNBQVMsS0FBS0YsTUFBTUUsU0FBUyxLQUN2QyxDQUFDd0IsZUFBZTtnQkFDaEJELHVCQUNJdkosY0FBY3FGLGFBQWE5Qix1Q0FBdUM7WUFDMUU7WUFDQSwrRUFBK0U7WUFDL0UsTUFBTWhpQixLQUFLK25CLEdBQUd4a0MsQ0FBQyxHQUFHNnBCLEtBQUs3cEIsQ0FBQztZQUN4QixNQUFNMGMsS0FBSzhuQixHQUFHaDNCLENBQUMsR0FBR3FjLEtBQUtyYyxDQUFDO1lBQ3hCLHdFQUF3RTtZQUN4RSx5RUFBeUU7WUFDekUsTUFBTWl2QixJQUFJNXVCLEtBQUsrMkIsS0FBSyxDQUFDbG9CLElBQUlEO1lBQ3pCLDRDQUE0QztZQUM1Qyw2RUFBNkU7WUFDN0UsdURBQXVEO1lBQ3ZELE1BQU1ZLE1BQU07Z0JBQ1IscUNBQXFDO2dCQUNyQywwQ0FBMEM7Z0JBQzFDLGdFQUFnRTtnQkFDaEUseUNBQXlDO2dCQUN6Q3JkLEdBQUc2cEIsS0FBSzdwQixDQUFDLEdBQUcsQUFBQ3ljLEtBQU1nZ0IsQ0FBQUEsSUFBSWdJLG9CQUFtQixJQUFNaEk7Z0JBQ2hELG9DQUFvQztnQkFDcENqdkIsR0FBR3FjLEtBQUtyYyxDQUFDLEdBQUcsQUFBQ2tQLEtBQU0rZixDQUFBQSxJQUFJZ0ksb0JBQW1CLElBQU1oSTtZQUNwRDtZQUNBLE9BQVE3ekIsa0JBQWtCekssSUFBSSxDQUFDdkIsTUFBTXFCLFFBQVEsRUFBRTtnQkFBRXNJLFVBQVU7b0JBQUNxQyxrQkFBa0IxSyxHQUFHLENBQUMsVUFBVTt3QkFBRWtPLElBQUksR0FBR0EsR0FBRyxXQUFXLEVBQUVsRixFQUFFLENBQUMsRUFBRTg3QixNQUFNQyxXQUFXLENBQUMsQ0FBQyxFQUFFRCxNQUFNRSxTQUFTLEVBQUU7d0JBQUUyQixhQUFhO3dCQUFLQyxjQUFjO3dCQUFPQyxNQUFNO3dCQUFRQyxNQUFNO3dCQUFRQyxRQUFRO3dCQUFRMStCLFVBQVVxQyxrQkFBa0IxSyxHQUFHLENBQUMsV0FBVzs0QkFBRWduQyxRQUFROzRCQUEwQjFOLE1BQU13TCxNQUFNbkYsS0FBSzt3QkFBQztvQkFBRztvQkFBSWoxQixrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRWluQyxJQUFJdGIsS0FBSzdwQixDQUFDO3dCQUFFb2xDLElBQUl2YixLQUFLcmMsQ0FBQzt3QkFBRTYzQixJQUFJaG9CLElBQUlyZCxDQUFDO3dCQUFFc2xDLElBQUlqb0IsSUFBSTdQLENBQUM7d0JBQUVvcEIsU0FBUzhOLGdCQUNsYW5FLGFBQWEzQixhQUFhLEdBQzFCMkIsYUFBYTNKLE9BQU87d0JBQUVnRixRQUFRb0gsTUFBTW5GLEtBQUs7d0JBQUVoQyxhQUFhNkksZ0JBQ3hEbkUsYUFBYTVCLDBCQUEwQixHQUNwQ3pELENBQUFBLGNBQWNxRixhQUFhN0IscUJBQXFCLEFBQUQsSUFDbER4RCxjQUFjcUYsYUFBYTdCLHFCQUFxQjt3QkFBRTZHLFdBQVcsQ0FBQyxLQUFLLEVBQUVuNUIsR0FBRyxXQUFXLEVBQUVsRixFQUFFLENBQUMsRUFBRTg3QixNQUFNQyxXQUFXLENBQUMsQ0FBQyxFQUFFRCxNQUFNRSxTQUFTLENBQUMsQ0FBQyxDQUFDO29CQUFDO2lCQUFHO1lBQUMsR0FBRyxHQUFHOTJCLEdBQUcsT0FBTyxFQUFFNDJCLE1BQU1DLFdBQVcsQ0FBQyxDQUFDLEVBQUVELE1BQU1FLFNBQVMsR0FBR3dCLGdCQUFnQixZQUFZLElBQUk7UUFDclA7SUFBRztBQUNYO0FBRUEsU0FBU2MsVUFBVSxFQUFFai9CLFFBQVEsRUFBRXk5QixlQUFlLEtBQUssRUFBRXJLLFNBQVMsRUFBRXhxQixRQUFRLEVBQUc7SUFDdkUsTUFBTSxFQUFFOHdCLGFBQWEsRUFBRVEsWUFBWSxFQUFFLEdBQUczQjtJQUN4QyxNQUFNLEVBQUU5eUIsVUFBVSxFQUFFcW5CLFVBQVUsRUFBRTFpQixTQUFTLEVBQUUsR0FBR3lpQixhQUFhO1FBQ3ZEaG5CLElBQUkrQztRQUNKeUUsTUFBTTtZQUNGb3dCO1lBQ0FySztRQUNKO1FBQ0FyVixVQUFVLENBQUMyYixpQkFDTlEsZ0JBQ0csQ0FBQ0EsYUFBYTtZQUNWNUcsT0FBTztnQkFBRUY7WUFBVTtZQUNuQnFLO1lBQ0EvSSxRQUFROXJCO1FBQ1o7SUFDWjtJQUNBLE9BQVF2RyxrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztRQUFFSixLQUFLa087UUFBWSxHQUFHcW5CLFVBQVU7UUFBRSxHQUFHMWlCLFNBQVM7UUFBRXBLLFVBQVVBO0lBQVM7QUFDNUc7QUFFQSxTQUFTay9CLFVBQVUsRUFBRWwvQixRQUFRLEVBQUVxeUIsUUFBUSxFQUFFO0lBQ3JDLE1BQU0sRUFBRWpFLE1BQU0sRUFBRTNvQixVQUFVLEVBQUUsR0FBR2dvQixhQUFhO1FBQ3hDNW5CLElBQUl3c0I7SUFDUjtJQUNBLE9BQU9od0Isa0JBQWtCMUssR0FBRyxDQUFDLE9BQU87UUFBRUosS0FBS2tPO1FBQVl6RixVQUFVQSxTQUFTO1lBQUVvdUI7UUFBTztJQUFHO0FBQzFGO0FBRUEsTUFBTStRLFFBQVE5b0MsTUFBTTB4QixJQUFJLENBQUMsU0FBU29YLE1BQU0sRUFBRUMsS0FBSyxFQUFFM0IsZUFBZSxLQUFLLEVBQUU3MEIsUUFBUSxFQUFFd3FCLFNBQVMsRUFBRztJQUN6RixNQUFNLEVBQUV2dEIsRUFBRSxFQUFFNnpCLGFBQWEsRUFBRUYscUJBQXFCLEVBQUV2SCxnQkFBZ0IsRUFBRWlJLFlBQVksRUFBRVUsYUFBYSxFQUFFM0Isa0JBQWtCLEVBQUVDLHVCQUF1QixFQUFFUixNQUFNLEVBQUVzQyxtQkFBbUIsRUFBRVYsWUFBWSxFQUFHLEdBQUcvQjtJQUM3TCxNQUFNLENBQUM4RyxnQkFBZ0JDLGtCQUFrQixHQUFHanBDLE1BQU1zVCxRQUFRLENBQUMsQ0FBQztJQUM1RCxJQUFJNDFCLGNBQWNILFFBQVEsYUFBYTtJQUN2QyxJQUFJLENBQUMxRixpQkFDQVEsZ0JBQ0csQ0FBQ0EsYUFBYTtRQUFFNUcsT0FBTztZQUFFRjtRQUFVO1FBQUdxSztRQUFjL0ksUUFBUTlyQjtJQUFTLElBQUs7UUFDOUUyMkIsY0FBYztJQUNsQjtJQUNBbHBDLE1BQU13TixTQUFTLENBQUM7UUFDWixJQUFJbTNCLG1CQUFtQixDQUFDcHlCLFNBQVMsRUFBRTtnQkFHWHBHO1lBRnBCLE1BQU15NUIsZUFBZXJ6QjtZQUNyQixNQUFNc3pCLGVBQWVsQixtQkFBbUIsQ0FBQ3B5QixTQUFTO1lBQ2xELE1BQU0rckIsZUFBY255QiwwQkFBQUEsU0FDZjJGLGFBQWEsQ0FBQyxDQUFDLENBQUMsRUFBRXRDLEdBQUcsUUFBUSxFQUFFbzJCLGNBQWMsZUFEOUJ6NUIsOENBQUFBLHdCQUVkc08scUJBQXFCLEdBQUcvSCxLQUFLO1lBQ25DLElBQUksQ0FBQzRyQixhQUFhO2dCQUNkLE1BQU0sSUFBSS80QixNQUFNO1lBQ3BCO1lBQ0EwakMsa0JBQWtCO2dCQUNkajRCLFdBQVcsQ0FBQyxVQUFVLEVBQUUsQUFBQzRxQixDQUFBQSxxQkFBcUIsVUFBVSxDQUFDLElBQUksQ0FBQSxJQUN4RGlLLENBQUFBLGFBQWF0SixVQUFVLENBQUMsS0FBS3FKLGFBQWFySixVQUFVLENBQUMsRUFBQyxJQUN2RCtCLFlBQVksSUFBSSxFQUFFLEFBQUMxQyxDQUFBQSxxQkFBcUIsVUFBVSxDQUFDLElBQUksQ0FBQSxJQUN0RDFqQixDQUFBQSxPQUFPMHRCLFlBQVksQ0FBQyxFQUFFLElBQUkxdEIsT0FBTzJ0QixZQUFZLENBQUMsRUFBRSxDQUFBLElBQ2pEdkgsWUFBWSxHQUFHLENBQUM7Z0JBQ3BCcEYsWUFBWSxDQUFDLFVBQVUsRUFBRWlLLHNCQUFzQixFQUFFLENBQUM7Z0JBQ2xENXdCLFVBQVU7Z0JBQ1Y0b0IsUUFBUTtZQUNaO1FBQ0osT0FDSztZQUNEOE4sa0JBQWtCLENBQUM7UUFDdkI7SUFDSixHQUFHO1FBQUN0RTtLQUFvQjtJQUN4QixNQUFNd0UsV0FBVzlHLE1BQU0sQ0FBQ3RGLFVBQVU7SUFDbEMsT0FBUS93QixrQkFBa0IxSyxHQUFHLENBQUMsT0FBTztRQUFFa08sSUFBSSxHQUFHQSxHQUFHLE9BQU8sRUFBRXV0QixVQUFVLENBQUMsRUFBRXhxQixVQUFVO1FBQUUsY0FBY3dxQjtRQUFXN3FCLE9BQU87WUFDM0csR0FBRzgyQixjQUFjO1lBQ2pCLEdBQUlELFFBQ0U7Z0JBQUUsR0FBR3hILHlCQUF5QjtnQkFBRSxHQUFHcUIsa0JBQWtCO1lBQUMsSUFDdEQsQ0FBQyxDQUFDO1lBQ1IsR0FBSSxDQUFDbUcsU0FBU3hFLENBQUFBLDBCQUFBQSxvQ0FBQUEsY0FBZWh5QixRQUFRLE1BQUtBLFdBQ3BDO2dCQUFFLEdBQUdpdkIsOEJBQThCO2dCQUFFLEdBQUdxQix1QkFBdUI7WUFBQyxJQUNoRSxDQUFDLENBQUM7WUFDUm53QixPQUFPO1lBQ1BDLFFBQVE7WUFDUnkyQixRQUFRRjtZQUNSdlEsYUFBYTtRQUNqQjtRQUFHMFEsU0FBUyxJQUFNcEYseUJBQUFBLG1DQUFBQSxhQUFlO2dCQUFFbUQ7Z0JBQWNuSyxPQUFPO29CQUFFRjtnQkFBVTtnQkFBR3NCLFFBQVE5ckI7WUFBUztRQUFJNUksVUFBVXFDLGtCQUFrQjFLLEdBQUcsQ0FBQzZuQyxVQUFVLENBQUM7SUFBRztBQUNsSjtBQUVBLE1BQU1HLFNBQVN0cEMsTUFBTTB4QixJQUFJLENBQUMsU0FBUzRYLE9BQU8sRUFBRTMvQixRQUFRLEVBQUVxeUIsUUFBUSxFQUFFRyxhQUFhLEVBQUVwRSxNQUFNLEVBQUc7UUFFckVpRSxpQkFDSEE7SUFGWixNQUFNLEVBQUV4c0IsRUFBRSxFQUFFaTBCLGtCQUFrQixFQUFFN0gsZ0JBQWdCLEVBQUV1QyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFcUcsZUFBZSxFQUFFbEMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLGVBQWUsRUFBRUMsZ0JBQWdCLEVBQUVDLGVBQWUsRUFBRUcsdUJBQXVCLEVBQUVDLHdCQUF3QixFQUFFQyxrQkFBa0IsRUFBRUMsb0JBQW9CLEVBQUVDLFlBQVksRUFBRWEsZ0JBQWdCLEVBQUVDLGlCQUFpQixFQUFFSSxhQUFhLEVBQUVDLGtCQUFrQixFQUFFQyxjQUFjLEVBQUVTLG1CQUFtQixFQUFFQyxzQkFBc0IsRUFBRUUscUJBQXFCLEVBQUVjLFNBQVMsRUFBRWEsV0FBVyxFQUFHLEdBQUczRTtJQUN4ZCxNQUFNbkcsVUFBU0Msa0JBQUFBLFNBQVN4MkIsS0FBSyxDQUFDLHdCQUFmdzJCLHNDQUFBQSxlQUEyQixDQUFDLEVBQUU7SUFDN0MsTUFBTUYsT0FBTUUsbUJBQUFBLFNBQVN4MkIsS0FBSyxDQUFDLHFCQUFmdzJCLHVDQUFBQSxnQkFBd0IsQ0FBQyxFQUFFO1FBNkVwQnlJO0lBNUVuQixPQUFRejRCLGtCQUFrQnpLLElBQUksQ0FBQyxPQUFPO1FBQUVpTyxJQUFJLEdBQUdBLEdBQUcsUUFBUSxFQUFFd3NCLFVBQVU7UUFBRTlwQixPQUFPO1lBQ3ZFLEdBQUdxdUIsa0JBQWtCO1lBQ3JCLEdBQUdnQyxXQUFXO1lBQ2QsR0FBSXBHLGdCQUNFO2dCQUFFLEdBQUcwRSx1QkFBdUI7Z0JBQUUsR0FBRzZCLGdCQUFnQjtZQUFDLElBQ2xEO2dCQUFFLEdBQUcvQixzQkFBc0I7Z0JBQUUsR0FBRzhCLGVBQWU7WUFBQyxDQUFDO1lBQ3ZELEdBQUkxSyxTQUFTO2dCQUFFLEdBQUcrSSxzQkFBc0I7Z0JBQUUsR0FBRzZCLGVBQWU7WUFBQyxJQUFJLENBQUMsQ0FBQztRQUN2RTtRQUFHLGVBQWU1RztRQUFRLFlBQVlEO1FBQUssZUFBZUU7UUFBVXFOLFNBQVMsQ0FBQzVsQztZQUMxRSxJQUFJQSxFQUFFMmlCLE1BQU0sS0FBSyxHQUFHO29CQUVMcWU7Z0JBRFhMLDBCQUFBQSxvQ0FBQUEsY0FBZ0I7b0JBQ1puSCxPQUFPd0gsQ0FBQUEsNEJBQUFBLGVBQWUsQ0FBQ3pJLFNBQVMsY0FBekJ5SSx1Q0FBQUEsNEJBQTZCO29CQUNwQ3BHLFFBQVFyQztnQkFDWjtZQUNKO1FBQ0o7UUFBR3VOLFlBQVksQ0FBQzlsQztZQUNaLHNFQUFzRTtZQUN0RUEsRUFBRXVjLGNBQWM7Z0JBRUx5a0I7WUFEWEwsMEJBQUFBLG9DQUFBQSxjQUFnQjtnQkFDWm5ILE9BQU93SCxDQUFBQSw0QkFBQUEsZUFBZSxDQUFDekksU0FBUyxjQUF6QnlJLHVDQUFBQSw0QkFBNkI7Z0JBQ3BDcEcsUUFBUXJDO1lBQ1o7UUFDSjtRQUFHd04sZUFBZSxDQUFDL2xDO1lBQ2ZBLEVBQUV1YyxjQUFjO2dCQUVMeWtCO1lBRFhKLCtCQUFBQSx5Q0FBQUEsbUJBQXFCO2dCQUNqQnBILE9BQU93SCxDQUFBQSw0QkFBQUEsZUFBZSxDQUFDekksU0FBUyxjQUF6QnlJLHVDQUFBQSw0QkFBNkI7Z0JBQ3BDcEcsUUFBUXJDO1lBQ1o7UUFDSjtRQUFHeU4sYUFBYSxDQUFDaG1DO1lBQ2IsSUFBSUEsRUFBRTJpQixNQUFNLEtBQUssR0FBRztnQkFDaEJ5Z0I7WUFDSjtZQUNBLElBQUlwakMsRUFBRTJpQixNQUFNLEtBQUssS0FBS3FkLG9CQUFvQjtnQkFDdEN1Qix1QkFBdUJoSjtZQUMzQjtRQUNKO1FBQUcwTixXQUFXLENBQUNqbUM7WUFDWCxJQUFJQSxFQUFFMmlCLE1BQU0sS0FBSyxHQUFHO2dCQUNoQixJQUFJMmUscUJBQXFCO29CQUNyQmlCLFVBQVVoSyxVQUFVO3dCQUNoQnlLLFVBQVVoakMsRUFBRWdqQyxRQUFRO3dCQUNwQkMsU0FBU2pqQyxFQUFFaWpDLE9BQU87b0JBQ3RCO2dCQUNKO1lBQ0o7UUFDSjtRQUFHaUQsYUFBYSxDQUFDbG1DO1lBQ2IsOERBQThEO1lBQzlELElBQUlBLEVBQUVtbUMsT0FBTyxLQUFLLEtBQUs3RSxxQkFBcUI7Z0JBQ3hDRyxzQkFBc0JsSixVQUFVO29CQUM1QnlLLFVBQVVoakMsRUFBRWdqQyxRQUFRO29CQUNwQkMsU0FBU2pqQyxFQUFFaWpDLE9BQU87Z0JBQ3RCO1lBQ0o7Z0JBRVdqQztZQURYVCw4QkFBQUEsd0NBQUFBLGtCQUFvQjtnQkFDaEIvRyxPQUFPd0gsQ0FBQUEsNEJBQUFBLGVBQWUsQ0FBQ3pJLFNBQVMsY0FBekJ5SSx1Q0FBQUEsNEJBQTZCO2dCQUNwQ3BHLFFBQVFyQztZQUNaO1FBQ0o7UUFBRzZOLGNBQWM7Z0JBQ05wRjttQkFEWVYsNkJBQUFBLHVDQUFBQSxpQkFBbUI7Z0JBQ3RDOUcsT0FBT3dILENBQUFBLDRCQUFBQSxlQUFlLENBQUN6SSxTQUFTLGNBQXpCeUksdUNBQUFBLDRCQUE2QjtnQkFDcENwRyxRQUFRckM7WUFDWjs7UUFBSXJ5QixVQUFVO1lBQUN1NUIsZUFBZ0JsM0Isa0JBQWtCekssSUFBSSxDQUFDLFFBQVE7Z0JBQUUyUSxPQUFPaXFCLGdCQUN6RDtvQkFDRSxHQUFHK0UsK0JBQStCO29CQUNsQyxHQUFHNkIsd0JBQXdCO2dCQUMvQixJQUNFO29CQUNFLEdBQUcvQiw4QkFBOEI7b0JBQ2pDLEdBQUc4Qix1QkFBdUI7Z0JBQzlCO2dCQUFHbjVCLFVBQVU7b0JBQUNteUIsUUFDVEYsQ0FBQUEscUJBQXFCLFVBQ2hCLE1BQ0F3QyxlQUFlN3hCLFFBQVEsRUFBQyxLQUFPUCxrQkFBa0IxSyxHQUFHLENBQUMsUUFBUTt3QkFBRTRRLE9BQU87NEJBQUUsR0FBR2l2Qix5QkFBeUI7NEJBQUUsR0FBRzZCLGtCQUFrQjt3QkFBQzt3QkFBR3I1QixVQUFVb3lCO29CQUFPO29CQUFLQSxXQUMxSkgsQ0FBQUEscUJBQXFCLFVBQ2hCLE1BQ0FLLHlCQUF5QixHQUFHa0MsbUJBQW1CdkMsaUJBQWdCLEtBQU81dkIsa0JBQWtCMUssR0FBRyxDQUFDLFFBQVE7d0JBQUU0USxPQUFPOzRCQUMvRyxHQUFHb3ZCLDJCQUEyQjs0QkFDOUIsR0FBRzJCLG9CQUFvQjt3QkFDM0I7d0JBQUd0NUIsVUFBVW15QjtvQkFBSTtpQkFBSTtZQUFDLEtBQU07WUFBTXdJLENBQUFBLDJCQUFBQSxxQ0FBQUEsZUFBaUI7Z0JBQzNEckgsT0FBT3dILENBQUFBLDRCQUFBQSxlQUFlLENBQUN6SSxTQUFTLGNBQXpCeUksdUNBQUFBLDRCQUE2QjtnQkFDcENwRyxRQUFRckM7Z0JBQ1JyeUI7WUFDSixPQUFPcUMsa0JBQWtCMUssR0FBRyxDQUFDLE9BQU87Z0JBQUU0USxPQUFPO29CQUNyQ1EsT0FBTztvQkFDUEMsUUFBUTtvQkFDUixHQUFHNnZCLFlBQVksQ0FBQ3hHLFNBQVM7Z0JBQzdCO2dCQUFHcnlCLFVBQVVBO1lBQVM7U0FBSTtJQUFDO0FBQzNDO0FBRUEsTUFBTW1nQyxzQkFBc0IsQ0FBQ0MsU0FBU0M7SUFDbEMsT0FBTyxDQUFDLEVBQUVoNUIsU0FBUyxFQUFFO1FBQ2pCLE1BQU1pNUIsZUFBZSxPQUFPOTlCLGFBQWEsY0FDbkNBLFNBQVMrOUIsY0FBYyxDQUFDLEdBQUdILFFBQVEsTUFBTSxDQUFDLElBQzFDO1FBQ04sSUFBSSxDQUFDRSxjQUFjO1lBQ2YsT0FBT2o1QjtRQUNYO1FBQ0EsbUVBQW1FO1FBQ25FLE1BQU1tNUIsWUFBWUYsYUFBYXh2QixxQkFBcUI7UUFDcEQsTUFBTTJ2QixXQUFXSCxhQUFhbjRCLGFBQWEsQ0FBQztRQUM1QyxJQUFJLENBQUNzNEIsVUFBVTtZQUNYLE9BQU9wNUI7UUFDWDtRQUNBLE1BQU1zdEIsY0FBYzhMLFNBQVMzdkIscUJBQXFCLEdBQUcvSCxLQUFLO1FBQzFELE1BQU0yM0Isa0JBQWtCL0wsY0FBYztRQUN0QywwRUFBMEU7UUFDMUUsTUFBTTk0QixRQUFRd2tDLHNCQUFzQnhrQyxLQUFLLENBQUM7UUFDMUMsSUFBSSxDQUFDQSxPQUFPO1lBQ1IsT0FBT3dMO1FBQ1g7UUFDQSxNQUFNLEdBQUdzNUIsS0FBS3hPLElBQUksR0FBR3QyQjtRQUNyQix5Q0FBeUM7UUFDekMsTUFBTTZnQyxjQUFjNEQsYUFBYW40QixhQUFhLENBQUMsQ0FBQyxjQUFjLEVBQUV3NEIsSUFBSSxhQUFhLEVBQUV4TyxJQUFJLEVBQUUsQ0FBQztRQUMxRixJQUFJLENBQUN1SyxhQUFhO1lBQ2QsT0FBT3IxQjtRQUNYO1FBQ0EsTUFBTXU1QixrQkFBa0JsRSxZQUFZNXJCLHFCQUFxQjtRQUN6RCxNQUFNK3ZCLFNBQVNELGdCQUFnQjkzQixJQUFJLEdBQUc0M0Isa0JBQWtCRixVQUFVMTNCLElBQUk7UUFDdEUsTUFBTWc0QixTQUFTRixnQkFBZ0IvM0IsR0FBRyxHQUFHNjNCLGtCQUFrQkYsVUFBVTMzQixHQUFHO1FBQ3BFLHdGQUF3RjtRQUN4RixNQUFNazRCLE9BQU8sQ0FBQ0Y7UUFDZCxNQUFNRyxPQUFPUixVQUFVejNCLEtBQUssR0FBRzgzQjtRQUMvQixNQUFNSSxPQUFPLENBQUNIO1FBQ2QsTUFBTUksT0FBT1YsVUFBVXgzQixNQUFNLEdBQUc4M0I7UUFDaEMsTUFBTUssV0FBVzc1QixLQUFLMkcsR0FBRyxDQUFDM0csS0FBS3lHLEdBQUcsQ0FBQzFHLFVBQVU1TixDQUFDLEVBQUVzbkMsT0FBT0M7UUFDdkQsTUFBTUksV0FBVzk1QixLQUFLMkcsR0FBRyxDQUFDM0csS0FBS3lHLEdBQUcsQ0FBQzFHLFVBQVVKLENBQUMsRUFBRWc2QixPQUFPQztRQUN2RCxPQUFPO1lBQ0gsR0FBRzc1QixTQUFTO1lBQ1o1TixHQUFHMG5DO1lBQ0hsNkIsR0FBR202QjtRQUNQO0lBQ0o7QUFDSjtBQUVBLFNBQVNDO1FBRzhDQyxtQkFDRUE7SUFIckQsTUFBTSxFQUFFM0gsaUJBQWlCLEVBQUV6SCxLQUFLLEVBQUV5RyxVQUFVLEVBQUVuRSxpQkFBaUIsRUFBRXNHLGVBQWUsRUFBRUYsYUFBYSxFQUFFLzBCLEVBQUUsRUFBRyxHQUFHMHlCO0lBQ3pHLE1BQU0rSSxXQUFXanJDLE1BQU00TixNQUFNLENBQUM7SUFDOUIsTUFBTSxDQUFDc3dCLFlBQVlnTixjQUFjLEdBQUdsckMsTUFBTXNULFFBQVEsRUFBQzIzQixvQkFBQUEsU0FBU3A5QixPQUFPLGNBQWhCbzlCLHdDQUFBQSxrQkFBa0JwdUIsV0FBVztJQUNoRixNQUFNLENBQUMycUIsYUFBYTJELGVBQWUsR0FBR25yQyxNQUFNc1QsUUFBUSxFQUFDMjNCLHFCQUFBQSxTQUFTcDlCLE9BQU8sY0FBaEJvOUIseUNBQUFBLG1CQUFrQnJ1QixZQUFZO0lBQ25GLG9FQUFvRTtJQUNwRTVjLE1BQU13TixTQUFTLENBQUM7UUFDWixJQUFJeTlCLFNBQVNwOUIsT0FBTyxFQUFFO1lBQ2xCLE1BQU1vZCxpQkFBaUIsSUFBSUMsZUFBZTtvQkFDeEIrZixtQkFDQ0E7Z0JBRGZDLGVBQWNELG9CQUFBQSxTQUFTcDlCLE9BQU8sY0FBaEJvOUIsd0NBQUFBLGtCQUFrQnB1QixXQUFXO2dCQUMzQ3N1QixnQkFBZUYscUJBQUFBLFNBQVNwOUIsT0FBTyxjQUFoQm85Qix5Q0FBQUEsbUJBQWtCcnVCLFlBQVk7WUFDakQ7WUFDQXFPLGVBQWVhLE9BQU8sQ0FBQ21mLFNBQVNwOUIsT0FBTztZQUN2QyxPQUFPO2dCQUNIb2QsZUFBZUgsVUFBVTtZQUM3QjtRQUNKO0lBQ0osR0FBRztRQUFDbWdCLFNBQVNwOUIsT0FBTztLQUFDO0lBQ3JCLE9BQVE3QixrQkFBa0J6SyxJQUFJLENBQUN5SyxrQkFBa0IzSyxRQUFRLEVBQUU7UUFBRXNJLFVBQVU7WUFBQ3FDLGtCQUFrQnpLLElBQUksQ0FBQyxPQUFPO2dCQUFFaU8sSUFBSSxHQUFHQSxHQUFHLE1BQU0sQ0FBQztnQkFBRXRPLEtBQUsrcEM7Z0JBQVUvNEIsT0FBTztvQkFBRSxHQUFHbXVCLGtCQUFrQmxDLGtCQUFrQjtvQkFBRSxHQUFHbUUsVUFBVTtnQkFBQztnQkFBRzM0QixVQUFVO29CQUFDa3lCLE1BQU0xUyxHQUFHLENBQUMsQ0FBQzJTLE1BQVFBLElBQUkzUyxHQUFHLENBQUMsQ0FBQ2tWOzRCQUNoTyxNQUFNcEIsUUFBUXdILGVBQWUsQ0FBQ3BHLE9BQU9yQyxRQUFRLENBQUM7NEJBQzlDLE9BQVFod0Isa0JBQWtCMUssR0FBRyxDQUFDdW5DLFdBQVc7Z0NBQUU3TSxVQUFVcUMsT0FBT3JDLFFBQVE7Z0NBQUVyeUIsVUFBVSxDQUFDLEVBQUVvdUIsTUFBTSxFQUFFLEdBQU0vckIsa0JBQWtCMUssR0FBRyxDQUFDZ29DLFFBQVE7d0NBQUV2UixRQUFRQTt3Q0FBUSxHQUFHc0csTUFBTTt3Q0FBRTEwQixVQUFVc3pCLFFBQVNqeEIsa0JBQWtCMUssR0FBRyxDQUFDc25DLFdBQVc7NENBQUV4QixjQUFjOzRDQUFPNzBCLFVBQVU4ckIsT0FBT3JDLFFBQVE7NENBQUVlLFdBQVdFLE1BQU1GLFNBQVM7NENBQUVwekIsVUFBVXFDLGtCQUFrQjFLLEdBQUcsQ0FBQ3duQyxPQUFPO2dEQUFFLEdBQUc3TCxLQUFLO2dEQUFFMXFCLFVBQVU4ckIsT0FBT3JDLFFBQVE7NENBQUM7d0NBQUcsS0FBTTtvQ0FBSzs0QkFBSSxHQUFHcUMsT0FBT3JDLFFBQVE7d0JBQ25aO29CQUFLaHdCLGtCQUFrQjFLLEdBQUcsQ0FBQ2ltQyxRQUFRO3dCQUFFckosWUFBWUE7d0JBQVlzSixhQUFhQTtvQkFBWTtpQkFBRztZQUFDO1lBQUl4N0Isa0JBQWtCMUssR0FBRyxDQUFDeTVCLGFBQWE7Z0JBQUVDLGVBQWU7Z0JBQU05SixXQUFXO29CQUNuS21LO3VCQUNJaUksb0JBQ0UsRUFBRSxHQUNGO3dCQUFDd0csb0JBQW9CdDZCLElBQUkrMEIsQ0FBQUEsMEJBQUFBLG9DQUFBQSxjQUFlaHlCLFFBQVEsS0FBSTtxQkFBSTtpQkFDakU7Z0JBQUU1SSxVQUFVNDZCLGdCQUFpQnY0QixrQkFBa0IxSyxHQUFHLENBQUN3bkMsT0FBTztvQkFBRUMsT0FBTztvQkFBTXgyQixVQUFVZ3lCLGNBQWNoeUIsUUFBUTtvQkFBRXdxQixXQUFXd0gsY0FBY3hILFNBQVM7Z0JBQUMsS0FBTTtZQUFLO1NBQUc7SUFBQztBQUM5SztBQUVBLFNBQVNxTyxXQUFXLEVBQUVsMUIsT0FBTyxFQUFFO1FBQ0xnc0I7SUFBdEIsTUFBTSxFQUFFb0YsU0FBUyxFQUFFLEdBQUdwRixDQUFBQSx3QkFBQUEsb0NBQUFBLG1DQUFBQSx3QkFBMEI7UUFBRW9GLFdBQVc7SUFBTTtJQUNuRSxJQUFJQSxXQUFXO1FBQ1gsT0FBT3Q3QixrQkFBa0IxSyxHQUFHLENBQUMwcEMsT0FBTyxDQUFDO0lBQ3pDO0lBQ0EsT0FBUWgvQixrQkFBa0IxSyxHQUFHLENBQUM4Z0Msb0JBQW9CO1FBQUVsc0IsU0FBU0E7UUFBU3ZNLFVBQVVxQyxrQkFBa0IxSyxHQUFHLENBQUMwcEMsT0FBTyxDQUFDO0lBQUc7QUFDckg7QUFFQSxTQUFTSyxXQUFXLEVBQUV0TyxTQUFTLEVBQUU7SUFDN0IsT0FBUS93QixrQkFBa0IxSyxHQUFHLENBQUNzbkMsV0FBVztRQUFFeEIsY0FBYztRQUFNNzBCLFVBQVV3cUI7UUFBV0EsV0FBV0E7UUFBV3B6QixVQUFVcUMsa0JBQWtCMUssR0FBRyxDQUFDd25DLE9BQU87WUFBRTFCLGNBQWM7WUFBTXJLLFdBQVdBO1lBQVd4cUIsVUFBVXdxQjtRQUFVO0lBQUc7QUFDeE47QUFFQTM4QixRQUFRZ3JDLFVBQVUsR0FBR0E7QUFDckJockMsUUFBUWdpQyxrQkFBa0IsR0FBR0E7QUFDN0JoaUMsUUFBUWlyQyxVQUFVLEdBQUdBO0FBQ3JCanJDLFFBQVFrOEIsd0JBQXdCLEdBQUdBO0FBQ25DbDhCLFFBQVFvOEIsa0JBQWtCLEdBQUdBO0FBQzdCcDhCLFFBQVE2N0Isd0JBQXdCLEdBQUdBO0FBQ25DNzdCLFFBQVErZ0MseUJBQXlCLEdBQUdBO0FBQ3BDL2dDLFFBQVFxaEMsbUJBQW1CLEdBQUdBO0FBQzlCcmhDLFFBQVFpZ0MsaUJBQWlCLEdBQUdBO0FBQzVCamdDLFFBQVE0Z0MsOEJBQThCLEdBQUdBO0FBQ3pDNWdDLFFBQVF1Z0Msc0JBQXNCLEdBQUdBO0FBQ2pDdmdDLFFBQVFvaEMsOEJBQThCLEdBQUdBO0FBQ3pDcGhDLFFBQVFtaEMseUJBQXlCLEdBQUdBO0FBQ3BDbmhDLFFBQVEwZ0Msc0JBQXNCLEdBQUdBO0FBQ2pDMWdDLFFBQVE4Z0MsK0JBQStCLEdBQUdBO0FBQzFDOWdDLFFBQVF5Z0MsdUJBQXVCLEdBQUdBO0FBQ2xDemdDLFFBQVFraEMsMkJBQTJCLEdBQUdBO0FBQ3RDbGhDLFFBQVFtK0IsYUFBYSxHQUFHQTtBQUN4Qm4rQixRQUFRbWdDLGtCQUFrQixHQUFHQTtBQUM3Qm5nQyxRQUFRcThCLHlCQUF5QixHQUFHQTtBQUNwQ3I4QixRQUFRcTdCLGFBQWEsR0FBR0E7QUFDeEJyN0IsUUFBUWc5QixrQkFBa0IsR0FBR0E7QUFDN0JoOUIsUUFBUTY5QixpQkFBaUIsR0FBR0E7QUFDNUI3OUIsUUFBUTg3QixrQkFBa0IsR0FBR0E7QUFDN0I5N0IsUUFBUThoQyxvQkFBb0IsR0FBR0EifQ==