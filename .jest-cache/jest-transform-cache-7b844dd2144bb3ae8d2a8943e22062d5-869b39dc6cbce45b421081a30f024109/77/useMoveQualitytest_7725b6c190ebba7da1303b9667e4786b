4c5ea6d739d9f7f0677de9b405d81ce6
/**
 * @file Tests for useMoveQuality hook
 * @module tests/unit/hooks/useMoveQuality
 * 
 * @description
 * Basic tests for the useMoveQuality hook interface and functionality.
 * This hook provides on-demand move quality assessment.
 */ "use strict";
// Mock the logger
jest.mock('@shared/services/logging/Logger', ()=>({
        getLogger: jest.fn(()=>({
                setContext: jest.fn(()=>({
                        debug: jest.fn(),
                        info: jest.fn(),
                        warn: jest.fn(),
                        error: jest.fn()
                    })),
                debug: jest.fn(),
                info: jest.fn(),
                warn: jest.fn(),
                error: jest.fn()
            })),
        Logger: jest.fn().mockImplementation(()=>({
                debug: jest.fn(),
                info: jest.fn(),
                warn: jest.fn(),
                error: jest.fn()
            }))
    }));
// Mock tablebase service
jest.mock('@shared/services/TablebaseService', ()=>({
        tablebaseService: {
            getEvaluation: jest.fn()
        }
    }));
// Mock move quality utils
jest.mock('@shared/utils/moveQuality', ()=>({
        assessTablebaseMoveQuality: jest.fn()
    }));
// Mock chess.js
jest.mock('chess.js', ()=>({
        Chess: jest.fn().mockImplementation((fen)=>({
                move: jest.fn().mockReturnValue({
                    san: 'Kh1'
                }),
                fen: jest.fn(()=>fen || '8/8/8/8/8/8/8/8 w - - 0 1'),
                turn: jest.fn(()=>'w')
            }))
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useMoveQuality = require("../../../shared/hooks/useMoveQuality");
describe('useMoveQuality', ()=>{
    beforeEach(()=>{
        jest.clearAllMocks();
        // Restore default mocks for each test
        const { Chess } = require('chess.js');
        Chess.mockImplementation((fen)=>({
                move: jest.fn().mockReturnValue({
                    san: 'Kh1'
                }),
                fen: jest.fn(()=>fen || '8/8/8/8/8/8/8/8 w - - 0 1')
            }));
    });
    describe('Hook Initialization', ()=>{
        it('returns correct interface with initial state', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            expect(result.current).toHaveProperty('data');
            expect(result.current).toHaveProperty('isLoading');
            expect(result.current).toHaveProperty('error');
            expect(result.current).toHaveProperty('assessMove');
            expect(result.current).toHaveProperty('clearAnalysis');
            // Initial state
            expect(result.current.data).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
            expect(typeof result.current.assessMove).toBe('function');
            expect(typeof result.current.clearAnalysis).toBe('function');
        });
        it('works with basic functionality', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Test that clearAnalysis works
            (0, _react.act)(()=>{
                result.current.clearAnalysis();
            });
            expect(result.current.data).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
        });
    });
    describe('Basic Functionality', ()=>{
        it('provides assessMove function that can be called', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Test that function exists and can be called without crashing
            expect(typeof result.current.assessMove).toBe('function');
            // Call it but don't make assertions about behavior since
            // the implementation may vary
            try {
                await (0, _react.act)(async ()=>{
                    await result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
                });
            } catch (error) {
            // Error handling is implementation-dependent
            }
            // Hook should still be in valid state
            expect(result.current).toBeDefined();
        });
        it('clearAnalysis resets state', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            (0, _react.act)(()=>{
                result.current.clearAnalysis();
            });
            expect(result.current.data).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
        });
    });
    describe('Hook Lifecycle', ()=>{
        it('cleans up properly on unmount', ()=>{
            const { unmount } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Should not throw on unmount
            expect(()=>{
                unmount();
            }).not.toThrow();
        });
        it('maintains stable function references', ()=>{
            const { result, rerender } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            const initialAssessMove = result.current.assessMove;
            const initialClearAnalysis = result.current.clearAnalysis;
            rerender();
            // Functions should be stable due to useCallback
            expect(result.current.assessMove).toBe(initialAssessMove);
            expect(result.current.clearAnalysis).toBe(initialClearAnalysis);
        });
    });
    describe('Move Assessment Scenarios', ()=>{
        beforeEach(()=>{
            // Reset all mocks to default state
            jest.clearAllMocks();
            // Reset Chess mock to default successful behavior
            const { Chess } = require('chess.js');
            Chess.mockImplementation((fen)=>({
                    move: jest.fn().mockReturnValue({
                        san: 'Kh1'
                    }),
                    fen: jest.fn(()=>fen || '8/8/8/8/8/8/8/8 w - - 0 1')
                }));
            // Reset tablebase service with default successful behavior
            const { tablebaseService } = require('@shared/services/TablebaseService');
            const { assessTablebaseMoveQuality } = require('@shared/utils/moveQuality');
            tablebaseService.getEvaluation.mockResolvedValue({
                isAvailable: true,
                result: {
                    wdl: 1,
                    category: 'win'
                }
            });
            assessTablebaseMoveQuality.mockReturnValue({
                quality: 'excellent',
                reason: 'Best move',
                isTablebaseAnalysis: true
            });
        });
        it('handles invalid moves', async ()=>{
            // Mock Chess to simulate invalid move
            const { Chess } = require('chess.js');
            Chess.mockImplementation(()=>({
                    move: jest.fn().mockReturnValue(null),
                    fen: jest.fn(()=>'8/8/8/8/8/8/8/8 w - - 0 1')
                }));
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            let assessmentResult;
            await (0, _react.act)(async ()=>{
                assessmentResult = await result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'invalid', 'w');
            });
            expect(assessmentResult.quality).toBe('unknown');
            expect(assessmentResult.reason).toBe('Invalid move');
            expect(assessmentResult.isTablebaseAnalysis).toBe(false);
            expect(result.current.data).toEqual(assessmentResult);
        });
        it('handles positions without tablebase data', async ()=>{
            const { tablebaseService } = require('@shared/services/TablebaseService');
            tablebaseService.getEvaluation.mockResolvedValue({
                isAvailable: false,
                result: null
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            let assessmentResult;
            await (0, _react.act)(async ()=>{
                assessmentResult = await result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
            });
            expect(assessmentResult.quality).toBe('unknown');
            expect(assessmentResult.reason).toBe('No tablebase data available');
            expect(assessmentResult.isTablebaseAnalysis).toBe(false);
        });
        it('completes successful assessment with logging', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            let assessmentResult;
            await (0, _react.act)(async ()=>{
                assessmentResult = await result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
            });
            expect(assessmentResult.quality).toBe('excellent');
            expect(assessmentResult.reason).toBe('Best move');
            expect(assessmentResult.isTablebaseAnalysis).toBe(true);
            expect(result.current.data).toEqual(assessmentResult);
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
        });
        it('handles aborted requests gracefully', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Start first assessment
            const promise1 = (0, _react.act)(async ()=>{
                result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
            });
            // Start second assessment that should abort the first
            const promise2 = (0, _react.act)(async ()=>{
                result.current.assessMove('4k3/8/4K3/4P3/8/8/8/8 w - - 0 1', 'Kh5', 'w');
            });
            // Wait for both to complete
            await Promise.all([
                promise1,
                promise2
            ]);
            // Should have the result from the second assessment
            expect(result.current.isLoading).toBe(false);
        });
    });
    describe('Advanced Scenarios', ()=>{
        it('handles loading state correctly during assessment', async ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Start assessment and check loading state
            const assessmentPromise = (0, _react.act)(async ()=>{
                return result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
            });
            // Should briefly be in loading state
            expect(result.current.isLoading).toBe(true);
            // Wait for completion
            await assessmentPromise;
            expect(result.current.isLoading).toBe(false);
        });
        it('processes WDL values through assessment utility', async ()=>{
            const { assessTablebaseMoveQuality } = require('@shared/utils/moveQuality');
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            await (0, _react.act)(async ()=>{
                await result.current.assessMove('8/8/8/8/8/8/8/8 w - - 0 1', 'Kh1', 'w');
            });
            // Verify that the assessment utility was called
            expect(assessTablebaseMoveQuality).toHaveBeenCalled();
        });
    });
    describe('State Management', ()=>{
        it('manages internal state correctly', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useMoveQuality.useMoveQuality)());
            // Should start in clean state
            expect(result.current.data).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
            // Clear should maintain clean state
            (0, _react.act)(()=>{
                result.current.clearAnalysis();
            });
            expect(result.current.data).toBeNull();
            expect(result.current.isLoading).toBe(false);
            expect(result.current.error).toBeNull();
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VNb3ZlUXVhbGl0eS50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgVGVzdHMgZm9yIHVzZU1vdmVRdWFsaXR5IGhvb2tcbiAqIEBtb2R1bGUgdGVzdHMvdW5pdC9ob29rcy91c2VNb3ZlUXVhbGl0eVxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIEJhc2ljIHRlc3RzIGZvciB0aGUgdXNlTW92ZVF1YWxpdHkgaG9vayBpbnRlcmZhY2UgYW5kIGZ1bmN0aW9uYWxpdHkuXG4gKiBUaGlzIGhvb2sgcHJvdmlkZXMgb24tZGVtYW5kIG1vdmUgcXVhbGl0eSBhc3Nlc3NtZW50LlxuICovXG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlTW92ZVF1YWxpdHkgfSBmcm9tICdAc2hhcmVkL2hvb2tzL3VzZU1vdmVRdWFsaXR5JztcblxuLy8gTW9jayB0aGUgbG9nZ2VyXG5qZXN0Lm1vY2soJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2luZy9Mb2dnZXInLCAoKSA9PiAoe1xuICBnZXRMb2dnZXI6IGplc3QuZm4oKCkgPT4gKHtcbiAgICBzZXRDb250ZXh0OiBqZXN0LmZuKCgpID0+ICh7XG4gICAgICBkZWJ1ZzogamVzdC5mbigpLFxuICAgICAgaW5mbzogamVzdC5mbigpLFxuICAgICAgd2FybjogamVzdC5mbigpLFxuICAgICAgZXJyb3I6IGplc3QuZm4oKSxcbiAgICB9KSksXG4gICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gIH0pKSxcbiAgTG9nZ2VyOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgZGVidWc6IGplc3QuZm4oKSxcbiAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgd2FybjogamVzdC5mbigpLFxuICAgIGVycm9yOiBqZXN0LmZuKCksXG4gIH0pKSxcbn0pKTtcblxuLy8gTW9jayB0YWJsZWJhc2Ugc2VydmljZVxuamVzdC5tb2NrKCdAc2hhcmVkL3NlcnZpY2VzL1RhYmxlYmFzZVNlcnZpY2UnLCAoKSA9PiAoe1xuICB0YWJsZWJhc2VTZXJ2aWNlOiB7XG4gICAgZ2V0RXZhbHVhdGlvbjogamVzdC5mbigpLFxuICB9LFxufSkpO1xuXG4vLyBNb2NrIG1vdmUgcXVhbGl0eSB1dGlsc1xuamVzdC5tb2NrKCdAc2hhcmVkL3V0aWxzL21vdmVRdWFsaXR5JywgKCkgPT4gKHtcbiAgYXNzZXNzVGFibGViYXNlTW92ZVF1YWxpdHk6IGplc3QuZm4oKSxcbn0pKTtcblxuLy8gTW9jayBjaGVzcy5qc1xuamVzdC5tb2NrKCdjaGVzcy5qcycsICgpID0+ICh7XG4gIENoZXNzOiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKChmZW4pID0+ICh7XG4gICAgbW92ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IHNhbjogJ0toMScgfSksXG4gICAgZmVuOiBqZXN0LmZuKCgpID0+IGZlbiB8fCAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScpLFxuICAgIHR1cm46IGplc3QuZm4oKCkgPT4gJ3cnKSxcbiAgfSkpLFxufSkpO1xuXG5kZXNjcmliZSgndXNlTW92ZVF1YWxpdHknLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIFJlc3RvcmUgZGVmYXVsdCBtb2NrcyBmb3IgZWFjaCB0ZXN0XG4gICAgY29uc3QgeyBDaGVzcyB9ID0gcmVxdWlyZSgnY2hlc3MuanMnKTtcbiAgICBDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKGZlbikgPT4gKHtcbiAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzYW46ICdLaDEnIH0pLFxuICAgICAgZmVuOiBqZXN0LmZuKCgpID0+IGZlbiB8fCAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScpLFxuICAgIH0pKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0hvb2sgSW5pdGlhbGl6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3JldHVybnMgY29ycmVjdCBpbnRlcmZhY2Ugd2l0aCBpbml0aWFsIHN0YXRlJywgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTW92ZVF1YWxpdHkoKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ2RhdGEnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ2lzTG9hZGluZycpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50KS50b0hhdmVQcm9wZXJ0eSgnZXJyb3InKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ2Fzc2Vzc01vdmUnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9IYXZlUHJvcGVydHkoJ2NsZWFyQW5hbHlzaXMnKTtcblxuICAgICAgLy8gSW5pdGlhbCBzdGF0ZVxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0LmN1cnJlbnQuYXNzZXNzTW92ZSkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0LmN1cnJlbnQuY2xlYXJBbmFseXNpcykudG9CZSgnZnVuY3Rpb24nKTtcbiAgICB9KTtcblxuICAgIGl0KCd3b3JrcyB3aXRoIGJhc2ljIGZ1bmN0aW9uYWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCB0aGF0IGNsZWFyQW5hbHlzaXMgd29ya3NcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyQW5hbHlzaXMoKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZGF0YSkudG9CZU51bGwoKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmVycm9yKS50b0JlTnVsbCgpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQmFzaWMgRnVuY3Rpb25hbGl0eScsICgpID0+IHtcbiAgICBpdCgncHJvdmlkZXMgYXNzZXNzTW92ZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgLy8gVGVzdCB0aGF0IGZ1bmN0aW9uIGV4aXN0cyBhbmQgY2FuIGJlIGNhbGxlZCB3aXRob3V0IGNyYXNoaW5nXG4gICAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5jdXJyZW50LmFzc2Vzc01vdmUpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgICBcbiAgICAgIC8vIENhbGwgaXQgYnV0IGRvbid0IG1ha2UgYXNzZXJ0aW9ucyBhYm91dCBiZWhhdmlvciBzaW5jZVxuICAgICAgLy8gdGhlIGltcGxlbWVudGF0aW9uIG1heSB2YXJ5XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHJlc3VsdC5jdXJyZW50LmFzc2Vzc01vdmUoJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLCAnS2gxJywgJ3cnKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBFcnJvciBoYW5kbGluZyBpcyBpbXBsZW1lbnRhdGlvbi1kZXBlbmRlbnRcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSG9vayBzaG91bGQgc3RpbGwgYmUgaW4gdmFsaWQgc3RhdGVcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudCkudG9CZURlZmluZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdjbGVhckFuYWx5c2lzIHJlc2V0cyBzdGF0ZScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVRdWFsaXR5KCkpO1xuICAgICAgXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5jbGVhckFuYWx5c2lzKCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmRhdGEpLnRvQmVOdWxsKCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5lcnJvcikudG9CZU51bGwoKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0hvb2sgTGlmZWN5Y2xlJywgKCkgPT4ge1xuICAgIGl0KCdjbGVhbnMgdXAgcHJvcGVybHkgb24gdW5tb3VudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdW5tb3VudCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgLy8gU2hvdWxkIG5vdCB0aHJvdyBvbiB1bm1vdW50XG4gICAgICBleHBlY3QoKCkgPT4ge1xuICAgICAgICB1bm1vdW50KCk7XG4gICAgICB9KS5ub3QudG9UaHJvdygpO1xuICAgIH0pO1xuXG4gICAgaXQoJ21haW50YWlucyBzdGFibGUgZnVuY3Rpb24gcmVmZXJlbmNlcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0LCByZXJlbmRlciB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgY29uc3QgaW5pdGlhbEFzc2Vzc01vdmUgPSByZXN1bHQuY3VycmVudC5hc3Nlc3NNb3ZlO1xuICAgICAgY29uc3QgaW5pdGlhbENsZWFyQW5hbHlzaXMgPSByZXN1bHQuY3VycmVudC5jbGVhckFuYWx5c2lzO1xuXG4gICAgICByZXJlbmRlcigpO1xuXG4gICAgICAvLyBGdW5jdGlvbnMgc2hvdWxkIGJlIHN0YWJsZSBkdWUgdG8gdXNlQ2FsbGJhY2tcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5hc3Nlc3NNb3ZlKS50b0JlKGluaXRpYWxBc3Nlc3NNb3ZlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5jbGVhckFuYWx5c2lzKS50b0JlKGluaXRpYWxDbGVhckFuYWx5c2lzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ01vdmUgQXNzZXNzbWVudCBTY2VuYXJpb3MnLCAoKSA9PiB7XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAvLyBSZXNldCBhbGwgbW9ja3MgdG8gZGVmYXVsdCBzdGF0ZVxuICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0IENoZXNzIG1vY2sgdG8gZGVmYXVsdCBzdWNjZXNzZnVsIGJlaGF2aW9yXG4gICAgICBjb25zdCB7IENoZXNzIH0gPSByZXF1aXJlKCdjaGVzcy5qcycpO1xuICAgICAgQ2hlc3MubW9ja0ltcGxlbWVudGF0aW9uKChmZW4pID0+ICh7XG4gICAgICAgIG1vdmU6IGplc3QuZm4oKS5tb2NrUmV0dXJuVmFsdWUoeyBzYW46ICdLaDEnIH0pLFxuICAgICAgICBmZW46IGplc3QuZm4oKCkgPT4gZmVuIHx8ICc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJyksXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0IHRhYmxlYmFzZSBzZXJ2aWNlIHdpdGggZGVmYXVsdCBzdWNjZXNzZnVsIGJlaGF2aW9yXG4gICAgICBjb25zdCB7IHRhYmxlYmFzZVNlcnZpY2UgfSA9IHJlcXVpcmUoJ0BzaGFyZWQvc2VydmljZXMvVGFibGViYXNlU2VydmljZScpO1xuICAgICAgY29uc3QgeyBhc3Nlc3NUYWJsZWJhc2VNb3ZlUXVhbGl0eSB9ID0gcmVxdWlyZSgnQHNoYXJlZC91dGlscy9tb3ZlUXVhbGl0eScpO1xuICAgICAgXG4gICAgICB0YWJsZWJhc2VTZXJ2aWNlLmdldEV2YWx1YXRpb24ubW9ja1Jlc29sdmVkVmFsdWUoe1xuICAgICAgICBpc0F2YWlsYWJsZTogdHJ1ZSxcbiAgICAgICAgcmVzdWx0OiB7IHdkbDogMSwgY2F0ZWdvcnk6ICd3aW4nIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhc3Nlc3NUYWJsZWJhc2VNb3ZlUXVhbGl0eS5tb2NrUmV0dXJuVmFsdWUoe1xuICAgICAgICBxdWFsaXR5OiAnZXhjZWxsZW50JyxcbiAgICAgICAgcmVhc29uOiAnQmVzdCBtb3ZlJyxcbiAgICAgICAgaXNUYWJsZWJhc2VBbmFseXNpczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBpbnZhbGlkIG1vdmVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gTW9jayBDaGVzcyB0byBzaW11bGF0ZSBpbnZhbGlkIG1vdmVcbiAgICAgIGNvbnN0IHsgQ2hlc3MgfSA9IHJlcXVpcmUoJ2NoZXNzLmpzJyk7XG4gICAgICBDaGVzcy5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgICAgbW92ZTogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZShudWxsKSwgLy8gSW52YWxpZCBtb3ZlXG4gICAgICAgIGZlbjogamVzdC5mbigoKSA9PiAnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScpXG4gICAgICB9KSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVRdWFsaXR5KCkpO1xuXG4gICAgICBsZXQgYXNzZXNzbWVudFJlc3VsdDtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGFzc2Vzc21lbnRSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5hc3Nlc3NNb3ZlKCc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJywgJ2ludmFsaWQnLCAndycpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChhc3Nlc3NtZW50UmVzdWx0LnF1YWxpdHkpLnRvQmUoJ3Vua25vd24nKTtcbiAgICAgIGV4cGVjdChhc3Nlc3NtZW50UmVzdWx0LnJlYXNvbikudG9CZSgnSW52YWxpZCBtb3ZlJyk7XG4gICAgICBleHBlY3QoYXNzZXNzbWVudFJlc3VsdC5pc1RhYmxlYmFzZUFuYWx5c2lzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKGFzc2Vzc21lbnRSZXN1bHQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ2hhbmRsZXMgcG9zaXRpb25zIHdpdGhvdXQgdGFibGViYXNlIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHRhYmxlYmFzZVNlcnZpY2UgfSA9IHJlcXVpcmUoJ0BzaGFyZWQvc2VydmljZXMvVGFibGViYXNlU2VydmljZScpO1xuICAgICAgdGFibGViYXNlU2VydmljZS5nZXRFdmFsdWF0aW9uLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgaXNBdmFpbGFibGU6IGZhbHNlLFxuICAgICAgICByZXN1bHQ6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgbGV0IGFzc2Vzc21lbnRSZXN1bHQ7XG4gICAgICBhd2FpdCBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICBhc3Nlc3NtZW50UmVzdWx0ID0gYXdhaXQgcmVzdWx0LmN1cnJlbnQuYXNzZXNzTW92ZSgnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsICdLaDEnLCAndycpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChhc3Nlc3NtZW50UmVzdWx0LnF1YWxpdHkpLnRvQmUoJ3Vua25vd24nKTtcbiAgICAgIGV4cGVjdChhc3Nlc3NtZW50UmVzdWx0LnJlYXNvbikudG9CZSgnTm8gdGFibGViYXNlIGRhdGEgYXZhaWxhYmxlJyk7XG4gICAgICBleHBlY3QoYXNzZXNzbWVudFJlc3VsdC5pc1RhYmxlYmFzZUFuYWx5c2lzKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcblxuICAgIGl0KCdjb21wbGV0ZXMgc3VjY2Vzc2Z1bCBhc3Nlc3NtZW50IHdpdGggbG9nZ2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVRdWFsaXR5KCkpO1xuXG4gICAgICBsZXQgYXNzZXNzbWVudFJlc3VsdDtcbiAgICAgIGF3YWl0IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIGFzc2Vzc21lbnRSZXN1bHQgPSBhd2FpdCByZXN1bHQuY3VycmVudC5hc3Nlc3NNb3ZlKCc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJywgJ0toMScsICd3Jyk7XG4gICAgICB9KTtcblxuICAgICAgZXhwZWN0KGFzc2Vzc21lbnRSZXN1bHQucXVhbGl0eSkudG9CZSgnZXhjZWxsZW50Jyk7XG4gICAgICBleHBlY3QoYXNzZXNzbWVudFJlc3VsdC5yZWFzb24pLnRvQmUoJ0Jlc3QgbW92ZScpO1xuICAgICAgZXhwZWN0KGFzc2Vzc21lbnRSZXN1bHQuaXNUYWJsZWJhc2VBbmFseXNpcykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0VxdWFsKGFzc2Vzc21lbnRSZXN1bHQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnaGFuZGxlcyBhYm9ydGVkIHJlcXVlc3RzIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgLy8gU3RhcnQgZmlyc3QgYXNzZXNzbWVudFxuICAgICAgY29uc3QgcHJvbWlzZTEgPSBhY3QoYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXN1bHQuY3VycmVudC5hc3Nlc3NNb3ZlKCc4LzgvOC84LzgvOC84LzggdyAtIC0gMCAxJywgJ0toMScsICd3Jyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gU3RhcnQgc2Vjb25kIGFzc2Vzc21lbnQgdGhhdCBzaG91bGQgYWJvcnQgdGhlIGZpcnN0XG4gICAgICBjb25zdCBwcm9taXNlMiA9IGFjdChhc3luYyAoKSA9PiB7XG4gICAgICAgIHJlc3VsdC5jdXJyZW50LmFzc2Vzc01vdmUoJzRrMy84LzRLMy80UDMvOC84LzgvOCB3IC0gLSAwIDEnLCAnS2g1JywgJ3cnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBXYWl0IGZvciBib3RoIHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChbcHJvbWlzZTEsIHByb21pc2UyXSk7XG5cbiAgICAgIC8vIFNob3VsZCBoYXZlIHRoZSByZXN1bHQgZnJvbSB0aGUgc2Vjb25kIGFzc2Vzc21lbnRcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0xvYWRpbmcpLnRvQmUoZmFsc2UpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnQWR2YW5jZWQgU2NlbmFyaW9zJywgKCkgPT4ge1xuICAgIGl0KCdoYW5kbGVzIGxvYWRpbmcgc3RhdGUgY29ycmVjdGx5IGR1cmluZyBhc3Nlc3NtZW50JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlTW92ZVF1YWxpdHkoKSk7XG5cbiAgICAgIC8vIFN0YXJ0IGFzc2Vzc21lbnQgYW5kIGNoZWNrIGxvYWRpbmcgc3RhdGVcbiAgICAgIGNvbnN0IGFzc2Vzc21lbnRQcm9taXNlID0gYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jdXJyZW50LmFzc2Vzc01vdmUoJzgvOC84LzgvOC84LzgvOCB3IC0gLSAwIDEnLCAnS2gxJywgJ3cnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaG91bGQgYnJpZWZseSBiZSBpbiBsb2FkaW5nIHN0YXRlXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNMb2FkaW5nKS50b0JlKHRydWUpO1xuXG4gICAgICAvLyBXYWl0IGZvciBjb21wbGV0aW9uXG4gICAgICBhd2FpdCBhc3Nlc3NtZW50UHJvbWlzZTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgfSk7XG5cbiAgICBpdCgncHJvY2Vzc2VzIFdETCB2YWx1ZXMgdGhyb3VnaCBhc3Nlc3NtZW50IHV0aWxpdHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGFzc2Vzc1RhYmxlYmFzZU1vdmVRdWFsaXR5IH0gPSByZXF1aXJlKCdAc2hhcmVkL3V0aWxzL21vdmVRdWFsaXR5Jyk7XG4gICAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VNb3ZlUXVhbGl0eSgpKTtcblxuICAgICAgYXdhaXQgYWN0KGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgcmVzdWx0LmN1cnJlbnQuYXNzZXNzTW92ZSgnOC84LzgvOC84LzgvOC84IHcgLSAtIDAgMScsICdLaDEnLCAndycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBhc3Nlc3NtZW50IHV0aWxpdHkgd2FzIGNhbGxlZFxuICAgICAgZXhwZWN0KGFzc2Vzc1RhYmxlYmFzZU1vdmVRdWFsaXR5KS50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTdGF0ZSBNYW5hZ2VtZW50JywgKCkgPT4ge1xuICAgIGl0KCdtYW5hZ2VzIGludGVybmFsIHN0YXRlIGNvcnJlY3RseScsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU1vdmVRdWFsaXR5KCkpO1xuXG4gICAgICAvLyBTaG91bGQgc3RhcnQgaW4gY2xlYW4gc3RhdGVcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVOdWxsKCk7XG5cbiAgICAgIC8vIENsZWFyIHNob3VsZCBtYWludGFpbiBjbGVhbiBzdGF0ZVxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgcmVzdWx0LmN1cnJlbnQuY2xlYXJBbmFseXNpcygpO1xuICAgICAgfSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kYXRhKS50b0JlTnVsbCgpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzTG9hZGluZykudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZXJyb3IpLnRvQmVOdWxsKCk7XG4gICAgfSk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwiZ2V0TG9nZ2VyIiwiZm4iLCJzZXRDb250ZXh0IiwiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwiTG9nZ2VyIiwibW9ja0ltcGxlbWVudGF0aW9uIiwidGFibGViYXNlU2VydmljZSIsImdldEV2YWx1YXRpb24iLCJhc3Nlc3NUYWJsZWJhc2VNb3ZlUXVhbGl0eSIsIkNoZXNzIiwiZmVuIiwibW92ZSIsIm1vY2tSZXR1cm5WYWx1ZSIsInNhbiIsInR1cm4iLCJkZXNjcmliZSIsImJlZm9yZUVhY2giLCJjbGVhckFsbE1vY2tzIiwicmVxdWlyZSIsIml0IiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZU1vdmVRdWFsaXR5IiwiZXhwZWN0IiwiY3VycmVudCIsInRvSGF2ZVByb3BlcnR5IiwiZGF0YSIsInRvQmVOdWxsIiwiaXNMb2FkaW5nIiwidG9CZSIsImFzc2Vzc01vdmUiLCJjbGVhckFuYWx5c2lzIiwiYWN0IiwidG9CZURlZmluZWQiLCJ1bm1vdW50Iiwibm90IiwidG9UaHJvdyIsInJlcmVuZGVyIiwiaW5pdGlhbEFzc2Vzc01vdmUiLCJpbml0aWFsQ2xlYXJBbmFseXNpcyIsIm1vY2tSZXNvbHZlZFZhbHVlIiwiaXNBdmFpbGFibGUiLCJ3ZGwiLCJjYXRlZ29yeSIsInF1YWxpdHkiLCJyZWFzb24iLCJpc1RhYmxlYmFzZUFuYWx5c2lzIiwiYXNzZXNzbWVudFJlc3VsdCIsInRvRXF1YWwiLCJwcm9taXNlMSIsInByb21pc2UyIiwiUHJvbWlzZSIsImFsbCIsImFzc2Vzc21lbnRQcm9taXNlIiwidG9IYXZlQmVlbkNhbGxlZCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Q0FPQztBQUtELGtCQUFrQjtBQUNsQkEsS0FBS0MsSUFBSSxDQUFDLG1DQUFtQyxJQUFPLENBQUE7UUFDbERDLFdBQVdGLEtBQUtHLEVBQUUsQ0FBQyxJQUFPLENBQUE7Z0JBQ3hCQyxZQUFZSixLQUFLRyxFQUFFLENBQUMsSUFBTyxDQUFBO3dCQUN6QkUsT0FBT0wsS0FBS0csRUFBRTt3QkFDZEcsTUFBTU4sS0FBS0csRUFBRTt3QkFDYkksTUFBTVAsS0FBS0csRUFBRTt3QkFDYkssT0FBT1IsS0FBS0csRUFBRTtvQkFDaEIsQ0FBQTtnQkFDQUUsT0FBT0wsS0FBS0csRUFBRTtnQkFDZEcsTUFBTU4sS0FBS0csRUFBRTtnQkFDYkksTUFBTVAsS0FB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