652a4521b35094636f46f92e4a01f30c
/**
 * @file Opponent turn handler module
 * @module store/orchestrators/handlePlayerMove/OpponentTurnHandler
 *
 * @description
 * Handles comprehensive opponent turn management in chess training sessions.
 * Provides sophisticated scheduling, execution, and cancellation of opponent moves
 * with race condition prevention and robust error handling.
 *
 * @remarks
 * Key architectural features:
 * - **Race condition prevention**: Multiple cancellation checks prevent stale executions
 * - **Encapsulated state management**: OpponentTurnManager class for clean state isolation
 * - **Tablebase integration**: Fetches optimal opponent moves from tablebase API
 * - **State synchronization**: Coordinates with training state for turn management
 * - **Error resilience**: Graceful handling of tablebase API failures
 * - **Cross-platform support**: Works in browser and Node.js test environments
 *
 * The handler prevents common issues like:
 * - Executing opponent moves after user undo operations
 * - Multiple concurrent opponent turns
 * - Memory leaks from uncleaned timeouts
 * - State desynchronization between UI and game logic
 *
 * @example
 * ```typescript
 * import { getOpponentTurnManager } from './OpponentTurnHandler';
 * 
 * const manager = getOpponentTurnManager();
 * 
 * // Schedule opponent move with default delay
 * manager.schedule(storeApi);
 *
 * // Schedule with custom delay
 * manager.schedule(storeApi, 1000);
 *
 * // Cancel any pending opponent move (e.g., during undo)
 * manager.cancel();
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get cancelScheduledOpponentTurn () {
        return cancelScheduledOpponentTurn;
    },
    get getOpponentTurnManager () {
        return getOpponentTurnManager;
    },
    get scheduleOpponentTurn () {
        return scheduleOpponentTurn;
    }
});
const _ChessService = require("../../../services/ChessService");
const _TablebaseService = require("../../../services/TablebaseService");
const _ErrorService = require("../../../services/ErrorService");
const _movecompletion = require("./move.completion");
const _logging = require("../../../services/logging");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
/** Default delay for opponent moves in milliseconds - provides natural game feel */ const OPPONENT_TURN_DELAY = 500;
/**
 * Manages opponent turn scheduling and execution with encapsulated state
 * 
 * @class OpponentTurnManager
 * 
 * @description
 * Encapsulates timeout management and cancellation state to prevent race conditions
 * and provide clean separation of concerns. This eliminates the need for module-level
 * global state that could cause issues in concurrent scenarios.
 * 
 * @example
 * ```typescript
 * const manager = new OpponentTurnManager();
 * 
 * // Schedule opponent turn
 * manager.schedule(api, 500);
 * 
 * // Cancel if needed (e.g., during undo)
 * manager.cancel();
 * ```
 */ class OpponentTurnManager {
    /**
   * Cancels any scheduled opponent turn to prevent race conditions
   *
   * @description
   * Provides immediate cancellation of pending opponent moves, essential for:
   * - Undo operations that revert game state
   * - User navigation away from training session
   * - Game completion or interruption scenarios
   *
   * @remarks
   * Uses two-phase cancellation strategy:
   * 1. Sets cancellation flag for timeout callbacks
   * 2. Clears active timeout to prevent execution
   *
   * This dual approach ensures no opponent moves execute after cancellation,
   * even if the timeout has already fired but not yet executed.
   */ cancel() {
        this.isCancelled = true;
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = undefined;
            (0, _logging.getLogger)().debug("[OpponentTurnHandler] Successfully cancelled scheduled opponent turn");
        } else {
            (0, _logging.getLogger)().debug("[OpponentTurnHandler] WARNING: No timeout to cancel, but set cancellation flag");
        }
    }
    /**
   * Schedules optimal opponent move execution with sophisticated timing control
   *
   * @param {StoreApi} api - Zustand store API for state management
   * @param {number} [delay=500] - Delay in milliseconds before executing opponent move
   * @param {Object} [options] - Optional configuration
   * @param {Function} [options.onOpponentMoveComplete] - Callback after opponent move completes
   *
   * @description
   * Coordinates the scheduling and execution of optimal opponent moves using tablebase data.
   * Provides natural game pacing while ensuring clean state management and error handling.
   *
   * @remarks
   * **Race Condition Prevention:**
   * - Cancels any existing scheduled opponent turn before scheduling new one
   * - Resets cancellation flags for clean state
   * - Multiple state checks before execution
   */ schedule(api, delay = OPPONENT_TURN_DELAY, options) {
        var _currentState_training_currentPosition;
        const currentState = api.getState();
        (0, _logging.getLogger)().info(`[OpponentTurnHandler] ðŸŽ¯ scheduleOpponentTurn called - delay: ${delay}ms`, {
            isPlayerTurn: currentState.training.isPlayerTurn,
            isOpponentThinking: currentState.training.isOpponentThinking,
            currentFen: _ChessService.chessService.getFen(),
            currentTurn: _ChessService.chessService.turn(),
            colorToTrain: (_currentState_training_currentPosition = currentState.training.currentPosition) === null || _currentState_training_currentPosition === void 0 ? void 0 : _currentState_training_currentPosition.colorToTrain
        });
        // Cancel any previously scheduled opponent turn
        this.cancel();
        // Clear the cancellation flag when scheduling new turn
        this.isCancelled = false;
        if (typeof window !== "undefined") {
            // Schedule new opponent turn with cancellable timeout
            this.timeout = setTimeout(async ()=>{
                (0, _logging.getLogger)().debug("[OpponentTurnHandler] Timeout fired, checking if we should execute opponent turn");
                // Check if this turn was cancelled
                if (this.isCancelled) {
                    (0, _logging.getLogger)().debug("[OpponentTurnHandler] ABORTING - Turn was cancelled by undo");
                    return;
                }
                // Check state again before executing - player might have undone the move
                const currentState = api.getState();
                if (currentState.training.isPlayerTurn) {
                    (0, _logging.getLogger)().debug("[OpponentTurnHandler] ABORTING - It's now player's turn (move was undone)");
                    return;
                }
                (0, _logging.getLogger)().debug("[OpponentTurnHandler] Executing opponent turn");
                await this.executeOpponentTurn(api, options === null || options === void 0 ? void 0 : options.onOpponentMoveComplete);
                // Clear the timeout reference after execution
                this.timeout = undefined;
            }, delay);
        } else {
            // Fallback for non-browser environments (tests)
            (async ()=>{
                await new Promise((resolve)=>setTimeout(resolve, delay));
                if (!this.isCancelled) {
                    await this.executeOpponentTurn(api, options === null || options === void 0 ? void 0 : options.onOpponentMoveComplete);
                }
            })();
        }
    }
    /**
   * Executes optimal opponent move using tablebase recommendations
   *
   * @param {StoreApi} api - Zustand store API for state management
   * @param {Function} [onComplete] - Optional callback after move completion
   * @returns {Promise<void>} Promise that resolves when opponent move execution is complete
   *
   * @private
   * @description
   * Core opponent move execution with comprehensive state validation and error handling.
   * Fetches the best move from tablebase API and executes it with proper state updates.
   */ async executeOpponentTurn(api, onComplete) {
        var _state_training_currentPosition;
        const { getState, setState } = api;
        // Check if we should actually execute opponent turn
        const state = getState();
        (0, _logging.getLogger)().info("[OpponentTurnHandler] ðŸ” executeOpponentTurn called:", {
            isPlayerTurn: state.training.isPlayerTurn,
            isOpponentThinking: state.training.isOpponentThinking,
            currentFen: _ChessService.chessService.getFen(),
            currentTurn: _ChessService.chessService.turn(),
            trainingColor: (_state_training_currentPosition = state.training.currentPosition) === null || _state_training_currentPosition === void 0 ? void 0 : _state_training_currentPosition.colorToTrain,
            wasCancelled: this.isCancelled
        });
        // Check cancellation flag first
        if (this.isCancelled) {
            (0, _logging.getLogger)().warn("[OpponentTurnHandler] âŒ ABORTING - Turn was cancelled!");
            return;
        }
        // Don't execute if it's the player's turn
        if (state.training.isPlayerTurn) {
            (0, _logging.getLogger)().warn("[OpponentTurnHandler] âŒ ABORTING - It's player's turn! This is the issue!");
            (0, _logging.getLogger)().warn("This prevents opponent from moving after 'Weiterspielen' click");
            return;
        }
        try {
            var _topMoves_moves, _topMoves_moves1, _topMoves_moves2;
            // Get current position
            const currentFen = _ChessService.chessService.getFen();
            // Fetch ALL moves from tablebase to find optimal one based on DTM
            // We need all moves to properly evaluate defense in losing positions
            const topMoves = await _TablebaseService.tablebaseService.getTopMoves(currentFen, 10);
            (0, _logging.getLogger)().info("[OpponentTurnHandler] DEBUG: Fetched moves from tablebase:", {
                fen: currentFen,
                movesCount: ((_topMoves_moves = topMoves.moves) === null || _topMoves_moves === void 0 ? void 0 : _topMoves_moves.length) || 0,
                moves: (_topMoves_moves1 = topMoves.moves) === null || _topMoves_moves1 === void 0 ? void 0 : _topMoves_moves1.map((m)=>({
                        san: m.san,
                        dtm: m.dtm,
                        wdl: m.wdl,
                        category: m.category
                    })),
                firstMove: ((_topMoves_moves2 = topMoves.moves) === null || _topMoves_moves2 === void 0 ? void 0 : _topMoves_moves2[0]) ? {
                    san: topMoves.moves[0].san,
                    dtm: topMoves.moves[0].dtm,
                    note: "This is what TablebaseService returned as first/best"
                } : null
            });
            if (!topMoves.isAvailable || !topMoves.moves || topMoves.moves.length === 0) {
                // No tablebase move available - just return control to player
                setState((draft)=>{
                    draft.training.isPlayerTurn = true;
                    draft.training.isOpponentThinking = false;
                });
                return;
            }
            // Select the optimal move based on game theory:
            // 1. Prefer best outcome (win > draw > loss) by WDL
            // 2. Within same outcome:
            //    - If winning: pick move with LOWEST DTM (fastest win)
            //    - If losing: pick move with HIGHEST DTM (slowest loss - best defense)
            //    - If drawing: pick any (all equivalent)
            const bestMove = selectOptimalMove(topMoves.moves);
            // Execute the opponent move (tablebase moves should always be valid)
            const move = _ChessService.chessService.move(bestMove.san);
            if (!move) {
                throw new Error(`Failed to execute tablebase move: ${bestMove.san}`);
            }
            // Update state - switch back to player's turn
            setState((draft)=>{
                draft.training.isPlayerTurn = true;
                draft.training.isOpponentThinking = false;
            // Note: Removed opponent move toast to reduce UI clutter
            });
            // Check if game ended after opponent move
            if (_ChessService.chessService.isGameOver()) {
                await (0, _movecompletion.handleTrainingCompletion)(api, false); // Player didn't win
            }
            // Call completion callback if provided
            if (onComplete) {
                try {
                    await onComplete();
                    (0, _logging.getLogger)().debug("[OpponentTurnHandler] Completion callback executed successfully");
                } catch (error) {
                    (0, _logging.getLogger)().error("[OpponentTurnHandler] Completion callback failed:", error);
                }
            }
        } catch (error) {
            // Handle opponent move errors
            const userMessage = _ErrorService.ErrorService.handleUIError(error instanceof Error ? error : new Error(String(error)), "OpponentMove", {
                component: "OpponentMove",
                action: "execute"
            });
            setState((draft)=>{
                draft.ui.toasts.push({
                    id: Date.now().toString(),
                    message: userMessage,
                    type: "error"
                });
                // Reset to player's turn and clear thinking flag on error
                draft.training.isPlayerTurn = true;
                draft.training.isOpponentThinking = false;
            });
        }
    }
    constructor(){
        _define_property(this, "timeout", void 0);
        _define_property(this, "isCancelled", false);
    }
}
/**
 * Selects the optimal move from available tablebase moves based on game theory
 *
 * @param moves - Array of available tablebase moves
 * @returns The optimal move to play
 *
 * @description
 * Implements sophisticated move selection based on endgame principles:
 *
 * **Selection Strategy:**
 * 1. **Outcome Priority**: Win > Draw > Loss (by WDL value)
 * 2. **Within Same Outcome**:
 *    - **Winning** (WDL > 0): Choose move with LOWEST DTM (fastest win)
 *    - **Losing** (WDL < 0): Choose move with HIGHEST DTM (best defense, delays mate)
 *    - **Drawing** (WDL = 0): All moves equivalent, pick first
 *
 * **Rationale:**
 * - In winning positions: Convert advantage efficiently
 * - In losing positions: Maximize resistance, make opponent prove technique
 * - In drawn positions: Maintain draw with any legal move
 *
 * @example
 * ```typescript
 * // Losing position - will pick Kd7 (DTM -27) over Kc7 (DTM -15)
 * const moves = [
 *   { san: "Kc7", dtm: -15, wdl: -1000 },
 *   { san: "Kd7", dtm: -27, wdl: -1000 }, // Selected - delays mate longest
 * ];
 * const best = selectOptimalMove(moves);
 * ```
 */ function selectOptimalMove(moves) {
    // VALIDATION: Check DTM sign consistency
    moves.forEach((move)=>{
        if (move.wdl < 0 && move.dtm && move.dtm > 0) {
            (0, _logging.getLogger)().warn("[OpponentTurnHandler] WARNING: Positive DTM in losing position!", {
                san: move.san,
                wdl: move.wdl,
                dtm: move.dtm,
                category: move.category
            });
        }
    });
    // Sort moves by optimal criteria
    const sortedMoves = [
        ...moves
    ].sort((a, b)=>{
        // First priority: Sort by outcome (higher WDL is better)
        if (a.wdl !== b.wdl) {
            return b.wdl - a.wdl; // Prefer wins over draws over losses
        }
        // Same outcome - sort by DTM based on position type
        if (a.dtm === null || a.dtm === undefined || b.dtm === null || b.dtm === undefined) {
            return 0; // Can't compare if DTM is missing
        }
        // Check position type based on WDL
        if (a.wdl > 0) {
            // These are "winning" positions for the opponent after our move
            // For optimal defense: prefer HIGHER DTM (gives opponent longer path to win)
            return Math.abs(b.dtm) - Math.abs(a.dtm); // FIXED: Higher DTM first for defense
        } else if (a.wdl < 0) {
            // LOSING position: prefer HIGHER DTM (slower loss - better defense)
            // DTM is negative for losses
            // Example: -27 is better than -15 (lose in 27 moves vs 15 moves)
            return Math.abs(b.dtm) - Math.abs(a.dtm);
        } else {
            // DRAW: all moves equivalent
            return 0;
        }
    });
    const selected = sortedMoves[0];
    // Log the decision for debugging
    (0, _logging.getLogger)().info("[OpponentTurnHandler] Move selection:", {
        availableMoves: moves.map((m)=>({
                san: m.san,
                wdl: m.wdl,
                dtm: m.dtm,
                category: m.category
            })),
        selectedMove: {
            san: selected.san,
            wdl: selected.wdl,
            dtm: selected.dtm,
            category: selected.category
        },
        reason: selected.wdl < 0 ? `Best defense - delays mate for ${Math.abs(selected.dtm || 0)} moves` : selected.wdl > 0 ? `Fastest win - mate in ${Math.abs(selected.dtm || 0)} moves` : "Draw maintaining move"
    });
    return selected;
}
// Singleton instance for backward compatibility and global access
let managerInstance = null;
function getOpponentTurnManager() {
    if (!managerInstance) {
        managerInstance = new OpponentTurnManager();
    }
    return managerInstance;
}
function scheduleOpponentTurn(api, delay, options) {
    getOpponentTurnManager().schedule(api, delay, options);
}
function cancelScheduledOpponentTurn() {
    getOpponentTurnManager().cancel();
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZS9PcHBvbmVudFR1cm5IYW5kbGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGUgT3Bwb25lbnQgdHVybiBoYW5kbGVyIG1vZHVsZVxuICogQG1vZHVsZSBzdG9yZS9vcmNoZXN0cmF0b3JzL2hhbmRsZVBsYXllck1vdmUvT3Bwb25lbnRUdXJuSGFuZGxlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogSGFuZGxlcyBjb21wcmVoZW5zaXZlIG9wcG9uZW50IHR1cm4gbWFuYWdlbWVudCBpbiBjaGVzcyB0cmFpbmluZyBzZXNzaW9ucy5cbiAqIFByb3ZpZGVzIHNvcGhpc3RpY2F0ZWQgc2NoZWR1bGluZywgZXhlY3V0aW9uLCBhbmQgY2FuY2VsbGF0aW9uIG9mIG9wcG9uZW50IG1vdmVzXG4gKiB3aXRoIHJhY2UgY29uZGl0aW9uIHByZXZlbnRpb24gYW5kIHJvYnVzdCBlcnJvciBoYW5kbGluZy5cbiAqXG4gKiBAcmVtYXJrc1xuICogS2V5IGFyY2hpdGVjdHVyYWwgZmVhdHVyZXM6XG4gKiAtICoqUmFjZSBjb25kaXRpb24gcHJldmVudGlvbioqOiBNdWx0aXBsZSBjYW5jZWxsYXRpb24gY2hlY2tzIHByZXZlbnQgc3RhbGUgZXhlY3V0aW9uc1xuICogLSAqKkVuY2Fwc3VsYXRlZCBzdGF0ZSBtYW5hZ2VtZW50Kio6IE9wcG9uZW50VHVybk1hbmFnZXIgY2xhc3MgZm9yIGNsZWFuIHN0YXRlIGlzb2xhdGlvblxuICogLSAqKlRhYmxlYmFzZSBpbnRlZ3JhdGlvbioqOiBGZXRjaGVzIG9wdGltYWwgb3Bwb25lbnQgbW92ZXMgZnJvbSB0YWJsZWJhc2UgQVBJXG4gKiAtICoqU3RhdGUgc3luY2hyb25pemF0aW9uKio6IENvb3JkaW5hdGVzIHdpdGggdHJhaW5pbmcgc3RhdGUgZm9yIHR1cm4gbWFuYWdlbWVudFxuICogLSAqKkVycm9yIHJlc2lsaWVuY2UqKjogR3JhY2VmdWwgaGFuZGxpbmcgb2YgdGFibGViYXNlIEFQSSBmYWlsdXJlc1xuICogLSAqKkNyb3NzLXBsYXRmb3JtIHN1cHBvcnQqKjogV29ya3MgaW4gYnJvd3NlciBhbmQgTm9kZS5qcyB0ZXN0IGVudmlyb25tZW50c1xuICpcbiAqIFRoZSBoYW5kbGVyIHByZXZlbnRzIGNvbW1vbiBpc3N1ZXMgbGlrZTpcbiAqIC0gRXhlY3V0aW5nIG9wcG9uZW50IG1vdmVzIGFmdGVyIHVzZXIgdW5kbyBvcGVyYXRpb25zXG4gKiAtIE11bHRpcGxlIGNvbmN1cnJlbnQgb3Bwb25lbnQgdHVybnNcbiAqIC0gTWVtb3J5IGxlYWtzIGZyb20gdW5jbGVhbmVkIHRpbWVvdXRzXG4gKiAtIFN0YXRlIGRlc3luY2hyb25pemF0aW9uIGJldHdlZW4gVUkgYW5kIGdhbWUgbG9naWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgZ2V0T3Bwb25lbnRUdXJuTWFuYWdlciB9IGZyb20gJy4vT3Bwb25lbnRUdXJuSGFuZGxlcic7XG4gKiBcbiAqIGNvbnN0IG1hbmFnZXIgPSBnZXRPcHBvbmVudFR1cm5NYW5hZ2VyKCk7XG4gKiBcbiAqIC8vIFNjaGVkdWxlIG9wcG9uZW50IG1vdmUgd2l0aCBkZWZhdWx0IGRlbGF5XG4gKiBtYW5hZ2VyLnNjaGVkdWxlKHN0b3JlQXBpKTtcbiAqXG4gKiAvLyBTY2hlZHVsZSB3aXRoIGN1c3RvbSBkZWxheVxuICogbWFuYWdlci5zY2hlZHVsZShzdG9yZUFwaSwgMTAwMCk7XG4gKlxuICogLy8gQ2FuY2VsIGFueSBwZW5kaW5nIG9wcG9uZW50IG1vdmUgKGUuZy4sIGR1cmluZyB1bmRvKVxuICogbWFuYWdlci5jYW5jZWwoKTtcbiAqIGBgYFxuICovXG5cbmltcG9ydCB0eXBlIHsgU3RvcmVBcGkgfSBmcm9tIFwiLi4vdHlwZXNcIjtcbmltcG9ydCB7IGNoZXNzU2VydmljZSB9IGZyb20gXCJAc2hhcmVkL3NlcnZpY2VzL0NoZXNzU2VydmljZVwiO1xuaW1wb3J0IHtcbiAgdGFibGViYXNlU2VydmljZSxcbiAgdHlwZSBUYWJsZWJhc2VNb3ZlLFxufSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9UYWJsZWJhc2VTZXJ2aWNlXCI7XG5pbXBvcnQgeyBFcnJvclNlcnZpY2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9FcnJvclNlcnZpY2VcIjtcbmltcG9ydCB7IGhhbmRsZVRyYWluaW5nQ29tcGxldGlvbiB9IGZyb20gXCIuL21vdmUuY29tcGxldGlvblwiO1xuaW1wb3J0IHsgZ2V0TG9nZ2VyIH0gZnJvbSBcIkBzaGFyZWQvc2VydmljZXMvbG9nZ2luZ1wiO1xuXG4vKiogRGVmYXVsdCBkZWxheSBmb3Igb3Bwb25lbnQgbW92ZXMgaW4gbWlsbGlzZWNvbmRzIC0gcHJvdmlkZXMgbmF0dXJhbCBnYW1lIGZlZWwgKi9cbmNvbnN0IE9QUE9ORU5UX1RVUk5fREVMQVkgPSA1MDA7XG5cbi8qKlxuICogTWFuYWdlcyBvcHBvbmVudCB0dXJuIHNjaGVkdWxpbmcgYW5kIGV4ZWN1dGlvbiB3aXRoIGVuY2Fwc3VsYXRlZCBzdGF0ZVxuICogXG4gKiBAY2xhc3MgT3Bwb25lbnRUdXJuTWFuYWdlclxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVuY2Fwc3VsYXRlcyB0aW1lb3V0IG1hbmFnZW1lbnQgYW5kIGNhbmNlbGxhdGlvbiBzdGF0ZSB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9uc1xuICogYW5kIHByb3ZpZGUgY2xlYW4gc2VwYXJhdGlvbiBvZiBjb25jZXJucy4gVGhpcyBlbGltaW5hdGVzIHRoZSBuZWVkIGZvciBtb2R1bGUtbGV2ZWxcbiAqIGdsb2JhbCBzdGF0ZSB0aGF0IGNvdWxkIGNhdXNlIGlzc3VlcyBpbiBjb25jdXJyZW50IHNjZW5hcmlvcy5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IG1hbmFnZXIgPSBuZXcgT3Bwb25lbnRUdXJuTWFuYWdlcigpO1xuICogXG4gKiAvLyBTY2hlZHVsZSBvcHBvbmVudCB0dXJuXG4gKiBtYW5hZ2VyLnNjaGVkdWxlKGFwaSwgNTAwKTtcbiAqIFxuICogLy8gQ2FuY2VsIGlmIG5lZWRlZCAoZS5nLiwgZHVyaW5nIHVuZG8pXG4gKiBtYW5hZ2VyLmNhbmNlbCgpO1xuICogYGBgXG4gKi9cbmNsYXNzIE9wcG9uZW50VHVybk1hbmFnZXIge1xuICBwcml2YXRlIHRpbWVvdXQ/OiBOb2RlSlMuVGltZW91dDtcbiAgcHJpdmF0ZSBpc0NhbmNlbGxlZCA9IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGFueSBzY2hlZHVsZWQgb3Bwb25lbnQgdHVybiB0byBwcmV2ZW50IHJhY2UgY29uZGl0aW9uc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUHJvdmlkZXMgaW1tZWRpYXRlIGNhbmNlbGxhdGlvbiBvZiBwZW5kaW5nIG9wcG9uZW50IG1vdmVzLCBlc3NlbnRpYWwgZm9yOlxuICAgKiAtIFVuZG8gb3BlcmF0aW9ucyB0aGF0IHJldmVydCBnYW1lIHN0YXRlXG4gICAqIC0gVXNlciBuYXZpZ2F0aW9uIGF3YXkgZnJvbSB0cmFpbmluZyBzZXNzaW9uXG4gICAqIC0gR2FtZSBjb21wbGV0aW9uIG9yIGludGVycnVwdGlvbiBzY2VuYXJpb3NcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVXNlcyB0d28tcGhhc2UgY2FuY2VsbGF0aW9uIHN0cmF0ZWd5OlxuICAgKiAxLiBTZXRzIGNhbmNlbGxhdGlvbiBmbGFnIGZvciB0aW1lb3V0IGNhbGxiYWNrc1xuICAgKiAyLiBDbGVhcnMgYWN0aXZlIHRpbWVvdXQgdG8gcHJldmVudCBleGVjdXRpb25cbiAgICpcbiAgICogVGhpcyBkdWFsIGFwcHJvYWNoIGVuc3VyZXMgbm8gb3Bwb25lbnQgbW92ZXMgZXhlY3V0ZSBhZnRlciBjYW5jZWxsYXRpb24sXG4gICAqIGV2ZW4gaWYgdGhlIHRpbWVvdXQgaGFzIGFscmVhZHkgZmlyZWQgYnV0IG5vdCB5ZXQgZXhlY3V0ZWQuXG4gICAqL1xuICBjYW5jZWwoKTogdm9pZCB7XG4gICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgIHRoaXMudGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgIGdldExvZ2dlcigpLmRlYnVnKFxuICAgICAgICBcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBTdWNjZXNzZnVsbHkgY2FuY2VsbGVkIHNjaGVkdWxlZCBvcHBvbmVudCB0dXJuXCIsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcbiAgICAgICAgXCJbT3Bwb25lbnRUdXJuSGFuZGxlcl0gV0FSTklORzogTm8gdGltZW91dCB0byBjYW5jZWwsIGJ1dCBzZXQgY2FuY2VsbGF0aW9uIGZsYWdcIixcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNjaGVkdWxlcyBvcHRpbWFsIG9wcG9uZW50IG1vdmUgZXhlY3V0aW9uIHdpdGggc29waGlzdGljYXRlZCB0aW1pbmcgY29udHJvbFxuICAgKlxuICAgKiBAcGFyYW0ge1N0b3JlQXBpfSBhcGkgLSBadXN0YW5kIHN0b3JlIEFQSSBmb3Igc3RhdGUgbWFuYWdlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5PTUwMF0gLSBEZWxheSBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGV4ZWN1dGluZyBvcHBvbmVudCBtb3ZlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uT3Bwb25lbnRNb3ZlQ29tcGxldGVdIC0gQ2FsbGJhY2sgYWZ0ZXIgb3Bwb25lbnQgbW92ZSBjb21wbGV0ZXNcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvb3JkaW5hdGVzIHRoZSBzY2hlZHVsaW5nIGFuZCBleGVjdXRpb24gb2Ygb3B0aW1hbCBvcHBvbmVudCBtb3ZlcyB1c2luZyB0YWJsZWJhc2UgZGF0YS5cbiAgICogUHJvdmlkZXMgbmF0dXJhbCBnYW1lIHBhY2luZyB3aGlsZSBlbnN1cmluZyBjbGVhbiBzdGF0ZSBtYW5hZ2VtZW50IGFuZCBlcnJvciBoYW5kbGluZy5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogKipSYWNlIENvbmRpdGlvbiBQcmV2ZW50aW9uOioqXG4gICAqIC0gQ2FuY2VscyBhbnkgZXhpc3Rpbmcgc2NoZWR1bGVkIG9wcG9uZW50IHR1cm4gYmVmb3JlIHNjaGVkdWxpbmcgbmV3IG9uZVxuICAgKiAtIFJlc2V0cyBjYW5jZWxsYXRpb24gZmxhZ3MgZm9yIGNsZWFuIHN0YXRlXG4gICAqIC0gTXVsdGlwbGUgc3RhdGUgY2hlY2tzIGJlZm9yZSBleGVjdXRpb25cbiAgICovXG4gIHNjaGVkdWxlKFxuICAgIGFwaTogU3RvcmVBcGksXG4gICAgZGVsYXk6IG51bWJlciA9IE9QUE9ORU5UX1RVUk5fREVMQVksXG4gICAgb3B0aW9ucz86IHsgb25PcHBvbmVudE1vdmVDb21wbGV0ZT86ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkIH1cbiAgKTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gYXBpLmdldFN0YXRlKCk7XG4gICAgZ2V0TG9nZ2VyKCkuaW5mbyhcbiAgICAgIGBbT3Bwb25lbnRUdXJuSGFuZGxlcl0g8J+OryBzY2hlZHVsZU9wcG9uZW50VHVybiBjYWxsZWQgLSBkZWxheTogJHtkZWxheX1tc2AsXG4gICAgICB7XG4gICAgICAgIGlzUGxheWVyVHVybjogY3VycmVudFN0YXRlLnRyYWluaW5nLmlzUGxheWVyVHVybixcbiAgICAgICAgaXNPcHBvbmVudFRoaW5raW5nOiBjdXJyZW50U3RhdGUudHJhaW5pbmcuaXNPcHBvbmVudFRoaW5raW5nLFxuICAgICAgICBjdXJyZW50RmVuOiBjaGVzc1NlcnZpY2UuZ2V0RmVuKCksXG4gICAgICAgIGN1cnJlbnRUdXJuOiBjaGVzc1NlcnZpY2UudHVybigpLFxuICAgICAgICBjb2xvclRvVHJhaW46IGN1cnJlbnRTdGF0ZS50cmFpbmluZy5jdXJyZW50UG9zaXRpb24/LmNvbG9yVG9UcmFpbixcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gQ2FuY2VsIGFueSBwcmV2aW91c2x5IHNjaGVkdWxlZCBvcHBvbmVudCB0dXJuXG4gICAgdGhpcy5jYW5jZWwoKTtcblxuICAgIC8vIENsZWFyIHRoZSBjYW5jZWxsYXRpb24gZmxhZyB3aGVuIHNjaGVkdWxpbmcgbmV3IHR1cm5cbiAgICB0aGlzLmlzQ2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgLy8gU2NoZWR1bGUgbmV3IG9wcG9uZW50IHR1cm4gd2l0aCBjYW5jZWxsYWJsZSB0aW1lb3V0XG4gICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0TG9nZ2VyKCkuZGVidWcoXG4gICAgICAgICAgXCJbT3Bwb25lbnRUdXJuSGFuZGxlcl0gVGltZW91dCBmaXJlZCwgY2hlY2tpbmcgaWYgd2Ugc2hvdWxkIGV4ZWN1dGUgb3Bwb25lbnQgdHVyblwiLFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdHVybiB3YXMgY2FuY2VsbGVkXG4gICAgICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgZ2V0TG9nZ2VyKCkuZGVidWcoXG4gICAgICAgICAgICBcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBBQk9SVElORyAtIFR1cm4gd2FzIGNhbmNlbGxlZCBieSB1bmRvXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBzdGF0ZSBhZ2FpbiBiZWZvcmUgZXhlY3V0aW5nIC0gcGxheWVyIG1pZ2h0IGhhdmUgdW5kb25lIHRoZSBtb3ZlXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoY3VycmVudFN0YXRlLnRyYWluaW5nLmlzUGxheWVyVHVybikge1xuICAgICAgICAgIGdldExvZ2dlcigpLmRlYnVnKFxuICAgICAgICAgICAgXCJbT3Bwb25lbnRUdXJuSGFuZGxlcl0gQUJPUlRJTkcgLSBJdCdzIG5vdyBwbGF5ZXIncyB0dXJuIChtb3ZlIHdhcyB1bmRvbmUpXCIsXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBFeGVjdXRpbmcgb3Bwb25lbnQgdHVyblwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlT3Bwb25lbnRUdXJuKGFwaSwgb3B0aW9ucz8ub25PcHBvbmVudE1vdmVDb21wbGV0ZSk7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgcmVmZXJlbmNlIGFmdGVyIGV4ZWN1dGlvblxuICAgICAgICB0aGlzLnRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICB9LCBkZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgKHRlc3RzKVxuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlT3Bwb25lbnRUdXJuKGFwaSwgb3B0aW9ucz8ub25PcHBvbmVudE1vdmVDb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIG9wdGltYWwgb3Bwb25lbnQgbW92ZSB1c2luZyB0YWJsZWJhc2UgcmVjb21tZW5kYXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7U3RvcmVBcGl9IGFwaSAtIFp1c3RhbmQgc3RvcmUgQVBJIGZvciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkNvbXBsZXRlXSAtIE9wdGlvbmFsIGNhbGxiYWNrIGFmdGVyIG1vdmUgY29tcGxldGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gb3Bwb25lbnQgbW92ZSBleGVjdXRpb24gaXMgY29tcGxldGVcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIENvcmUgb3Bwb25lbnQgbW92ZSBleGVjdXRpb24gd2l0aCBjb21wcmVoZW5zaXZlIHN0YXRlIHZhbGlkYXRpb24gYW5kIGVycm9yIGhhbmRsaW5nLlxuICAgKiBGZXRjaGVzIHRoZSBiZXN0IG1vdmUgZnJvbSB0YWJsZWJhc2UgQVBJIGFuZCBleGVjdXRlcyBpdCB3aXRoIHByb3BlciBzdGF0ZSB1cGRhdGVzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBleGVjdXRlT3Bwb25lbnRUdXJuKFxuICAgIGFwaTogU3RvcmVBcGksXG4gICAgb25Db21wbGV0ZT86ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgZ2V0U3RhdGUsIHNldFN0YXRlIH0gPSBhcGk7XG5cbiAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgZXhlY3V0ZSBvcHBvbmVudCB0dXJuXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGdldExvZ2dlcigpLmluZm8oXCJbT3Bwb25lbnRUdXJuSGFuZGxlcl0g8J+UjSBleGVjdXRlT3Bwb25lbnRUdXJuIGNhbGxlZDpcIiwge1xuICAgICAgaXNQbGF5ZXJUdXJuOiBzdGF0ZS50cmFpbmluZy5pc1BsYXllclR1cm4sXG4gICAgICBpc09wcG9uZW50VGhpbmtpbmc6IHN0YXRlLnRyYWluaW5nLmlzT3Bwb25lbnRUaGlua2luZyxcbiAgICAgIGN1cnJlbnRGZW46IGNoZXNzU2VydmljZS5nZXRGZW4oKSxcbiAgICAgIGN1cnJlbnRUdXJuOiBjaGVzc1NlcnZpY2UudHVybigpLFxuICAgICAgdHJhaW5pbmdDb2xvcjogc3RhdGUudHJhaW5pbmcuY3VycmVudFBvc2l0aW9uPy5jb2xvclRvVHJhaW4sXG4gICAgICB3YXNDYW5jZWxsZWQ6IHRoaXMuaXNDYW5jZWxsZWQsXG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBjYW5jZWxsYXRpb24gZmxhZyBmaXJzdFxuICAgIGlmICh0aGlzLmlzQ2FuY2VsbGVkKSB7XG4gICAgICBnZXRMb2dnZXIoKS53YXJuKFwiW09wcG9uZW50VHVybkhhbmRsZXJdIOKdjCBBQk9SVElORyAtIFR1cm4gd2FzIGNhbmNlbGxlZCFcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgZXhlY3V0ZSBpZiBpdCdzIHRoZSBwbGF5ZXIncyB0dXJuXG4gICAgaWYgKHN0YXRlLnRyYWluaW5nLmlzUGxheWVyVHVybikge1xuICAgICAgZ2V0TG9nZ2VyKCkud2FybihcIltPcHBvbmVudFR1cm5IYW5kbGVyXSDinYwgQUJPUlRJTkcgLSBJdCdzIHBsYXllcidzIHR1cm4hIFRoaXMgaXMgdGhlIGlzc3VlIVwiKTtcbiAgICAgIGdldExvZ2dlcigpLndhcm4oXCJUaGlzIHByZXZlbnRzIG9wcG9uZW50IGZyb20gbW92aW5nIGFmdGVyICdXZWl0ZXJzcGllbGVuJyBjbGlja1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGN1cnJlbnQgcG9zaXRpb25cbiAgICAgIGNvbnN0IGN1cnJlbnRGZW4gPSBjaGVzc1NlcnZpY2UuZ2V0RmVuKCk7XG5cbiAgICAgIC8vIEZldGNoIEFMTCBtb3ZlcyBmcm9tIHRhYmxlYmFzZSB0byBmaW5kIG9wdGltYWwgb25lIGJhc2VkIG9uIERUTVxuICAgICAgLy8gV2UgbmVlZCBhbGwgbW92ZXMgdG8gcHJvcGVybHkgZXZhbHVhdGUgZGVmZW5zZSBpbiBsb3NpbmcgcG9zaXRpb25zXG4gICAgICBjb25zdCB0b3BNb3ZlcyA9IGF3YWl0IHRhYmxlYmFzZVNlcnZpY2UuZ2V0VG9wTW92ZXMoY3VycmVudEZlbiwgMTApO1xuXG4gICAgICBnZXRMb2dnZXIoKS5pbmZvKFxuICAgICAgICBcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBERUJVRzogRmV0Y2hlZCBtb3ZlcyBmcm9tIHRhYmxlYmFzZTpcIixcbiAgICAgICAge1xuICAgICAgICAgIGZlbjogY3VycmVudEZlbixcbiAgICAgICAgICBtb3Zlc0NvdW50OiB0b3BNb3Zlcy5tb3Zlcz8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgbW92ZXM6IHRvcE1vdmVzLm1vdmVzPy5tYXAoKG0pID0+ICh7XG4gICAgICAgICAgICBzYW46IG0uc2FuLFxuICAgICAgICAgICAgZHRtOiBtLmR0bSxcbiAgICAgICAgICAgIHdkbDogbS53ZGwsXG4gICAgICAgICAgICBjYXRlZ29yeTogbS5jYXRlZ29yeSxcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgZmlyc3RNb3ZlOiB0b3BNb3Zlcy5tb3Zlcz8uWzBdXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBzYW46IHRvcE1vdmVzLm1vdmVzWzBdLnNhbixcbiAgICAgICAgICAgICAgICBkdG06IHRvcE1vdmVzLm1vdmVzWzBdLmR0bSxcbiAgICAgICAgICAgICAgICBub3RlOiBcIlRoaXMgaXMgd2hhdCBUYWJsZWJhc2VTZXJ2aWNlIHJldHVybmVkIGFzIGZpcnN0L2Jlc3RcIixcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgaWYgKFxuICAgICAgICAhdG9wTW92ZXMuaXNBdmFpbGFibGUgfHxcbiAgICAgICAgIXRvcE1vdmVzLm1vdmVzIHx8XG4gICAgICAgIHRvcE1vdmVzLm1vdmVzLmxlbmd0aCA9PT0gMFxuICAgICAgKSB7XG4gICAgICAgIC8vIE5vIHRhYmxlYmFzZSBtb3ZlIGF2YWlsYWJsZSAtIGp1c3QgcmV0dXJuIGNvbnRyb2wgdG8gcGxheWVyXG4gICAgICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgICAgIGRyYWZ0LnRyYWluaW5nLmlzUGxheWVyVHVybiA9IHRydWU7XG4gICAgICAgICAgZHJhZnQudHJhaW5pbmcuaXNPcHBvbmVudFRoaW5raW5nID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFNlbGVjdCB0aGUgb3B0aW1hbCBtb3ZlIGJhc2VkIG9uIGdhbWUgdGhlb3J5OlxuICAgICAgLy8gMS4gUHJlZmVyIGJlc3Qgb3V0Y29tZSAod2luID4gZHJhdyA+IGxvc3MpIGJ5IFdETFxuICAgICAgLy8gMi4gV2l0aGluIHNhbWUgb3V0Y29tZTpcbiAgICAgIC8vICAgIC0gSWYgd2lubmluZzogcGljayBtb3ZlIHdpdGggTE9XRVNUIERUTSAoZmFzdGVzdCB3aW4pXG4gICAgICAvLyAgICAtIElmIGxvc2luZzogcGljayBtb3ZlIHdpdGggSElHSEVTVCBEVE0gKHNsb3dlc3QgbG9zcyAtIGJlc3QgZGVmZW5zZSlcbiAgICAgIC8vICAgIC0gSWYgZHJhd2luZzogcGljayBhbnkgKGFsbCBlcXVpdmFsZW50KVxuICAgICAgY29uc3QgYmVzdE1vdmUgPSBzZWxlY3RPcHRpbWFsTW92ZSh0b3BNb3Zlcy5tb3Zlcyk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgdGhlIG9wcG9uZW50IG1vdmUgKHRhYmxlYmFzZSBtb3ZlcyBzaG91bGQgYWx3YXlzIGJlIHZhbGlkKVxuICAgICAgY29uc3QgbW92ZSA9IGNoZXNzU2VydmljZS5tb3ZlKGJlc3RNb3ZlLnNhbik7XG4gICAgICBpZiAoIW1vdmUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXhlY3V0ZSB0YWJsZWJhc2UgbW92ZTogJHtiZXN0TW92ZS5zYW59YCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBzdGF0ZSAtIHN3aXRjaCBiYWNrIHRvIHBsYXllcidzIHR1cm5cbiAgICAgIHNldFN0YXRlKChkcmFmdCkgPT4ge1xuICAgICAgICBkcmFmdC50cmFpbmluZy5pc1BsYXllclR1cm4gPSB0cnVlO1xuICAgICAgICBkcmFmdC50cmFpbmluZy5pc09wcG9uZW50VGhpbmtpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBOb3RlOiBSZW1vdmVkIG9wcG9uZW50IG1vdmUgdG9hc3QgdG8gcmVkdWNlIFVJIGNsdXR0ZXJcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDaGVjayBpZiBnYW1lIGVuZGVkIGFmdGVyIG9wcG9uZW50IG1vdmVcbiAgICAgIGlmIChjaGVzc1NlcnZpY2UuaXNHYW1lT3ZlcigpKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVRyYWluaW5nQ29tcGxldGlvbihhcGksIGZhbHNlKTsgLy8gUGxheWVyIGRpZG4ndCB3aW5cbiAgICAgIH1cblxuICAgICAgLy8gQ2FsbCBjb21wbGV0aW9uIGNhbGxiYWNrIGlmIHByb3ZpZGVkXG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IG9uQ29tcGxldGUoKTtcbiAgICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBDb21wbGV0aW9uIGNhbGxiYWNrIGV4ZWN1dGVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBnZXRMb2dnZXIoKS5lcnJvcihcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBDb21wbGV0aW9uIGNhbGxiYWNrIGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIEhhbmRsZSBvcHBvbmVudCBtb3ZlIGVycm9yc1xuICAgICAgY29uc3QgdXNlck1lc3NhZ2UgPSBFcnJvclNlcnZpY2UuaGFuZGxlVUlFcnJvcihcbiAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpLFxuICAgICAgICBcIk9wcG9uZW50TW92ZVwiLFxuICAgICAgICB7XG4gICAgICAgICAgY29tcG9uZW50OiBcIk9wcG9uZW50TW92ZVwiLFxuICAgICAgICAgIGFjdGlvbjogXCJleGVjdXRlXCIsXG4gICAgICAgIH0sXG4gICAgICApO1xuXG4gICAgICBzZXRTdGF0ZSgoZHJhZnQpID0+IHtcbiAgICAgICAgZHJhZnQudWkudG9hc3RzLnB1c2goe1xuICAgICAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXG4gICAgICAgICAgbWVzc2FnZTogdXNlck1lc3NhZ2UsXG4gICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVzZXQgdG8gcGxheWVyJ3MgdHVybiBhbmQgY2xlYXIgdGhpbmtpbmcgZmxhZyBvbiBlcnJvclxuICAgICAgICBkcmFmdC50cmFpbmluZy5pc1BsYXllclR1cm4gPSB0cnVlO1xuICAgICAgICBkcmFmdC50cmFpbmluZy5pc09wcG9uZW50VGhpbmtpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNlbGVjdHMgdGhlIG9wdGltYWwgbW92ZSBmcm9tIGF2YWlsYWJsZSB0YWJsZWJhc2UgbW92ZXMgYmFzZWQgb24gZ2FtZSB0aGVvcnlcbiAqXG4gKiBAcGFyYW0gbW92ZXMgLSBBcnJheSBvZiBhdmFpbGFibGUgdGFibGViYXNlIG1vdmVzXG4gKiBAcmV0dXJucyBUaGUgb3B0aW1hbCBtb3ZlIHRvIHBsYXlcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEltcGxlbWVudHMgc29waGlzdGljYXRlZCBtb3ZlIHNlbGVjdGlvbiBiYXNlZCBvbiBlbmRnYW1lIHByaW5jaXBsZXM6XG4gKlxuICogKipTZWxlY3Rpb24gU3RyYXRlZ3k6KipcbiAqIDEuICoqT3V0Y29tZSBQcmlvcml0eSoqOiBXaW4gPiBEcmF3ID4gTG9zcyAoYnkgV0RMIHZhbHVlKVxuICogMi4gKipXaXRoaW4gU2FtZSBPdXRjb21lKio6XG4gKiAgICAtICoqV2lubmluZyoqIChXREwgPiAwKTogQ2hvb3NlIG1vdmUgd2l0aCBMT1dFU1QgRFRNIChmYXN0ZXN0IHdpbilcbiAqICAgIC0gKipMb3NpbmcqKiAoV0RMIDwgMCk6IENob29zZSBtb3ZlIHdpdGggSElHSEVTVCBEVE0gKGJlc3QgZGVmZW5zZSwgZGVsYXlzIG1hdGUpXG4gKiAgICAtICoqRHJhd2luZyoqIChXREwgPSAwKTogQWxsIG1vdmVzIGVxdWl2YWxlbnQsIHBpY2sgZmlyc3RcbiAqXG4gKiAqKlJhdGlvbmFsZToqKlxuICogLSBJbiB3aW5uaW5nIHBvc2l0aW9uczogQ29udmVydCBhZHZhbnRhZ2UgZWZmaWNpZW50bHlcbiAqIC0gSW4gbG9zaW5nIHBvc2l0aW9uczogTWF4aW1pemUgcmVzaXN0YW5jZSwgbWFrZSBvcHBvbmVudCBwcm92ZSB0ZWNobmlxdWVcbiAqIC0gSW4gZHJhd24gcG9zaXRpb25zOiBNYWludGFpbiBkcmF3IHdpdGggYW55IGxlZ2FsIG1vdmVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogLy8gTG9zaW5nIHBvc2l0aW9uIC0gd2lsbCBwaWNrIEtkNyAoRFRNIC0yNykgb3ZlciBLYzcgKERUTSAtMTUpXG4gKiBjb25zdCBtb3ZlcyA9IFtcbiAqICAgeyBzYW46IFwiS2M3XCIsIGR0bTogLTE1LCB3ZGw6IC0xMDAwIH0sXG4gKiAgIHsgc2FuOiBcIktkN1wiLCBkdG06IC0yNywgd2RsOiAtMTAwMCB9LCAvLyBTZWxlY3RlZCAtIGRlbGF5cyBtYXRlIGxvbmdlc3RcbiAqIF07XG4gKiBjb25zdCBiZXN0ID0gc2VsZWN0T3B0aW1hbE1vdmUobW92ZXMpO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdE9wdGltYWxNb3ZlKG1vdmVzOiBUYWJsZWJhc2VNb3ZlW10pOiBUYWJsZWJhc2VNb3ZlIHtcbiAgLy8gVkFMSURBVElPTjogQ2hlY2sgRFRNIHNpZ24gY29uc2lzdGVuY3lcbiAgbW92ZXMuZm9yRWFjaCgobW92ZSkgPT4ge1xuICAgIGlmIChtb3ZlLndkbCA8IDAgJiYgbW92ZS5kdG0gJiYgbW92ZS5kdG0gPiAwKSB7XG4gICAgICBnZXRMb2dnZXIoKS53YXJuKFxuICAgICAgICBcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBXQVJOSU5HOiBQb3NpdGl2ZSBEVE0gaW4gbG9zaW5nIHBvc2l0aW9uIVwiLFxuICAgICAgICB7XG4gICAgICAgICAgc2FuOiBtb3ZlLnNhbixcbiAgICAgICAgICB3ZGw6IG1vdmUud2RsLFxuICAgICAgICAgIGR0bTogbW92ZS5kdG0sXG4gICAgICAgICAgY2F0ZWdvcnk6IG1vdmUuY2F0ZWdvcnksXG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU29ydCBtb3ZlcyBieSBvcHRpbWFsIGNyaXRlcmlhXG4gIGNvbnN0IHNvcnRlZE1vdmVzID0gWy4uLm1vdmVzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgLy8gRmlyc3QgcHJpb3JpdHk6IFNvcnQgYnkgb3V0Y29tZSAoaGlnaGVyIFdETCBpcyBiZXR0ZXIpXG4gICAgaWYgKGEud2RsICE9PSBiLndkbCkge1xuICAgICAgcmV0dXJuIGIud2RsIC0gYS53ZGw7IC8vIFByZWZlciB3aW5zIG92ZXIgZHJhd3Mgb3ZlciBsb3NzZXNcbiAgICB9XG5cbiAgICAvLyBTYW1lIG91dGNvbWUgLSBzb3J0IGJ5IERUTSBiYXNlZCBvbiBwb3NpdGlvbiB0eXBlXG4gICAgaWYgKFxuICAgICAgYS5kdG0gPT09IG51bGwgfHxcbiAgICAgIGEuZHRtID09PSB1bmRlZmluZWQgfHxcbiAgICAgIGIuZHRtID09PSBudWxsIHx8XG4gICAgICBiLmR0bSA9PT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDsgLy8gQ2FuJ3QgY29tcGFyZSBpZiBEVE0gaXMgbWlzc2luZ1xuICAgIH1cblxuICAgIC8vIENoZWNrIHBvc2l0aW9uIHR5cGUgYmFzZWQgb24gV0RMXG4gICAgaWYgKGEud2RsID4gMCkge1xuICAgICAgLy8gVGhlc2UgYXJlIFwid2lubmluZ1wiIHBvc2l0aW9ucyBmb3IgdGhlIG9wcG9uZW50IGFmdGVyIG91ciBtb3ZlXG4gICAgICAvLyBGb3Igb3B0aW1hbCBkZWZlbnNlOiBwcmVmZXIgSElHSEVSIERUTSAoZ2l2ZXMgb3Bwb25lbnQgbG9uZ2VyIHBhdGggdG8gd2luKVxuICAgICAgcmV0dXJuIE1hdGguYWJzKGIuZHRtKSAtIE1hdGguYWJzKGEuZHRtKTsgLy8gRklYRUQ6IEhpZ2hlciBEVE0gZmlyc3QgZm9yIGRlZmVuc2VcbiAgICB9IGVsc2UgaWYgKGEud2RsIDwgMCkge1xuICAgICAgLy8gTE9TSU5HIHBvc2l0aW9uOiBwcmVmZXIgSElHSEVSIERUTSAoc2xvd2VyIGxvc3MgLSBiZXR0ZXIgZGVmZW5zZSlcbiAgICAgIC8vIERUTSBpcyBuZWdhdGl2ZSBmb3IgbG9zc2VzXG4gICAgICAvLyBFeGFtcGxlOiAtMjcgaXMgYmV0dGVyIHRoYW4gLTE1IChsb3NlIGluIDI3IG1vdmVzIHZzIDE1IG1vdmVzKVxuICAgICAgcmV0dXJuIE1hdGguYWJzKGIuZHRtKSAtIE1hdGguYWJzKGEuZHRtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRFJBVzogYWxsIG1vdmVzIGVxdWl2YWxlbnRcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3Qgc2VsZWN0ZWQgPSBzb3J0ZWRNb3Zlc1swXTtcblxuICAvLyBMb2cgdGhlIGRlY2lzaW9uIGZvciBkZWJ1Z2dpbmdcbiAgZ2V0TG9nZ2VyKCkuaW5mbyhcIltPcHBvbmVudFR1cm5IYW5kbGVyXSBNb3ZlIHNlbGVjdGlvbjpcIiwge1xuICAgIGF2YWlsYWJsZU1vdmVzOiBtb3Zlcy5tYXAoKG0pID0+ICh7XG4gICAgICBzYW46IG0uc2FuLFxuICAgICAgd2RsOiBtLndkbCxcbiAgICAgIGR0bTogbS5kdG0sXG4gICAgICBjYXRlZ29yeTogbS5jYXRlZ29yeSxcbiAgICB9KSksXG4gICAgc2VsZWN0ZWRNb3ZlOiB7XG4gICAgICBzYW46IHNlbGVjdGVkLnNhbixcbiAgICAgIHdkbDogc2VsZWN0ZWQud2RsLFxuICAgICAgZHRtOiBzZWxlY3RlZC5kdG0sXG4gICAgICBjYXRlZ29yeTogc2VsZWN0ZWQuY2F0ZWdvcnksXG4gICAgfSxcbiAgICByZWFzb246XG4gICAgICBzZWxlY3RlZC53ZGwgPCAwXG4gICAgICAgID8gYEJlc3QgZGVmZW5zZSAtIGRlbGF5cyBtYXRlIGZvciAke01hdGguYWJzKHNlbGVjdGVkLmR0bSB8fCAwKX0gbW92ZXNgXG4gICAgICAgIDogc2VsZWN0ZWQud2RsID4gMFxuICAgICAgICAgID8gYEZhc3Rlc3Qgd2luIC0gbWF0ZSBpbiAke01hdGguYWJzKHNlbGVjdGVkLmR0bSB8fCAwKX0gbW92ZXNgXG4gICAgICAgICAgOiBcIkRyYXcgbWFpbnRhaW5pbmcgbW92ZVwiLFxuICB9KTtcblxuICByZXR1cm4gc2VsZWN0ZWQ7XG59XG5cbi8vIFNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhbmQgZ2xvYmFsIGFjY2Vzc1xubGV0IG1hbmFnZXJJbnN0YW5jZTogT3Bwb25lbnRUdXJuTWFuYWdlciB8IG51bGwgPSBudWxsO1xuXG4vKipcbiAqIEdldHMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZSBvZiBPcHBvbmVudFR1cm5NYW5hZ2VyXG4gKiBcbiAqIEByZXR1cm5zIHtPcHBvbmVudFR1cm5NYW5hZ2VyfSBUaGUgc2luZ2xldG9uIG1hbmFnZXIgaW5zdGFuY2VcbiAqIFxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlcyBhIHNpbmdsZXRvbiBpbnN0YW5jZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIGNvZGVcbiAqIHRoYXQgZXhwZWN0cyBnbG9iYWwgZnVuY3Rpb25zLiBUaGlzIGFsbG93cyBncmFkdWFsIG1pZ3JhdGlvbiB0byB0aGUgY2xhc3MtYmFzZWRcbiAqIGFwcHJvYWNoIHdoaWxlIG1haW50YWluaW5nIGV4aXN0aW5nIEFQSSBjb250cmFjdHMuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBtYW5hZ2VyID0gZ2V0T3Bwb25lbnRUdXJuTWFuYWdlcigpO1xuICogbWFuYWdlci5zY2hlZHVsZShhcGkpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHBvbmVudFR1cm5NYW5hZ2VyKCk6IE9wcG9uZW50VHVybk1hbmFnZXIge1xuICBpZiAoIW1hbmFnZXJJbnN0YW5jZSkge1xuICAgIG1hbmFnZXJJbnN0YW5jZSA9IG5ldyBPcHBvbmVudFR1cm5NYW5hZ2VyKCk7XG4gIH1cbiAgcmV0dXJuIG1hbmFnZXJJbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBTY2hlZHVsZXMgb3Bwb25lbnQgdHVybiAoYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3cmFwcGVyKVxuICogXG4gKiBAZGVwcmVjYXRlZCBVc2UgZ2V0T3Bwb25lbnRUdXJuTWFuYWdlcigpLnNjaGVkdWxlKCkgaW5zdGVhZFxuICogXG4gKiBAcGFyYW0ge1N0b3JlQXBpfSBhcGkgLSBadXN0YW5kIHN0b3JlIEFQSVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gLSBEZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25hbCBjb25maWd1cmF0aW9uXG4gKiBcbiAqIEBkZXNjcmlwdGlvblxuICogTGVnYWN5IHdyYXBwZXIgZnVuY3Rpb24gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBjb2RlLlxuICogTmV3IGNvZGUgc2hvdWxkIHVzZSB0aGUgT3Bwb25lbnRUdXJuTWFuYWdlciBjbGFzcyBkaXJlY3RseS5cbiAqIFxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIC8vIE9sZCB3YXkgKHN0aWxsIHdvcmtzIGJ1dCBkZXByZWNhdGVkKVxuICogc2NoZWR1bGVPcHBvbmVudFR1cm4oYXBpKTtcbiAqIFxuICogLy8gTmV3IHdheSAocmVjb21tZW5kZWQpXG4gKiBnZXRPcHBvbmVudFR1cm5NYW5hZ2VyKCkuc2NoZWR1bGUoYXBpKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2NoZWR1bGVPcHBvbmVudFR1cm4oXG4gIGFwaTogU3RvcmVBcGksXG4gIGRlbGF5PzogbnVtYmVyLFxuICBvcHRpb25zPzogeyBvbk9wcG9uZW50TW92ZUNvbXBsZXRlPzogKCkgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQgfVxuKTogdm9pZCB7XG4gIGdldE9wcG9uZW50VHVybk1hbmFnZXIoKS5zY2hlZHVsZShhcGksIGRlbGF5LCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDYW5jZWxzIHNjaGVkdWxlZCBvcHBvbmVudCB0dXJuIChiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdyYXBwZXIpXG4gKiBcbiAqIEBkZXByZWNhdGVkIFVzZSBnZXRPcHBvbmVudFR1cm5NYW5hZ2VyKCkuY2FuY2VsKCkgaW5zdGVhZFxuICogXG4gKiBAZGVzY3JpcHRpb25cbiAqIExlZ2FjeSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgY29kZS5cbiAqIE5ldyBjb2RlIHNob3VsZCB1c2UgdGhlIE9wcG9uZW50VHVybk1hbmFnZXIgY2xhc3MgZGlyZWN0bHkuXG4gKiBcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAvLyBPbGQgd2F5IChzdGlsbCB3b3JrcyBidXQgZGVwcmVjYXRlZClcbiAqIGNhbmNlbFNjaGVkdWxlZE9wcG9uZW50VHVybigpO1xuICogXG4gKiAvLyBOZXcgd2F5IChyZWNvbW1lbmRlZClcbiAqIGdldE9wcG9uZW50VHVybk1hbmFnZXIoKS5jYW5jZWwoKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FuY2VsU2NoZWR1bGVkT3Bwb25lbnRUdXJuKCk6IHZvaWQge1xuICBnZXRPcHBvbmVudFR1cm5NYW5hZ2VyKCkuY2FuY2VsKCk7XG59Il0sIm5hbWVzIjpbImNhbmNlbFNjaGVkdWxlZE9wcG9uZW50VHVybiIsImdldE9wcG9uZW50VHVybk1hbmFnZXIiLCJzY2hlZHVsZU9wcG9uZW50VHVybiIsIk9QUE9ORU5UX1RVUk5fREVMQVkiLCJPcHBvbmVudFR1cm5NYW5hZ2VyIiwiY2FuY2VsIiwiaXNDYW5jZWxsZWQiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidW5kZWZpbmVkIiwiZ2V0TG9nZ2VyIiwiZGVidWciLCJzY2hlZHVsZSIsImFwaSIsImRlbGF5Iiwib3B0aW9ucyIsImN1cnJlbnRTdGF0ZSIsImdldFN0YXRlIiwiaW5mbyIsImlzUGxheWVyVHVybiIsInRyYWluaW5nIiwiaXNPcHBvbmVudFRoaW5raW5nIiwiY3VycmVudEZlbiIsImNoZXNzU2VydmljZSIsImdldEZlbiIsImN1cnJlbnRUdXJuIiwidHVybiIsImNvbG9yVG9UcmFpbiIsImN1cnJlbnRQb3NpdGlvbiIsIndpbmRvdyIsInNldFRpbWVvdXQiLCJleGVjdXRlT3Bwb25lbnRUdXJuIiwib25PcHBvbmVudE1vdmVDb21wbGV0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwib25Db21wbGV0ZSIsInN0YXRlIiwic2V0U3RhdGUiLCJ0cmFpbmluZ0NvbG9yIiwid2FzQ2FuY2VsbGVkIiwid2FybiIsInRvcE1vdmVzIiwidGFibGViYXNlU2VydmljZSIsImdldFRvcE1vdmVzIiwiZmVuIiwibW92ZXNDb3VudCIsIm1vdmVzIiwibGVuZ3RoIiwibWFwIiwibSIsInNhbiIsImR0bSIsIndkbCIsImNhdGVnb3J5IiwiZmlyc3RNb3ZlIiwibm90ZSIsImlzQXZhaWxhYmxlIiwiZHJhZnQiLCJiZXN0TW92ZSIsInNlbGVjdE9wdGltYWxNb3ZlIiwibW92ZSIsIkVycm9yIiwiaXNHYW1lT3ZlciIsImhhbmRsZVRyYWluaW5nQ29tcGxldGlvbiIsImVycm9yIiwidXNlck1lc3NhZ2UiLCJFcnJvclNlcnZpY2UiLCJoYW5kbGVVSUVycm9yIiwiU3RyaW5nIiwiY29tcG9uZW50IiwiYWN0aW9uIiwidWkiLCJ0b2FzdHMiLCJwdXNoIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJtZXNzYWdlIiwidHlwZSIsImZvckVhY2giLCJzb3J0ZWRNb3ZlcyIsInNvcnQiLCJhIiwiYiIsIk1hdGgiLCJhYnMiLCJzZWxlY3RlZCIsImF2YWlsYWJsZU1vdmVzIiwic2VsZWN0ZWRNb3ZlIiwicmVhc29uIiwibWFuYWdlckluc3RhbmNlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUNDOzs7Ozs7Ozs7OztRQWllZUE7ZUFBQUE7O1FBdkRBQztlQUFBQTs7UUE2QkFDO2VBQUFBOzs7OEJBcGNhO2tDQUl0Qjs4QkFDc0I7Z0NBQ1k7eUJBQ2Y7Ozs7Ozs7Ozs7Ozs7O0FBRTFCLGtGQUFrRixHQUNsRixNQUFNQyxzQkFBc0I7QUFFNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0QsTUFBTUM7SUFJSjs7Ozs7Ozs7Ozs7Ozs7OztHQWdCQyxHQUNEQyxTQUFlO1FBQ2IsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsSUFBSSxJQUFJLENBQUNDLE9BQU8sRUFBRTtZQUNoQkMsYUFBYSxJQUFJLENBQUNELE9BQU87WUFDekIsSUFBSSxDQUFDQSxPQUFPLEdBQUdFO1lBQ2ZDLElBQUFBLGtCQUFTLElBQUdDLEtBQUssQ0FDZjtRQUVKLE9BQU87WUFDTEQsSUFBQUEsa0JBQVMsSUFBR0MsS0FBSyxDQUNmO1FBRUo7SUFDRjtJQUVBOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCQyxHQUNEQyxTQUNFQyxHQUFhLEVBQ2JDLFFBQWdCWCxtQkFBbUIsRUFDbkNZLE9BQWlFLEVBQzNEO1lBU1lDO1FBUmxCLE1BQU1BLGVBQWVILElBQUlJLFFBQVE7UUFDakNQLElBQUFBLGtCQUFTLElBQUdRLElBQUksQ0FDZCxDQUFDLDhEQUE4RCxFQUFFSixNQUFNLEVBQUUsQ0FBQyxFQUMxRTtZQUNFSyxjQUFjSCxhQUFhSSxRQUFRLENBQUNELFlBQVk7WUFDaERFLG9CQUFvQkwsYUFBYUksUUFBUSxDQUFDQyxrQkFBa0I7WUFDNURDLFlBQVlDLDBCQUFZLENBQUNDLE1BQU07WUFDL0JDLGFBQWFGLDBCQUFZLENBQUNHLElBQUk7WUFDOUJDLFlBQVksR0FBRVgseUNBQUFBLGFBQWFJLFFBQVEsQ0FBQ1EsZUFBZSxjQUFyQ1osNkRBQUFBLHVDQUF1Q1csWUFBWTtRQUNuRTtRQUdGLGdEQUFnRDtRQUNoRCxJQUFJLENBQUN0QixNQUFNO1FBRVgsdURBQXVEO1FBQ3ZELElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBRW5CLElBQUksT0FBT3VCLFdBQVcsYUFBYTtZQUNqQyxzREFBc0Q7WUFDdEQsSUFBSSxDQUFDdEIsT0FBTyxHQUFHdUIsV0FBVztnQkFDeEJwQixJQUFBQSxrQkFBUyxJQUFHQyxLQUFLLENBQ2Y7Z0JBR0YsbUNBQW1DO2dCQUNuQyxJQUFJLElBQUksQ0FBQ0wsV0FBVyxFQUFFO29CQUNwQkksSUFBQUEsa0JBQVMsSUFBR0MsS0FBSyxDQUNmO29CQUVGO2dCQUNGO2dCQUVBLHlFQUF5RTtnQkFDekUsTUFBTUssZUFBZUgsSUFBSUksUUFBUTtnQkFDakMsSUFBSUQsYUFBYUksUUFBUSxDQUFDRCxZQUFZLEVBQUU7b0JBQ3RDVCxJQUFBQSxrQkFBUyxJQUFHQyxLQUFLLENBQ2Y7b0JBRUY7Z0JBQ0Y7Z0JBRUFELElBQUFBLGtCQUFTLElBQUdDLEtBQUssQ0FBQztnQkFDbEIsTUFBTSxJQUFJLENBQUNvQixtQkFBbUIsQ0FBQ2xCLEtBQUtFLG9CQUFBQSw4QkFBQUEsUUFBU2lCLHNCQUFzQjtnQkFFbkUsOENBQThDO2dCQUM5QyxJQUFJLENBQUN6QixPQUFPLEdBQUdFO1lBQ2pCLEdBQUdLO1FBQ0wsT0FBTztZQUNMLGdEQUFnRDtZQUMvQyxDQUFBO2dCQUNDLE1BQU0sSUFBSW1CLFFBQVEsQ0FBQ0MsVUFBWUosV0FBV0ksU0FBU3BCO2dCQUNuRCxJQUFJLENBQUMsSUFBSSxDQUFDUixXQUFXLEVBQUU7b0JBQ3JCLE1BQU0sSUFBSSxDQUFDeUIsbUJBQW1CLENBQUNsQixLQUFLRSxvQkFBQUEsOEJBQUFBLFFBQVNpQixzQkFBc0I7Z0JBQ3JFO1lBQ0YsQ0FBQTtRQUNGO0lBQ0Y7SUFFQTs7Ozs7Ozs7Ozs7R0FXQyxHQUNELE1BQWNELG9CQUNabEIsR0FBYSxFQUNic0IsVUFBdUMsRUFDeEI7WUFVRUM7UUFUakIsTUFBTSxFQUFFbkIsUUFBUSxFQUFFb0IsUUFBUSxFQUFFLEdBQUd4QjtRQUUvQixvREFBb0Q7UUFDcEQsTUFBTXVCLFFBQVFuQjtRQUNkUCxJQUFBQSxrQkFBUyxJQUFHUSxJQUFJLENBQUMsd0RBQXdEO1lBQ3ZFQyxjQUFjaUIsTUFBTWhCLFFBQVEsQ0FBQ0QsWUFBWTtZQUN6Q0Usb0JBQW9CZSxNQUFNaEIsUUFBUSxDQUFDQyxrQkFBa0I7WUFDckRDLFlBQVlDLDBCQUFZLENBQUNDLE1BQU07WUFDL0JDLGFBQWFGLDBCQUFZLENBQUNHLElBQUk7WUFDOUJZLGFBQWEsR0FBRUYsa0NBQUFBLE1BQU1oQixRQUFRLENBQUNRLGVBQWUsY0FBOUJRLHNEQUFBQSxnQ0FBZ0NULFlBQVk7WUFDM0RZLGNBQWMsSUFBSSxDQUFDakMsV0FBVztRQUNoQztRQUVBLGdDQUFnQztRQUNoQyxJQUFJLElBQUksQ0FBQ0EsV0FBVyxFQUFFO1lBQ3BCSSxJQUFBQSxrQkFBUyxJQUFHOEIsSUFBSSxDQUFDO1lBQ2pCO1FBQ0Y7UUFFQSwwQ0FBMEM7UUFDMUMsSUFBSUosTUFBTWhCLFFBQVEsQ0FBQ0QsWUFBWSxFQUFFO1lBQy9CVCxJQUFBQSxrQkFBUyxJQUFHOEIsSUFBSSxDQUFDO1lBQ2pCOUIsSUFBQUEsa0JBQVMsSUFBRzhCLElBQUksQ0FBQztZQUNqQjtRQUNGO1FBRUEsSUFBSTtnQkFZY0MsaUJBQ0xBLGtCQU1JQTtZQWxCZix1QkFBdUI7WUFDdkIsTUFBTW5CLGFBQWFDLDBCQUFZLENBQUNDLE1BQU07WUFFdEMsa0VBQWtFO1lBQ2xFLHFFQUFxRTtZQUNyRSxNQUFNaUIsV0FBVyxNQUFNQyxrQ0FBZ0IsQ0FBQ0MsV0FBVyxDQUFDckIsWUFBWTtZQUVoRVosSUFBQUEsa0JBQVMsSUFBR1EsSUFBSSxDQUNkLDhEQUNBO2dCQUNFMEIsS0FBS3RCO2dCQUNMdUIsWUFBWUosRUFBQUEsa0JBQUFBLFNBQVNLLEtBQUssY0FBZEwsc0NBQUFBLGdCQUFnQk0sTUFBTSxLQUFJO2dCQUN0Q0QsS0FBSyxHQUFFTCxtQkFBQUEsU0FBU0ssS0FBSyxjQUFkTCx1Q0FBQUEsaUJBQWdCTyxHQUFHLENBQUMsQ0FBQ0MsSUFBTyxDQUFBO3dCQUNqQ0MsS0FBS0QsRUFBRUMsR0FBRzt3QkFDVkMsS0FBS0YsRUFBRUUsR0FBRzt3QkFDVkMsS0FBS0gsRUFBRUcsR0FBRzt3QkFDVkMsVUFBVUosRUFBRUksUUFBUTtvQkFDdEIsQ0FBQTtnQkFDQUMsV0FBV2IsRUFBQUEsbUJBQUFBLFNBQVNLLEtBQUssY0FBZEwsdUNBQUFBLGdCQUFnQixDQUFDLEVBQUUsSUFDMUI7b0JBQ0VTLEtBQUtULFNBQVNLLEtBQUssQ0FBQyxFQUFFLENBQUNJLEdBQUc7b0JBQzFCQyxLQUFLVixTQUFTSyxLQUFLLENBQUMsRUFBRSxDQUFDSyxHQUFHO29CQUMxQkksTUFBTTtnQkFDUixJQUNBO1lBQ047WUFHRixJQUNFLENBQUNkLFNBQVNlLFdBQVcsSUFDckIsQ0FBQ2YsU0FBU0ssS0FBSyxJQUNmTCxTQUFTSyxLQUFLLENBQUNDLE1BQU0sS0FBSyxHQUMxQjtnQkFDQSw4REFBOEQ7Z0JBQzlEVixTQUFTLENBQUNvQjtvQkFDUkEsTUFBTXJDLFFBQVEsQ0FBQ0QsWUFBWSxHQUFHO29CQUM5QnNDLE1BQU1yQyxRQUFRLENBQUNDLGtCQUFrQixHQUFHO2dCQUN0QztnQkFDQTtZQUNGO1lBRUEsZ0RBQWdEO1lBQ2hELG9EQUFvRDtZQUNwRCwwQkFBMEI7WUFDMUIsMkRBQTJEO1lBQzNELDJFQUEyRTtZQUMzRSw2Q0FBNkM7WUFDN0MsTUFBTXFDLFdBQVdDLGtCQUFrQmxCLFNBQVNLLEtBQUs7WUFFakQscUVBQXFFO1lBQ3JFLE1BQU1jLE9BQU9yQywwQkFBWSxDQUFDcUMsSUFBSSxDQUFDRixTQUFTUixHQUFHO1lBQzNDLElBQUksQ0FBQ1UsTUFBTTtnQkFDVCxNQUFNLElBQUlDLE1BQU0sQ0FBQyxrQ0FBa0MsRUFBRUgsU0FBU1IsR0FBRyxFQUFFO1lBQ3JFO1lBRUEsOENBQThDO1lBQzlDYixTQUFTLENBQUNvQjtnQkFDUkEsTUFBTXJDLFFBQVEsQ0FBQ0QsWUFBWSxHQUFHO2dCQUM5QnNDLE1BQU1yQyxRQUFRLENBQUNDLGtCQUFrQixHQUFHO1lBRXBDLHlEQUF5RDtZQUMzRDtZQUVBLDBDQUEwQztZQUMxQyxJQUFJRSwwQkFBWSxDQUFDdUMsVUFBVSxJQUFJO2dCQUM3QixNQUFNQyxJQUFBQSx3Q0FBd0IsRUFBQ2xELEtBQUssUUFBUSxvQkFBb0I7WUFDbEU7WUFFQSx1Q0FBdUM7WUFDdkMsSUFBSXNCLFlBQVk7Z0JBQ2QsSUFBSTtvQkFDRixNQUFNQTtvQkFDTnpCLElBQUFBLGtCQUFTLElBQUdDLEtBQUssQ0FBQztnQkFDcEIsRUFBRSxPQUFPcUQsT0FBTztvQkFDZHRELElBQUFBLGtCQUFTLElBQUdzRCxLQUFLLENBQUMscURBQXFEQTtnQkFDekU7WUFDRjtRQUNGLEVBQUUsT0FBT0EsT0FBTztZQUNkLDhCQUE4QjtZQUM5QixNQUFNQyxjQUFjQywwQkFBWSxDQUFDQyxhQUFhLENBQzVDSCxpQkFBaUJILFFBQVFHLFFBQVEsSUFBSUgsTUFBTU8sT0FBT0osU0FDbEQsZ0JBQ0E7Z0JBQ0VLLFdBQVc7Z0JBQ1hDLFFBQVE7WUFDVjtZQUdGakMsU0FBUyxDQUFDb0I7Z0JBQ1JBLE1BQU1jLEVBQUUsQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUM7b0JBQ25CQyxJQUFJQyxLQUFLQyxHQUFHLEdBQUdDLFFBQVE7b0JBQ3ZCQyxTQUFTYjtvQkFDVGMsTUFBTTtnQkFDUjtnQkFDQSwwREFBMEQ7Z0JBQzFEdEIsTUFBTXJDLFFBQVEsQ0FBQ0QsWUFBWSxHQUFHO2dCQUM5QnNDLE1BQU1yQyxRQUFRLENBQUNDLGtCQUFrQixHQUFHO1lBQ3RDO1FBQ0Y7SUFDRjs7UUFwUUEsdUJBQVFkLFdBQVIsS0FBQTtRQUNBLHVCQUFRRCxlQUFjOztBQW9ReEI7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBOEJDLEdBQ0QsU0FBU3FELGtCQUFrQmIsS0FBc0I7SUFDL0MseUNBQXlDO0lBQ3pDQSxNQUFNa0MsT0FBTyxDQUFDLENBQUNwQjtRQUNiLElBQUlBLEtBQUtSLEdBQUcsR0FBRyxLQUFLUSxLQUFLVCxHQUFHLElBQUlTLEtBQUtULEdBQUcsR0FBRyxHQUFHO1lBQzVDekMsSUFBQUEsa0JBQVMsSUFBRzhCLElBQUksQ0FDZCxtRUFDQTtnQkFDRVUsS0FBS1UsS0FBS1YsR0FBRztnQkFDYkUsS0FBS1EsS0FBS1IsR0FBRztnQkFDYkQsS0FBS1MsS0FBS1QsR0FBRztnQkFDYkUsVUFBVU8sS0FBS1AsUUFBUTtZQUN6QjtRQUVKO0lBQ0Y7SUFFQSxpQ0FBaUM7SUFDakMsTUFBTTRCLGNBQWM7V0FBSW5DO0tBQU0sQ0FBQ29DLElBQUksQ0FBQyxDQUFDQyxHQUFHQztRQUN0Qyx5REFBeUQ7UUFDekQsSUFBSUQsRUFBRS9CLEdBQUcsS0FBS2dDLEVBQUVoQyxHQUFHLEVBQUU7WUFDbkIsT0FBT2dDLEVBQUVoQyxHQUFHLEdBQUcrQixFQUFFL0IsR0FBRyxFQUFFLHFDQUFxQztRQUM3RDtRQUVBLG9EQUFvRDtRQUNwRCxJQUNFK0IsRUFBRWhDLEdBQUcsS0FBSyxRQUNWZ0MsRUFBRWhDLEdBQUcsS0FBSzFDLGFBQ1YyRSxFQUFFakMsR0FBRyxLQUFLLFFBQ1ZpQyxFQUFFakMsR0FBRyxLQUFLMUMsV0FDVjtZQUNBLE9BQU8sR0FBRyxrQ0FBa0M7UUFDOUM7UUFFQSxtQ0FBbUM7UUFDbkMsSUFBSTBFLEVBQUUvQixHQUFHLEdBQUcsR0FBRztZQUNiLGdFQUFnRTtZQUNoRSw2RUFBNkU7WUFDN0UsT0FBT2lDLEtBQUtDLEdBQUcsQ0FBQ0YsRUFBRWpDLEdBQUcsSUFBSWtDLEtBQUtDLEdBQUcsQ0FBQ0gsRUFBRWhDLEdBQUcsR0FBRyxzQ0FBc0M7UUFDbEYsT0FBTyxJQUFJZ0MsRUFBRS9CLEdBQUcsR0FBRyxHQUFHO1lBQ3BCLG9FQUFvRTtZQUNwRSw2QkFBNkI7WUFDN0IsaUVBQWlFO1lBQ2pFLE9BQU9pQyxLQUFLQyxHQUFHLENBQUNGLEVBQUVqQyxHQUFHLElBQUlrQyxLQUFLQyxHQUFHLENBQUNILEVBQUVoQyxHQUFHO1FBQ3pDLE9BQU87WUFDTCw2QkFBNkI7WUFDN0IsT0FBTztRQUNUO0lBQ0Y7SUFFQSxNQUFNb0MsV0FBV04sV0FBVyxDQUFDLEVBQUU7SUFFL0IsaUNBQWlDO0lBQ2pDdkUsSUFBQUEsa0JBQVMsSUFBR1EsSUFBSSxDQUFDLHlDQUF5QztRQUN4RHNFLGdCQUFnQjFDLE1BQU1FLEdBQUcsQ0FBQyxDQUFDQyxJQUFPLENBQUE7Z0JBQ2hDQyxLQUFLRCxFQUFFQyxHQUFHO2dCQUNWRSxLQUFLSCxFQUFFRyxHQUFHO2dCQUNWRCxLQUFLRixFQUFFRSxHQUFHO2dCQUNWRSxVQUFVSixFQUFFSSxRQUFRO1lBQ3RCLENBQUE7UUFDQW9DLGNBQWM7WUFDWnZDLEtBQUtxQyxTQUFTckMsR0FBRztZQUNqQkUsS0FBS21DLFNBQVNuQyxHQUFHO1lBQ2pCRCxLQUFLb0MsU0FBU3BDLEdBQUc7WUFDakJFLFVBQVVrQyxTQUFTbEMsUUFBUTtRQUM3QjtRQUNBcUMsUUFDRUgsU0FBU25DLEdBQUcsR0FBRyxJQUNYLENBQUMsK0JBQStCLEVBQUVpQyxLQUFLQyxHQUFHLENBQUNDLFNBQVNwQyxHQUFHLElBQUksR0FBRyxNQUFNLENBQUMsR0FDckVvQyxTQUFTbkMsR0FBRyxHQUFHLElBQ2IsQ0FBQyxzQkFBc0IsRUFBRWlDLEtBQUtDLEdBQUcsQ0FBQ0MsU0FBU3BDLEdBQUcsSUFBSSxHQUFHLE1BQU0sQ0FBQyxHQUM1RDtJQUNWO0lBRUEsT0FBT29DO0FBQ1Q7QUFFQSxrRUFBa0U7QUFDbEUsSUFBSUksa0JBQThDO0FBa0IzQyxTQUFTMUY7SUFDZCxJQUFJLENBQUMwRixpQkFBaUI7UUFDcEJBLGtCQUFrQixJQUFJdkY7SUFDeEI7SUFDQSxPQUFPdUY7QUFDVDtBQXdCTyxTQUFTekYscUJBQ2RXLEdBQWEsRUFDYkMsS0FBYyxFQUNkQyxPQUFpRTtJQUVqRWQseUJBQXlCVyxRQUFRLENBQUNDLEtBQUtDLE9BQU9DO0FBQ2hEO0FBb0JPLFNBQVNmO0lBQ2RDLHlCQUF5QkksTUFBTTtBQUNqQyJ9