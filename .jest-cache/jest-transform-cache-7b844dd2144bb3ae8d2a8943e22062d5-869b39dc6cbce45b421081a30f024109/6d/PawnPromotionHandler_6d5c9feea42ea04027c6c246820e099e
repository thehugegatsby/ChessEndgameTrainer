2926090e107944a975618051f11c4407
/**
 * @file Pawn promotion handler module
 * @module store/orchestrators/handlePlayerMove/PawnPromotionHandler
 *
 * @description
 * Comprehensive pawn promotion management for chess endgame training.
 * Handles detection, evaluation, auto-win scenarios, and future UI integration
 * with sophisticated tablebase analysis for optimal training feedback.
 *
 * @remarks
 * **Core Functionality:**
 * - Detects pawn promotion moves using chess.js flags and properties
 * - Evaluates promotion outcomes using tablebase analysis
 * - Identifies auto-win scenarios for immediate training completion
 * - Provides foundation for future promotion choice UI
 *
 * **Tablebase Integration:**
 * - WDL perspective conversion for accurate player evaluation
 * - Category analysis (mate, win) for auto-win detection
 * - Error resilient evaluation with graceful fallbacks
 *
 * **Training Flow Integration:**
 * - Seamless integration with move orchestration
 * - Automatic training completion for winning promotions
 * - User feedback through German localized messages
 *
 * **Future Extensibility:**
 * - Designed for promotion choice UI implementation
 * - Supports all promotion pieces (Q, R, N, B)
 * - Modular architecture for easy UI integration
 *
 * @example
 * ```typescript
 * const promotionHandler = new PawnPromotionHandler();
 *
 * // Check if move involves promotion
 * const promotionInfo = promotionHandler.checkPromotion(validatedMove);
 * if (promotionInfo.isPromotion) {
 *   // Evaluate if promotion leads to auto-win
 *   const isAutoWin = await promotionHandler.evaluatePromotionOutcome(
 *     fenAfter,
 *     validatedMove.color
 *   );
 *
 *   if (isAutoWin) {
 *     await promotionHandler.handleAutoWin(api, { ...promotionInfo, isAutoWin: true });
 *   }
 * }
 * ```
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get PROMOTION_CHOICES () {
        return PROMOTION_CHOICES;
    },
    get PawnPromotionHandler () {
        return PawnPromotionHandler;
    }
});
const _ChessService = require("../../../services/ChessService");
const _TablebaseService = require("../../../services/TablebaseService");
const _logging = require("../../../services/logging");
const _movecompletion = require("./move.completion");
const PROMOTION_CHOICES = [
    {
        piece: "q",
        label: "Dame",
        description: "Stärkste Figur - kann in alle Richtungen ziehen"
    },
    {
        piece: "r",
        label: "Turm",
        description: "Zieht horizontal und vertikal"
    },
    {
        piece: "n",
        label: "Springer",
        description: "Zieht in L-Form, kann über Figuren springen"
    },
    {
        piece: "b",
        label: "Läufer",
        description: "Zieht diagonal"
    }
];
class PawnPromotionHandler {
    /**
   * Checks if a move involves pawn promotion
   *
   * @param move - The validated move that was executed
   * @returns Promotion information
   */ checkPromotion(move) {
        // chess.js sets the 'promotion' property in the move object
        // and flags contain 'p' for promotion
        const isPromotion = move.flags && move.flags.includes("p");
        if (!isPromotion) {
            return {
                isPromotion: false
            };
        }
        (0, _logging.getLogger)().debug("[PawnPromotion] Promotion detected:", {
            from: move.from,
            to: move.to,
            piece: move.piece,
            promotion: move.promotion,
            flags: move.flags
        });
        // Validate promotion piece type
        const promotionPiece = this.isValidPromotionPiece(move.promotion) ? move.promotion : undefined;
        return {
            isPromotion: true,
            promotionPiece,
            from: move.from,
            to: move.to,
            isAutoWin: false,
            moveDescription: move.san
        };
    }
    /**
   * Evaluates if a promotion leads to an immediate win
   *
   * @param currentFen - FEN position after promotion
   * @param promotingColor - Color of the player who promoted ('w' or 'b')
   * @returns Promise<boolean> - True if promotion leads to auto-win
   */ async evaluatePromotionOutcome(currentFen, promotingColor) {
        try {
            // Basic FEN validation
            if (!currentFen || !currentFen.includes(" ")) {
                (0, _logging.getLogger)().warn("[PawnPromotion] Invalid FEN format:", currentFen);
                return false;
            }
            // Check if game is immediately over after promotion
            if (_ChessService.chessService.isGameOver()) {
                const isCheckmate = _ChessService.chessService.isCheckmate();
                (0, _logging.getLogger)().debug("[PawnPromotion] Game over after promotion:", {
                    isCheckmate,
                    fen: currentFen.split(" ")[0]
                });
                return isCheckmate; // Checkmate = auto-win
            }
            // Use tablebase to evaluate the resulting position
            const evaluation = await _TablebaseService.tablebaseService.getEvaluation(currentFen).catch(()=>({
                    isAvailable: false
                }));
            if (evaluation.isAvailable && "result" in evaluation && evaluation.result && "wdl" in evaluation.result && typeof evaluation.result.wdl === "number") {
                // Check if promotion created a winning position from promoting player's perspective
                // WDL is from white's perspective: positive = good for white, negative = good for black
                const wdlFromPromotingPlayerPerspective = promotingColor === "w" ? evaluation.result.wdl : -evaluation.result.wdl;
                const isWinning = wdlFromPromotingPlayerPerspective > 0;
                (0, _logging.getLogger)().debug("[PawnPromotion] Tablebase evaluation:", {
                    wdl: evaluation.result.wdl,
                    wdlFromPromotingPlayerPerspective,
                    promotingColor,
                    category: evaluation.result.category,
                    isWinning,
                    fen: currentFen.split(" ")[0]
                });
                // Consider it an auto-win if it's a forced mate or other winning category
                // Categories like 'mate', 'win', etc. indicate definitive winning scenarios
                const category = evaluation.result.category;
                const isAutoWinCategory = !!(category && typeof category === "string" && (category.includes("mate") || category.includes("win")));
                return isWinning && isAutoWinCategory;
            }
            return false;
        } catch (error) {
            (0, _logging.getLogger)().error("[PawnPromotion] Error evaluating promotion outcome:", error);
            return false;
        }
    }
    /**
   * Handles auto-win scenario after promotion
   *
   * @param api - Store API for state updates
   * @param promotionInfo - Information about the promotion
   */ async handleAutoWin(api, promotionInfo) {
        (0, _logging.getLogger)().info("[PawnPromotion] Auto-win detected - completing training session");
        const { setState } = api;
        // Show celebration dialog instead of toast
        const promotionPieceLabel = promotionInfo.promotionPiece ? this.getPromotionPieceLabel(promotionInfo.promotionPiece) : "Dame"; // Default to queen if undefined
        setState((draft)=>{
            draft.training.moveSuccessDialog = {
                isOpen: true,
                promotionPiece: promotionPieceLabel,
                moveDescription: promotionInfo.moveDescription
            };
        });
        // Complete training session as won
        await (0, _movecompletion.handleTrainingCompletion)(api, true);
    }
    /**
   * Shows promotion choice dialog (for future UI implementation)
   *
   * @param api - Store API for state updates
   * @param from - Source square (e.g., "e7")
   * @param to - Target square (e.g., "e8")
   * @param callback - Callback to execute with chosen piece
   */ showPromotionDialog(api, from, to, callback) {
        (0, _logging.getLogger)().debug("[PawnPromotion] Showing promotion dialog:", {
            from,
            to
        });
        const { setState } = api;
        // For now, just auto-promote to queen and call callback
        // TODO: Implement actual promotion choice UI
        const chosenPiece = "q";
        setState((draft)=>{
            draft.ui.toasts.push({
                id: Date.now().toString(),
                message: `Bauernumwandlung: ${from}-${to} → Dame`,
                type: "info"
            });
        });
        callback(chosenPiece);
    }
    /**
   * Validates promotion piece choice
   *
   * @param piece - Promotion piece character (can be undefined)
   * @returns True if valid promotion piece
   */ isValidPromotionPiece(piece) {
        return typeof piece === "string" && [
            "q",
            "r",
            "n",
            "b"
        ].includes(piece);
    }
    /**
   * Gets promotion piece label for UI display
   *
   * @param piece - Promotion piece character
   * @returns German label for the piece
   */ getPromotionPieceLabel(piece) {
        const choice = PROMOTION_CHOICES.find((c)=>c.piece === piece);
        return (choice === null || choice === void 0 ? void 0 : choice.label) || piece.toUpperCase();
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvc2hhcmVkL3N0b3JlL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZS9QYXduUHJvbW90aW9uSGFuZGxlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFBhd24gcHJvbW90aW9uIGhhbmRsZXIgbW9kdWxlXG4gKiBAbW9kdWxlIHN0b3JlL29yY2hlc3RyYXRvcnMvaGFuZGxlUGxheWVyTW92ZS9QYXduUHJvbW90aW9uSGFuZGxlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogQ29tcHJlaGVuc2l2ZSBwYXduIHByb21vdGlvbiBtYW5hZ2VtZW50IGZvciBjaGVzcyBlbmRnYW1lIHRyYWluaW5nLlxuICogSGFuZGxlcyBkZXRlY3Rpb24sIGV2YWx1YXRpb24sIGF1dG8td2luIHNjZW5hcmlvcywgYW5kIGZ1dHVyZSBVSSBpbnRlZ3JhdGlvblxuICogd2l0aCBzb3BoaXN0aWNhdGVkIHRhYmxlYmFzZSBhbmFseXNpcyBmb3Igb3B0aW1hbCB0cmFpbmluZyBmZWVkYmFjay5cbiAqXG4gKiBAcmVtYXJrc1xuICogKipDb3JlIEZ1bmN0aW9uYWxpdHk6KipcbiAqIC0gRGV0ZWN0cyBwYXduIHByb21vdGlvbiBtb3ZlcyB1c2luZyBjaGVzcy5qcyBmbGFncyBhbmQgcHJvcGVydGllc1xuICogLSBFdmFsdWF0ZXMgcHJvbW90aW9uIG91dGNvbWVzIHVzaW5nIHRhYmxlYmFzZSBhbmFseXNpc1xuICogLSBJZGVudGlmaWVzIGF1dG8td2luIHNjZW5hcmlvcyBmb3IgaW1tZWRpYXRlIHRyYWluaW5nIGNvbXBsZXRpb25cbiAqIC0gUHJvdmlkZXMgZm91bmRhdGlvbiBmb3IgZnV0dXJlIHByb21vdGlvbiBjaG9pY2UgVUlcbiAqXG4gKiAqKlRhYmxlYmFzZSBJbnRlZ3JhdGlvbjoqKlxuICogLSBXREwgcGVyc3BlY3RpdmUgY29udmVyc2lvbiBmb3IgYWNjdXJhdGUgcGxheWVyIGV2YWx1YXRpb25cbiAqIC0gQ2F0ZWdvcnkgYW5hbHlzaXMgKG1hdGUsIHdpbikgZm9yIGF1dG8td2luIGRldGVjdGlvblxuICogLSBFcnJvciByZXNpbGllbnQgZXZhbHVhdGlvbiB3aXRoIGdyYWNlZnVsIGZhbGxiYWNrc1xuICpcbiAqICoqVHJhaW5pbmcgRmxvdyBJbnRlZ3JhdGlvbjoqKlxuICogLSBTZWFtbGVzcyBpbnRlZ3JhdGlvbiB3aXRoIG1vdmUgb3JjaGVzdHJhdGlvblxuICogLSBBdXRvbWF0aWMgdHJhaW5pbmcgY29tcGxldGlvbiBmb3Igd2lubmluZyBwcm9tb3Rpb25zXG4gKiAtIFVzZXIgZmVlZGJhY2sgdGhyb3VnaCBHZXJtYW4gbG9jYWxpemVkIG1lc3NhZ2VzXG4gKlxuICogKipGdXR1cmUgRXh0ZW5zaWJpbGl0eToqKlxuICogLSBEZXNpZ25lZCBmb3IgcHJvbW90aW9uIGNob2ljZSBVSSBpbXBsZW1lbnRhdGlvblxuICogLSBTdXBwb3J0cyBhbGwgcHJvbW90aW9uIHBpZWNlcyAoUSwgUiwgTiwgQilcbiAqIC0gTW9kdWxhciBhcmNoaXRlY3R1cmUgZm9yIGVhc3kgVUkgaW50ZWdyYXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgcHJvbW90aW9uSGFuZGxlciA9IG5ldyBQYXduUHJvbW90aW9uSGFuZGxlcigpO1xuICpcbiAqIC8vIENoZWNrIGlmIG1vdmUgaW52b2x2ZXMgcHJvbW90aW9uXG4gKiBjb25zdCBwcm9tb3Rpb25JbmZvID0gcHJvbW90aW9uSGFuZGxlci5jaGVja1Byb21vdGlvbih2YWxpZGF0ZWRNb3ZlKTtcbiAqIGlmIChwcm9tb3Rpb25JbmZvLmlzUHJvbW90aW9uKSB7XG4gKiAgIC8vIEV2YWx1YXRlIGlmIHByb21vdGlvbiBsZWFkcyB0byBhdXRvLXdpblxuICogICBjb25zdCBpc0F1dG9XaW4gPSBhd2FpdCBwcm9tb3Rpb25IYW5kbGVyLmV2YWx1YXRlUHJvbW90aW9uT3V0Y29tZShcbiAqICAgICBmZW5BZnRlcixcbiAqICAgICB2YWxpZGF0ZWRNb3ZlLmNvbG9yXG4gKiAgICk7XG4gKlxuICogICBpZiAoaXNBdXRvV2luKSB7XG4gKiAgICAgYXdhaXQgcHJvbW90aW9uSGFuZGxlci5oYW5kbGVBdXRvV2luKGFwaSwgeyAuLi5wcm9tb3Rpb25JbmZvLCBpc0F1dG9XaW46IHRydWUgfSk7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5cbmltcG9ydCB0eXBlIHsgVmFsaWRhdGVkTW92ZSB9IGZyb20gXCJAc2hhcmVkL3R5cGVzL2NoZXNzXCI7XG5pbXBvcnQgeyBjaGVzc1NlcnZpY2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9DaGVzc1NlcnZpY2VcIjtcbmltcG9ydCB7IHRhYmxlYmFzZVNlcnZpY2UgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9UYWJsZWJhc2VTZXJ2aWNlXCI7XG5pbXBvcnQgeyBnZXRMb2dnZXIgfSBmcm9tIFwiQHNoYXJlZC9zZXJ2aWNlcy9sb2dnaW5nXCI7XG5pbXBvcnQgdHlwZSB7IFN0b3JlQXBpIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5pbXBvcnQgeyBoYW5kbGVUcmFpbmluZ0NvbXBsZXRpb24gfSBmcm9tIFwiLi9tb3ZlLmNvbXBsZXRpb25cIjtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCBhIHBhd24gcHJvbW90aW9uIG1vdmVcbiAqIEBpbnRlcmZhY2UgUHJvbW90aW9uSW5mb1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFByb21vdGlvbkluZm8ge1xuICAvKiogV2hldGhlciB0aGUgbW92ZSBpbnZvbHZlcyBwYXduIHByb21vdGlvbiAqL1xuICBpc1Byb21vdGlvbjogYm9vbGVhbjtcbiAgLyoqIFRoZSBwaWVjZSB0aGUgcGF3biB3YXMgcHJvbW90ZWQgdG8gKi9cbiAgcHJvbW90aW9uUGllY2U/OiBcInFcIiB8IFwiclwiIHwgXCJuXCIgfCBcImJcIjtcbiAgLyoqIFNvdXJjZSBzcXVhcmUgb2YgdGhlIHByb21vdGluZyBwYXduICovXG4gIGZyb20/OiBzdHJpbmc7XG4gIC8qKiBUYXJnZXQgc3F1YXJlIHdoZXJlIHByb21vdGlvbiBvY2N1cnMgKi9cbiAgdG8/OiBzdHJpbmc7XG4gIC8qKiBXaGV0aGVyIHByb21vdGlvbiBsZWFkcyB0byBpbW1lZGlhdGUgd2luICovXG4gIGlzQXV0b1dpbj86IGJvb2xlYW47XG4gIC8qKiBNb3ZlIGRlc2NyaXB0aW9uIGZvciBkaXNwbGF5IHB1cnBvc2VzICovXG4gIG1vdmVEZXNjcmlwdGlvbj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBBdmFpbGFibGUgcHJvbW90aW9uIGNob2ljZSB3aXRoIEdlcm1hbiBsb2NhbGl6YXRpb25cbiAqIEBpbnRlcmZhY2UgUHJvbW90aW9uQ2hvaWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJvbW90aW9uQ2hvaWNlIHtcbiAgLyoqIFNpbmdsZSBjaGFyYWN0ZXIgcGllY2UgaWRlbnRpZmllciAqL1xuICBwaWVjZTogXCJxXCIgfCBcInJcIiB8IFwiblwiIHwgXCJiXCI7XG4gIC8qKiBHZXJtYW4gbGFiZWwgZm9yIHRoZSBwaWVjZSAqL1xuICBsYWJlbDogc3RyaW5nO1xuICAvKiogR2VybWFuIGRlc2NyaXB0aW9uIG9mIHBpZWNlIGNhcGFiaWxpdGllcyAqL1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG4vKipcbiAqIENvbXBsZXRlIHNldCBvZiBwcm9tb3Rpb24gcGllY2VzIHdpdGggR2VybWFuIGxvY2FsaXphdGlvblxuICogQGNvbnN0YW50IFBST01PVElPTl9DSE9JQ0VTXG4gKiBAZGVzY3JpcHRpb24gUHJvdmlkZXMgdXNlci1mcmllbmRseSBHZXJtYW4gbGFiZWxzIGFuZCBkZXNjcmlwdGlvbnMgZm9yIGFsbCBwcm9tb3Rpb24gcGllY2VzXG4gKi9cbmV4cG9ydCBjb25zdCBQUk9NT1RJT05fQ0hPSUNFUzogUHJvbW90aW9uQ2hvaWNlW10gPSBbXG4gIHtcbiAgICBwaWVjZTogXCJxXCIsXG4gICAgbGFiZWw6IFwiRGFtZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlN0w6Rya3N0ZSBGaWd1ciAtIGthbm4gaW4gYWxsZSBSaWNodHVuZ2VuIHppZWhlblwiLFxuICB9LFxuICB7IHBpZWNlOiBcInJcIiwgbGFiZWw6IFwiVHVybVwiLCBkZXNjcmlwdGlvbjogXCJaaWVodCBob3Jpem9udGFsIHVuZCB2ZXJ0aWthbFwiIH0sXG4gIHtcbiAgICBwaWVjZTogXCJuXCIsXG4gICAgbGFiZWw6IFwiU3ByaW5nZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaaWVodCBpbiBMLUZvcm0sIGthbm4gw7xiZXIgRmlndXJlbiBzcHJpbmdlblwiLFxuICB9LFxuICB7IHBpZWNlOiBcImJcIiwgbGFiZWw6IFwiTMOkdWZlclwiLCBkZXNjcmlwdGlvbjogXCJaaWVodCBkaWFnb25hbFwiIH0sXG5dO1xuXG4vKipcbiAqIEFkdmFuY2VkIHBhd24gcHJvbW90aW9uIGhhbmRsZXIgd2l0aCB0YWJsZWJhc2UgaW50ZWdyYXRpb25cbiAqIEBjbGFzcyBQYXduUHJvbW90aW9uSGFuZGxlclxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogTWFuYWdlcyBhbGwgYXNwZWN0cyBvZiBwYXduIHByb21vdGlvbiBpbiBjaGVzcyBlbmRnYW1lIHRyYWluaW5nOlxuICpcbiAqICoqRGV0ZWN0aW9uICYgQW5hbHlzaXM6KipcbiAqIC0gSWRlbnRpZmllcyBwcm9tb3Rpb24gbW92ZXMgdXNpbmcgY2hlc3MuanMgbW92ZSBmbGFnc1xuICogLSBWYWxpZGF0ZXMgcHJvbW90aW9uIHBpZWNlIHR5cGVzXG4gKiAtIEV4dHJhY3RzIG1vdmUgY29vcmRpbmF0ZXMgZm9yIFVJIGRpc3BsYXlcbiAqXG4gKiAqKk91dGNvbWUgRXZhbHVhdGlvbjoqKlxuICogLSBVc2VzIHRhYmxlYmFzZSBhbmFseXNpcyB0byBldmFsdWF0ZSBwcm9tb3Rpb24gcmVzdWx0c1xuICogLSBDb252ZXJ0cyBXREwgdmFsdWVzIHRvIHBsYXllciBwZXJzcGVjdGl2ZSBmb3IgYWNjdXJhdGUgYXNzZXNzbWVudFxuICogLSBEZXRlY3RzIGF1dG8td2luIHNjZW5hcmlvcyAoZm9yY2VkIG1hdGUsIHdpbm5pbmcgcG9zaXRpb25zKVxuICogLSBIYW5kbGVzIGltbWVkaWF0ZSBjaGVja21hdGUgZGV0ZWN0aW9uXG4gKlxuICogKipUcmFpbmluZyBJbnRlZ3JhdGlvbjoqKlxuICogLSBUcmlnZ2VycyBhdXRvbWF0aWMgdHJhaW5pbmcgY29tcGxldGlvbiBmb3Igd2lubmluZyBwcm9tb3Rpb25zXG4gKiAtIFByb3ZpZGVzIHVzZXIgZmVlZGJhY2sgdGhyb3VnaCBsb2NhbGl6ZWQgbWVzc2FnZXNcbiAqIC0gSW50ZWdyYXRlcyBzZWFtbGVzc2x5IHdpdGggbW92ZSBvcmNoZXN0cmF0aW9uIGZsb3dcbiAqXG4gKiAqKkZ1dHVyZSBVSSBTdXBwb3J0OioqXG4gKiAtIEZvdW5kYXRpb24gZm9yIHByb21vdGlvbiBjaG9pY2UgZGlhbG9nIGltcGxlbWVudGF0aW9uXG4gKiAtIFN1cHBvcnRzIGFsbCBwcm9tb3Rpb24gcGllY2VzIHdpdGggR2VybWFuIGxvY2FsaXphdGlvblxuICogLSBNb2R1bGFyIGFyY2hpdGVjdHVyZSBmb3IgZWFzeSBVSSBjb21wb25lbnQgaW50ZWdyYXRpb25cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIGhhbmRsZXIgdXNlcyBzb3BoaXN0aWNhdGVkIFdETCAoV2luL0RyYXcvTG9zcykgcGVyc3BlY3RpdmUgY29udmVyc2lvbjpcbiAqIC0gVGFibGViYXNlIHJldHVybnMgV0RMIGZyb20gd2hpdGUncyBwZXJzcGVjdGl2ZVxuICogLSBWYWx1ZXMgYXJlIGNvbnZlcnRlZCB0byBwcm9tb3RpbmcgcGxheWVyJ3MgcGVyc3BlY3RpdmVcbiAqIC0gQXV0by13aW4gZGV0ZWN0aW9uIGNvbnNpZGVycyBib3RoIFdETCB2YWx1ZXMgYW5kIHJlc3VsdCBjYXRlZ29yaWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGhhbmRsZXIgPSBuZXcgUGF3blByb21vdGlvbkhhbmRsZXIoKTtcbiAqXG4gKiAvLyBDb21wbGV0ZSBwcm9tb3Rpb24gd29ya2Zsb3dcbiAqIGNvbnN0IHByb21vdGlvbkluZm8gPSBoYW5kbGVyLmNoZWNrUHJvbW90aW9uKG1vdmUpO1xuICogaWYgKHByb21vdGlvbkluZm8uaXNQcm9tb3Rpb24pIHtcbiAqICAgY29uc3QgaXNBdXRvV2luID0gYXdhaXQgaGFuZGxlci5ldmFsdWF0ZVByb21vdGlvbk91dGNvbWUoZmVuLCAndycpO1xuICogICBpZiAoaXNBdXRvV2luKSB7XG4gKiAgICAgYXdhaXQgaGFuZGxlci5oYW5kbGVBdXRvV2luKGFwaSwgeyAuLi5wcm9tb3Rpb25JbmZvLCBpc0F1dG9XaW46IHRydWUgfSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiAvLyBHZXQgcGllY2UgbGFiZWwgZm9yIFVJXG4gKiBjb25zdCBsYWJlbCA9IGhhbmRsZXIuZ2V0UHJvbW90aW9uUGllY2VMYWJlbCgncScpOyAvLyBSZXR1cm5zOiBcIkRhbWVcIlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXduUHJvbW90aW9uSGFuZGxlciB7XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBtb3ZlIGludm9sdmVzIHBhd24gcHJvbW90aW9uXG4gICAqXG4gICAqIEBwYXJhbSBtb3ZlIC0gVGhlIHZhbGlkYXRlZCBtb3ZlIHRoYXQgd2FzIGV4ZWN1dGVkXG4gICAqIEByZXR1cm5zIFByb21vdGlvbiBpbmZvcm1hdGlvblxuICAgKi9cbiAgY2hlY2tQcm9tb3Rpb24obW92ZTogVmFsaWRhdGVkTW92ZSk6IFByb21vdGlvbkluZm8ge1xuICAgIC8vIGNoZXNzLmpzIHNldHMgdGhlICdwcm9tb3Rpb24nIHByb3BlcnR5IGluIHRoZSBtb3ZlIG9iamVjdFxuICAgIC8vIGFuZCBmbGFncyBjb250YWluICdwJyBmb3IgcHJvbW90aW9uXG4gICAgY29uc3QgaXNQcm9tb3Rpb24gPSBtb3ZlLmZsYWdzICYmIG1vdmUuZmxhZ3MuaW5jbHVkZXMoXCJwXCIpO1xuXG4gICAgaWYgKCFpc1Byb21vdGlvbikge1xuICAgICAgcmV0dXJuIHsgaXNQcm9tb3Rpb246IGZhbHNlIH07XG4gICAgfVxuXG4gICAgZ2V0TG9nZ2VyKCkuZGVidWcoXCJbUGF3blByb21vdGlvbl0gUHJvbW90aW9uIGRldGVjdGVkOlwiLCB7XG4gICAgICBmcm9tOiBtb3ZlLmZyb20sXG4gICAgICB0bzogbW92ZS50byxcbiAgICAgIHBpZWNlOiBtb3ZlLnBpZWNlLFxuICAgICAgcHJvbW90aW9uOiBtb3ZlLnByb21vdGlvbixcbiAgICAgIGZsYWdzOiBtb3ZlLmZsYWdzLFxuICAgIH0pO1xuXG4gICAgLy8gVmFsaWRhdGUgcHJvbW90aW9uIHBpZWNlIHR5cGVcbiAgICBjb25zdCBwcm9tb3Rpb25QaWVjZSA9IHRoaXMuaXNWYWxpZFByb21vdGlvblBpZWNlKG1vdmUucHJvbW90aW9uKVxuICAgICAgPyBtb3ZlLnByb21vdGlvblxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNQcm9tb3Rpb246IHRydWUsXG4gICAgICBwcm9tb3Rpb25QaWVjZSxcbiAgICAgIGZyb206IG1vdmUuZnJvbSxcbiAgICAgIHRvOiBtb3ZlLnRvLFxuICAgICAgaXNBdXRvV2luOiBmYWxzZSwgLy8gV2lsbCBiZSBkZXRlcm1pbmVkIGJ5IGV2YWx1YXRlUHJvbW90aW9uT3V0Y29tZVxuICAgICAgbW92ZURlc2NyaXB0aW9uOiBtb3ZlLnNhbiwgLy8gSW5jbHVkZSBTQU4gbm90YXRpb24gZm9yIGRpc3BsYXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlcyBpZiBhIHByb21vdGlvbiBsZWFkcyB0byBhbiBpbW1lZGlhdGUgd2luXG4gICAqXG4gICAqIEBwYXJhbSBjdXJyZW50RmVuIC0gRkVOIHBvc2l0aW9uIGFmdGVyIHByb21vdGlvblxuICAgKiBAcGFyYW0gcHJvbW90aW5nQ29sb3IgLSBDb2xvciBvZiB0aGUgcGxheWVyIHdobyBwcm9tb3RlZCAoJ3cnIG9yICdiJylcbiAgICogQHJldHVybnMgUHJvbWlzZTxib29sZWFuPiAtIFRydWUgaWYgcHJvbW90aW9uIGxlYWRzIHRvIGF1dG8td2luXG4gICAqL1xuICBhc3luYyBldmFsdWF0ZVByb21vdGlvbk91dGNvbWUoXG4gICAgY3VycmVudEZlbjogc3RyaW5nLFxuICAgIHByb21vdGluZ0NvbG9yOiBcIndcIiB8IFwiYlwiLFxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQmFzaWMgRkVOIHZhbGlkYXRpb25cbiAgICAgIGlmICghY3VycmVudEZlbiB8fCAhY3VycmVudEZlbi5pbmNsdWRlcyhcIiBcIikpIHtcbiAgICAgICAgZ2V0TG9nZ2VyKCkud2FybihcIltQYXduUHJvbW90aW9uXSBJbnZhbGlkIEZFTiBmb3JtYXQ6XCIsIGN1cnJlbnRGZW4pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBnYW1lIGlzIGltbWVkaWF0ZWx5IG92ZXIgYWZ0ZXIgcHJvbW90aW9uXG4gICAgICBpZiAoY2hlc3NTZXJ2aWNlLmlzR2FtZU92ZXIoKSkge1xuICAgICAgICBjb25zdCBpc0NoZWNrbWF0ZSA9IGNoZXNzU2VydmljZS5pc0NoZWNrbWF0ZSgpO1xuICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltQYXduUHJvbW90aW9uXSBHYW1lIG92ZXIgYWZ0ZXIgcHJvbW90aW9uOlwiLCB7XG4gICAgICAgICAgaXNDaGVja21hdGUsXG4gICAgICAgICAgZmVuOiBjdXJyZW50RmVuLnNwbGl0KFwiIFwiKVswXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpc0NoZWNrbWF0ZTsgLy8gQ2hlY2ttYXRlID0gYXV0by13aW5cbiAgICAgIH1cblxuICAgICAgLy8gVXNlIHRhYmxlYmFzZSB0byBldmFsdWF0ZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uXG4gICAgICBjb25zdCBldmFsdWF0aW9uID0gYXdhaXQgdGFibGViYXNlU2VydmljZVxuICAgICAgICAuZ2V0RXZhbHVhdGlvbihjdXJyZW50RmVuKVxuICAgICAgICAuY2F0Y2goKCkgPT4gKHsgaXNBdmFpbGFibGU6IGZhbHNlIH0pKTtcblxuICAgICAgaWYgKFxuICAgICAgICBldmFsdWF0aW9uLmlzQXZhaWxhYmxlICYmXG4gICAgICAgIFwicmVzdWx0XCIgaW4gZXZhbHVhdGlvbiAmJlxuICAgICAgICBldmFsdWF0aW9uLnJlc3VsdCAmJlxuICAgICAgICBcIndkbFwiIGluIGV2YWx1YXRpb24ucmVzdWx0ICYmXG4gICAgICAgIHR5cGVvZiBldmFsdWF0aW9uLnJlc3VsdC53ZGwgPT09IFwibnVtYmVyXCJcbiAgICAgICkge1xuICAgICAgICAvLyBDaGVjayBpZiBwcm9tb3Rpb24gY3JlYXRlZCBhIHdpbm5pbmcgcG9zaXRpb24gZnJvbSBwcm9tb3RpbmcgcGxheWVyJ3MgcGVyc3BlY3RpdmVcbiAgICAgICAgLy8gV0RMIGlzIGZyb20gd2hpdGUncyBwZXJzcGVjdGl2ZTogcG9zaXRpdmUgPSBnb29kIGZvciB3aGl0ZSwgbmVnYXRpdmUgPSBnb29kIGZvciBibGFja1xuICAgICAgICBjb25zdCB3ZGxGcm9tUHJvbW90aW5nUGxheWVyUGVyc3BlY3RpdmUgPVxuICAgICAgICAgIHByb21vdGluZ0NvbG9yID09PSBcIndcIlxuICAgICAgICAgICAgPyBldmFsdWF0aW9uLnJlc3VsdC53ZGxcbiAgICAgICAgICAgIDogLWV2YWx1YXRpb24ucmVzdWx0LndkbDtcbiAgICAgICAgY29uc3QgaXNXaW5uaW5nID0gd2RsRnJvbVByb21vdGluZ1BsYXllclBlcnNwZWN0aXZlID4gMDtcblxuICAgICAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltQYXduUHJvbW90aW9uXSBUYWJsZWJhc2UgZXZhbHVhdGlvbjpcIiwge1xuICAgICAgICAgIHdkbDogZXZhbHVhdGlvbi5yZXN1bHQud2RsLFxuICAgICAgICAgIHdkbEZyb21Qcm9tb3RpbmdQbGF5ZXJQZXJzcGVjdGl2ZSxcbiAgICAgICAgICBwcm9tb3RpbmdDb2xvcixcbiAgICAgICAgICBjYXRlZ29yeTogZXZhbHVhdGlvbi5yZXN1bHQuY2F0ZWdvcnksXG4gICAgICAgICAgaXNXaW5uaW5nLFxuICAgICAgICAgIGZlbjogY3VycmVudEZlbi5zcGxpdChcIiBcIilbMF0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbnNpZGVyIGl0IGFuIGF1dG8td2luIGlmIGl0J3MgYSBmb3JjZWQgbWF0ZSBvciBvdGhlciB3aW5uaW5nIGNhdGVnb3J5XG4gICAgICAgIC8vIENhdGVnb3JpZXMgbGlrZSAnbWF0ZScsICd3aW4nLCBldGMuIGluZGljYXRlIGRlZmluaXRpdmUgd2lubmluZyBzY2VuYXJpb3NcbiAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBldmFsdWF0aW9uLnJlc3VsdC5jYXRlZ29yeTtcbiAgICAgICAgY29uc3QgaXNBdXRvV2luQ2F0ZWdvcnkgPSAhIShcbiAgICAgICAgICBjYXRlZ29yeSAmJlxuICAgICAgICAgIHR5cGVvZiBjYXRlZ29yeSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgIChjYXRlZ29yeS5pbmNsdWRlcyhcIm1hdGVcIikgfHwgY2F0ZWdvcnkuaW5jbHVkZXMoXCJ3aW5cIikpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBpc1dpbm5pbmcgJiYgaXNBdXRvV2luQ2F0ZWdvcnk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZ2V0TG9nZ2VyKCkuZXJyb3IoXG4gICAgICAgIFwiW1Bhd25Qcm9tb3Rpb25dIEVycm9yIGV2YWx1YXRpbmcgcHJvbW90aW9uIG91dGNvbWU6XCIsXG4gICAgICAgIGVycm9yLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhdXRvLXdpbiBzY2VuYXJpbyBhZnRlciBwcm9tb3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGFwaSAtIFN0b3JlIEFQSSBmb3Igc3RhdGUgdXBkYXRlc1xuICAgKiBAcGFyYW0gcHJvbW90aW9uSW5mbyAtIEluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm9tb3Rpb25cbiAgICovXG4gIGFzeW5jIGhhbmRsZUF1dG9XaW4oXG4gICAgYXBpOiBTdG9yZUFwaSxcbiAgICBwcm9tb3Rpb25JbmZvOiBQcm9tb3Rpb25JbmZvLFxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBnZXRMb2dnZXIoKS5pbmZvKFxuICAgICAgXCJbUGF3blByb21vdGlvbl0gQXV0by13aW4gZGV0ZWN0ZWQgLSBjb21wbGV0aW5nIHRyYWluaW5nIHNlc3Npb25cIixcbiAgICApO1xuXG4gICAgY29uc3QgeyBzZXRTdGF0ZSB9ID0gYXBpO1xuXG4gICAgLy8gU2hvdyBjZWxlYnJhdGlvbiBkaWFsb2cgaW5zdGVhZCBvZiB0b2FzdFxuICAgIGNvbnN0IHByb21vdGlvblBpZWNlTGFiZWwgPSBwcm9tb3Rpb25JbmZvLnByb21vdGlvblBpZWNlXG4gICAgICA/IHRoaXMuZ2V0UHJvbW90aW9uUGllY2VMYWJlbChwcm9tb3Rpb25JbmZvLnByb21vdGlvblBpZWNlKVxuICAgICAgOiBcIkRhbWVcIjsgLy8gRGVmYXVsdCB0byBxdWVlbiBpZiB1bmRlZmluZWRcbiAgICBzZXRTdGF0ZSgoZHJhZnQpID0+IHtcbiAgICAgIGRyYWZ0LnRyYWluaW5nLm1vdmVTdWNjZXNzRGlhbG9nID0ge1xuICAgICAgICBpc09wZW46IHRydWUsXG4gICAgICAgIHByb21vdGlvblBpZWNlOiBwcm9tb3Rpb25QaWVjZUxhYmVsLFxuICAgICAgICBtb3ZlRGVzY3JpcHRpb246IHByb21vdGlvbkluZm8ubW92ZURlc2NyaXB0aW9uLFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIENvbXBsZXRlIHRyYWluaW5nIHNlc3Npb24gYXMgd29uXG4gICAgYXdhaXQgaGFuZGxlVHJhaW5pbmdDb21wbGV0aW9uKGFwaSwgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogU2hvd3MgcHJvbW90aW9uIGNob2ljZSBkaWFsb2cgKGZvciBmdXR1cmUgVUkgaW1wbGVtZW50YXRpb24pXG4gICAqXG4gICAqIEBwYXJhbSBhcGkgLSBTdG9yZSBBUEkgZm9yIHN0YXRlIHVwZGF0ZXNcbiAgICogQHBhcmFtIGZyb20gLSBTb3VyY2Ugc3F1YXJlIChlLmcuLCBcImU3XCIpXG4gICAqIEBwYXJhbSB0byAtIFRhcmdldCBzcXVhcmUgKGUuZy4sIFwiZThcIilcbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aXRoIGNob3NlbiBwaWVjZVxuICAgKi9cbiAgc2hvd1Byb21vdGlvbkRpYWxvZyhcbiAgICBhcGk6IFN0b3JlQXBpLFxuICAgIGZyb206IHN0cmluZyxcbiAgICB0bzogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAocGllY2U6IFwicVwiIHwgXCJyXCIgfCBcIm5cIiB8IFwiYlwiKSA9PiB2b2lkLFxuICApOiB2b2lkIHtcbiAgICBnZXRMb2dnZXIoKS5kZWJ1ZyhcIltQYXduUHJvbW90aW9uXSBTaG93aW5nIHByb21vdGlvbiBkaWFsb2c6XCIsIHtcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgc2V0U3RhdGUgfSA9IGFwaTtcblxuICAgIC8vIEZvciBub3csIGp1c3QgYXV0by1wcm9tb3RlIHRvIHF1ZWVuIGFuZCBjYWxsIGNhbGxiYWNrXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGFjdHVhbCBwcm9tb3Rpb24gY2hvaWNlIFVJXG4gICAgY29uc3QgY2hvc2VuUGllY2U6IFwicVwiIHwgXCJyXCIgfCBcIm5cIiB8IFwiYlwiID0gXCJxXCI7XG5cbiAgICBzZXRTdGF0ZSgoZHJhZnQpID0+IHtcbiAgICAgIGRyYWZ0LnVpLnRvYXN0cy5wdXNoKHtcbiAgICAgICAgaWQ6IERhdGUubm93KCkudG9TdHJpbmcoKSxcbiAgICAgICAgbWVzc2FnZTogYEJhdWVybnVtd2FuZGx1bmc6ICR7ZnJvbX0tJHt0b30g4oaSIERhbWVgLFxuICAgICAgICB0eXBlOiBcImluZm9cIixcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2soY2hvc2VuUGllY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyBwcm9tb3Rpb24gcGllY2UgY2hvaWNlXG4gICAqXG4gICAqIEBwYXJhbSBwaWVjZSAtIFByb21vdGlvbiBwaWVjZSBjaGFyYWN0ZXIgKGNhbiBiZSB1bmRlZmluZWQpXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdmFsaWQgcHJvbW90aW9uIHBpZWNlXG4gICAqL1xuICBpc1ZhbGlkUHJvbW90aW9uUGllY2UoXG4gICAgcGllY2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgKTogcGllY2UgaXMgXCJxXCIgfCBcInJcIiB8IFwiblwiIHwgXCJiXCIge1xuICAgIHJldHVybiB0eXBlb2YgcGllY2UgPT09IFwic3RyaW5nXCIgJiYgW1wicVwiLCBcInJcIiwgXCJuXCIsIFwiYlwiXS5pbmNsdWRlcyhwaWVjZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBwcm9tb3Rpb24gcGllY2UgbGFiZWwgZm9yIFVJIGRpc3BsYXlcbiAgICpcbiAgICogQHBhcmFtIHBpZWNlIC0gUHJvbW90aW9uIHBpZWNlIGNoYXJhY3RlclxuICAgKiBAcmV0dXJucyBHZXJtYW4gbGFiZWwgZm9yIHRoZSBwaWVjZVxuICAgKi9cbiAgZ2V0UHJvbW90aW9uUGllY2VMYWJlbChwaWVjZTogXCJxXCIgfCBcInJcIiB8IFwiblwiIHwgXCJiXCIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGNob2ljZSA9IFBST01PVElPTl9DSE9JQ0VTLmZpbmQoKGMpID0+IGMucGllY2UgPT09IHBpZWNlKTtcbiAgICByZXR1cm4gY2hvaWNlPy5sYWJlbCB8fCBwaWVjZS50b1VwcGVyQ2FzZSgpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiUFJPTU9USU9OX0NIT0lDRVMiLCJQYXduUHJvbW90aW9uSGFuZGxlciIsInBpZWNlIiwibGFiZWwiLCJkZXNjcmlwdGlvbiIsImNoZWNrUHJvbW90aW9uIiwibW92ZSIsImlzUHJvbW90aW9uIiwiZmxhZ3MiLCJpbmNsdWRlcyIsImdldExvZ2dlciIsImRlYnVnIiwiZnJvbSIsInRvIiwicHJvbW90aW9uIiwicHJvbW90aW9uUGllY2UiLCJpc1ZhbGlkUHJvbW90aW9uUGllY2UiLCJ1bmRlZmluZWQiLCJpc0F1dG9XaW4iLCJtb3ZlRGVzY3JpcHRpb24iLCJzYW4iLCJldmFsdWF0ZVByb21vdGlvbk91dGNvbWUiLCJjdXJyZW50RmVuIiwicHJvbW90aW5nQ29sb3IiLCJ3YXJuIiwiY2hlc3NTZXJ2aWNlIiwiaXNHYW1lT3ZlciIsImlzQ2hlY2ttYXRlIiwiZmVuIiwic3BsaXQiLCJldmFsdWF0aW9uIiwidGFibGViYXNlU2VydmljZSIsImdldEV2YWx1YXRpb24iLCJjYXRjaCIsImlzQXZhaWxhYmxlIiwicmVzdWx0Iiwid2RsIiwid2RsRnJvbVByb21vdGluZ1BsYXllclBlcnNwZWN0aXZlIiwiaXNXaW5uaW5nIiwiY2F0ZWdvcnkiLCJpc0F1dG9XaW5DYXRlZ29yeSIsImVycm9yIiwiaGFuZGxlQXV0b1dpbiIsImFwaSIsInByb21vdGlvbkluZm8iLCJpbmZvIiwic2V0U3RhdGUiLCJwcm9tb3Rpb25QaWVjZUxhYmVsIiwiZ2V0UHJvbW90aW9uUGllY2VMYWJlbCIsImRyYWZ0IiwidHJhaW5pbmciLCJtb3ZlU3VjY2Vzc0RpYWxvZyIsImlzT3BlbiIsImhhbmRsZVRyYWluaW5nQ29tcGxldGlvbiIsInNob3dQcm9tb3Rpb25EaWFsb2ciLCJjYWxsYmFjayIsImNob3NlblBpZWNlIiwidWkiLCJ0b2FzdHMiLCJwdXNoIiwiaWQiLCJEYXRlIiwibm93IiwidG9TdHJpbmciLCJtZXNzYWdlIiwidHlwZSIsImNob2ljZSIsImZpbmQiLCJjIiwidG9VcHBlckNhc2UiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaURDOzs7Ozs7Ozs7OztRQThDWUE7ZUFBQUE7O1FB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