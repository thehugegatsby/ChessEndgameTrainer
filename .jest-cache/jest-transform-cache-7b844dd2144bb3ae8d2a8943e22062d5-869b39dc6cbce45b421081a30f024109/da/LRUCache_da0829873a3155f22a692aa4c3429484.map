{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-training-board-complete/src/shared/lib/cache/LRUCache.ts"],"sourcesContent":["/**\n * @file Minimal LRU Cache implementation for position caching\n * @module lib/cache/LRUCache\n * \n * @description\n * Lightweight Least Recently Used (LRU) cache implementation designed\n * specifically for chess position caching without external dependencies.\n * Provides efficient memory management with automatic eviction of least\n * recently used entries when capacity is exceeded.\n * \n * @remarks\n * Key features:\n * - Generic type support for flexible data storage\n * - Automatic LRU eviction policy\n * - Cache statistics tracking (hits, misses, hit rate)\n * - Memory usage estimation\n * - Performance metrics for optimization\n * - Clean, minimal API without external dependencies\n * \n * The cache uses JavaScript's Map for O(1) operations and maintains\n * insertion order for efficient LRU tracking.\n */\n\n/**\n * Cache statistics interface for performance monitoring\n * \n * @interface CacheStats\n * \n * @property {number} hits - Number of successful cache lookups\n * @property {number} misses - Number of failed cache lookups\n * @property {number} size - Current number of items in cache\n * @property {number} maxSize - Maximum cache capacity\n * @property {number} hitRate - Cache hit rate as a decimal (0.0 to 1.0)\n */\nexport interface CacheStats {\n  hits: number;\n  misses: number;\n  size: number;\n  maxSize: number;\n  hitRate: number;\n}\n\n/**\n * LRU Cache implementation with generic type support\n * \n * @template T The type of values stored in the cache\n * \n * @class LRUCache\n * @description\n * Implements a Least Recently Used cache with automatic eviction.\n * Uses a Map for O(1) operations and maintains insertion order for\n * efficient LRU tracking. Provides comprehensive statistics tracking.\n * \n * @example\n * ```typescript\n * // Create cache for chess positions\n * const positionCache = new LRUCache<PositionEvaluation>(200);\n * \n * // Store and retrieve values\n * positionCache.set('fen1', evaluation);\n * const cached = positionCache.get('fen1');\n * \n * // Monitor performance\n * const stats = positionCache.getStats();\n * console.log(`Hit rate: ${(stats.hitRate * 100).toFixed(1)}%`);\n * ```\n */\nexport class LRUCache<T> {\n  private cache = new Map<string, T>();\n  private readonly maxSize: number;\n  private hits = 0;\n  private misses = 0;\n\n  /**\n   * Create a new LRU cache\n   * \n   * @param {number} [maxSize=100] - Maximum number of items to store\n   */\n  constructor(maxSize: number = 100) {\n    this.maxSize = maxSize;\n  }\n\n  /**\n   * Get a value from the cache\n   * \n   * @param {string} key - The cache key to look up\n   * @returns {T | undefined} The cached value or undefined if not found\n   * \n   * @description\n   * Retrieves a value from the cache and marks it as recently used.\n   * Updates hit/miss statistics and moves the accessed item to the\n   * end of the cache (most recently used position).\n   */\n  get(key: string): T | undefined {\n    const value = this.cache.get(key);\n    if (value !== undefined) {\n      this.hits++;\n      // Move to end (most recently used)\n      this.cache.delete(key);\n      this.cache.set(key, value);\n      return value;\n    }\n    this.misses++;\n    return undefined;\n  }\n\n  /**\n   * Set a value in the cache\n   * \n   * @param {string} key - The cache key\n   * @param {T} value - The value to store\n   * \n   * @description\n   * Stores a value in the cache. If the cache is at capacity,\n   * evicts the least recently used item. If the key already exists,\n   * updates the value and marks it as recently used.\n   */\n  set(key: string, value: T): void {\n    // Remove if exists (to reorder)\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      // Remove oldest (first) entry\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey !== undefined) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n\n  /**\n   * Check if a key exists in the cache\n   * \n   * @param {string} key - The cache key to check\n   * @returns {boolean} True if the key exists in the cache\n   */\n  has(key: string): boolean {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Delete a key from the cache\n   * \n   * @param {string} key - The cache key to delete\n   * @returns {boolean} True if the key was deleted, false if it didn't exist\n   */\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all items from the cache and reset statistics\n   * \n   * @description\n   * Removes all cached items and resets hit/miss counters to zero.\n   * Useful for testing or when cache needs to be completely refreshed.\n   */\n  clear(): void {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n  }\n\n  /**\n   * Get cache performance statistics\n   * \n   * @returns {CacheStats} Object containing cache statistics\n   * \n   * @description\n   * Returns comprehensive statistics including hit rate, current size,\n   * and total hits/misses for performance monitoring and optimization.\n   */\n  getStats(): CacheStats {\n    const total = this.hits + this.misses;\n    return {\n      hits: this.hits,\n      misses: this.misses,\n      size: this.cache.size,\n      maxSize: this.maxSize,\n      hitRate: total > 0 ? this.hits / total : 0,\n    };\n  }\n\n  /**\n   * Estimate memory usage of the cache\n   * \n   * @returns {number} Estimated memory usage in bytes\n   * \n   * @description\n   * Provides a rough estimate of memory usage by assuming\n   * approximately 1KB per cache entry. Useful for monitoring\n   * memory consumption in production environments.\n   */\n  getMemoryUsage(): number {\n    // Rough estimate\n    return this.cache.size * 1000; // Assume 1KB per entry\n  }\n\n  /**\n   * Get all cache keys\n   * \n   * @returns {string[]} Array of all cache keys\n   * \n   * @description\n   * Returns an array of all keys currently in the cache.\n   * Keys are returned in insertion order (least to most recent).\n   */\n  keys(): string[] {\n    return Array.from(this.cache.keys());\n  }\n}\n"],"names":["LRUCache","get","key","value","cache","undefined","hits","delete","set","misses","has","size","maxSize","firstKey","keys","next","clear","getStats","total","hitRate","getMemoryUsage","Array","from","Map"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;CAqBC,GAED;;;;;;;;;;CAUC;;;;+BAkCYA;;;eAAAA;;;;;;;;;;;;;;;;AAAN,MAAMA;IAeX;;;;;;;;;;GAUC,GACDC,IAAIC,GAAW,EAAiB;QAC9B,MAAMC,QAAQ,IAAI,CAACC,KAAK,CAACH,GAAG,CAACC;QAC7B,IAAIC,UAAUE,WAAW;YACvB,IAAI,CAACC,IAAI;YACT,mCAAmC;YACnC,IAAI,CAACF,KAAK,CAACG,MAAM,CAACL;YAClB,IAAI,CAACE,KAAK,CAACI,GAAG,CAACN,KAAKC;YACpB,OAAOA;QACT;QACA,IAAI,CAACM,MAAM;QACX,OAAOJ;IACT;IAEA;;;;;;;;;;GAUC,GACDG,IAAIN,GAAW,EAAEC,KAAQ,EAAQ;QAC/B,gCAAgC;QAChC,IAAI,IAAI,CAACC,KAAK,CAACM,GAAG,CAACR,MAAM;YACvB,IAAI,CAACE,KAAK,CAACG,MAAM,CAACL;QACpB,OAAO,IAAI,IAAI,CAACE,KAAK,CAACO,IAAI,IAAI,IAAI,CAACC,OAAO,EAAE;YAC1C,8BAA8B;YAC9B,MAAMC,WAAW,IAAI,CAACT,KAAK,CAACU,IAAI,GAAGC,IAAI,GAAGZ,KAAK;YAC/C,IAAIU,aAAaR,WAAW;gBAC1B,IAAI,CAACD,KAAK,CAACG,MAAM,CAACM;YACpB;QACF;QACA,IAAI,CAACT,KAAK,CAACI,GAAG,CAACN,KAAKC;IACtB;IAEA;;;;;GAKC,GACDO,IAAIR,GAAW,EAAW;QACxB,OAAO,IAAI,CAACE,KAAK,CAACM,GAAG,CAACR;IACxB;IAEA;;;;;GAKC,GACDK,OAAOL,GAAW,EAAW;QAC3B,OAAO,IAAI,CAACE,KAAK,CAACG,MAAM,CAACL;IAC3B;IAEA;;;;;;GAMC,GACDc,QAAc;QACZ,IAAI,CAACZ,KAAK,CAACY,KAAK;QAChB,IAAI,CAACV,IAAI,GAAG;QACZ,IAAI,CAACG,MAAM,GAAG;IAChB;IAEA;;;;;;;;GAQC,GACDQ,WAAuB;QACrB,MAAMC,QAAQ,IAAI,CAACZ,IAAI,GAAG,IAAI,CAACG,MAAM;QACrC,OAAO;YACLH,MAAM,IAAI,CAACA,IAAI;YACfG,QAAQ,IAAI,CAACA,MAAM;YACnBE,MAAM,IAAI,CAACP,KAAK,CAACO,IAAI;YACrBC,SAAS,IAAI,CAACA,OAAO;YACrBO,SAASD,QAAQ,IAAI,IAAI,CAACZ,IAAI,GAAGY,QAAQ;QAC3C;IACF;IAEA;;;;;;;;;GASC,GACDE,iBAAyB;QACvB,iBAAiB;QACjB,OAAO,IAAI,CAAChB,KAAK,CAACO,IAAI,GAAG,MAAM,uBAAuB;IACxD;IAEA;;;;;;;;GAQC,GACDG,OAAiB;QACf,OAAOO,MAAMC,IAAI,CAAC,IAAI,CAAClB,KAAK,CAACU,IAAI;IACnC;IAzIA;;;;GAIC,GACD,YAAYF,UAAkB,GAAG,CAAE;QAVnC,uBAAQR,SAAQ,IAAImB;QACpB,uBAAiBX,WAAjB,KAAA;QACA,uBAAQN,QAAO;QACf,uBAAQG,UAAS;QAQf,IAAI,CAACG,OAAO,GAAGA;IACjB;AAmIF"}