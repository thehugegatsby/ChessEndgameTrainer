f2a7ed600d2e945d0911cb08b6e56afc
/**
 * @file Unit tests for enhanced useDerivedProgress hook with cache-first strategy
 * @description Tests cache integration, fallback scenarios, and performance optimizations
 */ "use strict";
// Mock the cache service
jest.mock('@shared/services/DueCardsCacheService', ()=>{
    let mockCacheData = null;
    let mockCacheStats = {
        available: true,
        totalEntries: 0,
        estimatedSize: 0,
        lastCleanup: null
    };
    const mockCacheService = {
        getDueCards: jest.fn(()=>mockCacheData),
        setDueCards: jest.fn(()=>{
            mockCacheStats.totalEntries += 1;
            mockCacheStats.estimatedSize += 1000; // Simulate size growth
        }),
        clearUserCache: jest.fn(()=>{
            mockCacheData = null;
            mockCacheStats.totalEntries = Math.max(0, mockCacheStats.totalEntries - 1);
        }),
        clearAllCache: jest.fn(()=>{
            mockCacheData = null;
            mockCacheStats = {
                available: true,
                totalEntries: 0,
                estimatedSize: 0,
                lastCleanup: null
            };
        }),
        getCacheStats: jest.fn(()=>mockCacheStats),
        forceCleanup: jest.fn()
    };
    // Helper to set mock cache data for tests
    mockCacheService.__setMockCacheData = (data)=>{
        mockCacheData = data;
    };
    return {
        dueCardsCacheService: mockCacheService,
        createInputHash: jest.fn((input)=>'mock-hash-' + JSON.stringify(input).length)
    };
});
// Mock logger to avoid console spam in tests
jest.mock('@shared/services/logging/Logger', ()=>({
        getLogger: ()=>({
                setContext: ()=>({
                        debug: jest.fn(),
                        info: jest.fn(),
                        warn: jest.fn(),
                        error: jest.fn()
                    })
            })
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _react = require("@testing-library/react");
const _useProgressStore = require("../../../shared/store/hooks/useProgressStore");
const _rootStore = require("../../../shared/store/rootStore");
const _DueCardsCacheService = require("../../../shared/services/DueCardsCacheService");
// Test helpers
const createTestCard = (id, nextReviewAt)=>({
        id,
        nextReviewAt,
        lastReviewedAt: Date.now() - 86400000,
        interval: 1,
        repetition: 1,
        efactor: 2.5,
        lapses: 0
    });
const createDueCard = (id)=>createTestCard(id, Date.now() - 1000); // Due 1 second ago
const createFutureCard = (id)=>createTestCard(id, Date.now() + 86400000); // Due in 24 hours
describe('useDerivedProgress Hook (Enhanced with Cache)', ()=>{
    const userId = 'test-user-123';
    let mockCacheService;
    beforeEach(()=>{
        mockCacheService = _DueCardsCacheService.dueCardsCacheService;
        mockCacheService.__setMockCacheData(null);
        // Reset cache stats
        jest.mocked(mockCacheService.getCacheStats).mockReturnValue({
            available: true,
            totalEntries: 0,
            estimatedSize: 0,
            lastCleanup: null
        });
        jest.clearAllMocks();
        // Reset store to initial state
        _rootStore.useStore.getState().progress.resetProgress();
    });
    describe('Basic functionality without cache', ()=>{
        it('should calculate due cards without userId (fallback mode)', ()=>{
            // Setup some card progress
            const cards = [
                createDueCard('due-1'),
                createDueCard('due-2'),
                createFutureCard('future-1')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
                _rootStore.useStore.getState().progress.updateSessionProgress({
                    positionsCorrect: 8,
                    positionsAttempted: 10
                });
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(null));
            expect(result.current.dueCardCount).toBe(2);
            expect(result.current.totalCards).toBe(3);
            expect(result.current.successRate).toBe(80);
            expect(result.current.isFromCache).toBe(false);
            expect(result.current.cacheStats.available).toBe(false);
            // Should not call cache service without userId
            expect(mockCacheService.getDueCards).not.toHaveBeenCalled();
        });
        it('should handle empty card progress', ()=>{
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            expect(result.current.dueCardCount).toBe(0);
            expect(result.current.totalCards).toBe(0);
            expect(result.current.successRate).toBe(0);
            expect(result.current.isFromCache).toBe(false);
        });
    });
    describe('Cache-first strategy', ()=>{
        it('should use cached result when available', ()=>{
            // Setup cards in store
            const cards = [
                createDueCard('due-1'),
                createDueCard('due-2'),
                createFutureCard('future-1')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
            });
            // Mock cached result
            const mockCachedResult = {
                dueCards: [
                    {
                        ...createDueCard('due-1'),
                        __isDue: true,
                        __brand: 'DueCard'
                    },
                    {
                        ...createDueCard('due-2'),
                        __isDue: true,
                        __brand: 'DueCard'
                    }
                ],
                calculatedAt: Date.now() - 30000,
                stats: {
                    totalCards: 3,
                    dueCount: 2,
                    duePercentage: 67,
                    nextDueAt: Date.now() + 3600000,
                    averageInterval: 2.5
                },
                inputHash: 'cached-hash',
                createdAt: Date.now() - 30000,
                lastAccessedAt: Date.now() - 30000
            };
            mockCacheService.__setMockCacheData(mockCachedResult);
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            expect(result.current.isFromCache).toBe(true);
            expect(result.current.dueCardCount).toBe(2);
            expect(result.current.stats).toEqual(mockCachedResult.stats);
            expect(mockCacheService.getDueCards).toHaveBeenCalledWith(userId, expect.any(String));
        });
        it('should compute fresh result on cache miss and cache it', ()=>{
            // Setup cards in store
            const cards = [
                createDueCard('due-1'),
                createFutureCard('future-1'),
                createFutureCard('future-2')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
            });
            // No cached result (cache miss)
            mockCacheService.__setMockCacheData(null);
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            expect(result.current.isFromCache).toBe(false);
            expect(result.current.dueCardCount).toBe(1);
            expect(result.current.totalCards).toBe(3);
            // Should have tried to get from cache
            expect(mockCacheService.getDueCards).toHaveBeenCalledWith(userId, expect.any(String));
            // Should have cached the result
            expect(mockCacheService.setDueCards).toHaveBeenCalledWith(userId, expect.arrayContaining([
                expect.objectContaining({
                    id: 'due-1'
                })
            ]), expect.objectContaining({
                dueCount: 1,
                totalCards: 3
            }), expect.any(String));
        });
        it('should handle cache service errors gracefully', ()=>{
            // Setup cards
            const cards = [
                createDueCard('due-1')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
            });
            // Mock cache service to throw error
            jest.mocked(mockCacheService.setDueCards).mockImplementation(()=>{
                throw new Error('Cache write error');
            });
            const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            // Should still return computed result despite cache error
            expect(result.current.dueCardCount).toBe(1);
            expect(result.current.isFromCache).toBe(false);
            expect(result.current.totalCards).toBe(1);
        });
    });
    describe('Input hash validation', ()=>{
        it('should create consistent input hash for same inputs', ()=>{
            const cards = [
                createDueCard('due-1'),
                createFutureCard('future-1')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
            });
            // Render hook multiple times
            (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            // Both should call getDueCards with same hash
            expect(mockCacheService.getDueCards).toHaveBeenCalledTimes(2);
        });
        it('should create different hash when cards change', ()=>{
            // Initial cards
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards([
                    createDueCard('due-1')
                ]);
            });
            const { rerender } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            // Add more cards
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards([
                    createDueCard('due-1'),
                    createDueCard('due-2')
                ]);
            });
            rerender();
            // Should have called getDueCards twice with different contexts
            expect(mockCacheService.getDueCards).toHaveBeenCalledTimes(2);
        });
    });
    describe('Performance optimization', ()=>{
        it('should handle large card collections efficiently', ()=>{
            // Create 1000 cards (500 due, 500 future)
            const largeCardSet = Array.from({
                length: 1000
            }, (_, i)=>i % 2 === 0 ? createDueCard(`due-${i}`) : createFutureCard(`future-${i}`));
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(largeCardSet);
            });
            const startTime = performance.now();
            (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            const endTime = performance.now();
            // Should complete within reasonable time (< 100ms)
            expect(endTime - startTime).toBeLessThan(100);
            // Should attempt to cache the large result
            expect(mockCacheService.setDueCards).toHaveBeenCalled();
        });
        it('should use 5-minute timestamp buckets for cache stability', ()=>{
            const cards = [
                createDueCard('due-1')
            ];
            (0, _react.act)(()=>{
                _rootStore.useStore.getState().progress.initializeCards(cards);
            });
            // Mock time to be mid-bucket
            const originalDateNow = Date.now;
            const fixedTime = 1700000000000; // Fixed timestamp
            Date.now = jest.fn(()=>fixedTime + 2 * 60 * 1000); // +2 minutes
            (0, _react.renderHook)(()=>(0, _useProgressStore.useDerivedProgress)(userId));
            // Should use 5-minute bucket in hash calculation
            expect(mockCacheService.getDueCards).toHaveBeenCalled();
            Date.now = originalDateNow;
        });
    });
});
describe('useDueCardsCache Hook', ()=>{
    let mockCacheService;
    beforeEach(()=>{
        mockCacheService = _DueCardsCacheService.dueCardsCacheService;
        jest.clearAllMocks();
    });
    it('should provide cache management functions', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDueCardsCache)());
        expect(typeof result.current.clearUserCache).toBe('function');
        expect(typeof result.current.clearAllCache).toBe('function');
        expect(typeof result.current.getCacheStats).toBe('function');
        expect(typeof result.current.forceCleanup).toBe('function');
    });
    it('should call cache service methods correctly', ()=>{
        const { result } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDueCardsCache)());
        // Test clearUserCache
        result.current.clearUserCache('test-user');
        expect(mockCacheService.clearUserCache).toHaveBeenCalledWith('test-user');
        // Test clearAllCache
        result.current.clearAllCache();
        expect(mockCacheService.clearAllCache).toHaveBeenCalled();
        // Test getCacheStats
        result.current.getCacheStats();
        expect(mockCacheService.getCacheStats).toHaveBeenCalled();
        // Test forceCleanup
        result.current.forceCleanup();
        expect(mockCacheService.forceCleanup).toHaveBeenCalled();
    });
    it('should return stable references (useMemo)', ()=>{
        const { result, rerender } = (0, _react.renderHook)(()=>(0, _useProgressStore.useDueCardsCache)());
        const firstRender = result.current;
        rerender();
        const secondRender = result.current;
        // All functions should be the same reference
        expect(firstRender.clearUserCache).toBe(secondRender.clearUserCache);
        expect(firstRender.clearAllCache).toBe(secondRender.clearAllCache);
        expect(firstRender.getCacheStats).toBe(secondRender.getCacheStats);
        expect(firstRender.forceCleanup).toBe(secondRender.forceCleanup);
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3RoZWh1L2Nvb2xQcm9qZWN0cy9FbmRnYW1lVHJhaW5lci10cmFpbmluZy1ib2FyZC1jb21wbGV0ZS9zcmMvdGVzdHMvdW5pdC9ob29rcy91c2VEZXJpdmVkUHJvZ3Jlc3MudGVzdC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlIFVuaXQgdGVzdHMgZm9yIGVuaGFuY2VkIHVzZURlcml2ZWRQcm9ncmVzcyBob29rIHdpdGggY2FjaGUtZmlyc3Qgc3RyYXRlZ3lcbiAqIEBkZXNjcmlwdGlvbiBUZXN0cyBjYWNoZSBpbnRlZ3JhdGlvbiwgZmFsbGJhY2sgc2NlbmFyaW9zLCBhbmQgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uc1xuICovXG5cbmltcG9ydCB7IHJlbmRlckhvb2ssIGFjdCB9IGZyb20gJ0B0ZXN0aW5nLWxpYnJhcnkvcmVhY3QnO1xuaW1wb3J0IHsgdXNlRGVyaXZlZFByb2dyZXNzLCB1c2VEdWVDYXJkc0NhY2hlIH0gZnJvbSAnQHNoYXJlZC9zdG9yZS9ob29rcy91c2VQcm9ncmVzc1N0b3JlJztcbmltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAnQHNoYXJlZC9zdG9yZS9yb290U3RvcmUnO1xuaW1wb3J0IHsgZHVlQ2FyZHNDYWNoZVNlcnZpY2UgfSBmcm9tICdAc2hhcmVkL3NlcnZpY2VzL0R1ZUNhcmRzQ2FjaGVTZXJ2aWNlJztcbmltcG9ydCB0eXBlIHsgQ2FyZFByb2dyZXNzIH0gZnJvbSAnQHNoYXJlZC9zdG9yZS9zbGljZXMvdHlwZXMnO1xuXG4vLyBNb2NrIHRoZSBjYWNoZSBzZXJ2aWNlXG5qZXN0Lm1vY2soJ0BzaGFyZWQvc2VydmljZXMvRHVlQ2FyZHNDYWNoZVNlcnZpY2UnLCAoKSA9PiB7XG4gIGxldCBtb2NrQ2FjaGVEYXRhOiBhbnkgPSBudWxsO1xuICBsZXQgbW9ja0NhY2hlU3RhdHMgPSB7XG4gICAgYXZhaWxhYmxlOiB0cnVlLFxuICAgIHRvdGFsRW50cmllczogMCxcbiAgICBlc3RpbWF0ZWRTaXplOiAwLFxuICAgIGxhc3RDbGVhbnVwOiBudWxsXG4gIH07XG5cbiAgY29uc3QgbW9ja0NhY2hlU2VydmljZSA9IHtcbiAgICBnZXREdWVDYXJkczogamVzdC5mbigoKSA9PiBtb2NrQ2FjaGVEYXRhKSxcbiAgICBzZXREdWVDYXJkczogamVzdC5mbigoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVTdGF0cy50b3RhbEVudHJpZXMgKz0gMTtcbiAgICAgIG1vY2tDYWNoZVN0YXRzLmVzdGltYXRlZFNpemUgKz0gMTAwMDsgLy8gU2ltdWxhdGUgc2l6ZSBncm93dGhcbiAgICB9KSxcbiAgICBjbGVhclVzZXJDYWNoZTogamVzdC5mbigoKSA9PiB7XG4gICAgICBtb2NrQ2FjaGVEYXRhID0gbnVsbDtcbiAgICAgIG1vY2tDYWNoZVN0YXRzLnRvdGFsRW50cmllcyA9IE1hdGgubWF4KDAsIG1vY2tDYWNoZVN0YXRzLnRvdGFsRW50cmllcyAtIDEpO1xuICAgIH0pLFxuICAgIGNsZWFyQWxsQ2FjaGU6IGplc3QuZm4oKCkgPT4ge1xuICAgICAgbW9ja0NhY2hlRGF0YSA9IG51bGw7XG4gICAgICBtb2NrQ2FjaGVTdGF0cyA9IHsgYXZhaWxhYmxlOiB0cnVlLCB0b3RhbEVudHJpZXM6IDAsIGVzdGltYXRlZFNpemU6IDAsIGxhc3RDbGVhbnVwOiBudWxsIH07XG4gICAgfSksXG4gICAgZ2V0Q2FjaGVTdGF0czogamVzdC5mbigoKSA9PiBtb2NrQ2FjaGVTdGF0cyksXG4gICAgZm9yY2VDbGVhbnVwOiBqZXN0LmZuKClcbiAgfTtcblxuICAvLyBIZWxwZXIgdG8gc2V0IG1vY2sgY2FjaGUgZGF0YSBmb3IgdGVzdHNcbiAgKG1vY2tDYWNoZVNlcnZpY2UgYXMgYW55KS5fX3NldE1vY2tDYWNoZURhdGEgPSAoZGF0YTogYW55KSA9PiB7XG4gICAgbW9ja0NhY2hlRGF0YSA9IGRhdGE7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBkdWVDYXJkc0NhY2hlU2VydmljZTogbW9ja0NhY2hlU2VydmljZSxcbiAgICBjcmVhdGVJbnB1dEhhc2g6IGplc3QuZm4oKGlucHV0OiBhbnkpID0+ICdtb2NrLWhhc2gtJyArIEpTT04uc3RyaW5naWZ5KGlucHV0KS5sZW5ndGgpXG4gIH07XG59KTtcblxuLy8gTW9jayBsb2dnZXIgdG8gYXZvaWQgY29uc29sZSBzcGFtIGluIHRlc3RzXG5qZXN0Lm1vY2soJ0BzaGFyZWQvc2VydmljZXMvbG9nZ2luZy9Mb2dnZXInLCAoKSA9PiAoe1xuICBnZXRMb2dnZXI6ICgpID0+ICh7XG4gICAgc2V0Q29udGV4dDogKCkgPT4gKHtcbiAgICAgIGRlYnVnOiBqZXN0LmZuKCksXG4gICAgICBpbmZvOiBqZXN0LmZuKCksXG4gICAgICB3YXJuOiBqZXN0LmZuKCksXG4gICAgICBlcnJvcjogamVzdC5mbigpXG4gICAgfSlcbiAgfSlcbn0pKTtcblxuLy8gVGVzdCBoZWxwZXJzXG5jb25zdCBjcmVhdGVUZXN0Q2FyZCA9IChpZDogc3RyaW5nLCBuZXh0UmV2aWV3QXQ6IG51bWJlcik6IENhcmRQcm9ncmVzcyA9PiAoe1xuICBpZCxcbiAgbmV4dFJldmlld0F0LFxuICBsYXN0UmV2aWV3ZWRBdDogRGF0ZS5ub3coKSAtIDg2NDAwMDAwLCAvLyAyNCBob3VycyBhZ29cbiAgaW50ZXJ2YWw6IDEsXG4gIHJlcGV0aXRpb246IDEsXG4gIGVmYWN0b3I6IDIuNSxcbiAgbGFwc2VzOiAwXG59KTtcblxuY29uc3QgY3JlYXRlRHVlQ2FyZCA9IChpZDogc3RyaW5nKSA9PiBjcmVhdGVUZXN0Q2FyZChpZCwgRGF0ZS5ub3coKSAtIDEwMDApOyAvLyBEdWUgMSBzZWNvbmQgYWdvXG5jb25zdCBjcmVhdGVGdXR1cmVDYXJkID0gKGlkOiBzdHJpbmcpID0+IGNyZWF0ZVRlc3RDYXJkKGlkLCBEYXRlLm5vdygpICsgODY0MDAwMDApOyAvLyBEdWUgaW4gMjQgaG91cnNcblxuZGVzY3JpYmUoJ3VzZURlcml2ZWRQcm9ncmVzcyBIb29rIChFbmhhbmNlZCB3aXRoIENhY2hlKScsICgpID0+IHtcbiAgY29uc3QgdXNlcklkID0gJ3Rlc3QtdXNlci0xMjMnO1xuICBsZXQgbW9ja0NhY2hlU2VydmljZTogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDYWNoZVNlcnZpY2UgPSBkdWVDYXJkc0NhY2hlU2VydmljZSBhcyBhbnk7XG4gICAgbW9ja0NhY2hlU2VydmljZS5fX3NldE1vY2tDYWNoZURhdGEobnVsbCk7XG4gICAgXG4gICAgLy8gUmVzZXQgY2FjaGUgc3RhdHNcbiAgICBqZXN0Lm1vY2tlZChtb2NrQ2FjaGVTZXJ2aWNlLmdldENhY2hlU3RhdHMpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICBhdmFpbGFibGU6IHRydWUsXG4gICAgICB0b3RhbEVudHJpZXM6IDAsXG4gICAgICBlc3RpbWF0ZWRTaXplOiAwLFxuICAgICAgbGFzdENsZWFudXA6IG51bGxcbiAgICB9KTtcblxuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIFxuICAgIC8vIFJlc2V0IHN0b3JlIHRvIGluaXRpYWwgc3RhdGVcbiAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnByb2dyZXNzLnJlc2V0UHJvZ3Jlc3MoKTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Jhc2ljIGZ1bmN0aW9uYWxpdHkgd2l0aG91dCBjYWNoZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNhbGN1bGF0ZSBkdWUgY2FyZHMgd2l0aG91dCB1c2VySWQgKGZhbGxiYWNrIG1vZGUpJywgKCkgPT4ge1xuICAgICAgLy8gU2V0dXAgc29tZSBjYXJkIHByb2dyZXNzXG4gICAgICBjb25zdCBjYXJkcyA9IFtcbiAgICAgICAgY3JlYXRlRHVlQ2FyZCgnZHVlLTEnKSxcbiAgICAgICAgY3JlYXRlRHVlQ2FyZCgnZHVlLTInKSxcbiAgICAgICAgY3JlYXRlRnV0dXJlQ2FyZCgnZnV0dXJlLTEnKVxuICAgICAgXTtcblxuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5wcm9ncmVzcy5pbml0aWFsaXplQ2FyZHMoY2FyZHMpO1xuICAgICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnByb2dyZXNzLnVwZGF0ZVNlc3Npb25Qcm9ncmVzcyh7XG4gICAgICAgICAgcG9zaXRpb25zQ29ycmVjdDogOCxcbiAgICAgICAgICBwb3NpdGlvbnNBdHRlbXB0ZWQ6IDEwXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyhudWxsKSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kdWVDYXJkQ291bnQpLnRvQmUoMik7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQudG90YWxDYXJkcykudG9CZSgzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5zdWNjZXNzUmF0ZSkudG9CZSg4MCk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNGcm9tQ2FjaGUpLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmNhY2hlU3RhdHMuYXZhaWxhYmxlKS50b0JlKGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdWxkIG5vdCBjYWxsIGNhY2hlIHNlcnZpY2Ugd2l0aG91dCB1c2VySWRcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZW1wdHkgY2FyZCBwcm9ncmVzcycsICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyh1c2VySWQpKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmR1ZUNhcmRDb3VudCkudG9CZSgwKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC50b3RhbENhcmRzKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN1Y2Nlc3NSYXRlKS50b0JlKDApO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRnJvbUNhY2hlKS50b0JlKGZhbHNlKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0NhY2hlLWZpcnN0IHN0cmF0ZWd5JywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXNlIGNhY2hlZCByZXN1bHQgd2hlbiBhdmFpbGFibGUnLCAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCBjYXJkcyBpbiBzdG9yZVxuICAgICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIGNyZWF0ZUR1ZUNhcmQoJ2R1ZS0xJyksXG4gICAgICAgIGNyZWF0ZUR1ZUNhcmQoJ2R1ZS0yJyksXG4gICAgICAgIGNyZWF0ZUZ1dHVyZUNhcmQoJ2Z1dHVyZS0xJylcbiAgICAgIF07XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkucHJvZ3Jlc3MuaW5pdGlhbGl6ZUNhcmRzKGNhcmRzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBNb2NrIGNhY2hlZCByZXN1bHRcbiAgICAgIGNvbnN0IG1vY2tDYWNoZWRSZXN1bHQgPSB7XG4gICAgICAgIGR1ZUNhcmRzOiBbXG4gICAgICAgICAgeyAuLi5jcmVhdGVEdWVDYXJkKCdkdWUtMScpLCBfX2lzRHVlOiB0cnVlLCBfX2JyYW5kOiAnRHVlQ2FyZCcgfSxcbiAgICAgICAgICB7IC4uLmNyZWF0ZUR1ZUNhcmQoJ2R1ZS0yJyksIF9faXNEdWU6IHRydWUsIF9fYnJhbmQ6ICdEdWVDYXJkJyB9XG4gICAgICAgIF0sXG4gICAgICAgIGNhbGN1bGF0ZWRBdDogRGF0ZS5ub3coKSAtIDMwMDAwLCAvLyAzMCBzZWNvbmRzIGFnb1xuICAgICAgICBzdGF0czoge1xuICAgICAgICAgIHRvdGFsQ2FyZHM6IDMsXG4gICAgICAgICAgZHVlQ291bnQ6IDIsXG4gICAgICAgICAgZHVlUGVyY2VudGFnZTogNjcsXG4gICAgICAgICAgbmV4dER1ZUF0OiBEYXRlLm5vdygpICsgMzYwMDAwMCxcbiAgICAgICAgICBhdmVyYWdlSW50ZXJ2YWw6IDIuNVxuICAgICAgICB9LFxuICAgICAgICBpbnB1dEhhc2g6ICdjYWNoZWQtaGFzaCcsXG4gICAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSAtIDMwMDAwLFxuICAgICAgICBsYXN0QWNjZXNzZWRBdDogRGF0ZS5ub3coKSAtIDMwMDAwXG4gICAgICB9O1xuXG4gICAgICBtb2NrQ2FjaGVTZXJ2aWNlLl9fc2V0TW9ja0NhY2hlRGF0YShtb2NrQ2FjaGVkUmVzdWx0KTtcblxuICAgICAgY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT4gdXNlRGVyaXZlZFByb2dyZXNzKHVzZXJJZCkpO1xuXG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuaXNGcm9tQ2FjaGUpLnRvQmUodHJ1ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQuZHVlQ2FyZENvdW50KS50b0JlKDIpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LnN0YXRzKS50b0VxdWFsKG1vY2tDYWNoZWRSZXN1bHQuc3RhdHMpO1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHVzZXJJZCwgZXhwZWN0LmFueShTdHJpbmcpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29tcHV0ZSBmcmVzaCByZXN1bHQgb24gY2FjaGUgbWlzcyBhbmQgY2FjaGUgaXQnLCAoKSA9PiB7XG4gICAgICAvLyBTZXR1cCBjYXJkcyBpbiBzdG9yZVxuICAgICAgY29uc3QgY2FyZHMgPSBbXG4gICAgICAgIGNyZWF0ZUR1ZUNhcmQoJ2R1ZS0xJyksXG4gICAgICAgIGNyZWF0ZUZ1dHVyZUNhcmQoJ2Z1dHVyZS0xJyksXG4gICAgICAgIGNyZWF0ZUZ1dHVyZUNhcmQoJ2Z1dHVyZS0yJylcbiAgICAgIF07XG5cbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkucHJvZ3Jlc3MuaW5pdGlhbGl6ZUNhcmRzKGNhcmRzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBObyBjYWNoZWQgcmVzdWx0IChjYWNoZSBtaXNzKVxuICAgICAgbW9ja0NhY2hlU2VydmljZS5fX3NldE1vY2tDYWNoZURhdGEobnVsbCk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyh1c2VySWQpKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmlzRnJvbUNhY2hlKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5kdWVDYXJkQ291bnQpLnRvQmUoMSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQudG90YWxDYXJkcykudG9CZSgzKTtcblxuICAgICAgLy8gU2hvdWxkIGhhdmUgdHJpZWQgdG8gZ2V0IGZyb20gY2FjaGVcbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh1c2VySWQsIGV4cGVjdC5hbnkoU3RyaW5nKSk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBoYXZlIGNhY2hlZCB0aGUgcmVzdWx0XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXREdWVDYXJkcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgZXhwZWN0LmFycmF5Q29udGFpbmluZyhbZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBpZDogJ2R1ZS0xJyB9KV0pLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IGR1ZUNvdW50OiAxLCB0b3RhbENhcmRzOiAzIH0pLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZylcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBjYWNoZSBzZXJ2aWNlIGVycm9ycyBncmFjZWZ1bGx5JywgKCkgPT4ge1xuICAgICAgLy8gU2V0dXAgY2FyZHNcbiAgICAgIGNvbnN0IGNhcmRzID0gW2NyZWF0ZUR1ZUNhcmQoJ2R1ZS0xJyldO1xuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5wcm9ncmVzcy5pbml0aWFsaXplQ2FyZHMoY2FyZHMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vY2sgY2FjaGUgc2VydmljZSB0byB0aHJvdyBlcnJvclxuICAgICAgamVzdC5tb2NrZWQobW9ja0NhY2hlU2VydmljZS5zZXREdWVDYXJkcykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWNoZSB3cml0ZSBlcnJvcicpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyh1c2VySWQpKTtcblxuICAgICAgLy8gU2hvdWxkIHN0aWxsIHJldHVybiBjb21wdXRlZCByZXN1bHQgZGVzcGl0ZSBjYWNoZSBlcnJvclxuICAgICAgZXhwZWN0KHJlc3VsdC5jdXJyZW50LmR1ZUNhcmRDb3VudCkudG9CZSgxKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY3VycmVudC5pc0Zyb21DYWNoZSkudG9CZShmYWxzZSk7XG4gICAgICBleHBlY3QocmVzdWx0LmN1cnJlbnQudG90YWxDYXJkcykudG9CZSgxKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0lucHV0IGhhc2ggdmFsaWRhdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBjb25zaXN0ZW50IGlucHV0IGhhc2ggZm9yIHNhbWUgaW5wdXRzJywgKCkgPT4ge1xuICAgICAgY29uc3QgY2FyZHMgPSBbY3JlYXRlRHVlQ2FyZCgnZHVlLTEnKSwgY3JlYXRlRnV0dXJlQ2FyZCgnZnV0dXJlLTEnKV07XG4gICAgICBcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkucHJvZ3Jlc3MuaW5pdGlhbGl6ZUNhcmRzKGNhcmRzKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW5kZXIgaG9vayBtdWx0aXBsZSB0aW1lc1xuICAgICAgcmVuZGVySG9vaygoKSA9PiB1c2VEZXJpdmVkUHJvZ3Jlc3ModXNlcklkKSk7XG4gICAgICByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyh1c2VySWQpKTtcblxuICAgICAgLy8gQm90aCBzaG91bGQgY2FsbCBnZXREdWVDYXJkcyB3aXRoIHNhbWUgaGFzaFxuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGRpZmZlcmVudCBoYXNoIHdoZW4gY2FyZHMgY2hhbmdlJywgKCkgPT4ge1xuICAgICAgLy8gSW5pdGlhbCBjYXJkc1xuICAgICAgYWN0KCgpID0+IHtcbiAgICAgICAgdXNlU3RvcmUuZ2V0U3RhdGUoKS5wcm9ncmVzcy5pbml0aWFsaXplQ2FyZHMoW2NyZWF0ZUR1ZUNhcmQoJ2R1ZS0xJyldKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB7IHJlcmVuZGVyIH0gPSByZW5kZXJIb29rKCgpID0+IHVzZURlcml2ZWRQcm9ncmVzcyh1c2VySWQpKTtcblxuICAgICAgLy8gQWRkIG1vcmUgY2FyZHNcbiAgICAgIGFjdCgoKSA9PiB7XG4gICAgICAgIHVzZVN0b3JlLmdldFN0YXRlKCkucHJvZ3Jlc3MuaW5pdGlhbGl6ZUNhcmRzKFtcbiAgICAgICAgICBjcmVhdGVEdWVDYXJkKCdkdWUtMScpLCBcbiAgICAgICAgICBjcmVhdGVEdWVDYXJkKCdkdWUtMicpXG4gICAgICAgIF0pO1xuICAgICAgfSk7XG5cbiAgICAgIHJlcmVuZGVyKCk7XG5cbiAgICAgIC8vIFNob3VsZCBoYXZlIGNhbGxlZCBnZXREdWVDYXJkcyB0d2ljZSB3aXRoIGRpZmZlcmVudCBjb250ZXh0c1xuICAgICAgZXhwZWN0KG1vY2tDYWNoZVNlcnZpY2UuZ2V0RHVlQ2FyZHMpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1BlcmZvcm1hbmNlIG9wdGltaXphdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBsYXJnZSBjYXJkIGNvbGxlY3Rpb25zIGVmZmljaWVudGx5JywgKCkgPT4ge1xuICAgICAgLy8gQ3JlYXRlIDEwMDAgY2FyZHMgKDUwMCBkdWUsIDUwMCBmdXR1cmUpXG4gICAgICBjb25zdCBsYXJnZUNhcmRTZXQgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAxMDAwIH0sIChfLCBpKSA9PiBcbiAgICAgICAgaSAlIDIgPT09IDAgXG4gICAgICAgICAgPyBjcmVhdGVEdWVDYXJkKGBkdWUtJHtpfWApXG4gICAgICAgICAgOiBjcmVhdGVGdXR1cmVDYXJkKGBmdXR1cmUtJHtpfWApXG4gICAgICApO1xuXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnByb2dyZXNzLmluaXRpYWxpemVDYXJkcyhsYXJnZUNhcmRTZXQpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgcmVuZGVySG9vaygoKSA9PiB1c2VEZXJpdmVkUHJvZ3Jlc3ModXNlcklkKSk7XG4gICAgICBjb25zdCBlbmRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICBcbiAgICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gcmVhc29uYWJsZSB0aW1lICg8IDEwMG1zKVxuICAgICAgZXhwZWN0KGVuZFRpbWUgLSBzdGFydFRpbWUpLnRvQmVMZXNzVGhhbigxMDApO1xuICAgICAgXG4gICAgICAvLyBTaG91bGQgYXR0ZW1wdCB0byBjYWNoZSB0aGUgbGFyZ2UgcmVzdWx0XG4gICAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5zZXREdWVDYXJkcykudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCB1c2UgNS1taW51dGUgdGltZXN0YW1wIGJ1Y2tldHMgZm9yIGNhY2hlIHN0YWJpbGl0eScsICgpID0+IHtcbiAgICAgIGNvbnN0IGNhcmRzID0gW2NyZWF0ZUR1ZUNhcmQoJ2R1ZS0xJyldO1xuICAgICAgXG4gICAgICBhY3QoKCkgPT4ge1xuICAgICAgICB1c2VTdG9yZS5nZXRTdGF0ZSgpLnByb2dyZXNzLmluaXRpYWxpemVDYXJkcyhjYXJkcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gTW9jayB0aW1lIHRvIGJlIG1pZC1idWNrZXRcbiAgICAgIGNvbnN0IG9yaWdpbmFsRGF0ZU5vdyA9IERhdGUubm93O1xuICAgICAgY29uc3QgZml4ZWRUaW1lID0gMTcwMDAwMDAwMDAwMDsgLy8gRml4ZWQgdGltZXN0YW1wXG4gICAgICBEYXRlLm5vdyA9IGplc3QuZm4oKCkgPT4gZml4ZWRUaW1lICsgMiAqIDYwICogMTAwMCk7IC8vICsyIG1pbnV0ZXNcblxuICAgICAgcmVuZGVySG9vaygoKSA9PiB1c2VEZXJpdmVkUHJvZ3Jlc3ModXNlcklkKSk7XG5cbiAgICAgIC8vIFNob3VsZCB1c2UgNS1taW51dGUgYnVja2V0IGluIGhhc2ggY2FsY3VsYXRpb25cbiAgICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmdldER1ZUNhcmRzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAgIERhdGUubm93ID0gb3JpZ2luYWxEYXRlTm93O1xuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgndXNlRHVlQ2FyZHNDYWNoZSBIb29rJywgKCkgPT4ge1xuICBsZXQgbW9ja0NhY2hlU2VydmljZTogYW55O1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIG1vY2tDYWNoZVNlcnZpY2UgPSBkdWVDYXJkc0NhY2hlU2VydmljZSBhcyBhbnk7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcHJvdmlkZSBjYWNoZSBtYW5hZ2VtZW50IGZ1bmN0aW9ucycsICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEdWVDYXJkc0NhY2hlKCkpO1xuXG4gICAgZXhwZWN0KHR5cGVvZiByZXN1bHQuY3VycmVudC5jbGVhclVzZXJDYWNoZSkudG9CZSgnZnVuY3Rpb24nKTtcbiAgICBleHBlY3QodHlwZW9mIHJlc3VsdC5jdXJyZW50LmNsZWFyQWxsQ2FjaGUpLnRvQmUoJ2Z1bmN0aW9uJyk7XG4gICAgZXhwZWN0KHR5cGVvZiByZXN1bHQuY3VycmVudC5nZXRDYWNoZVN0YXRzKS50b0JlKCdmdW5jdGlvbicpO1xuICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0LmN1cnJlbnQuZm9yY2VDbGVhbnVwKS50b0JlKCdmdW5jdGlvbicpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGNhbGwgY2FjaGUgc2VydmljZSBtZXRob2RzIGNvcnJlY3RseScsICgpID0+IHtcbiAgICBjb25zdCB7IHJlc3VsdCB9ID0gcmVuZGVySG9vaygoKSA9PiB1c2VEdWVDYXJkc0NhY2hlKCkpO1xuXG4gICAgLy8gVGVzdCBjbGVhclVzZXJDYWNoZVxuICAgIHJlc3VsdC5jdXJyZW50LmNsZWFyVXNlckNhY2hlKCd0ZXN0LXVzZXInKTtcbiAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5jbGVhclVzZXJDYWNoZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ3Rlc3QtdXNlcicpO1xuXG4gICAgLy8gVGVzdCBjbGVhckFsbENhY2hlXG4gICAgcmVzdWx0LmN1cnJlbnQuY2xlYXJBbGxDYWNoZSgpO1xuICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmNsZWFyQWxsQ2FjaGUpLnRvSGF2ZUJlZW5DYWxsZWQoKTtcblxuICAgIC8vIFRlc3QgZ2V0Q2FjaGVTdGF0c1xuICAgIHJlc3VsdC5jdXJyZW50LmdldENhY2hlU3RhdHMoKTtcbiAgICBleHBlY3QobW9ja0NhY2hlU2VydmljZS5nZXRDYWNoZVN0YXRzKS50b0hhdmVCZWVuQ2FsbGVkKCk7XG5cbiAgICAvLyBUZXN0IGZvcmNlQ2xlYW51cFxuICAgIHJlc3VsdC5jdXJyZW50LmZvcmNlQ2xlYW51cCgpO1xuICAgIGV4cGVjdChtb2NrQ2FjaGVTZXJ2aWNlLmZvcmNlQ2xlYW51cCkudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBzdGFibGUgcmVmZXJlbmNlcyAodXNlTWVtbyknLCAoKSA9PiB7XG4gICAgY29uc3QgeyByZXN1bHQsIHJlcmVuZGVyIH0gPSByZW5kZXJIb29rKCgpID0+IHVzZUR1ZUNhcmRzQ2FjaGUoKSk7XG5cbiAgICBjb25zdCBmaXJzdFJlbmRlciA9IHJlc3VsdC5jdXJyZW50O1xuICAgIFxuICAgIHJlcmVuZGVyKCk7XG4gICAgXG4gICAgY29uc3Qgc2Vjb25kUmVuZGVyID0gcmVzdWx0LmN1cnJlbnQ7XG5cbiAgICAvLyBBbGwgZnVuY3Rpb25zIHNob3VsZCBiZSB0aGUgc2FtZSByZWZlcmVuY2VcbiAgICBleHBlY3QoZmlyc3RSZW5kZXIuY2xlYXJVc2VyQ2FjaGUpLnRvQmUoc2Vjb25kUmVuZGVyLmNsZWFyVXNlckNhY2hlKTtcbiAgICBleHBlY3QoZmlyc3RSZW5kZXIuY2xlYXJBbGxDYWNoZSkudG9CZShzZWNvbmRSZW5kZXIuY2xlYXJBbGxDYWNoZSk7XG4gICAgZXhwZWN0KGZpcnN0UmVuZGVyLmdldENhY2hlU3RhdHMpLnRvQmUoc2Vjb25kUmVuZGVyLmdldENhY2hlU3RhdHMpO1xuICAgIGV4cGVjdChmaXJzdFJlbmRlci5mb3JjZUNsZWFudXApLnRvQmUoc2Vjb25kUmVuZGVyLmZvcmNlQ2xlYW51cCk7XG4gIH0pO1xufSk7Il0sIm5hbWVzIjpbImplc3QiLCJtb2NrIiwibW9ja0NhY2hlRGF0YSIsIm1vY2tDYWNoZVN0YXRzIiwiYXZhaWxhYmxlIiwidG90YWxFbnRyaWVzIiwiZXN0aW1hdGVkU2l6ZSIsImxhc3RDbGVhbnVwIiwibW9ja0NhY2hlU2VydmljZSIsImdldER1ZUNhcmRzIiwiZm4iLCJzZXREdWVDYXJkcyIsImNsZWFyVXNlckNhY2hlIiwiTWF0aCIsIm1heCIsImNsZWFyQWxsQ2FjaGUiLCJnZXRDYWNoZVN0YXRzIiwiZm9yY2VDbGVhbnVwIiwiX19zZXRNb2NrQ2FjaGVEYXRhIiwiZGF0YSIsImR1ZUNhcmRzQ2FjaGVTZXJ2aWNlIiwiY3JlYXRlSW5wdXRIYXNoIiwiaW5wdXQiLCJKU09OIiwic3RyaW5naWZ5IiwibGVuZ3RoIiwiZ2V0TG9nZ2VyIiwic2V0Q29udGV4dCIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImNyZWF0ZVRlc3RDYXJkIiwiaWQiLCJuZXh0UmV2aWV3QXQiLCJsYXN0UmV2aWV3ZWRBdCIsIkRhdGUiLCJub3ciLCJpbnRlcnZhbCIsInJlcGV0aXRpb24iLCJlZmFjdG9yIiwibGFwc2VzIiwiY3JlYXRlRHVlQ2FyZCIsImNyZWF0ZUZ1dHVyZUNhcmQiLCJkZXNjcmliZSIsInVzZXJJZCIsImJlZm9yZUVhY2giLCJtb2NrZWQiLCJtb2NrUmV0dXJuVmFsdWUiLCJjbGVhckFsbE1vY2tzIiwidXNlU3RvcmUiLCJnZXRTdGF0ZSIsInByb2dyZXNzIiwicmVzZXRQcm9ncmVzcyIsIml0IiwiY2FyZHMiLCJhY3QiLCJpbml0aWFsaXplQ2FyZHMiLCJ1cGRhdGVTZXNzaW9uUHJvZ3Jlc3MiLCJwb3NpdGlvbnNDb3JyZWN0IiwicG9zaXRpb25zQXR0ZW1wdGVkIiwicmVzdWx0IiwicmVuZGVySG9vayIsInVzZURlcml2ZWRQcm9ncmVzcyIsImV4cGVjdCIsImN1cnJlbnQiLCJkdWVDYXJkQ291bnQiLCJ0b0JlIiwidG90YWxDYXJkcyIsInN1Y2Nlc3NSYXRlIiwiaXNGcm9tQ2FjaGUiLCJjYWNoZVN0YXRzIiwibm90IiwidG9IYXZlQmVlbkNhbGxlZCIsIm1vY2tDYWNoZWRSZXN1bHQiLCJkdWVDYXJkcyIsIl9faXNEdWUiLCJfX2JyYW5kIiwiY2FsY3VsYXRlZEF0Iiwic3RhdHMiLCJkdWVDb3VudCIsImR1ZVBlcmNlbnRhZ2UiLCJuZXh0RHVlQXQiLCJhdmVyYWdlSW50ZXJ2YWwiLCJpbnB1dEhhc2giLCJjcmVhdGVkQXQiLCJsYXN0QWNjZXNzZWRBdCIsInRvRXF1YWwiLCJ0b0hhdmVCZWVuQ2FsbGVkV2l0aCIsImFueSIsIlN0cmluZyIsImFycmF5Q29udGFpbmluZyIsIm9iamVjdENvbnRhaW5pbmciLCJtb2NrSW1wbGVtZW50YXRpb24iLCJFcnJvciIsInRvSGF2ZUJlZW5DYWxsZWRUaW1lcyIsInJlcmVuZGVyIiwibGFyZ2VDYXJkU2V0IiwiQXJyYXkiLCJmcm9tIiwiXyIsImkiLCJzdGFydFRpbWUiLCJwZXJmb3JtYW5jZSIsImVuZFRpbWUiLCJ0b0JlTGVzc1RoYW4iLCJvcmlnaW5hbERhdGVOb3ciLCJmaXhlZFRpbWUiLCJ1c2VEdWVDYXJkc0NhY2hlIiwiZmlyc3RSZW5kZXIiLCJzZWNvbmRSZW5kZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Q0FHQztBQVFELHlCQUF5QjtBQUN6QkEsS0FBS0MsSUFBSSxDQUFDLHlDQUF5QztJQUNqRCxJQUFJQyxnQkFBcUI7SUFDekIsSUFBSUMsaUJBQWlCO1FBQ25CQyxXQUFXO1FBQ1hDLGNBQWM7UUFDZEMsZUFBZTtRQUNmQyxhQUFhO0lBQ2Y7SUFFQSxNQUFNQyxtQkFBbUI7UUFDdkJDLGFBQWFULEtBQUtVLEVBQUUsQ0FBQyxJQUFNUjtRQUMzQlMsYUFBYVgsS0FBS1UsRUFBRSxDQUFDO1lBQ25CUCxlQUFlRSxZQUFZLElBQUk7WUFDL0JGLGVBQWVHLGFBQWEsSUFBSSxNQUFNLHVCQUF1QjtRQUMvRDtRQUNBTSxnQkFBZ0JaLEtBQUtVLEVBQUUsQ0FBQztZQUN0QlIsZ0JBQWdCO1lBQ2hCQyxlQUFlRSxZQUFZLEdBQUdRLEtBQUtDLEdBQUcsQ0FBQyxHQUFHWCxlQUFlRSxZQUFZLEdBQUc7UUFDMUU7UUFDQVUsZUFBZWYsS0FBS1UsRUFBRSxDQUFDO1lBQ3JCUixnQkFBZ0I7WUFDaEJDLGlCQUFpQjtnQkFBRUMsV0FBVztnQkFBTUMs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