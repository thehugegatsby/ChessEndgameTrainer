{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-firebase-testing/src/tests/integration/firebase/FirebaseService.test.ts"],"sourcesContent":["/**\n * @file Firebase Service Integration Tests\n * @description Comprehensive Firebase integration tests with emulator\n * \n * Tests for Issue #83: Firebase service integration test infrastructure\n * Covers User Progress CRUD, Authentication, Real-time updates, and concurrency\n * \n * @jest-environment node\n */\n\n// Setup fetch for Firebase Auth in Node environment\nimport '../../setup/firebase-test-setup';\n\n// Path abstraction layer\nimport { \n  getUserProgressPath, \n  getUserStatsPath, \n  getCardProgressPath \n} from '@tests/utils/firebase-paths';\n\nimport { \n  doc, \n  getDoc, \n  setDoc, \n  updateDoc, \n  deleteDoc,\n  onSnapshot,\n  serverTimestamp,\n  getDocs,\n  collection,\n  query,\n  where,\n  writeBatch,\n  Timestamp\n} from 'firebase/firestore';\n\nimport {\n  initializeTestFirebase,\n  createTestUser,\n  createAnonymousUser,\n  createTestUserWithProgress,\n  seedUserProgress,\n  clearUserProgressData,\n  clearFirestoreData,\n  cleanupAllTestFirebase,\n  TEST_USER_STATS,\n  TEST_CARD_PROGRESS,\n  RealtimeTestHelper,\n  type TestFirebaseInstance\n} from '@tests/utils/firebase-test-helpers';\n\nimport { signOut, signInWithEmailAndPassword } from 'firebase/auth';\n\nimport { waitForEmulator, isEmulatorRunning } from '@tests/utils/firebase-emulator-api';\nimport type { UserStats, CardProgress } from '@shared/store/slices/types';\n\n// Increase timeout for integration tests\njest.setTimeout(30000);\n\ndescribe('Firebase Service Integration', () => {\n  let testInstance: TestFirebaseInstance;\n  let testUserId: string;\n  let realtimeHelper: RealtimeTestHelper;\n\n  beforeAll(async () => {\n    // Ensure emulator is running\n    const emulatorReady = await isEmulatorRunning();\n    if (!emulatorReady) {\n      console.log('Waiting for Firebase emulator to start...');\n      await waitForEmulator();\n    }\n    \n    // Clear all data before starting tests\n    await clearFirestoreData();\n  });\n\n  beforeEach(async () => {\n    // Create isolated Firebase instance for each test\n    testInstance = await initializeTestFirebase();\n    realtimeHelper = new RealtimeTestHelper();\n    \n    // Create authenticated test user\n    const userCredential = await createTestUser(testInstance.auth);\n    testUserId = userCredential.user.uid;\n  });\n\n  afterEach(async () => {\n    // Cleanup real-time listeners\n    realtimeHelper.cleanup();\n    \n    // Clear user data BEFORE signing out (needs auth for security rules)\n    if (testUserId && testInstance?.db) {\n      try {\n        await clearUserProgressData(testInstance.db, testUserId);\n      } catch (error) {\n        // Ignore errors if user data doesn't exist\n      }\n    }\n    \n    // Sign out any authenticated user AFTER clearing data\n    if (testInstance?.auth) {\n      await signOut(testInstance.auth);\n    }\n  });\n\n  afterAll(async () => {\n    // Cleanup all test Firebase instances\n    await cleanupAllTestFirebase();\n  });\n\n  describe('Firestore CRUD Operations', () => {\n    describe('UserStats Operations', () => {\n      it('creates user progress document with authentication', async () => {\n        const userStats: UserStats = {\n          ...TEST_USER_STATS,\n          userId: testUserId,\n        };\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        \n        await setDoc(docRef, {\n          ...userStats,\n          lastActive: serverTimestamp(),\n        });\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.exists()).toBe(true);\n        expect(docSnap.data()?.userId).toBe(testUserId);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(25);\n      });\n\n      it('reads user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        const docSnap = await getDoc(docRef);\n        \n        expect(docSnap.exists()).toBe(true);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(25);\n        expect(docSnap.data()?.overallSuccessRate).toBe(0.85);\n      });\n\n      it('updates user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        \n        await updateDoc(docRef, {\n          totalPositionsCompleted: 30,\n          overallSuccessRate: 0.90,\n          lastActive: serverTimestamp(),\n        });\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(30);\n        expect(docSnap.data()?.overallSuccessRate).toBe(0.90);\n      });\n\n      it('deletes user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        await deleteDoc(docRef);\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.exists()).toBe(false);\n      });\n    });\n\n    describe('CardProgress Operations', () => {\n      it('creates multiple card progress documents', async () => {\n        const batch = writeBatch(testInstance.db);\n        \n        TEST_CARD_PROGRESS.forEach((card) => {\n          const docRef = doc(\n            testInstance.db, \n            `users/${testUserId}/userProgress/${card.id}`\n          );\n          batch.set(docRef, {\n            ...card,\n            lastUpdated: serverTimestamp(),\n          });\n        });\n        \n        await batch.commit();\n        \n        // Verify all cards were created\n        const progressCollection = collection(\n          testInstance.db, \n          `users/${testUserId}/userProgress`\n        );\n        const snapshot = await getDocs(progressCollection);\n        \n        // Filter out stats document, count only card documents\n        const cardDocs = snapshot.docs.filter(d => d.id !== 'stats');\n        expect(cardDocs.length).toBe(TEST_CARD_PROGRESS.length);\n      });\n\n      it('queries due cards using where clause', async () => {\n        await seedUserProgress(testInstance.db, testUserId, undefined, TEST_CARD_PROGRESS);\n        \n        const now = Date.now();\n        const progressCollection = collection(\n          testInstance.db,\n          `users/${testUserId}/userProgress`\n        );\n        \n        // Query for due cards (nextReviewAt <= now)\n        const dueCardsQuery = query(\n          progressCollection,\n          where('nextReviewAt', '<=', now)\n        );\n        \n        const snapshot = await getDocs(dueCardsQuery);\n        \n        // Should find pos-2 which is overdue\n        expect(snapshot.size).toBeGreaterThan(0);\n        const dueCard = snapshot.docs.find(d => d.id === 'pos-2');\n        expect(dueCard).toBeDefined();\n      });\n    });\n  });\n\n  describe('Real-time Updates', () => {\n    it('receives real-time updates through onSnapshot for UserStats', (done) => {\n      const docRef = doc(testInstance.db, `users/${testUserId}/userProgress/stats`);\n      let updateCount = 0;\n      \n      const unsubscribe = onSnapshot(docRef, (snapshot) => {\n        updateCount++;\n        \n        if (updateCount === 1) {\n          // Initial empty snapshot\n          expect(snapshot.exists()).toBe(false);\n          \n          // Trigger first write\n          setDoc(docRef, {\n            ...TEST_USER_STATS,\n            userId: testUserId,\n            totalPositionsCompleted: 10,\n          });\n        } else if (updateCount === 2) {\n          // After first write\n          expect(snapshot.exists()).toBe(true);\n          expect(snapshot.data()?.totalPositionsCompleted).toBe(10);\n          \n          // Trigger update\n          updateDoc(docRef, {\n            totalPositionsCompleted: 15,\n          });\n        } else if (updateCount === 3) {\n          // After update\n          expect(snapshot.data()?.totalPositionsCompleted).toBe(15);\n          unsubscribe();\n          done();\n        }\n      });\n      \n      realtimeHelper.registerListener(unsubscribe);\n    });\n\n    it('receives real-time updates for CardProgress collection', (done) => {\n      const progressCollection = collection(\n        testInstance.db,\n        `users/${testUserId}/userProgress`\n      );\n      \n      let snapshotCount = 0;\n      \n      const unsubscribe = onSnapshot(progressCollection, (snapshot) => {\n        snapshotCount++;\n        \n        if (snapshotCount === 1) {\n          // Initial empty collection\n          expect(snapshot.empty).toBe(true);\n          \n          // Add first card\n          const card1Ref = doc(progressCollection, 'card-1');\n          setDoc(card1Ref, {\n            id: 'card-1',\n            nextReviewAt: Date.now() + 86400000,\n            lastReviewedAt: Date.now(),\n            interval: 1,\n            repetition: 1,\n            efactor: 2.5,\n            quality: 4,\n          });\n        } else if (snapshotCount === 2) {\n          // After first card added\n          expect(snapshot.size).toBe(1);\n          \n          // Add second card\n          const card2Ref = doc(progressCollection, 'card-2');\n          setDoc(card2Ref, {\n            id: 'card-2',\n            nextReviewAt: Date.now() + 172800000,\n            lastReviewedAt: Date.now(),\n            interval: 2,\n            repetition: 2,\n            efactor: 2.4,\n            quality: 3,\n          });\n        } else if (snapshotCount === 3) {\n          // After second card added\n          expect(snapshot.size).toBe(2);\n          unsubscribe();\n          done();\n        }\n      });\n      \n      realtimeHelper.registerListener(unsubscribe);\n    });\n  });\n\n  describe('Authentication & Security', () => {\n    it('allows user to access only their own progress data', async () => {\n      // Create first user with progress\n      const { userId: userId1 } = await createTestUserWithProgress(\n        testInstance,\n        'user1@test.com'\n      );\n      \n      // Sign out user1\n      await signOut(testInstance.auth);\n      \n      // Create and sign in as user2\n      const userCredential2 = await createTestUser(\n        testInstance.auth,\n        'user2@test.com'\n      );\n      const userId2 = userCredential2.user.uid;\n      \n      // Now as user2, try to read user1's data (should fail with security rules)\n      const user1DocRef = doc(\n        testInstance.db,\n        getUserStatsPath(userId1)\n      );\n      \n      // This should fail with security rules enabled\n      await expect(getDoc(user1DocRef)).rejects.toThrow();\n      \n      // User2 should be able to write and read their own data\n      await seedUserProgress(testInstance.db, userId2);\n      const user2DocRef = doc(testInstance.db, getUserStatsPath(userId2));\n      const user2Doc = await getDoc(user2DocRef);\n      \n      expect(user2Doc.exists()).toBe(true);\n      expect(user2Doc.data()?.userId).toBe(userId2);\n    });\n\n    it('supports anonymous user progress tracking', async () => {\n      const anonCredential = await createAnonymousUser(testInstance.auth);\n      const anonUserId = anonCredential.user.uid;\n      \n      await seedUserProgress(\n        testInstance.db,\n        anonUserId,\n        { userId: anonUserId }\n      );\n      \n      const docRef = doc(\n        testInstance.db,\n        `users/${anonUserId}/userProgress/stats`\n      );\n      const docSnap = await getDoc(docRef);\n      \n      expect(docSnap.exists()).toBe(true);\n      expect(docSnap.data()?.userId).toBe(anonUserId);\n    });\n  });\n\n  describe('Concurrent Operations', () => {\n    it('handles concurrent updates to the same document', async () => {\n      const docRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Set initial value\n      await setDoc(docRef, {\n        ...TEST_USER_STATS,\n        userId: testUserId,\n        totalPositionsCompleted: 0,\n      });\n      \n      // Simulate concurrent updates\n      const updates = Array.from({ length: 5 }, (_, i) => \n        updateDoc(docRef, {\n          totalPositionsCompleted: i + 1,\n          lastActive: serverTimestamp(),\n        })\n      );\n      \n      await Promise.all(updates);\n      \n      // Check final state\n      const finalDoc = await getDoc(docRef);\n      expect(finalDoc.exists()).toBe(true);\n      expect(finalDoc.data()?.totalPositionsCompleted).toBeDefined();\n      expect(typeof finalDoc.data()?.totalPositionsCompleted).toBe('number');\n    });\n\n    it('handles batch operations with multiple cards', async () => {\n      const batch = writeBatch(testInstance.db);\n      \n      // Create 10 cards in a batch\n      for (let i = 0; i < 10; i++) {\n        const cardRef = doc(\n          testInstance.db,\n          `users/${testUserId}/userProgress/card-${i}`\n        );\n        \n        batch.set(cardRef, {\n          id: `card-${i}`,\n          nextReviewAt: Date.now() + (i * 86400000), // Stagger by days\n          lastReviewedAt: Date.now(),\n          interval: i + 1,\n          repetition: 1,\n          efactor: 2.5,\n          quality: 4,\n          lastUpdated: serverTimestamp(),\n        });\n      }\n      \n      await batch.commit();\n      \n      // Verify all cards were created\n      const progressCollection = collection(\n        testInstance.db,\n        `users/${testUserId}/userProgress`\n      );\n      const snapshot = await getDocs(progressCollection);\n      \n      expect(snapshot.size).toBe(10);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('handles invalid document paths gracefully', async () => {\n      // Test invalid path construction\n      expect(() => {\n        // This creates an invalid path with empty segment\n        doc(testInstance.db, 'users', '', 'userProgress', 'stats');\n      }).toThrow('Invalid document reference');\n    });\n\n    it('handles missing required fields', async () => {\n      const docRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Missing required userId field\n      const invalidStats = {\n        totalPositionsCompleted: 10,\n        // userId missing\n      };\n      \n      // This should succeed at Firestore level but fail validation in app\n      await setDoc(docRef, invalidStats);\n      \n      const docSnap = await getDoc(docRef);\n      expect(docSnap.exists()).toBe(true);\n      expect(docSnap.data()?.userId).toBeUndefined();\n    });\n  });\n\n  describe('Multi-device Sync Scenarios', () => {\n    it('simulates progress sync between multiple devices', async () => {\n      const statsDocRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Device A initial write\n      await setDoc(statsDocRef, {\n        ...TEST_USER_STATS,\n        userId: testUserId,\n        totalPositionsCompleted: 10,\n        device: 'A',\n        lastActive: Timestamp.fromMillis(Date.now()),\n      });\n      \n      // Device B reads current state\n      const deviceBRead = await getDoc(statsDocRef);\n      expect(deviceBRead.data()?.totalPositionsCompleted).toBe(10);\n      \n      // Device B updates\n      await updateDoc(statsDocRef, {\n        totalPositionsCompleted: 15,\n        device: 'B',\n        lastActive: Timestamp.fromMillis(Date.now() + 1000),\n      });\n      \n      // Device A reads updated state\n      const deviceARead = await getDoc(statsDocRef);\n      expect(deviceARead.data()?.totalPositionsCompleted).toBe(15);\n      expect(deviceARead.data()?.device).toBe('B');\n    });\n\n    it('handles conflicting card progress updates', async () => {\n      const cardRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/card-1`\n      );\n      \n      // Initial card state\n      await setDoc(cardRef, {\n        id: 'card-1',\n        nextReviewAt: Date.now() + 86400000,\n        lastReviewedAt: Date.now(),\n        interval: 1,\n        repetition: 1,\n        efactor: 2.5,\n        quality: 4,\n      });\n      \n      // Simulate two devices updating the same card\n      const device1Update = updateDoc(cardRef, {\n        quality: 5,\n        repetition: 2,\n        lastReviewedAt: Timestamp.fromMillis(Date.now() + 1000),\n      });\n      \n      const device2Update = updateDoc(cardRef, {\n        quality: 3,\n        repetition: 2,\n        lastReviewedAt: Timestamp.fromMillis(Date.now() + 2000),\n      });\n      \n      // Both updates should succeed (last write wins)\n      await Promise.all([device1Update, device2Update]);\n      \n      const finalState = await getDoc(cardRef);\n      expect(finalState.exists()).toBe(true);\n      expect(finalState.data()?.repetition).toBe(2);\n      // Quality will be either 3 or 5 depending on timing\n      expect([3, 5]).toContain(finalState.data()?.quality);\n    });\n  });\n});"],"names":["jest","setTimeout","describe","testInstance","testUserId","realtimeHelper","beforeAll","emulatorReady","isEmulatorRunning","console","log","waitForEmulator","clearFirestoreData","beforeEach","initializeTestFirebase","RealtimeTestHelper","userCredential","createTestUser","auth","user","uid","afterEach","cleanup","db","clearUserProgressData","error","signOut","afterAll","cleanupAllTestFirebase","it","docSnap","userStats","TEST_USER_STATS","userId","docRef","doc","getUserStatsPath","setDoc","lastActive","serverTimestamp","getDoc","expect","exists","toBe","data","totalPositionsCompleted","seedUserProgress","overallSuccessRate","updateDoc","deleteDoc","batch","writeBatch","TEST_CARD_PROGRESS","forEach","card","id","set","lastUpdated","commit","progressCollection","collection","snapshot","getDocs","cardDocs","docs","filter","d","length","undefined","now","Date","dueCardsQuery","query","where","size","toBeGreaterThan","dueCard","find","toBeDefined","done","updateCount","unsubscribe","onSnapshot","registerListener","snapshotCount","empty","card1Ref","nextReviewAt","lastReviewedAt","interval","repetition","efactor","quality","card2Ref","user2Doc","userId1","createTestUserWithProgress","userCredential2","userId2","user1DocRef","rejects","toThrow","user2DocRef","anonCredential","createAnonymousUser","anonUserId","finalDoc","updates","Array","from","_","i","Promise","all","cardRef","invalidStats","toBeUndefined","deviceBRead","deviceARead","statsDocRef","device","Timestamp","fromMillis","finalState","device1Update","device2Update","toContain"],"mappings":"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"}