{"version":3,"sources":["/home/thehu/coolProjects/EndgameTrainer-firebase-testing/src/tests/integration/firebase/FirebaseService.test.ts"],"sourcesContent":["/**\n * @file Firebase Service Integration Tests\n * @description Comprehensive Firebase integration tests with emulator\n * \n * Tests for Issue #83: Firebase service integration test infrastructure\n * Covers User Progress CRUD, Authentication, Real-time updates, and concurrency\n * \n * @jest-environment node\n */\n\n// Setup fetch for Firebase Auth in Node environment\nimport '../setup/firebase-test-setup';\n\n// Path abstraction layer\nimport { \n  getUserProgressPath, \n  getUserStatsPath, \n  getCardProgressPath \n} from '@tests/utils/firebase-paths';\n\nimport { \n  doc, \n  getDoc, \n  setDoc, \n  updateDoc, \n  deleteDoc,\n  onSnapshot,\n  serverTimestamp,\n  getDocs,\n  collection,\n  query,\n  where,\n  writeBatch,\n  Timestamp\n} from 'firebase/firestore';\n\nimport {\n  initializeTestFirebase,\n  createTestUser,\n  createAnonymousUser,\n  createTestUserWithProgress,\n  seedUserProgress,\n  clearUserProgressData,\n  clearFirestoreData,\n  cleanupAllTestFirebase,\n  TEST_USER_STATS,\n  TEST_CARD_PROGRESS,\n  RealtimeTestHelper,\n  type TestFirebaseInstance\n} from '@tests/utils/firebase-test-helpers';\n\nimport { waitForEmulator, isEmulatorRunning } from '@tests/utils/firebase-emulator-api';\nimport type { UserStats, CardProgress } from '@shared/store/slices/types';\n\n// Increase timeout for integration tests\njest.setTimeout(30000);\n\ndescribe('Firebase Service Integration', () => {\n  let testInstance: TestFirebaseInstance;\n  let testUserId: string;\n  let realtimeHelper: RealtimeTestHelper;\n\n  beforeAll(async () => {\n    // Ensure emulator is running\n    const emulatorReady = await isEmulatorRunning();\n    if (!emulatorReady) {\n      console.log('Waiting for Firebase emulator to start...');\n      await waitForEmulator();\n    }\n    \n    // Clear all data before starting tests\n    await clearFirestoreData();\n  });\n\n  beforeEach(async () => {\n    // Create isolated Firebase instance for each test\n    testInstance = await initializeTestFirebase();\n    realtimeHelper = new RealtimeTestHelper();\n    \n    // Create authenticated test user\n    const userCredential = await createTestUser(testInstance.auth);\n    testUserId = userCredential.user.uid;\n  });\n\n  afterEach(async () => {\n    // Cleanup real-time listeners\n    realtimeHelper.cleanup();\n    \n    // Clear user data\n    if (testUserId) {\n      await clearUserProgressData(testInstance.db, testUserId);\n    }\n  });\n\n  afterAll(async () => {\n    // Cleanup all test Firebase instances\n    await cleanupAllTestFirebase();\n  });\n\n  describe('Firestore CRUD Operations', () => {\n    describe('UserStats Operations', () => {\n      it('creates user progress document with authentication', async () => {\n        const userStats: UserStats = {\n          ...TEST_USER_STATS,\n          userId: testUserId,\n        };\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        \n        await setDoc(docRef, {\n          ...userStats,\n          lastActive: serverTimestamp(),\n        });\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.exists()).toBe(true);\n        expect(docSnap.data()?.userId).toBe(testUserId);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(25);\n      });\n\n      it('reads user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        const docSnap = await getDoc(docRef);\n        \n        expect(docSnap.exists()).toBe(true);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(25);\n        expect(docSnap.data()?.overallSuccessRate).toBe(0.85);\n      });\n\n      it('updates user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        \n        await updateDoc(docRef, {\n          totalPositionsCompleted: 30,\n          overallSuccessRate: 0.90,\n          lastActive: serverTimestamp(),\n        });\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.data()?.totalPositionsCompleted).toBe(30);\n        expect(docSnap.data()?.overallSuccessRate).toBe(0.90);\n      });\n\n      it('deletes user progress document', async () => {\n        await seedUserProgress(testInstance.db, testUserId);\n        \n        const docRef = doc(testInstance.db, getUserStatsPath(testUserId));\n        await deleteDoc(docRef);\n        \n        const docSnap = await getDoc(docRef);\n        expect(docSnap.exists()).toBe(false);\n      });\n    });\n\n    describe('CardProgress Operations', () => {\n      it('creates multiple card progress documents', async () => {\n        const batch = writeBatch(testInstance.db);\n        \n        TEST_CARD_PROGRESS.forEach((card) => {\n          const docRef = doc(\n            testInstance.db, \n            `users/${testUserId}/userProgress/${card.id}`\n          );\n          batch.set(docRef, {\n            ...card,\n            lastUpdated: serverTimestamp(),\n          });\n        });\n        \n        await batch.commit();\n        \n        // Verify all cards were created\n        const progressCollection = collection(\n          testInstance.db, \n          `users/${testUserId}/userProgress`\n        );\n        const snapshot = await getDocs(progressCollection);\n        \n        // Filter out stats document, count only card documents\n        const cardDocs = snapshot.docs.filter(d => d.id !== 'stats');\n        expect(cardDocs.length).toBe(TEST_CARD_PROGRESS.length);\n      });\n\n      it('queries due cards using where clause', async () => {\n        await seedUserProgress(testInstance.db, testUserId, undefined, TEST_CARD_PROGRESS);\n        \n        const now = Date.now();\n        const progressCollection = collection(\n          testInstance.db,\n          `users/${testUserId}/userProgress`\n        );\n        \n        // Query for due cards (nextReviewAt <= now)\n        const dueCardsQuery = query(\n          progressCollection,\n          where('nextReviewAt', '<=', now)\n        );\n        \n        const snapshot = await getDocs(dueCardsQuery);\n        \n        // Should find pos-2 which is overdue\n        expect(snapshot.size).toBeGreaterThan(0);\n        const dueCard = snapshot.docs.find(d => d.id === 'pos-2');\n        expect(dueCard).toBeDefined();\n      });\n    });\n  });\n\n  describe('Real-time Updates', () => {\n    it('receives real-time updates through onSnapshot for UserStats', (done) => {\n      const docRef = doc(testInstance.db, `users/${testUserId}/userProgress/stats`);\n      let updateCount = 0;\n      \n      const unsubscribe = onSnapshot(docRef, (snapshot) => {\n        updateCount++;\n        \n        if (updateCount === 1) {\n          // Initial empty snapshot\n          expect(snapshot.exists()).toBe(false);\n          \n          // Trigger first write\n          setDoc(docRef, {\n            ...TEST_USER_STATS,\n            userId: testUserId,\n            totalPositionsCompleted: 10,\n          });\n        } else if (updateCount === 2) {\n          // After first write\n          expect(snapshot.exists()).toBe(true);\n          expect(snapshot.data()?.totalPositionsCompleted).toBe(10);\n          \n          // Trigger update\n          updateDoc(docRef, {\n            totalPositionsCompleted: 15,\n          });\n        } else if (updateCount === 3) {\n          // After update\n          expect(snapshot.data()?.totalPositionsCompleted).toBe(15);\n          unsubscribe();\n          done();\n        }\n      });\n      \n      realtimeHelper.registerListener(unsubscribe);\n    });\n\n    it('receives real-time updates for CardProgress collection', (done) => {\n      const progressCollection = collection(\n        testInstance.db,\n        `users/${testUserId}/userProgress`\n      );\n      \n      let snapshotCount = 0;\n      \n      const unsubscribe = onSnapshot(progressCollection, (snapshot) => {\n        snapshotCount++;\n        \n        if (snapshotCount === 1) {\n          // Initial empty collection\n          expect(snapshot.empty).toBe(true);\n          \n          // Add first card\n          const card1Ref = doc(progressCollection, 'card-1');\n          setDoc(card1Ref, {\n            id: 'card-1',\n            nextReviewAt: Date.now() + 86400000,\n            lastReviewedAt: Date.now(),\n            interval: 1,\n            repetition: 1,\n            efactor: 2.5,\n            quality: 4,\n          });\n        } else if (snapshotCount === 2) {\n          // After first card added\n          expect(snapshot.size).toBe(1);\n          \n          // Add second card\n          const card2Ref = doc(progressCollection, 'card-2');\n          setDoc(card2Ref, {\n            id: 'card-2',\n            nextReviewAt: Date.now() + 172800000,\n            lastReviewedAt: Date.now(),\n            interval: 2,\n            repetition: 2,\n            efactor: 2.4,\n            quality: 3,\n          });\n        } else if (snapshotCount === 3) {\n          // After second card added\n          expect(snapshot.size).toBe(2);\n          unsubscribe();\n          done();\n        }\n      });\n      \n      realtimeHelper.registerListener(unsubscribe);\n    });\n  });\n\n  describe('Authentication & Security', () => {\n    it('allows user to access only their own progress data', async () => {\n      // Create first user with progress\n      const { userId: userId1 } = await createTestUserWithProgress(\n        testInstance,\n        'user1@test.com'\n      );\n      \n      // Create second user  \n      const userCredential2 = await createTestUser(\n        testInstance.auth,\n        'user2@test.com'\n      );\n      const userId2 = userCredential2.user.uid;\n      \n      // Try to read user1's data as user2 (should fail in production with security rules)\n      // Note: Emulator may not enforce security rules by default\n      const user1DocRef = doc(\n        testInstance.db,\n        `users/${userId1}/userProgress/stats`\n      );\n      \n      // This would fail with proper security rules\n      const docSnap = await getDoc(user1DocRef);\n      \n      // In production, this should be false due to security rules\n      // In emulator without rules enforcement, it might succeed\n      // This test documents the expected behavior\n      if (docSnap.exists()) {\n        console.warn('Security rules may not be enforced in emulator');\n      }\n    });\n\n    it('supports anonymous user progress tracking', async () => {\n      const anonCredential = await createAnonymousUser(testInstance.auth);\n      const anonUserId = anonCredential.user.uid;\n      \n      await seedUserProgress(\n        testInstance.db,\n        anonUserId,\n        { userId: anonUserId }\n      );\n      \n      const docRef = doc(\n        testInstance.db,\n        `users/${anonUserId}/userProgress/stats`\n      );\n      const docSnap = await getDoc(docRef);\n      \n      expect(docSnap.exists()).toBe(true);\n      expect(docSnap.data()?.userId).toBe(anonUserId);\n    });\n  });\n\n  describe('Concurrent Operations', () => {\n    it('handles concurrent updates to the same document', async () => {\n      const docRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Set initial value\n      await setDoc(docRef, {\n        ...TEST_USER_STATS,\n        userId: testUserId,\n        totalPositionsCompleted: 0,\n      });\n      \n      // Simulate concurrent updates\n      const updates = Array.from({ length: 5 }, (_, i) => \n        updateDoc(docRef, {\n          totalPositionsCompleted: i + 1,\n          lastActive: serverTimestamp(),\n        })\n      );\n      \n      await Promise.all(updates);\n      \n      // Check final state\n      const finalDoc = await getDoc(docRef);\n      expect(finalDoc.exists()).toBe(true);\n      expect(finalDoc.data()?.totalPositionsCompleted).toBeDefined();\n      expect(typeof finalDoc.data()?.totalPositionsCompleted).toBe('number');\n    });\n\n    it('handles batch operations with multiple cards', async () => {\n      const batch = writeBatch(testInstance.db);\n      \n      // Create 10 cards in a batch\n      for (let i = 0; i < 10; i++) {\n        const cardRef = doc(\n          testInstance.db,\n          `users/${testUserId}/userProgress/card-${i}`\n        );\n        \n        batch.set(cardRef, {\n          id: `card-${i}`,\n          nextReviewAt: Date.now() + (i * 86400000), // Stagger by days\n          lastReviewedAt: Date.now(),\n          interval: i + 1,\n          repetition: 1,\n          efactor: 2.5,\n          quality: 4,\n          lastUpdated: serverTimestamp(),\n        });\n      }\n      \n      await batch.commit();\n      \n      // Verify all cards were created\n      const progressCollection = collection(\n        testInstance.db,\n        `users/${testUserId}/userProgress`\n      );\n      const snapshot = await getDocs(progressCollection);\n      \n      expect(snapshot.size).toBe(10);\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('handles invalid document paths gracefully', async () => {\n      // Invalid path (empty userId)\n      const invalidDocRef = doc(testInstance.db, 'users//userProgress/stats');\n      \n      await expect(\n        setDoc(invalidDocRef, TEST_USER_STATS)\n      ).rejects.toThrow();\n    });\n\n    it('handles missing required fields', async () => {\n      const docRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Missing required userId field\n      const invalidStats = {\n        totalPositionsCompleted: 10,\n        // userId missing\n      };\n      \n      // This should succeed at Firestore level but fail validation in app\n      await setDoc(docRef, invalidStats);\n      \n      const docSnap = await getDoc(docRef);\n      expect(docSnap.exists()).toBe(true);\n      expect(docSnap.data()?.userId).toBeUndefined();\n    });\n  });\n\n  describe('Multi-device Sync Scenarios', () => {\n    it('simulates progress sync between multiple devices', async () => {\n      const statsDocRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/stats`\n      );\n      \n      // Device A initial write\n      await setDoc(statsDocRef, {\n        ...TEST_USER_STATS,\n        userId: testUserId,\n        totalPositionsCompleted: 10,\n        device: 'A',\n        lastActive: Timestamp.fromMillis(Date.now()),\n      });\n      \n      // Device B reads current state\n      const deviceBRead = await getDoc(statsDocRef);\n      expect(deviceBRead.data()?.totalPositionsCompleted).toBe(10);\n      \n      // Device B updates\n      await updateDoc(statsDocRef, {\n        totalPositionsCompleted: 15,\n        device: 'B',\n        lastActive: Timestamp.fromMillis(Date.now() + 1000),\n      });\n      \n      // Device A reads updated state\n      const deviceARead = await getDoc(statsDocRef);\n      expect(deviceARead.data()?.totalPositionsCompleted).toBe(15);\n      expect(deviceARead.data()?.device).toBe('B');\n    });\n\n    it('handles conflicting card progress updates', async () => {\n      const cardRef = doc(\n        testInstance.db,\n        `users/${testUserId}/userProgress/card-1`\n      );\n      \n      // Initial card state\n      await setDoc(cardRef, {\n        id: 'card-1',\n        nextReviewAt: Date.now() + 86400000,\n        lastReviewedAt: Date.now(),\n        interval: 1,\n        repetition: 1,\n        efactor: 2.5,\n        quality: 4,\n      });\n      \n      // Simulate two devices updating the same card\n      const device1Update = updateDoc(cardRef, {\n        quality: 5,\n        repetition: 2,\n        lastReviewedAt: Timestamp.fromMillis(Date.now() + 1000),\n      });\n      \n      const device2Update = updateDoc(cardRef, {\n        quality: 3,\n        repetition: 2,\n        lastReviewedAt: Timestamp.fromMillis(Date.now() + 2000),\n      });\n      \n      // Both updates should succeed (last write wins)\n      await Promise.all([device1Update, device2Update]);\n      \n      const finalState = await getDoc(cardRef);\n      expect(finalState.exists()).toBe(true);\n      expect(finalState.data()?.repetition).toBe(2);\n      // Quality will be either 3 or 5 depending on timing\n      expect([3, 5]).toContain(finalState.data()?.quality);\n    });\n  });\n});"],"names":["jest","setTimeout","describe","testInstance","testUserId","realtimeHelper","beforeAll","emulatorReady","isEmulatorRunning","console","log","waitForEmulator","clearFirestoreData","beforeEach","initializeTestFirebase","RealtimeTestHelper","userCredential","createTestUser","auth","user","uid","afterEach","cleanup","clearUserProgressData","db","afterAll","cleanupAllTestFirebase","it","docSnap","userStats","TEST_USER_STATS","userId","docRef","doc","getUserStatsPath","setDoc","lastActive","serverTimestamp","getDoc","expect","exists","toBe","data","totalPositionsCompleted","seedUserProgress","overallSuccessRate","updateDoc","deleteDoc","batch","writeBatch","TEST_CARD_PROGRESS","forEach","card","id","set","lastUpdated","commit","progressCollection","collection","snapshot","getDocs","cardDocs","docs","filter","d","length","undefined","now","Date","dueCardsQuery","query","where","size","toBeGreaterThan","dueCard","find","toBeDefined","done","updateCount","unsubscribe","onSnapshot","registerListener","snapshotCount","empty","card1Ref","nextReviewAt","lastReviewedAt","interval","repetition","efactor","quality","card2Ref","userId1","createTestUserWithProgress","userCredential2","userId2","user1DocRef","warn","anonCredential","createAnonymousUser","anonUserId","finalDoc","updates","Array","from","_","i","Promise","all","cardRef","invalidDocRef","rejects","toThrow","invalidStats","toBeUndefined","deviceBRead","deviceARead","statsDocRef","device","Timestamp","fromMillis","finalState","device1Update","device2Update","toContain"],"mappings":"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"}