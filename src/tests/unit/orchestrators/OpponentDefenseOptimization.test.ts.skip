/**
 * Test suite for optimal defense by the opponent (computer)
 * The computer should choose moves that maximize DTM when losing
 */

import { OpponentTurnHandler } from "@shared/store/orchestrators/handlePlayerMove";
import { tablebaseService } from "@shared/services/TablebaseService";
import { chessService } from "@shared/services/ChessService";

jest.mock("@shared/services/TablebaseService");
jest.mock("@shared/services/ChessService");

describe("Opponent Defense Optimization", () => {
  const mockTablebaseService = tablebaseService as jest.Mocked<
    typeof tablebaseService
  >;
  const mockChessService = chessService as jest.Mocked<typeof chessService>;

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("FAILING TEST: Should choose move with highest DTM when losing (Black)", () => {
    // Position: 2k5/8/8/4PK2/8/8/8/8 b - - 2 3
    // Black is losing but should choose Kd7 (DTM -27) over other moves
    
    const fenBefore = "2k5/8/8/4PK2/8/8/8/8 b - - 2 3";
    
    // Mock the chess service
    mockChessService.getFen.mockReturnValue(fenBefore);
    mockChessService.turn.mockReturnValue("b");
    
    // Mock tablebase response with all Black's moves
    // Note: getTopMoves is called with limit=1 in current implementation
    // but we need to test that it should get ALL moves to find best DTM
    const allMoves = [
      { 
        san: "Kd7", 
        uci: "c8d7", 
        category: "loss", 
        dtm: -27,  // BEST: loses in 27 moves
        dtz: -30, 
        wdl: -1000 
      },
      { 
        san: "Kb7", 
        uci: "c8b7", 
        category: "loss", 
        dtm: -25,  // Worse: loses in 25 moves
        dtz: -28, 
        wdl: -1000 
      },
      { 
        san: "Kc7", 
        uci: "c8c7", 
        category: "loss", 
        dtm: -15,  // Much worse: loses in 15 moves
        dtz: -18, 
        wdl: -1000 
      },
      { 
        san: "Kb8", 
        uci: "c8b8", 
        category: "loss", 
        dtm: -20,  // Also worse: loses in 20 moves
        dtz: -23, 
        wdl: -1000 
      },
      { 
        san: "Kd8", 
        uci: "c8d8", 
        category: "loss", 
        dtm: -26,  // Close but not optimal: loses in 26 moves
        dtz: -29, 
        wdl: -1000 
      },
    ];
    
    // The current implementation calls getTopMoves(fen, 1)
    // which returns only the first move
    mockTablebaseService.getTopMoves.mockResolvedValue({
      isAvailable: true,
      moves: [allMoves[0]], // Current implementation would get first move only
    });
    
    console.log("\n=== Opponent Defense Test (Black) ===");
    console.log("Position: Black to move, losing");
    console.log("Available moves with DTM:");
    console.log("  Kd7: DTM -27 (BEST - delays mate longest)");
    console.log("  Kd8: DTM -26");
    console.log("  Kb7: DTM -25");  
    console.log("  Kb8: DTM -20");
    console.log("  Kc7: DTM -15");
    console.log("\nCurrent implementation: Takes first move from API");
    console.log("Expected: Should analyze ALL moves and pick highest DTM");
    
    // With current implementation, it takes moves[0] without considering DTM
    // This test documents the expected behavior that needs to be implemented
    expect(true).toBe(true); // Placeholder - actual integration test would be complex
  });

  it("Should choose optimal defense based on DTM for losing positions", () => {
    // This test documents the expected algorithm
    
    // Given a set of losing moves
    const moves = [
      { san: "Ka2", dtm: -5, category: "loss", wdl: -1000 },
      { san: "Kb1", dtm: -10, category: "loss", wdl: -1000 },  // Best defense
      { san: "Kb2", dtm: -7, category: "loss", wdl: -1000 },
    ];
    
    // The algorithm should:
    // 1. Check if position is losing (all moves have negative WDL)
    // 2. Sort by DTM (highest/least negative first)
    // 3. Pick the move with highest DTM
    
    const sortedMoves = [...moves].sort((a, b) => {
      // For losing positions (negative DTM), we want the HIGHEST (least negative) DTM
      // -5 is worse than -10 (loses faster)
      // So we want -10 to come first
      return Math.abs(b.dtm!) - Math.abs(a.dtm!);
    });
    
    console.log("\n=== Defense Algorithm Test ===");
    console.log("Original moves:", moves.map(m => `${m.san}(DTM ${m.dtm})`));
    console.log("Sorted by DTM:", sortedMoves.map(m => `${m.san}(DTM ${m.dtm})`));
    console.log("Best defense:", sortedMoves[0].san);
    
    expect(sortedMoves[0].san).toBe("Kb1"); // Move with DTM -10 (delays mate longest)
  });

  it("Should handle winning positions normally (pick fastest win)", () => {
    // For winning positions, pick the move with LOWEST positive DTM (fastest win)
    
    const moves = [
      { san: "Kd5", dtm: 10, category: "win", wdl: 1000 },  // Slower win
      { san: "Ke5", dtm: 5, category: "win", wdl: 1000 },   // Best - fastest win
      { san: "Kf5", dtm: 8, category: "win", wdl: 1000 },   // Medium speed
    ];
    
    const sortedMoves = [...moves].sort((a, b) => {
      // For winning positions (positive DTM), we want the LOWEST DTM (fastest win)
      return Math.abs(a.dtm!) - Math.abs(b.dtm!);
    });
    
    console.log("\n=== Winning Position Test ===");
    console.log("Original moves:", moves.map(m => `${m.san}(DTM ${m.dtm})`));
    console.log("Sorted by DTM:", sortedMoves.map(m => `${m.san}(DTM ${m.dtm})`));
    console.log("Best win:", sortedMoves[0].san);
    
    expect(sortedMoves[0].san).toBe("Ke5"); // Move with DTM 5 (fastest win)
  });

  it("Should handle mixed positions (prefer wins/draws over losses)", () => {
    // When there are moves with different outcomes, prefer by outcome first
    
    const moves = [
      { san: "Ka1", dtm: -20, category: "loss", wdl: -1000 },  // Loss
      { san: "Kb1", dtm: null, category: "draw", wdl: 0 },     // Draw - better than loss
      { san: "Kc1", dtm: 15, category: "win", wdl: 1000 },     // Win - best
    ];
    
    // First sort by outcome (win > draw > loss), then by DTM within same outcome
    const sortedMoves = [...moves].sort((a, b) => {
      // First compare by WDL (higher is better)
      if (a.wdl !== b.wdl) {
        return b.wdl - a.wdl;
      }
      // If same outcome, sort by DTM appropriately
      if (a.dtm === null || b.dtm === null) return 0;
      if (a.wdl > 0) {
        // Winning: prefer lower DTM (faster win)
        return Math.abs(a.dtm) - Math.abs(b.dtm);
      } else {
        // Losing: prefer higher DTM (slower loss)
        return Math.abs(b.dtm) - Math.abs(a.dtm);
      }
    });
    
    console.log("\n=== Mixed Outcomes Test ===");
    console.log("Original moves:", moves.map(m => `${m.san}(${m.category}, DTM ${m.dtm})`));
    console.log("Sorted by outcome:", sortedMoves.map(m => `${m.san}(${m.category})`));
    console.log("Best move:", sortedMoves[0].san);
    
    expect(sortedMoves[0].san).toBe("Kc1"); // Win is always best
  });
});