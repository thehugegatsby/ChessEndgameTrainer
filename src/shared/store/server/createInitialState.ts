/**
 * @file Server-side state initialization for SSR
 * @module store/server/createInitialState
 *
 * @description
 * Creates pre-populated initial state for Zustand store on the server.
 * This eliminates hydration mismatches by ensuring server and client
 * start with identical state.
 *
 * @remarks
 * This function is safe for server-side execution as it does not rely on
 * stateful singletons or browser-specific APIs. Each request gets its own
 * isolated chess instance and state object.
 */

import { Chess } from "chess.js";
import { getServerPositionService } from "@shared/services/database/serverPositionService";
import type { EndgamePosition } from "@shared/types/endgame";
import type { TrainingPosition } from "@shared/store/slices/trainingSlice";
import type {
  RootState,
} from "@shared/store/slices/types";
import type { ValidatedMove } from "@shared/types";


/**
 * Helper function to convert EndgamePosition to TrainingPosition with proper defaults
 */
function toTrainingPosition(position: EndgamePosition & Partial<TrainingPosition>): TrainingPosition {
  return {
    ...position,
    colorToTrain: position.colorToTrain || position.sideToMove || "white",
    targetOutcome: position.targetOutcome || (() => {
      if (position.goal === "win") {
        return position.sideToMove === "white" ? "1-0" : "0-1";
      }
      if (position.goal === "draw") {
        return "1/2-1/2";
      }
      return "1-0"; // Default to win for white
    })(),
    ...(position.timeLimit !== undefined && { timeLimit: position.timeLimit }),
    ...(position.chapterId !== undefined && { chapterId: position.chapterId }),
  };
}

/**
 * Creates the initial store state for a given position on the server.
 *
 * @param {EndgamePosition} position - The endgame position to initialize state with
 * @returns {Promise<Partial<RootState>>} Partial state object for hydrating client store
 *
 * @throws {Error} When FEN is invalid or position data is malformed
 *
 * @example
 * ```typescript
 * // In a server component
 * const position = await positionService.getPosition(id);
 * const initialState = await createInitialStateForPosition(position);
 *
 * return (
 *   <StoreProvider initialState={initialState}>
 *     <EndgameTrainingPage />
 *   </StoreProvider>
 * );
 * ```
 */
/**
 * Server hydration state type - partial state for initial hydration
 */
export type ServerHydrationState = Partial<RootState>;

export async function createInitialStateForPosition(
  position: EndgamePosition,
): Promise<Partial<RootState>> {
  // 1. Create a fresh, request-scoped chess instance to avoid singleton issues
  const chess = new Chess();
  try {
    chess.load(position.fen);
  } catch {
    throw new Error(
      `Invalid FEN provided for position ${position.id}: ${position.fen}`,
    );
  }

  // 2. Create the TrainingPosition object with proper defaults
  const trainingPosition = toTrainingPosition(position as EndgamePosition & Partial<TrainingPosition>);

  // 3. Determine player's turn
  const currentTurn = chess.turn();
  const isPlayerTurn = currentTurn === trainingPosition.colorToTrain.charAt(0);

  // 4. Fetch navigation positions concurrently (non-blocking)
  const positionService = getServerPositionService();
  let nextPosition: EndgamePosition | null = null;
  let previousPosition: EndgamePosition | null = null;
  const isLoadingNavigation = false;

  try {
    const [nextPos, prevPos] = await Promise.all([
      positionService.getNextPosition(position.id, position.category),
      positionService.getPreviousPosition(position.id, position.category),
    ]);

    nextPosition = nextPos;
    previousPosition = prevPos;
  } catch (error) {
    // Navigation loading is non-critical, continue without it
    console.warn("Failed to load navigation positions on server:", error);
  }

  // Convert navigation positions to TrainingPositions
  const nextTrainingPos = nextPosition
    ? toTrainingPosition(nextPosition as EndgamePosition & Partial<TrainingPosition>)
    : null;

  const prevTrainingPos = previousPosition
    ? toTrainingPosition(previousPosition as EndgamePosition & Partial<TrainingPosition>)
    : null;

  // 5. Generate move history from chess.js - simplified for server-side
  const moveHistory: ValidatedMove[] = [];

  // 6. Construct and return the state object for hydration (only state properties, not actions)
  // Return type is already Partial<RootState>, so TypeScript will properly handle partial slices
  // We cast to any first to bypass the strict type checking within the literal
  const initialState = {
    // Game state - initialize with position data (partial state, actions added by store)
    game: {
      currentFen: position.fen,
      currentPgn: "", // Will be generated by ChessService
      moveHistory: moveHistory,
      currentMoveIndex: moveHistory.length,
      isGameFinished: false,
      gameResult: null,
      isCheckmate: false,
      isDraw: false,
      isStalemate: false,
    },

    // Training state - pre-populated with position and navigation (partial state, actions added by store)
    training: {
      currentPosition: trainingPosition,
      nextPosition: nextTrainingPos,
      previousPosition: prevTrainingPos,
      isLoadingNavigation,
      navigationError: null,
      chapterProgress: null,
      isPlayerTurn,
      isOpponentThinking: false,
      isSuccess: false,
      // sessionStartTime: undefined - omit instead of undefined
      // sessionEndTime: undefined - omit instead of undefined
      hintsUsed: 0,
      mistakeCount: 0,
      currentStreak: 0,
      bestStreak: 0,
      showCheckmark: false,
      autoProgressEnabled: false,
      moveErrorDialog: null,
      moveSuccessDialog: null,
      evaluationBaseline: null,
    },

    // Tablebase state - clean initial state (partial state, actions added by store)
    tablebase: {
      tablebaseMove: null,
      analysisStatus: "idle" as const,
      evaluations: [],
      currentEvaluation: undefined,
    },

    // UI state - position is pre-loaded (partial state, actions added by store)
    ui: {
      isSidebarOpen: false,
      currentModal: null,
      toasts: [],
      loading: {
        global: false,
        position: false, // Position is pre-loaded on server
        tablebase: false,
        analysis: false,
      },
      analysisPanel: {
        isOpen: false,
        activeTab: "moves" as const,
        showTablebase: true,
      },
    },
  } as unknown as Partial<RootState>;
  
  return initialState;
}
